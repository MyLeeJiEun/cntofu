
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>处理不可屏蔽中断-Linux 内核揭密</title>
<meta content='处理不可屏蔽中断,Linux 内核揭密' name='keywords'>
<meta content='处理不可屏蔽中断,Linux 内核揭密' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/104/Interrupts/interrupts-5.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">异常处理的实现</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/104/Interrupts/interrupts-7.html">
<span class="">深入外部硬件中断</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/104/index.html">Linux 内核揭密</a>
<a target="_blank" rel="nofollow" href="https://github.com/ye11ow/linux-insides-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="interrupts-and-interrupt-handling-part-6">Interrupts and Interrupt Handling. Part 6.</h1>
<h2 id="non-maskable-interrupt-handler">Non-maskable interrupt handler</h2>
<p>It is sixth part of the <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html">Interrupts and Interrupt Handling in the Linux kernel</a> chapter and in the previous <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-5.html">part</a> we saw implementation of some exception handlers for the <a href="https://en.wikipedia.org/wiki/General_protection_fault">General Protection Fault</a> exception, divide exception, invalid <a href="https://en.wikipedia.org/wiki/Opcode">opcode</a> exceptions and etc. As I wrote in the previous part we will see implementations of the rest exceptions in this part. We will see implementation of the following handlers:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable</a> interrupt;</li>
<li><a href="http://pdos.csail.mit.edu/6.828/2005/readings/i386/BOUND.htm">BOUND</a> Range Exceeded Exception;</li>
<li><a href="https://en.wikipedia.org/wiki/Coprocessor">Coprocessor</a> exception;</li>
<li><a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> coprocessor exception.</li>
</ul>
<p>in this part. So, let's start.</p>
<h2 id="non-maskable-interrupt-handling">Non-Maskable interrupt handling</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable</a> interrupt is a hardware interrupt that cannot be ignored by standard masking techniques. In a general way, a non-maskable interrupt can be generated in either of two ways:</p>
<ul>
<li>External hardware asserts the non-maskable interrupt <a href="https://en.wikipedia.org/wiki/CPU_socket">pin</a> on the CPU.</li>
<li>The processor receives a message on the system bus or the APIC serial bus with a delivery mode <code>NMI</code>.</li>
</ul>
<p>When the processor receives a <code>NMI</code> from one of these sources, the processor handles it immediately by calling the <code>NMI</code> handler pointed to by interrupt vector which has number <code>2</code> (see table in the first <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-1.html">part</a>). We already filled the <a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table</a> with the <a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">vector number</a>, address of the <code>nmi</code> interrupt handler and <code>NMI_STACK</code> <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/kernel-stacks">Interrupt Stack Table entry</a>:</p>
<pre><code class="language-C">set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);
</code></pre>
<p>in the <code>trap_init</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> source code file. In the previous <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html">parts</a> we saw that entry points of the all interrupt handlers are defined with the:</p>
<pre><code class="language-assembly">.macro idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1
ENTRY(\sym)
...
...
...
END(\sym)
.endm
</code></pre>
<p>macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly source code file. But the handler of the <code>Non-Maskable</code> interrupts is not defined with this macro. It has own entry point:</p>
<pre><code class="language-assembly">ENTRY(nmi)
...
...
...
END(nmi)
</code></pre>
<p>in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly file. Lets dive into it and will try to understand how <code>Non-Maskable</code> interrupt handler works. The <code>nmi</code> handlers starts from the call of the:</p>
<pre><code class="language-assembly">PARAVIRT_ADJUST_EXCEPTION_FRAME
</code></pre>
<p>macro but we will not dive into details about it in this part, because this macro related to the <a href="https://en.wikipedia.org/wiki/Paravirtualization">Paravirtualization</a> stuff which we will see in another chapter. After this save the content of the <code>rdx</code> register on the stack:</p>
<pre><code class="language-assembly">pushq	%rdx
</code></pre>
<p>And allocated check that <code>cs</code> was not the kernel segment when an non-maskable interrupt occurs:</p>
<pre><code class="language-assembly">cmpl	$__KERNEL_CS, 16(%rsp)
jne	first_nmi
</code></pre>
<p>The <code>__KERNEL_CS</code> macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/segment.h">arch/x86/include/asm/segment.h</a> and represented second descriptor in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a>:</p>
<pre><code class="language-C">#define GDT_ENTRY_KERNEL_CS	2
#define __KERNEL_CS	(GDT_ENTRY_KERNEL_CS*8)
</code></pre>
<p>more about <code>GDT</code> you can read in the second <a href="http://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-2.html">part</a> of the Linux kernel booting process chapter. If <code>cs</code> is not kernel segment, it means that it is not nested <code>NMI</code> and we jump on the <code>first_nmi</code> label. Let's consider this case. First of all we put address of the current stack pointer to the <code>rdx</code> and pushes <code>1</code> to the stack in the <code>first_nmi</code> label:</p>
<pre><code class="language-assembly">first_nmi:
	movq	(%rsp), %rdx
	pushq	$1
</code></pre>
<p>Why do we push <code>1</code> on the stack? As the comment says: <code>We allow breakpoints in NMIs</code>. On the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>, like other architectures, the CPU will not execute another <code>NMI</code> until the first <code>NMI</code> is completed. A <code>NMI</code> interrupt finished with the <a href="http://faydoc.tripod.com/cpu/iret.htm">iret</a> instruction like other interrupts and exceptions do it. If the <code>NMI</code> handler triggers either a <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> or <a href="https://en.wikipedia.org/wiki/Breakpoint">breakpoint</a> or another exception which are use <code>iret</code> instruction too. If this happens while in <code>NMI</code> context, the CPU will leave <code>NMI</code> context and a new <code>NMI</code> may come in. The <code>iret</code> used to return from those exceptions will re-enable <code>NMIs</code> and we will get nested non-maskable interrupts. The problem the <code>NMI</code> handler will not return to the state that it was, when the exception triggered, but instead it will return to a state that will allow new <code>NMIs</code> to preempt the running <code>NMI</code> handler. If another <code>NMI</code> comes in before the first NMI handler is complete, the new NMI will write all over the preempted <code>NMIs</code> stack. We can have nested <code>NMIs</code> where the next <code>NMI</code> is using the top of the stack of the previous <code>NMI</code>. It means that we cannot execute it because a nested non-maskable interrupt will corrupt stack of a previous non-maskable interrupt. That's why we have allocated space on the stack for temporary variable. We will check this variable that it was set when a previous <code>NMI</code> is executing and clear if it is not nested <code>NMI</code>. We push <code>1</code> here to the previously allocated space on the stack to denote that a <code>non-maskable</code> interrupt executed currently. Remember that when and <code>NMI</code> or another exception occurs we have the following <a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a>:</p>
<pre><code>+------------------------+
|         SS             |
|         RSP            |
|        RFLAGS          |
|         CS             |
|         RIP            |
+------------------------+
</code></pre>
<p>and also an error code if an exception has it. So, after all of these manipulations our stack frame will look like this:</p>
<pre><code>+------------------------+
|         SS             |
|         RSP            |
|        RFLAGS          |
|         CS             |
|         RIP            |
|         RDX            |
|          1             |
+------------------------+
</code></pre>
<p>In the next step we allocate yet another <code>40</code> bytes on the stack:</p>
<pre><code class="language-assembly">subq	$(5*8), %rsp
</code></pre>
<p>and pushes the copy of the original stack frame after the allocated space:</p>
<pre><code class="language-C">.rept 5
pushq	11*8(%rsp)
.endr
</code></pre>
<p>with the <a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC116">.rept</a> assembly directive. We need in the copy of the original stack frame. Generally we need in two copies of the interrupt stack. First is <code>copied</code> interrupts stack: <code>saved</code> stack frame and <code>copied</code> stack frame. Now we pushes original stack frame to the <code>saved</code> stack frame which locates after the just allocated <code>40</code> bytes (<code>copied</code> stack frame). This stack frame is used to fixup the <code>copied</code> stack frame that a nested NMI may change. The second - <code>copied</code> stack frame modified by any nested <code>NMIs</code> to let the first <code>NMI</code> know that we triggered a second <code>NMI</code> and we should repeat the first <code>NMI</code> handler. Ok, we have made first copy of the original stack frame, now time to make second copy:</p>
<pre><code class="language-assembly">addq	$(10*8), %rsp

.rept 5
pushq	-6*8(%rsp)
.endr
subq	$(5*8), %rsp
</code></pre>
<p>After all of these manipulations our stack frame will be like this:</p>
<pre><code>+-------------------------+
| original SS             |
| original Return RSP     |
| original RFLAGS         |
| original CS             |
| original RIP            |
+-------------------------+
| temp storage for rdx    |
+-------------------------+
| NMI executing variable  |
+-------------------------+
| copied SS               |
| copied Return RSP       |
| copied RFLAGS           |
| copied CS               |
| copied RIP              |
+-------------------------+
| Saved SS                |
| Saved Return RSP        |
| Saved RFLAGS            |
| Saved CS                |
| Saved RIP               |
+-------------------------+
</code></pre>
<p>After this we push dummy error code on the stack as we did it already in the previous exception handlers and allocate space for the general purpose registers on the stack:</p>
<pre><code class="language-assembly">pushq	$-1
ALLOC_PT_GPREGS_ON_STACK
</code></pre>
<p>We already saw implementation of the <code>ALLOC_PT_GREGS_ON_STACK</code> macro in the third part of the interrupts <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-3.html">chapter</a>. This macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/calling.h">arch/x86/entry/calling.h</a> and yet another allocates <code>120</code> bytes on stack for the general purpose registers, from the <code>rdi</code> to the <code>r15</code>:</p>
<pre><code class="language-assembly">.macro ALLOC_PT_GPREGS_ON_STACK addskip=0
addq	$-(15*8+\addskip), %rsp
.endm
</code></pre>
<p>After space allocation for the general registers we can see call of the <code>paranoid_entry</code>:</p>
<pre><code class="language-assembly">call	paranoid_entry
</code></pre>
<p>We can remember from the previous parts this label. It pushes general purpose registers on the stack, reads <code>MSR_GS_BASE</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register">Model Specific register</a> and checks its value. If the value of the <code>MSR_GS_BASE</code> is negative, we came from the kernel mode and just return from the <code>paranoid_entry</code>, in other way it means that we came from the usermode and need to execute <code>swapgs</code> instruction which will change user <code>gs</code> with the kernel <code>gs</code>:</p>
<pre><code class="language-assembly">ENTRY(paranoid_entry)
	cld
	SAVE_C_REGS 8
	SAVE_EXTRA_REGS 8
	movl	$1, %ebx
	movl	$MSR_GS_BASE, %ecx
	rdmsr
	testl	%edx, %edx
	js	1f
	SWAPGS
	xorl	%ebx, %ebx
1:	ret
END(paranoid_entry)
</code></pre>
<p>Note that after the <code>swapgs</code> instruction we zeroed the <code>ebx</code> register. Next time we will check content of this register and if we executed <code>swapgs</code> than <code>ebx</code> must contain <code>0</code> and <code>1</code> in other way. In the next step we store value of the <code>cr2</code> <a href="https://en.wikipedia.org/wiki/Control_register">control register</a> to the <code>r12</code> register, because the <code>NMI</code> handler can cause <code>page fault</code> and corrupt the value of this control register:</p>
<pre><code class="language-C">movq	%cr2, %r12
</code></pre>
<p>Now time to call actual <code>NMI</code> handler. We push the address of the <code>pt_regs</code> to the <code>rdi</code>, error code to the <code>rsi</code> and call the <code>do_nmi</code> handler:</p>
<pre><code class="language-assembly">movq	%rsp, %rdi
movq	$-1, %rsi
call	do_nmi
</code></pre>
<p>We will back to the <code>do_nmi</code> little later in this part, but now let's look what occurs after the <code>do_nmi</code> will finish its execution. After the <code>do_nmi</code> handler will be finished we check the <code>cr2</code> register, because we can got page fault during <code>do_nmi</code> performed and if we got it we restore original <code>cr2</code>, in other way we jump on the label <code>1</code>. After this we test content of the <code>ebx</code> register (remember it must contain <code>0</code> if we have used <code>swapgs</code> instruction and <code>1</code> if we didn't use it) and execute <code>SWAPGS_UNSAFE_STACK</code> if it contains <code>1</code> or jump to the <code>nmi_restore</code> label. The <code>SWAPGS_UNSAFE_STACK</code> macro just expands to the <code>swapgs</code> instruction. In the <code>nmi_restore</code> label we restore general purpose registers, clear allocated space on the stack for this registers, clear our temporary variable and exit from the interrupt handler with the <code>INTERRUPT_RETURN</code> macro:</p>
<pre><code class="language-assembly">	movq	%cr2, %rcx
	cmpq	%rcx, %r12
	je	1f
	movq	%r12, %cr2
1:
	testl	%ebx, %ebx
	jnz	nmi_restore
nmi_swapgs:
	SWAPGS_UNSAFE_STACK
nmi_restore:
	RESTORE_EXTRA_REGS
	RESTORE_C_REGS
	/* Pop the extra iret frame at once */
	REMOVE_PT_GPREGS_FROM_STACK 6*8
	/* Clear the NMI executing stack variable */
	movq	$0, 5*8(%rsp)
	INTERRUPT_RETURN
</code></pre>
<p>where <code>INTERRUPT_RETURN</code> is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/irqflags.h">arch/x86/include/irqflags.h</a> and just expands to the <code>iret</code> instruction. That's all.</p>
<p>Now let's consider case when another <code>NMI</code> interrupt occurred when previous <code>NMI</code> interrupt didn't finish its execution. You can remember from the beginning of this part that we've made a check that we came from userspace and jump on the <code>first_nmi</code> in this case:</p>
<pre><code class="language-assembly">cmpl	$__KERNEL_CS, 16(%rsp)
jne	first_nmi
</code></pre>
<p>Note that in this case it is first <code>NMI</code> every time, because if the first <code>NMI</code> catched page fault, breakpoint or another exception it will be executed in the kernel mode. If we didn't come from userspace, first of all we test our temporary variable:</p>
<pre><code class="language-assembly">cmpl	$1, -8(%rsp)
je	nested_nmi
</code></pre>
<p>and if it is set to <code>1</code> we jump to the <code>nested_nmi</code> label. If it is not <code>1</code>, we test the <code>IST</code> stack. In the case of nested <code>NMIs</code> we check that we are above the <code>repeat_nmi</code>. In this case we ignore it, in other way we check that we above than <code>end_repeat_nmi</code> and jump on the <code>nested_nmi_out</code> label.</p>
<p>Now let's look on the <code>do_nmi</code> exception handler. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/nmi.c">arch/x86/kernel/nmi.c</a> source code file and takes two parameters:</p>
<ul>
<li>address of the <code>pt_regs</code>;</li>
<li>error code.</li>
</ul>
<p>as all exception handlers. The <code>do_nmi</code> starts from the call of the <code>nmi_nesting_preprocess</code> function and ends with the call of the <code>nmi_nesting_postprocess</code>. The <code>nmi_nesting_preprocess</code> function checks that we likely do not work with the debug stack and if we on the debug stack set the <code>update_debug_stack</code> <a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html">per-cpu</a> variable to <code>1</code> and call the <code>debug_stack_set_zero</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c">arch/x86/kernel/cpu/common.c</a>. This function increases the <code>debug_stack_use_ctr</code> per-cpu variable and loads new <code>Interrupt Descriptor Table</code>:</p>
<pre><code class="language-C">static inline void nmi_nesting_preprocess(struct pt_regs *regs)
{
        if (unlikely(is_debug_stack(regs-&gt;sp))) {
                debug_stack_set_zero();
                this_cpu_write(update_debug_stack, 1);
        }
}
</code></pre>
<p>The <code>nmi_nesting_postprocess</code> function checks the <code>update_debug_stack</code> per-cpu variable which we set in the <code>nmi_nesting_preprocess</code> and resets debug stack or in another words it loads origin <code>Interrupt Descriptor Table</code>. After the call of the <code>nmi_nesting_preprocess</code> function, we can see the call of the <code>nmi_enter</code> in the <code>do_nmi</code>. The <code>nmi_enter</code> increases <code>lockdep_recursion</code> field of the interrupted process, update preempt counter and informs the <a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a> subsystem about <code>NMI</code>. There is also <code>nmi_exit</code> function that does the same stuff as <code>nmi_enter</code>, but vice-versa. After the <code>nmi_enter</code> we increase <code>__nmi_count</code> in the <code>irq_stat</code> structure and call the <code>default_do_nmi</code> function. First of all in the <code>default_do_nmi</code> we check the address of the previous nmi and update address of the last nmi to the actual:</p>
<pre><code class="language-C">if (regs-&gt;ip == __this_cpu_read(last_nmi_rip))
    b2b = true;
else
    __this_cpu_write(swallow_nmi, false);

__this_cpu_write(last_nmi_rip, regs-&gt;ip);
</code></pre>
<p>After this first of all we need to handle CPU-specific <code>NMIs</code>:</p>
<pre><code class="language-C">handled = nmi_handle(NMI_LOCAL, regs, b2b);
__this_cpu_add(nmi_stats.normal, handled);
</code></pre>
<p>And then non-specific <code>NMIs</code> depends on its reason:</p>
<pre><code class="language-C">reason = x86_platform.get_nmi_reason();
if (reason &amp; NMI_REASON_MASK) {
	if (reason &amp; NMI_REASON_SERR)
		pci_serr_error(reason, regs);
	else if (reason &amp; NMI_REASON_IOCHK)
		io_check_error(reason, regs);

	__this_cpu_add(nmi_stats.external, 1);
	return;
}
</code></pre>
<p>That's all.</p>
<h2 id="range-exceeded-exception">Range Exceeded Exception</h2>
<p>The next exception is the <code>BOUND</code> range exceeded exception. The <code>BOUND</code> instruction determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). If the index is not within bounds, a <code>BOUND</code> range exceeded exception or <code>#BR</code> is occurred. The handler of the <code>#BR</code> exception is the <code>do_bounds</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. The <code>do_bounds</code> handler starts with the call of the <code>exception_enter</code> function and ends with the call of the <code>exception_exit</code>:</p>
<pre><code class="language-C">prev_state = exception_enter();

if (notify_die(DIE_TRAP, "bounds", regs, error_code,
	           X86_TRAP_BR, SIGSEGV) == NOTIFY_STOP)
    goto exit;
...
...
...
exception_exit(prev_state);
return;
</code></pre>
<p>After we have got the state of the previous context, we add the exception to the <code>notify_die</code> chain and if it will return <code>NOTIFY_STOP</code> we return from the exception. More about notify chains and the <code>context tracking</code> functions you can read in the <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-5.html">previous part</a>. In the next step we enable interrupts if they were disabled with the <code>contidional_sti</code> function that checks <code>IF</code> flag and call the <code>local_irq_enable</code> depends on its value:</p>
<pre><code class="language-C">conditional_sti(regs);

if (!user_mode(regs))
	die("bounds", regs, error_code);
</code></pre>
<p>and check that if we didn't came from user mode we send <code>SIGSEGV</code> signal with the <code>die</code> function. After this we check is <a href="https://en.wikipedia.org/wiki/Intel_MPX">MPX</a> enabled or not, and if this feature is disabled we jump on the <code>exit_trap</code> label:</p>
<pre><code class="language-C">if (!cpu_feature_enabled(X86_FEATURE_MPX)) {
	goto exit_trap;
}

where we execute `do_trap` function (more about it you can find in the previous part):

```C
exit_trap:
	do_trap(X86_TRAP_BR, SIGSEGV, "bounds", regs, error_code, NULL);
	exception_exit(prev_state);
</code></pre>
<p>If <code>MPX</code> feature is enabled we check the <code>BNDSTATUS</code> with the <code>get_xsave_field_ptr</code> function and if it is zero, it means that the <code>MPX</code> was not responsible for this exception:</p>
<pre><code class="language-C">bndcsr = get_xsave_field_ptr(XSTATE_BNDCSR);
if (!bndcsr)
		goto exit_trap;
</code></pre>
<p>After all of this, there is still only one way when <code>MPX</code> is responsible for this exception. We will not dive into the details about Intel Memory Protection Extensions in this part, but will see it in another chapter.</p>
<h2 id="coprocessor-exception-and-simd-exception">Coprocessor exception and SIMD exception</h2>
<p>The next two exceptions are <a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a> Floating-Point Error exception or <code>#MF</code> and <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> Floating-Point Exception or <code>#XF</code>. The first exception occurs when the <code>x87 FPU</code> has detected floating point error. For example divide by zero, numeric overflow and etc. The second exception occurs when the processor has detected <a href="https://en.wikipedia.org/wiki/SSE3">SSE/SSE2/SSE3</a> <code>SIMD</code> floating-point exception. It can be the same as for the <code>x87 FPU</code>. The handlers for these exceptions are <code>do_coprocessor_error</code> and <code>do_simd_coprocessor_error</code> are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> and very similar on each other. They both make a call of the <code>math_error</code> function from the same source code file but pass different vector number. The <code>do_coprocessor_error</code> passes <code>X86_TRAP_MF</code> vector number to the <code>math_error</code>:</p>
<pre><code class="language-C">dotraplinkage void do_coprocessor_error(struct pt_regs *regs, long error_code)
{
	enum ctx_state prev_state;

	prev_state = exception_enter();
	math_error(regs, error_code, X86_TRAP_MF);
	exception_exit(prev_state);
}
</code></pre>
<p>and <code>do_simd_coprocessor_error</code> passes <code>X86_TRAP_XF</code> to the <code>math_error</code> function:</p>
<pre><code class="language-C">dotraplinkage void
do_simd_coprocessor_error(struct pt_regs *regs, long error_code)
{
	enum ctx_state prev_state;

	prev_state = exception_enter();
	math_error(regs, error_code, X86_TRAP_XF);
	exception_exit(prev_state);
}
</code></pre>
<p>First of all the <code>math_error</code> function defines current interrupted task, address of its fpu, string which describes an exception, add it to the <code>notify_die</code> chain and return from the exception handler if it will return <code>NOTIFY_STOP</code>:</p>
<pre><code class="language-C">	struct task_struct *task = current;
	struct fpu *fpu = &amp;task-&gt;thread.fpu;
	siginfo_t info;
	char *str = (trapnr == X86_TRAP_MF) ? "fpu exception" :
						"simd exception";

	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, SIGFPE) == NOTIFY_STOP)
		return;
</code></pre>
<p>After this we check that we are from the kernel mode and if yes we will try to fix an exception with the <code>fixup_exception</code> function. If we cannot we fill the task with the exception's error code and vector number and die:</p>
<pre><code class="language-C">if (!user_mode(regs)) {
	if (!fixup_exception(regs)) {
		task-&gt;thread.error_code = error_code;
		task-&gt;thread.trap_nr = trapnr;
		die(str, regs, error_code);
	}
	return;
}
</code></pre>
<p>If we came from the user mode, we save the <code>fpu</code> state, fill the task structure with the vector number of an exception and <code>siginfo_t</code> with the number of signal, <code>errno</code>, the address where exception occurred and signal code:</p>
<pre><code class="language-C">fpu__save(fpu);

task-&gt;thread.trap_nr	= trapnr;
task-&gt;thread.error_code = error_code;
info.si_signo		= SIGFPE;
info.si_errno		= 0;
info.si_addr		= (void __user *)uprobe_get_trap_addr(regs);
info.si_code = fpu__exception_code(fpu, trapnr);
</code></pre>
<p>After this we check the signal code and if it is non-zero we return:</p>
<pre><code class="language-C">if (!info.si_code)
	return;
</code></pre>
<p>Or send the <code>SIGFPE</code> signal in the end:</p>
<pre><code class="language-C">force_sig_info(SIGFPE, &amp;info, task);
</code></pre>
<p>That's all.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is the end of the sixth part of the <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html">Interrupts and Interrupt Handling</a> chapter and we saw implementation of some exception handlers in this part, like <code>non-maskable</code> interrupt, <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> and <a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a> floating point exception. Finally we have finsihed with the <code>trap_init</code> function in this part and will go ahead in the next part. The next our point is the external interrupts and the <code>early_irq_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/General_protection_fault">General Protection Fault</a></li>
<li><a href="https://en.wikipedia.org/wiki/Opcode">opcode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable</a></li>
<li><a href="http://pdos.csail.mit.edu/6.828/2005/readings/i386/BOUND.htm">BOUND instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/CPU_socket">CPU socket</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/kernel-stacks">Interrupt Stack Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Paravirtualization">Paravirtualization</a></li>
<li><a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC116">.rept</a></li>
<li><a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coprocessor">Coprocessor</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="http://faydoc.tripod.com/cpu/iret.htm">iret</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a></li>
<li><a href="https://en.wikipedia.org/wiki/Breakpoint">breakpoint</a></li>
<li><a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a></li>
<li><a href="https://en.wikipedia.org/wiki/Model-specific_register">Model Specific regiser</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_MPX">MPX</a></li>
<li><a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-5.html">Previous part</a></li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/31/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/31/index.html">操作系统思考</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 74个">74</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/181/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/181/index.html">命令行的艺术</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/101.html">jlevy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 46710个">46710</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/44/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/44/index.html">Shell 编程范例</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/23.html">泰晓科技</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月30日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 296个">296</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/193/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/193/index.html">Pixi教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/109.html">Zainking</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">56页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2020年5月17日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/154/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/154/index.html">Python 学习总结</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/86.html">itroger</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">11页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月12日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/133/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/vuejs_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/133/index.html">vue中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/71.html">srzyhead</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="vuejs">vuejs</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/104/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/104/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/README.html" title="简介" data-book-page-rel-url="README.html" data-book-page-id="7458">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/README.html" title="引导" data-book-page-rel-url="Booting/README.html" data-book-page-id="7459">引导</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-1.html" title="从引导加载程序内核" data-book-page-rel-url="Booting/linux-bootstrap-1.html" data-book-page-id="7460">从引导加载程序内核</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-2.html" title="在内核安装代码的第一步" data-book-page-rel-url="Booting/linux-bootstrap-2.html" data-book-page-id="7461">在内核安装代码的第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-3.html" title="视频模式初始化和转换到保护模式" data-book-page-rel-url="Booting/linux-bootstrap-3.html" data-book-page-id="7462">视频模式初始化和转换到保护模式</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-4.html" title="过渡到 64 位模式" data-book-page-rel-url="Booting/linux-bootstrap-4.html" data-book-page-id="7463">过渡到 64 位模式</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-5.html" title="内核解压缩" data-book-page-rel-url="Booting/linux-bootstrap-5.html" data-book-page-id="7464">内核解压缩</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/README.html" title="初始化" data-book-page-rel-url="Initialization/README.html" data-book-page-id="7465">初始化</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-1.html" title="内核解压之后的首要步骤" data-book-page-rel-url="Initialization/linux-initialization-1.html" data-book-page-id="7466">内核解压之后的首要步骤</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-2.html" title="早期的中断和异常控制" data-book-page-rel-url="Initialization/linux-initialization-2.html" data-book-page-id="7467">早期的中断和异常控制</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-3.html" title="在到达内核入口之前最后的准备" data-book-page-rel-url="Initialization/linux-initialization-3.html" data-book-page-id="7468">在到达内核入口之前最后的准备</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-4.html" title="内核入口 - start_kernel" data-book-page-rel-url="Initialization/linux-initialization-4.html" data-book-page-id="7469">内核入口 - start_kernel</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-5.html" title="体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-5.html" data-book-page-id="7470">体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-6.html" title="进一步初始化指定体系架构" data-book-page-rel-url="Initialization/linux-initialization-6.html" data-book-page-id="7471">进一步初始化指定体系架构</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-7.html" title="最后对指定体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-7.html" data-book-page-id="7472">最后对指定体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-8.html" title="调度器初始化" data-book-page-rel-url="Initialization/linux-initialization-8.html" data-book-page-id="7473">调度器初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-9.html" title="RCU 初始化" data-book-page-rel-url="Initialization/linux-initialization-9.html" data-book-page-id="7474">RCU 初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-10.html" title="初始化结束" data-book-page-rel-url="Initialization/linux-initialization-10.html" data-book-page-id="7475">初始化结束</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/README.html" title="中断" data-book-page-rel-url="Interrupts/README.html" data-book-page-id="7476">中断</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-1.html" title="中断和中断处理 Part 1." data-book-page-rel-url="Interrupts/interrupts-1.html" data-book-page-id="7477">中断和中断处理 Part 1.</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-2.html" title="深入 Linux 内核中的中断" data-book-page-rel-url="Interrupts/interrupts-2.html" data-book-page-id="7478">深入 Linux 内核中的中断</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-3.html" title="初步中断处理" data-book-page-rel-url="Interrupts/interrupts-3.html" data-book-page-id="7479">初步中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-4.html" title="中断处理" data-book-page-rel-url="Interrupts/interrupts-4.html" data-book-page-id="7480">中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-5.html" title="异常处理的实现" data-book-page-rel-url="Interrupts/interrupts-5.html" data-book-page-id="7481">异常处理的实现</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-6.html" title="处理不可屏蔽中断" data-book-page-rel-url="Interrupts/interrupts-6.html" data-book-page-id="7482">处理不可屏蔽中断</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-7.html" title="深入外部硬件中断" data-book-page-rel-url="Interrupts/interrupts-7.html" data-book-page-id="7483">深入外部硬件中断</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-8.html" title="IRQs的非早期初始化" data-book-page-rel-url="Interrupts/interrupts-8.html" data-book-page-id="7484">IRQs的非早期初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-9.html" title="Softirq, Tasklets and Workqueues" data-book-page-rel-url="Interrupts/interrupts-9.html" data-book-page-id="7485">Softirq, Tasklets and Workqueues</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-10.html" title="最后一部分" data-book-page-rel-url="Interrupts/interrupts-10.html" data-book-page-id="7486">最后一部分</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/README.html" title="系统调用" data-book-page-rel-url="SysCall/README.html" data-book-page-id="7487">系统调用</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-1.html" title="系统调用概念简介" data-book-page-rel-url="SysCall/syscall-1.html" data-book-page-id="7488">系统调用概念简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-2.html" title="Linux 内核如何处理系统调用" data-book-page-rel-url="SysCall/syscall-2.html" data-book-page-id="7489">Linux 内核如何处理系统调用</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-3.html" title="vsyscall and vDSO" data-book-page-rel-url="SysCall/syscall-3.html" data-book-page-id="7490">vsyscall and vDSO</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-4.html" title="Linux 内核如何运行程序" data-book-page-rel-url="SysCall/syscall-4.html" data-book-page-id="7491">Linux 内核如何运行程序</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/README.html" title="定时器和时钟管理" data-book-page-rel-url="Timers/README.html" data-book-page-id="7492">定时器和时钟管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-1.html" title="简介" data-book-page-rel-url="Timers/timers-1.html" data-book-page-id="7493">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-2.html" title="时钟源框架简介" data-book-page-rel-url="Timers/timers-2.html" data-book-page-id="7494">时钟源框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-3.html" title="The tick broadcast framework and dyntick" data-book-page-rel-url="Timers/timers-3.html" data-book-page-id="7495">The tick broadcast framework and dyntick</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-4.html" title="定时器介绍" data-book-page-rel-url="Timers/timers-4.html" data-book-page-id="7496">定时器介绍</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-5.html" title="Clockevents 框架简介" data-book-page-rel-url="Timers/timers-5.html" data-book-page-id="7497">Clockevents 框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-6.html" title="x86 相关的时钟源" data-book-page-rel-url="Timers/timers-6.html" data-book-page-id="7498">x86 相关的时钟源</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-7.html" title="Linux 内核中与时钟相关的系统调用" data-book-page-rel-url="Timers/timers-7.html" data-book-page-id="7499">Linux 内核中与时钟相关的系统调用</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/README.html" title="同步原语" data-book-page-rel-url="SyncPrim/README.html" data-book-page-id="7500">同步原语</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-1.html" title="自旋锁简介" data-book-page-rel-url="SyncPrim/sync-1.html" data-book-page-id="7501">自旋锁简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-2.html" title="队列自旋锁" data-book-page-rel-url="SyncPrim/sync-2.html" data-book-page-id="7502">队列自旋锁</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-3.html" title="信号量" data-book-page-rel-url="SyncPrim/sync-3.html" data-book-page-id="7503">信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-4.html" title="互斥锁" data-book-page-rel-url="SyncPrim/sync-4.html" data-book-page-id="7504">互斥锁</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-5.html" title="读者/写者信号量" data-book-page-rel-url="SyncPrim/sync-5.html" data-book-page-id="7505">读者/写者信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-6.html" title="顺序锁" data-book-page-rel-url="SyncPrim/sync-6.html" data-book-page-id="7506">顺序锁</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/MM/README.html" title="内存管理" data-book-page-rel-url="MM/README.html" data-book-page-id="7508">内存管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/MM/linux-mm-1.html" title="内存块" data-book-page-rel-url="MM/linux-mm-1.html" data-book-page-id="7509">内存块</a>
</li>
<li>
<a class="pjax" href="../../../book/104/MM/linux-mm-2.html" title="固定映射地址和 ioremap" data-book-page-rel-url="MM/linux-mm-2.html" data-book-page-id="7510">固定映射地址和 ioremap</a>
</li>
<li>
<a class="pjax" href="../../../book/104/MM/linux-mm-3.html" title="kmemcheck" data-book-page-rel-url="MM/linux-mm-3.html" data-book-page-id="7511">kmemcheck</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/README.html" title="概念" data-book-page-rel-url="Concepts/README.html" data-book-page-id="7512">概念</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Concepts/per-cpu.html" title="每个 CPU 的变量" data-book-page-rel-url="Concepts/per-cpu.html" data-book-page-id="7513">每个 CPU 的变量</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/cpumask.html" title="CPU 掩码" data-book-page-rel-url="Concepts/cpumask.html" data-book-page-id="7514">CPU 掩码</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/initcall.html" title="initcall 机制" data-book-page-rel-url="Concepts/initcall.html" data-book-page-id="7515">initcall 机制</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/notification_chains.html" title="Linux 内核的通知链" data-book-page-rel-url="Concepts/notification_chains.html" data-book-page-id="7516">Linux 内核的通知链</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/DataStructures/README.html" title="Linux 内核中的数据结构" data-book-page-rel-url="DataStructures/README.html" data-book-page-id="7517">Linux 内核中的数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/DataStructures/dlist.html" title="双向链表" data-book-page-rel-url="DataStructures/dlist.html" data-book-page-id="7518">双向链表</a>
</li>
<li>
<a class="pjax" href="../../../book/104/DataStructures/radix-tree.html" title="基数树" data-book-page-rel-url="DataStructures/radix-tree.html" data-book-page-id="7519">基数树</a>
</li>
<li>
<a class="pjax" href="../../../book/104/DataStructures/bitmap.html" title="位数组" data-book-page-rel-url="DataStructures/bitmap.html" data-book-page-id="7520">位数组</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Theory/README.html" title="理论" data-book-page-rel-url="Theory/README.html" data-book-page-id="7521">理论</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Theory/Paging.html" title="分页" data-book-page-rel-url="Theory/Paging.html" data-book-page-id="7522">分页</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Theory/ELF.html" title="Elf64 格式" data-book-page-rel-url="Theory/ELF.html" data-book-page-id="7523">Elf64 格式</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/README.html" title="杂项" data-book-page-rel-url="Misc/README.html" data-book-page-id="7524">杂项</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Misc/how_kernel_compiled.html" title="内核编译方法" data-book-page-rel-url="Misc/how_kernel_compiled.html" data-book-page-id="7525">内核编译方法</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/linkers.html" title="链接器" data-book-page-rel-url="Misc/linkers.html" data-book-page-id="7526">链接器</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/contribute.html" title="Linux 内核开发" data-book-page-rel-url="Misc/contribute.html" data-book-page-id="7527">Linux 内核开发</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/program_startup.html" title="用户空间的程序启动过程" data-book-page-rel-url="Misc/program_startup.html" data-book-page-id="7528">用户空间的程序启动过程</a>
</li>
<li>
<a class="pjax" href="../../../book/104/" title="Write and Submit your first Linux kernel Patch" data-book-page-rel-url="" data-book-page-id="7507">Write and Submit your first Linux kernel Patch</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/KernelStructures/README.html" title="内核数据结构" data-book-page-rel-url="KernelStructures/README.html" data-book-page-id="7529">内核数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/KernelStructures/idt.html" title="中断描述符表" data-book-page-rel-url="KernelStructures/idt.html" data-book-page-id="7530">中断描述符表</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/LINKS.html" title="有帮助的链接" data-book-page-rel-url="LINKS.html" data-book-page-id="7531">有帮助的链接</a>
</li>
<li>
<a class="pjax" href="../../../book/104/contributors.html" title="贡献者" data-book-page-rel-url="contributors.html" data-book-page-id="7532">贡献者</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =104;var bookPageId =7482;var bookPageRelUrl ='Interrupts/interrupts-6.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>