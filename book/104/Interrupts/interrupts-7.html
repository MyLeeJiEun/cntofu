
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>深入外部硬件中断-Linux 内核揭密</title>
<meta content='深入外部硬件中断,Linux 内核揭密' name='keywords'>
<meta content='深入外部硬件中断,Linux 内核揭密' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/104/Interrupts/interrupts-6.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">处理不可屏蔽中断</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/104/Interrupts/interrupts-8.html">
<span class="">IRQs的非早期初始化</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/104/index.html">Linux 内核揭密</a>
<a target="_blank" rel="nofollow" href="https://github.com/ye11ow/linux-insides-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="interrupts-and-interrupt-handling-part-7">Interrupts and Interrupt Handling. Part 7.</h1>
<h2 id="introduction-to-external-interrupts">Introduction to external interrupts</h2>
<p>This is the seventh part of the Interrupts and Interrupt Handling in the Linux kernel <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html">chapter</a> and in the previous <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/interrupts-6.html">part</a> we have finished with the exceptions which are generated by the processor. In this part we will continue to dive to the interrupt handling and will start with the external hardware interrupt handling. As you can remember, in the previous part we have finished with the <code>trap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/trap.c</a> and the next step is the call of the <code>early_irq_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>.</p>
<p>Interrupts are signal that are sent across <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> or <code>Interrupt Request Line</code> by a hardware or software. External hardware interrupts allow devices like keyboard, mouse and etc, to indicate that it needs attention of the processor. Once the processor receives the <code>Interrupt Request</code>, it will temporary stop execution of the running program and invoke special routine which depends on an interrupt. We already know that this routine is called interrupt handler (or how we will call it <code>ISR</code> or <code>Interrupt Service Routine</code> from this part). The <code>ISR</code> or <code>Interrupt Handler Routine</code> can be found in Interrupt Vector table that is located at fixed address in the memory. After the interrupt is handled processor resumes the interrupted process. At the boot/initialization time, the Linux kernel identifies all devices in the machine, and appropriate interrupt handlers are loaded into the interrupt table. As we saw in the previous parts, most exceptions are handled simply by the sending a <a href="https://en.wikipedia.org/wiki/Unix_signal">Unix signal</a> to the interrupted process. That's why kernel is can handle an exception quickly. Unfortunately we can not use this approach for the external hardware interrupts, because often they arrive after (and sometimes long after) the process to which they are related has been suspended. So it would make no sense to send a Unix signal to the current process. External interrupt handling depends on the type of an interrupt:</p>
<ul>
<li><code>I/O</code> interrupts;</li>
<li>Timer interrupts;</li>
<li>Interprocessor interrupts.</li>
</ul>
<p>I will try to describe all types of interrupts in this book.</p>
<p>Generally, a handler of an <code>I/O</code> interrupt must be flexible enough to service several devices at the same time. For example in the <a href="https://en.wikipedia.org/wiki/Conventional_PCI">PCI</a> bus architecture several devices may share the same <code>IRQ</code> line. In the simplest way the Linux kernel must do following thing when an <code>I/O</code> interrupt occurred:</p>
<ul>
<li>Save the value of an <code>IRQ</code> and the register's contents on the kernel stack;</li>
<li>Send an acknowledgment to the hardware controller which is servicing the <code>IRQ</code> line;</li>
<li>Execute the interrupt service routine (next we will call it <code>ISR</code>) which is associated with the device;</li>
<li>Restore registers and return from an interrupt;</li>
</ul>
<p>Ok, we know a little theory and now let's start with the <code>early_irq_init</code> function. The implementation of the <code>early_irq_init</code> function is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a>. This function make early initialization of the <code>irq_desc</code> structure. The <code>irq_desc</code> structure is the foundation of interrupt management code in the Linux kernel. An array of this structure, which has the same name - <code>irq_desc</code>, keeps track of every interrupt request source in the Linux kernel. This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqdesc.h">include/linux/irqdesc.h</a> and as you can note it depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. This kernel configuration option enables support for sparse irqs. The <code>irq_desc</code> structure contains many different files:</p>
<ul>
<li><code>irq_common_data</code> - per irq and chip data passed down to chip functions;</li>
<li><code>status_use_accessors</code> - contains status of the interrupt source which is combination of the values from the <code>enum</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irq.h">include/linux/irq.h</a> and different macros which are defined in the same source code file;</li>
<li><code>kstat_irqs</code> - irq stats per-cpu;</li>
<li><code>handle_irq</code> - highlevel irq-events handler;</li>
<li><code>action</code> - identifies the interrupt service routines to be invoked when the <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> occurs;</li>
<li><code>irq_count</code> - counter of interrupt occurrences on the IRQ line;</li>
<li><code>depth</code> - <code>0</code> if the IRQ line is enabled and a positive value if it has been disabled at least once;</li>
<li><code>last_unhandled</code> - aging timer for unhandled count;</li>
<li><code>irqs_unhandled</code> - count of the unhandled interrupts;</li>
<li><code>lock</code> - a spin lock used to serialize the accesses to the <code>IRQ</code> descriptor;</li>
<li><code>pending_mask</code> - pending rebalanced interrupts;</li>
<li><code>owner</code> - an owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;</li>
<li>and etc.</li>
</ul>
<p>Of course it is not all fields of the <code>irq_desc</code> structure, because it is too long to describe each field of this structure, but we will see it all soon. Now let's start to dive into the implementation of the <code>early_irq_init</code> function.</p>
<h2 id="early-external-interrupts-initialization">Early external interrupts initialization</h2>
<p>Now, let's look on the implementation of the <code>early_irq_init</code> function. Note that implementation of the <code>early_irq_init</code> function depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. Now we consider implementation of the <code>early_irq_init</code> function when the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option is not set. This function starts from the declaration of the following variables: <code>irq</code> descriptors counter, loop counter, memory node and the <code>irq_desc</code> descriptor:</p>
<pre><code class="language-C">int __init early_irq_init(void)
{
        int count, i, node = first_online_node;
        struct irq_desc *desc;
		...
		...
		...
}
</code></pre>
<p>The <code>node</code> is an online <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> node which depends on the <code>MAX_NUMNODES</code> value which depends on the <code>CONFIG_NODES_SHIFT</code> kernel configuration parameter:</p>
<pre><code class="language-C">#define MAX_NUMNODES    (1 &lt;&lt; NODES_SHIFT)
...
...
...
#ifdef CONFIG_NODES_SHIFT
    #define NODES_SHIFT     CONFIG_NODES_SHIFT
#else
    #define NODES_SHIFT     0
#endif
</code></pre>
<p>As I already wrote, implementation of the <code>first_online_node</code> macro depends on the <code>MAX_NUMNODES</code> value:</p>
<pre><code class="language-C">#if MAX_NUMNODES &gt; 1
  #define first_online_node       first_node(node_states[N_ONLINE])
#else
  #define first_online_node       0  
</code></pre>
<p>The <code>node_states</code> is the <a href="https://en.wikipedia.org/wiki/Enumerated_type">enum</a> which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/nodemask.h">include/linux/nodemask.h</a> and represent the set of the states of a node. In our case we are searching an online node and it will be <code>0</code> if <code>MAX_NUMNODES</code> is one or zero. If the <code>MAX_NUMNODES</code> is greater than one, the <code>node_states[N_ONLINE]</code> will return <code>1</code> and the <code>first_node</code> macro will be expands to the call of the <code>__first_node</code> function which will return <code>minimal</code> or the first online node:</p>
<pre><code class="language-C">#define first_node(src) __first_node(&amp;(src))

static inline int __first_node(const nodemask_t *srcp)
{
        return min_t(int, MAX_NUMNODES, find_first_bit(srcp-&gt;bits, MAX_NUMNODES));
}
</code></pre>
<p>More about this will be in the another chapter about the <code>NUMA</code>. The next step after the declaration of these local variables is the call of the:</p>
<pre><code class="language-C">init_irq_default_affinity();
</code></pre>
<p>function. The <code>init_irq_default_affinity</code> function defined in the same source code file and depends on the <code>CONFIG_SMP</code> kernel configuration option allocates a given <a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html">cpumask</a> structure (in our case it is the <code>irq_default_affinity</code>):</p>
<pre><code class="language-C">#if defined(CONFIG_SMP)
cpumask_var_t irq_default_affinity;

static void __init init_irq_default_affinity(void)
{
        alloc_cpumask_var(&amp;irq_default_affinity, GFP_NOWAIT);
        cpumask_setall(irq_default_affinity);
}
#else
static void __init init_irq_default_affinity(void)
{
}
#endif
</code></pre>
<p>We know that when a hardware, such as disk controller or keyboard, needs attention from the processor, it throws an interrupt. The interrupt tells to the processor that something has happened and that the processor should interrupt current process and handle an incoming event. In order to prevent multiple devices from sending the same interrupts, the <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> system was established where each device in a computer system is assigned its own special IRQ so that its interrupts are unique. Linux kernel can assign certain <code>IRQs</code> to specific processors. This is known as <code>SMP IRQ affinity</code>, and it allows you control how your system will respond to various hardware events (that's why it has certain implementation only if the <code>CONFIG_SMP</code> kernel configuration option is set). After we allocated <code>irq_default_affinity</code> cpumask, we can see <code>printk</code> output:</p>
<pre><code class="language-C">printk(KERN_INFO "NR_IRQS:%d\n", NR_IRQS);
</code></pre>
<p>which prints <code>NR_IRQS</code>:</p>
<pre><code class="language-C">~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
</code></pre>
<p>The <code>NR_IRQS</code> is the maximum number of the <code>irq</code> descriptors or in another words maximum number of interrupts. Its value depends on the state of the <code>CONFIG_X86_IO_APIC</code> kernel configuration option. If the <code>CONFIG_X86_IO_APIC</code> is not set and the Linux kernel uses an old <a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a> chip, the <code>NR_IRQS</code> is:</p>
<pre><code class="language-C">#define NR_IRQS_LEGACY                    16

#ifdef CONFIG_X86_IO_APIC
...
...
...
#else
# define NR_IRQS                        NR_IRQS_LEGACY
#endif
</code></pre>
<p>In other way, when the <code>CONFIG_X86_IO_APIC</code> kernel configuration option is set, the <code>NR_IRQS</code> depends on the amount of the processors and amount of the interrupt vectors:</p>
<pre><code class="language-C">#define CPU_VECTOR_LIMIT               (64 * NR_CPUS)
#define NR_VECTORS                     256
#define IO_APIC_VECTOR_LIMIT           ( 32 * MAX_IO_APICS )
#define MAX_IO_APICS                   128

# define NR_IRQS                                       \
        (CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ?     \
                (NR_VECTORS + CPU_VECTOR_LIMIT)  :     \
                (NR_VECTORS + IO_APIC_VECTOR_LIMIT))
...
...
...
</code></pre>
<p>We remember from the previous parts, that the amount of processors we can set during Linux kernel configuration process with the <code>CONFIG_NR_CPUS</code> configuration option:</p>
<p><a href="http://oi60.tinypic.com/1zdm1dt.jpg" data-uk-lightbox><img src="http://oi60.tinypic.com/1zdm1dt.jpg" alt="kernel"></a></p>
<p>In the first case (<code>CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT</code>), the <code>NR_IRQS</code> will be <code>4352</code>, in the second case (<code>CPU_VECTOR_LIMIT &lt; IO_APIC_VECTOR_LIMIT</code>), the <code>NR_IRQS</code> will be <code>768</code>. In my case the <code>NR_CPUS</code> is <code>8</code> as you can see in the my configuration, the <code>CPU_VECTOR_LIMIT</code> is <code>512</code> and the <code>IO_APIC_VECTOR_LIMIT</code> is <code>4096</code>. So <code>NR_IRQS</code> for my configuration is <code>4352</code>:</p>
<pre><code>~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
</code></pre>
<p>In the next step we assign array of the IRQ descriptors to the <code>irq_desc</code> variable which we defined in the start of the <code>early_irq_init</code> function and calculate count of the <code>irq_desc</code> array with the <code>ARRAY_SIZE</code> macro:</p>
<pre><code class="language-C">desc = irq_desc;
count = ARRAY_SIZE(irq_desc);
</code></pre>
<p>The <code>irq_desc</code> array defined in the same source code file and looks like:</p>
<pre><code class="language-C">struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
        [0 ... NR_IRQS-1] = {
                .handle_irq     = handle_bad_irq,
                .depth          = 1,
                .lock           = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),
        }
};
</code></pre>
<p>The <code>irq_desc</code> is array of the <code>irq</code> descriptors. It has three already initialized fields:</p>
<ul>
<li><code>handle_irq</code> - as I already wrote above, this field is the highlevel irq-event handler. In our case it initialized with the <code>handle_bad_irq</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/handle.c">kernel/irq/handle.c</a> source code file and handles spurious and unhandled irqs;</li>
<li><code>depth</code> - <code>0</code> if the IRQ line is enabled and a positive value if it has been disabled at least once;</li>
<li><code>lock</code> - A spin lock used to serialize the accesses to the <code>IRQ</code> descriptor.</li>
</ul>
<p>As we calculated count of the interrupts and initialized our <code>irq_desc</code> array, we start to fill descriptors in the loop:</p>
<pre><code class="language-C">for (i = 0; i &lt; count; i++) {
    desc[i].kstat_irqs = alloc_percpu(unsigned int);
    alloc_masks(&amp;desc[i], GFP_KERNEL, node);
    raw_spin_lock_init(&amp;desc[i].lock);
    lockdep_set_class(&amp;desc[i].lock, &amp;irq_desc_lock_class);
	desc_set_defaults(i, &amp;desc[i], node, NULL);
}
</code></pre>
<p>We are going through the all interrupt descriptors and do the following things:</p>
<p>First of all we allocate <a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html">percpu</a> variable for the <code>irq</code> kernel statistic with the <code>alloc_percpu</code> macro. This macro allocates one instance of an object of the given type for every processor on the system. You can access kernel statistic from the userspace via <code>/proc/stat</code>:</p>
<pre><code>~$ cat /proc/stat
cpu  207907 68 53904 5427850 14394 0 394 0 0 0
cpu0 25881 11 6684 679131 1351 0 18 0 0 0
cpu1 24791 16 5894 679994 2285 0 24 0 0 0
cpu2 26321 4 7154 678924 664 0 71 0 0 0
cpu3 26648 8 6931 678891 414 0 244 0 0 0
...
...
...
</code></pre>
<p>Where the sixth column is the servicing interrupts. After this we allocate <a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html">cpumask</a> for the given irq descriptor affinity and initialize the <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for the given interrupt descriptor. After this before the <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a>, the lock will be acquired with a call of the <code>raw_spin_lock</code> and unlocked with the call of the <code>raw_spin_unlock</code>. In the next step we call the <code>lockdep_set_class</code> macro which set the <a href="https://lwn.net/Articles/185666/">Lock validator</a> <code>irq_desc_lock_class</code> class for the lock of the given interrupt descriptor. More about <code>lockdep</code>, <code>spinlock</code> and other synchronization primitives will be described in the separate chapter.</p>
<p>In the end of the loop we call the <code>desc_set_defaults</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a>. This function takes four parameters:</p>
<ul>
<li>number of a irq;</li>
<li>interrupt descriptor;</li>
<li>online <code>NUMA</code> node;</li>
<li>owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;</li>
</ul>
<p>and fills the rest of the <code>irq_desc</code> fields. The <code>desc_set_defaults</code> function fills interrupt number, <code>irq</code> chip, platform-specific per-chip private data for the chip methods, per-IRQ data for the <code>irq_chip</code> methods and <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">MSI</a> descriptor for the per <code>irq</code> and <code>irq</code> chip data:</p>
<pre><code class="language-C">desc-&gt;irq_data.irq = irq;
desc-&gt;irq_data.chip = &amp;no_irq_chip;
desc-&gt;irq_data.chip_data = NULL;
desc-&gt;irq_data.handler_data = NULL;
desc-&gt;irq_data.msi_desc = NULL;
...
...
...
</code></pre>
<p>The <code>irq_data.chip</code> structure provides general <code>API</code> like the <code>irq_set_chip</code>, <code>irq_set_irq_type</code> and etc, for the irq controller <a href="https://github.com/torvalds/linux/tree/master/drivers/irqchip">drivers</a>. You can find it in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/chip.c">kernel/irq/chip.c</a> source code file.</p>
<p>After this we set the status of the accessor for the given descriptor and set disabled state of the interrupts:</p>
<pre><code class="language-C">...
...
...
irq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);
irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_DISABLED);
...
...
...
</code></pre>
<p>In the next step we set the high level interrupt handlers to the <code>handle_bad_irq</code> which handles spurious and unhandled irqs (as the hardware stuff is not initialized yet, we set this handler), set <code>irq_desc.desc</code> to <code>1</code> which means that an <code>IRQ</code> is disabled, reset count of the unhandled interrupts and interrupts in general:</p>
<pre><code class="language-C">...
...
...
desc-&gt;handle_irq = handle_bad_irq;
desc-&gt;depth = 1;
desc-&gt;irq_count = 0;
desc-&gt;irqs_unhandled = 0;
desc-&gt;name = NULL;
desc-&gt;owner = owner;
...
...
...
</code></pre>
<p>After this we go through the all <a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html">possible</a> processor with the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h#L714">for_each_possible_cpu</a> helper and set the <code>kstat_irqs</code> to zero for the given interrupt descriptor:</p>
<pre><code class="language-C">	for_each_possible_cpu(cpu)
		*per_cpu_ptr(desc-&gt;kstat_irqs, cpu) = 0;
</code></pre>
<p>and call the <code>desc_smp_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a> that initializes <code>NUMA</code> node of the given interrupt descriptor, sets default <code>SMP</code> affinity and clears the <code>pending_mask</code> of the given interrupt descriptor depends on the value of the <code>CONFIG_GENERIC_PENDING_IRQ</code> kernel configuration option:</p>
<pre><code class="language-C">static void desc_smp_init(struct irq_desc *desc, int node)
{
        desc-&gt;irq_data.node = node;
        cpumask_copy(desc-&gt;irq_data.affinity, irq_default_affinity);
#ifdef CONFIG_GENERIC_PENDING_IRQ
        cpumask_clear(desc-&gt;pending_mask);
#endif
}
</code></pre>
<p>In the end of the <code>early_irq_init</code> function we return the return value of the <code>arch_early_irq_init</code> function:</p>
<pre><code class="language-C">return arch_early_irq_init();
</code></pre>
<p>This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/apic/vector.c">kernel/apic/vector.c</a> and contains only one call of the <code>arch_early_ioapic_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/apic/io_apic.c">kernel/apic/io_apic.c</a>. As we can understand from the <code>arch_early_ioapic_init</code> function's name, this function makes early initialization of the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">I/O APIC</a>. First of all it make a check of the number of the legacy interrupts with the call of the <code>nr_legacy_irqs</code> function. If we have no legacy interrupts with the <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> programmable interrupt controller we set <code>io_apic_irqs</code> to the <code>0xffffffffffffffff</code>:</p>
<pre><code class="language-C">if (!nr_legacy_irqs())
	io_apic_irqs = ~0UL;
</code></pre>
<p>After this we are going through the all <code>I/O APICs</code> and allocate space for the registers with the call of the <code>alloc_ioapic_saved_registers</code>:</p>
<pre><code class="language-C">for_each_ioapic(i)
	alloc_ioapic_saved_registers(i);
</code></pre>
<p>And in the end of the <code>arch_early_ioapic_init</code> function we are going through the all legacy irqs (from <code>IRQ0</code> to <code>IRQ15</code>) in the loop and allocate space for the <code>irq_cfg</code> which represents configuration of an irq on the given <code>NUMA</code> node:</p>
<pre><code class="language-C">for (i = 0; i &lt; nr_legacy_irqs(); i++) {
    cfg = alloc_irq_and_cfg_at(i, node);
    cfg-&gt;vector = IRQ0_VECTOR + i;
    cpumask_setall(cfg-&gt;domain);
}
</code></pre>
<p>That's all.</p>
<h2 id="sparse-irqs">Sparse IRQs</h2>
<p>We already saw in the beginning of this part that implementation of the <code>early_irq_init</code> function depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. Previously we saw implementation of the <code>early_irq_init</code> function when the <code>CONFIG_SPARSE_IRQ</code> configuration option is not set, now let's look on the its implementation when this option is set. Implementation of this function very similar, but little differ. We can see the same definition of variables and call of the <code>init_irq_default_affinity</code> in the beginning of the <code>early_irq_init</code> function:</p>
<pre><code class="language-C">#ifdef CONFIG_SPARSE_IRQ
int __init early_irq_init(void)
{
    int i, initcnt, node = first_online_node;
	struct irq_desc *desc;

	init_irq_default_affinity();
	...
	...
	...
}
#else
...
...
...
</code></pre>
<p>But after this we can see the following call:</p>
<pre><code class="language-C">initcnt = arch_probe_nr_irqs();
</code></pre>
<p>The <code>arch_probe_nr_irqs</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/apic/vector.c">arch/x86/kernel/apic/vector.c</a> and calculates count of the pre-allocated irqs and update <code>nr_irqs</code> with its number. But stop. Why there are pre-allocated irqs? There is alternative form of interrupts called - <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">Message Signaled Interrupts</a> available in the <a href="https://en.wikipedia.org/wiki/Conventional_PCI">PCI</a>. Instead of assigning a fixed number of the interrupt request, the device is allowed to record a message at a particular address of RAM, in fact, the display on the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a>. <code>MSI</code> permits a device to allocate <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code> or <code>32</code> interrupts and <code>MSI-X</code> permits a device to allocate up to <code>2048</code> interrupts. Now we know that irqs can be pre-allocated. More about <code>MSI</code> will be in a next part, but now let's look on the <code>arch_probe_nr_irqs</code> function. We can see the check which assign amount of the interrupt vectors for the each processor in the system to the <code>nr_irqs</code> if it is greater and calculate the <code>nr</code> which represents number of <code>MSI</code> interrupts:</p>
<pre><code class="language-C">int nr_irqs = NR_IRQS;

if (nr_irqs &gt; (NR_VECTORS * nr_cpu_ids))
	nr_irqs = NR_VECTORS * nr_cpu_ids;

nr = (gsi_top + nr_legacy_irqs()) + 8 * nr_cpu_ids;
</code></pre>
<p>Take a look on the <code>gsi_top</code> variable. Each <code>APIC</code> is identified with its own <code>ID</code> and with the offset where its <code>IRQ</code> starts. It is called <code>GSI</code> base or <code>Global System Interrupt</code> base. So the <code>gsi_top</code> represents it. We get the <code>Global System Interrupt</code> base from the <a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a> table (you can remember that we have parsed this table in the sixth <a href="http://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-6.html">part</a> of the Linux Kernel initialization process chapter).</p>
<p>After this we update the <code>nr</code> depends on the value of the <code>gsi_top</code>:</p>
<pre><code class="language-C">#if defined(CONFIG_PCI_MSI) || defined(CONFIG_HT_IRQ)
        if (gsi_top &lt;= NR_IRQS_LEGACY)
                nr +=  8 * nr_cpu_ids;
        else
                nr += gsi_top * 16;
#endif
</code></pre>
<p>Update the <code>nr_irqs</code> if it less than <code>nr</code> and return the number of the legacy irqs:</p>
<pre><code class="language-C">if (nr &lt; nr_irqs)
    nr_irqs = nr;

return nr_legacy_irqs();
}
</code></pre>
<p>The next after the <code>arch_probe_nr_irqs</code> is printing information about number of <code>IRQs</code>:</p>
<pre><code class="language-C">printk(KERN_INFO "NR_IRQS:%d nr_irqs:%d %d\n", NR_IRQS, nr_irqs, initcnt);
</code></pre>
<p>We can find it in the <a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a> output:</p>
<pre><code>$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352 nr_irqs:488 16
</code></pre>
<p>After this we do some checks that <code>nr_irqs</code> and <code>initcnt</code> values is not greater than maximum allowable number of <code>irqs</code>:</p>
<pre><code class="language-C">if (WARN_ON(nr_irqs &gt; IRQ_BITMAP_BITS))
    nr_irqs = IRQ_BITMAP_BITS;

if (WARN_ON(initcnt &gt; IRQ_BITMAP_BITS))
    initcnt = IRQ_BITMAP_BITS;
</code></pre>
<p>where <code>IRQ_BITMAP_BITS</code> is equal to the <code>NR_IRQS</code> if the <code>CONFIG_SPARSE_IRQ</code> is not set and <code>NR_IRQS + 8196</code> in other way. In the next step we are going over all interrupt descriptors which need to be allocated in the loop and allocate space for the descriptor and insert to the <code>irq_desc_tree</code> <a href="http://0xax.gitbooks.io/linux-insides/content/DataStructures/radix-tree.html">radix tree</a>:</p>
<pre><code class="language-C">for (i = 0; i &lt; initcnt; i++) {
    desc = alloc_desc(i, node, NULL);
    set_bit(i, allocated_irqs);
	irq_insert_desc(i, desc);
}
</code></pre>
<p>In the end of the <code>early_irq_init</code> function we return the value of the call of the <code>arch_early_irq_init</code> function as we did it already in the previous variant when the <code>CONFIG_SPARSE_IRQ</code> option was not set:</p>
<pre><code class="language-C">return arch_early_irq_init();
</code></pre>
<p>That's all.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is the end of the seventh part of the <a href="http://0xax.gitbooks.io/linux-insides/content/interrupts/index.html">Interrupts and Interrupt Handling</a> chapter and we started to dive into external hardware interrupts in this part. We saw early initialization of the <code>irq_desc</code> structure which represents description of an external interrupt and contains information about it like list of irq actions, information about interrupt handler, interrupt's owner, count of the unhandled interrupt and etc. In the next part we will continue to research external interrupts.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">numa</a></li>
<li><a href="https://en.wikipedia.org/wiki/Enumerated_type">Enum type</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/cpumask.html">cpumask</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a></li>
<li><a href="https://lwn.net/Articles/185666/">Lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">MSI</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">I/O APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a></li>
<li><a href="http://0xax.gitbooks.io/linux-insides/content/DataStructures/radix-tree.html">radix tree</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a></li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/151/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/151/index.html">Shell脚本编程30分钟入门</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/83.html">qinjx</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">5页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 5224个">5224</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/114/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/114/index.html">Linux 内核揭密</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">86页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/31/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/31/index.html">操作系统思考</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 74个">74</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/144/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/gulp_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/144/index.html">gulp 入门指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/39.html">onface</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="gulp">gulp</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">8页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1780个">1780</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/159/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/159/index.html">im-service 简介</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/91.html">yu000hong</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">37页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/131/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/visualstudio_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/131/index.html">Office 365 开发入门指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/70.html">chenxizhang</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="visualstudio">visualstudio</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">51页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 98个">98</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/104/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/104/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/README.html" title="简介" data-book-page-rel-url="README.html" data-book-page-id="7458">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/README.html" title="引导" data-book-page-rel-url="Booting/README.html" data-book-page-id="7459">引导</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-1.html" title="从引导加载程序内核" data-book-page-rel-url="Booting/linux-bootstrap-1.html" data-book-page-id="7460">从引导加载程序内核</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-2.html" title="在内核安装代码的第一步" data-book-page-rel-url="Booting/linux-bootstrap-2.html" data-book-page-id="7461">在内核安装代码的第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-3.html" title="视频模式初始化和转换到保护模式" data-book-page-rel-url="Booting/linux-bootstrap-3.html" data-book-page-id="7462">视频模式初始化和转换到保护模式</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-4.html" title="过渡到 64 位模式" data-book-page-rel-url="Booting/linux-bootstrap-4.html" data-book-page-id="7463">过渡到 64 位模式</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Booting/linux-bootstrap-5.html" title="内核解压缩" data-book-page-rel-url="Booting/linux-bootstrap-5.html" data-book-page-id="7464">内核解压缩</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/README.html" title="初始化" data-book-page-rel-url="Initialization/README.html" data-book-page-id="7465">初始化</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-1.html" title="内核解压之后的首要步骤" data-book-page-rel-url="Initialization/linux-initialization-1.html" data-book-page-id="7466">内核解压之后的首要步骤</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-2.html" title="早期的中断和异常控制" data-book-page-rel-url="Initialization/linux-initialization-2.html" data-book-page-id="7467">早期的中断和异常控制</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-3.html" title="在到达内核入口之前最后的准备" data-book-page-rel-url="Initialization/linux-initialization-3.html" data-book-page-id="7468">在到达内核入口之前最后的准备</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-4.html" title="内核入口 - start_kernel" data-book-page-rel-url="Initialization/linux-initialization-4.html" data-book-page-id="7469">内核入口 - start_kernel</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-5.html" title="体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-5.html" data-book-page-id="7470">体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-6.html" title="进一步初始化指定体系架构" data-book-page-rel-url="Initialization/linux-initialization-6.html" data-book-page-id="7471">进一步初始化指定体系架构</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-7.html" title="最后对指定体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-7.html" data-book-page-id="7472">最后对指定体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-8.html" title="调度器初始化" data-book-page-rel-url="Initialization/linux-initialization-8.html" data-book-page-id="7473">调度器初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-9.html" title="RCU 初始化" data-book-page-rel-url="Initialization/linux-initialization-9.html" data-book-page-id="7474">RCU 初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Initialization/linux-initialization-10.html" title="初始化结束" data-book-page-rel-url="Initialization/linux-initialization-10.html" data-book-page-id="7475">初始化结束</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/README.html" title="中断" data-book-page-rel-url="Interrupts/README.html" data-book-page-id="7476">中断</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-1.html" title="中断和中断处理 Part 1." data-book-page-rel-url="Interrupts/interrupts-1.html" data-book-page-id="7477">中断和中断处理 Part 1.</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-2.html" title="深入 Linux 内核中的中断" data-book-page-rel-url="Interrupts/interrupts-2.html" data-book-page-id="7478">深入 Linux 内核中的中断</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-3.html" title="初步中断处理" data-book-page-rel-url="Interrupts/interrupts-3.html" data-book-page-id="7479">初步中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-4.html" title="中断处理" data-book-page-rel-url="Interrupts/interrupts-4.html" data-book-page-id="7480">中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-5.html" title="异常处理的实现" data-book-page-rel-url="Interrupts/interrupts-5.html" data-book-page-id="7481">异常处理的实现</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-6.html" title="处理不可屏蔽中断" data-book-page-rel-url="Interrupts/interrupts-6.html" data-book-page-id="7482">处理不可屏蔽中断</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-7.html" title="深入外部硬件中断" data-book-page-rel-url="Interrupts/interrupts-7.html" data-book-page-id="7483">深入外部硬件中断</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-8.html" title="IRQs的非早期初始化" data-book-page-rel-url="Interrupts/interrupts-8.html" data-book-page-id="7484">IRQs的非早期初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-9.html" title="Softirq, Tasklets and Workqueues" data-book-page-rel-url="Interrupts/interrupts-9.html" data-book-page-id="7485">Softirq, Tasklets and Workqueues</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Interrupts/interrupts-10.html" title="最后一部分" data-book-page-rel-url="Interrupts/interrupts-10.html" data-book-page-id="7486">最后一部分</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/README.html" title="系统调用" data-book-page-rel-url="SysCall/README.html" data-book-page-id="7487">系统调用</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-1.html" title="系统调用概念简介" data-book-page-rel-url="SysCall/syscall-1.html" data-book-page-id="7488">系统调用概念简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-2.html" title="Linux 内核如何处理系统调用" data-book-page-rel-url="SysCall/syscall-2.html" data-book-page-id="7489">Linux 内核如何处理系统调用</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-3.html" title="vsyscall and vDSO" data-book-page-rel-url="SysCall/syscall-3.html" data-book-page-id="7490">vsyscall and vDSO</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SysCall/syscall-4.html" title="Linux 内核如何运行程序" data-book-page-rel-url="SysCall/syscall-4.html" data-book-page-id="7491">Linux 内核如何运行程序</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/README.html" title="定时器和时钟管理" data-book-page-rel-url="Timers/README.html" data-book-page-id="7492">定时器和时钟管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-1.html" title="简介" data-book-page-rel-url="Timers/timers-1.html" data-book-page-id="7493">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-2.html" title="时钟源框架简介" data-book-page-rel-url="Timers/timers-2.html" data-book-page-id="7494">时钟源框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-3.html" title="The tick broadcast framework and dyntick" data-book-page-rel-url="Timers/timers-3.html" data-book-page-id="7495">The tick broadcast framework and dyntick</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-4.html" title="定时器介绍" data-book-page-rel-url="Timers/timers-4.html" data-book-page-id="7496">定时器介绍</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-5.html" title="Clockevents 框架简介" data-book-page-rel-url="Timers/timers-5.html" data-book-page-id="7497">Clockevents 框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-6.html" title="x86 相关的时钟源" data-book-page-rel-url="Timers/timers-6.html" data-book-page-id="7498">x86 相关的时钟源</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Timers/timers-7.html" title="Linux 内核中与时钟相关的系统调用" data-book-page-rel-url="Timers/timers-7.html" data-book-page-id="7499">Linux 内核中与时钟相关的系统调用</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/README.html" title="同步原语" data-book-page-rel-url="SyncPrim/README.html" data-book-page-id="7500">同步原语</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-1.html" title="自旋锁简介" data-book-page-rel-url="SyncPrim/sync-1.html" data-book-page-id="7501">自旋锁简介</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-2.html" title="队列自旋锁" data-book-page-rel-url="SyncPrim/sync-2.html" data-book-page-id="7502">队列自旋锁</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-3.html" title="信号量" data-book-page-rel-url="SyncPrim/sync-3.html" data-book-page-id="7503">信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-4.html" title="互斥锁" data-book-page-rel-url="SyncPrim/sync-4.html" data-book-page-id="7504">互斥锁</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-5.html" title="读者/写者信号量" data-book-page-rel-url="SyncPrim/sync-5.html" data-book-page-id="7505">读者/写者信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/104/SyncPrim/sync-6.html" title="顺序锁" data-book-page-rel-url="SyncPrim/sync-6.html" data-book-page-id="7506">顺序锁</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/MM/README.html" title="内存管理" data-book-page-rel-url="MM/README.html" data-book-page-id="7508">内存管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/MM/linux-mm-1.html" title="内存块" data-book-page-rel-url="MM/linux-mm-1.html" data-book-page-id="7509">内存块</a>
</li>
<li>
<a class="pjax" href="../../../book/104/MM/linux-mm-2.html" title="固定映射地址和 ioremap" data-book-page-rel-url="MM/linux-mm-2.html" data-book-page-id="7510">固定映射地址和 ioremap</a>
</li>
<li>
<a class="pjax" href="../../../book/104/MM/linux-mm-3.html" title="kmemcheck" data-book-page-rel-url="MM/linux-mm-3.html" data-book-page-id="7511">kmemcheck</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/README.html" title="概念" data-book-page-rel-url="Concepts/README.html" data-book-page-id="7512">概念</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Concepts/per-cpu.html" title="每个 CPU 的变量" data-book-page-rel-url="Concepts/per-cpu.html" data-book-page-id="7513">每个 CPU 的变量</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/cpumask.html" title="CPU 掩码" data-book-page-rel-url="Concepts/cpumask.html" data-book-page-id="7514">CPU 掩码</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/initcall.html" title="initcall 机制" data-book-page-rel-url="Concepts/initcall.html" data-book-page-id="7515">initcall 机制</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Concepts/notification_chains.html" title="Linux 内核的通知链" data-book-page-rel-url="Concepts/notification_chains.html" data-book-page-id="7516">Linux 内核的通知链</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/DataStructures/README.html" title="Linux 内核中的数据结构" data-book-page-rel-url="DataStructures/README.html" data-book-page-id="7517">Linux 内核中的数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/DataStructures/dlist.html" title="双向链表" data-book-page-rel-url="DataStructures/dlist.html" data-book-page-id="7518">双向链表</a>
</li>
<li>
<a class="pjax" href="../../../book/104/DataStructures/radix-tree.html" title="基数树" data-book-page-rel-url="DataStructures/radix-tree.html" data-book-page-id="7519">基数树</a>
</li>
<li>
<a class="pjax" href="../../../book/104/DataStructures/bitmap.html" title="位数组" data-book-page-rel-url="DataStructures/bitmap.html" data-book-page-id="7520">位数组</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Theory/README.html" title="理论" data-book-page-rel-url="Theory/README.html" data-book-page-id="7521">理论</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Theory/Paging.html" title="分页" data-book-page-rel-url="Theory/Paging.html" data-book-page-id="7522">分页</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Theory/ELF.html" title="Elf64 格式" data-book-page-rel-url="Theory/ELF.html" data-book-page-id="7523">Elf64 格式</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/README.html" title="杂项" data-book-page-rel-url="Misc/README.html" data-book-page-id="7524">杂项</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/Misc/how_kernel_compiled.html" title="内核编译方法" data-book-page-rel-url="Misc/how_kernel_compiled.html" data-book-page-id="7525">内核编译方法</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/linkers.html" title="链接器" data-book-page-rel-url="Misc/linkers.html" data-book-page-id="7526">链接器</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/contribute.html" title="Linux 内核开发" data-book-page-rel-url="Misc/contribute.html" data-book-page-id="7527">Linux 内核开发</a>
</li>
<li>
<a class="pjax" href="../../../book/104/Misc/program_startup.html" title="用户空间的程序启动过程" data-book-page-rel-url="Misc/program_startup.html" data-book-page-id="7528">用户空间的程序启动过程</a>
</li>
<li>
<a class="pjax" href="../../../book/104/" title="Write and Submit your first Linux kernel Patch" data-book-page-rel-url="" data-book-page-id="7507">Write and Submit your first Linux kernel Patch</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/KernelStructures/README.html" title="内核数据结构" data-book-page-rel-url="KernelStructures/README.html" data-book-page-id="7529">内核数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/104/KernelStructures/idt.html" title="中断描述符表" data-book-page-rel-url="KernelStructures/idt.html" data-book-page-id="7530">中断描述符表</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/104/LINKS.html" title="有帮助的链接" data-book-page-rel-url="LINKS.html" data-book-page-id="7531">有帮助的链接</a>
</li>
<li>
<a class="pjax" href="../../../book/104/contributors.html" title="贡献者" data-book-page-rel-url="contributors.html" data-book-page-id="7532">贡献者</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =104;var bookPageId =7483;var bookPageRelUrl ='Interrupts/interrupts-7.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>