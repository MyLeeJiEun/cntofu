
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>API-vue中文文档</title>
<meta content='API,vue中文文档' name='keywords'>
<meta content='API,vue中文文档' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/133/comparison.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">对比其它框架</span>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/133/index.html">vue中文文档</a>
<a target="_blank" rel="nofollow" href="https://github.com/srzyhead/vue_doc_cn" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="api">API</h1>
<h2 id="全局配置">全局配置</h2>
<p><code>Vue.config</code> 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下面属性：</p>
<h3 id="debug">debug</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Boolean</code></p> </li>
<li> <p><strong>默认值：</strong> <code>false</code></p> </li>
<li> <p><strong>用法：</strong></p> <pre><code>Vue.config.debug = true
</code></pre> <p>在调试模式中，Vue 会：</p>
<ol>
<li> <p>为所有的警告打印栈追踪。</p> </li>
<li> <p>把所有的锚节点以注释节点显示在 DOM 中，更易于检查渲染结果的结构。</p> </li>
</ol> <p class="tip">只有开发版本可以使用调试模式。</p> </li>
</ul>
<h3 id="delimiters">delimiters</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Array&lt;String&gt;</code></p> </li>
<li> <p><strong>默认值：</strong> <code>["{{", "}}"]</code></p> </li>
<li> <p><strong>用法：</strong></p> <pre><code>// ES6 模板字符串
Vue.config.delimiters = ['${', '}']
</code></pre> <p>修改文本插值的定界符。</p> </li>
</ul>
<h3 id="unsafedelimiters">unsafeDelimiters</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Array&lt;String&gt;</code></p> </li>
<li> <p><strong>默认值：</strong> <code>{% raw %}["{{{", "}}}"]{% endraw %}</code></p> </li>
<li> <p><strong>用法：</strong></p> <pre><code>// make it look more dangerous
Vue.config.unsafeDelimiters = ['{!!', '!!}']
</code></pre> <p>修改原生 HTML 插值的定界符。</p> </li>
</ul>
<h3 id="silent">silent</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Boolean</code></p> </li>
<li> <p><strong>默认值：</strong> <code>false</code></p> </li>
<li> <p><strong>用法：</strong></p> <pre><code>Vue.config.silent = true
</code></pre> <p>取消 Vue.js 所有的日志与警告。</p> </li>
</ul>
<h3 id="async">async</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Boolean</code></p> </li>
<li> <p><strong>默认值：</strong> <code>true</code></p> </li>
<li> <p><strong>用法：</strong></p> <pre><code>Vue.config.async = false
</code></pre> <p>如果关闭了异步模式，Vue 在检测到数据变化时同步更新 DOM。在有些情况下这有助于调试，但是也可能导致性能下降，并且影响 watcher 回调的调用顺序。<strong><code>async: false</code>不推荐用在生产环境中。</strong></p> </li>
</ul>
<h3 id="devtools">devtools</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Boolean</code></p> </li>
<li> <p><strong>默认值：</strong> <code>true</code> (生产版为 <code>false</code>)</p> </li>
<li> <p><strong>用法：</strong></p> <pre><code>// 在加载 Vue 之后立即同步的设置
Vue.config.devtools = true
</code></pre> <p>配置是否允许 <a href="https://github.com/vuejs/vue-devtools">vue-devtools</a> 检查代码。开发版默认为 <code>true</code>， 生产版默认为 <code>false</code>。 生产版设为 <code>true</code> 可以启用检查。</p> </li>
</ul>
<h2 id="全局-api">全局 API</h2>
<h3 id="Vue-extend">Vue.extend( options )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Object} options</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>创建基础 Vue 构造器的“子类”。参数是一个对象，包含组件选项。</p> <p>这里要注意的特例是 <code>el</code> 和 <code>data</code> 选项—— 在 <code>Vue.extend()</code> 中它们必须是函数。</p> <pre><code>&lt;div id="mount-point"&gt;&lt;/div&gt;
</code></pre> <pre><code>// 创建可复用的构造器
var Profile = Vue.extend({
  template: '&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;'
})
// 创建一个 Profile 实例
var profile = new Profile({
  data: {
    firstName: 'Walter',
    lastName: 'White',
    alias: 'Heisenberg'
  }
})
// 挂载到元素上
profile.$mount('#mount-point')
</code></pre> <p>结果：</p> <pre><code>&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt;
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html">组件</a></p> </li>
</ul>
<h3 id="Vue-nextTick">Vue.nextTick( callback )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Function} callback</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>延迟回调在下次 DOM 更新循环之后执行。在修改数据之后立即使用这个方法，等待 DOM 更新。</p> <pre><code>// 修改数据
vm.msg = 'Hello'
// DOM 没有更新
Vue.nextTick(function () {
  // DOM 更新了
})
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/reactivity.html#异步更新队列">异步更新队列</a></p> </li>
</ul>
<h3 id="Vue-set">Vue.set( object, key, value )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{String} key</code></li>
<li><code>{*} value</code></li>
</ul> </li>
<li> <p><strong>返回值：</strong> 设置的值</p> </li>
<li> <p><strong>用法：</strong></p> <p>设置对象的属性。如果对象是响应的，将触发视图更新。这个方法主要用于解决 不能检测到属性添加的限制。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/reactivity.html">深入响应式原理</a></p> </li>
</ul>
<h3 id="Vue-delete">Vue.delete( object, key )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{String} key</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>删除对象的属性。如果对象是响应的，将触发视图更新。这个方法主要用于解决 不能检测到属性删除的限制。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/reactivity.html">深入响应式原理</a></p> </li>
</ul>
<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>注册或获取全局指令。</p> <pre><code>// 注册
Vue.directive('my-directive', {
  bind: function () {},
  update: function () {},
  unbind: function () {}
})

// 注册，传入一个函数
Vue.directive('my-directive', function () {
  // this will be called as `update`
})

// getter，返回已注册的指令
var myDirective = Vue.directive('my-directive')
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/custom-directive.html">自定义指令</a></p> </li>
</ul>
<h3 id="Vue-elementDirective">Vue.elementDirective( id, [definition] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} id</code></li>
<li><code>{Object} [definition]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>注册或获取全局的元素指令。</p> <pre><code>// 注册
Vue.elementDirective('my-element', {
  bind: function () {},
  // 没有使用 `update`
  unbind: function () {}
})

// getter，返回已注册的元素指令
var myDirective = Vue.elementDirective('my-element')
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/custom-directive.html#元素指令">元素指令</a></p> </li>
</ul>
<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>注册或获取全局过滤器。</p> <pre><code>// 注册
Vue.filter('my-filter', function (value) {
  // 返回处理后的值
})

// 双向过滤器
Vue.filter('my-filter', {
  read: function () {},
  write: function () {}
})

// getter，返回已注册的指令
var myFilter = Vue.filter('my-filter')
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/custom-filter.html">自定义过滤器</a></p> </li>
</ul>
<h3 id="Vue-component">Vue.component( id, [definition] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>注册或获取全局组件。</p> <pre><code>// 注册组件，传入一个扩展的构造器
Vue.component('my-component', Vue.extend({ /* ... */}))

// 注册组件，传入一个选项对象（自动调用 Vue.extend）
Vue.component('my-component', { /* ... */ })

// 获取注册的组件（始终返回构造器）
var MyComponent = Vue.component('my-component')
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html">组件</a></p> </li>
</ul>
<h3 id="Vue-transition">Vue.transition( id, [hooks] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} id</code></li>
<li><code>{Object} [hooks]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>注册或获取全局的过渡钩子对象。</p> <pre><code>// 注册
Vue.transition('fade', {
  enter: function () {},
  leave: function () {}
})

// 获取注册的钩子
var fadeTransition = Vue.transition('fade')
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/transitions.html">过渡</a></p> </li>
</ul>
<h3 id="Vue-partial">Vue.partial( id, [partial] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} id</code></li>
<li><code>{String} [partial]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>注册或获取全局的 partial。</p> <pre><code>// 注册
Vue.partial('my-partial', '&lt;div&gt;Hi&lt;/div&gt;')

// 获取注册的 partial
var myPartial = Vue.partial('my-partial')
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="#partial">特殊元素 - &lt;partial&gt;</a></p> </li>
</ul>
<h3 id="Vue-use">Vue.use( plugin, [options] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Object | Function} plugin</code></li>
<li><code>{Object} [options]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>安装 Vue.js 插件。如果插件是一个对象，必须有一个 <code>install</code> 方法。如果它是一个函数，它会被作为安装方法。安装方法以 Vue 为参数。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/plugins.html">插件</a></p> </li>
</ul>
<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Object} mixin</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>全局应用一个混合，将影响所有 Vue 实例。插件作者可以用它向组件注入自定义逻辑。<strong>不推荐用在应用代码中。</strong></p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/mixins.html#全局混合">全局混合</a></p> </li>
</ul>
<h2 id="选项--数据">选项 / 数据</h2>
<h3 id="data">data</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object | Function</code></p> </li>
<li> <p><strong>限制：</strong> 在组件定义中只能是函数。</p> </li>
<li> <p><strong>详细：</strong></p> <p>Vue 实例的数据对象。Vue.js 会递归地将它全部属性转为 getter/setter，从而让它能响应数据变化。<strong>这个对象必须是普通对象</strong>：原生对象，getter/setter 及原型属性会被忽略。不推荐观察复杂对象。</p> <p>在实例创建之后，可以用 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了数据对象所有的属性。</p> <p>在定义<strong>组件</strong>时，同一定义将创建多个实例，此时 <code>data</code> 必须是一个函数，返回原始数据对象。如果 <code>data</code> 仍然是一个普通对象，则所有的实例将指向同一个对象！换成函数后，每当创建一个实例时，会调用这个函数，返回一个新的原始数据对象的副本。</p> <p>名字以 <code>_</code> 或 <code>$</code>开始的属性<strong>不会</strong>被 Vue 实例代理，因为它们可能与 Vue 的内置属性与 API 方法冲突。用 <code>vm.$data._property</code> 访问它们。</p> <p>可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到原始数据对象。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var data = { a: 1 }

// 直接创建一个实例
var vm = new Vue({
  data: data
})
vm.a // -&gt; 1
vm.$data === data // -&gt; true

// 在 Vue.extend() 中必须是函数
var Component = Vue.extend({
  data: function () {
    return { a: 1 }
  }
})
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/reactivity.html">深入响应式原理</a></p> </li>
</ul>
<h3 id="props">props</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Array | Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>包含一些特性——期望使用的父组件数据的属性。可以是数组或对象。对象用于高级配置，如类型检查，自定义验证，默认值等。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>// 简单语法
Vue.component('props-demo-simple', {
  props: ['size', 'myMessage']
})

// 对象语法，指定验证要求
Vue.component('props-demo-advanced', {
  props: {
    // 只检测类型
    size: Number,
    // 检测类型 + 其它验证
    name: {
      type: String,
      required: true,
      // 双向绑定
      twoWay: true
    }
  }
})
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html#Props">Props</a></p> </li>
</ul>
<h3 id="propsdata">propsData</h3>
<blockquote>
<p>1.0.22+</p>
</blockquote>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>限制：</strong> 只用于 <code>new</code> 创建实例中。</p> </li>
<li> <p><strong>详细：</strong></p> <p>在创建实例的过程传递 props。主要作用是方便测试。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var Comp = Vue.extend({
  props: ['msg'],
  template: '&lt;div&gt;{{ msg }}&lt;/div&gt;'
})

var vm = new Comp({
  propsData: {
    msg: 'hello'
  }
})
</code></pre> </li>
</ul>
<h3 id="computed">computed</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>实例计算属性。getter 和 setter 的 <code>this</code> 自动地绑定到实例。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var vm = new Vue({
  data: { a: 1 },
  computed: {
    // 仅读取，值只须为函数
    aDouble: function () {
      return this.a * 2
    },
    // 读取和设置
    aPlus: {
      get: function () {
        return this.a + 1
      },
      set: function (v) {
        this.a = v - 1
      }
    }
  }
})
vm.aPlus   // -&gt; 2
vm.aPlus = 3
vm.a       // -&gt; 2
vm.aDouble // -&gt; 4
</code></pre> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/computed.html">计算属性</a></li>
<li><a href="../../book/133/guide/reactivity.html#计算属性的奥秘">深入响应式原理：计算属性的奥秘</a></li>
</ul> </li>
</ul>
<h3 id="methods">methods</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>实例方法。实例可以直接访问这些方法，也可以用在指令表达式内。方法的 <code>this</code> 自动绑定到实例。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var vm = new Vue({
  data: { a: 1 },
  methods: {
    plus: function () {
      this.a++
    }
  }
})
vm.plus()
vm.a // 2
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/events.html">方法与事件处理器</a></p> </li>
</ul>
<h3 id="watch">watch</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。在实例化时为每个键调用 <code>$watch()</code> 。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var vm = new Vue({
  data: {
    a: 1
  },
  watch: {
    'a': function (val, oldVal) {
      console.log('new: %s, old: %s', val, oldVal)
    },
    // 方法名
    'b': 'someMethod',
    // 深度 watcher
    'c': {
      handler: function (val, oldVal) { /* ... */ },
      deep: true
    }
  }
})
vm.a = 2 // -&gt; new: 2, old: 1
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="#vm-watch">实例方法 - vm.$watch</a></p> </li>
</ul>
<h2 id="选项--dom">选项 / DOM</h2>
<h3 id="el">el</h3>
<ul>
<li> <p><strong>类型：</strong> <code>String | HTMLElement | Function</code></p> </li>
<li> <p><strong>限制：</strong> 在组件定义中只能是函数。</p> </li>
<li> <p><strong>详细：</strong></p> <p>为实例提供挂载元素。值可以是 CSS 选择符，或实际 HTML 元素，或返回 HTML 元素的函数。注意元素只用作挂载点。如果提供了模板则元素被替换，除非 <code>replace</code> 为 false。元素可以用 <code>vm.$el</code> 访问。</p> <p>用在 <code>Vue.extend</code> 中必须是函数值，这样所有实例不会共享元素。</p> <p>如果在初始化时指定了这个选项，实例将立即进入编译过程。否则，需要调用 <code>vm.$mount()</code>，手动开始编译。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="template">template</h3>
<ul>
<li> <p><strong>类型：</strong> <code>String</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>实例模板。模板默认<strong>替换</strong>挂载元素。如果 <code>replace</code> 选项为 <code>false</code>，模板将插入挂载元素内。两种情况下，挂载元素的内容都将被忽略，除非模板有内容分发 slot。</p> <p>如果值以 <code>#</code> 开始，则它用作选项符，将使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type="x-template"&gt;</code> 包含模板。</p> <p>注意在一些情况下，例如如模板包含多个顶级元素，或只包含普通文本，实例将变成一个片断实例，管理多个节点而不是一个节点。片断实例的挂载元素上的非流程控制指令被忽略。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></li>
<li><a href="../../book/133/guide/components.html#使用-Slot-分发内容">使用 slot 分发内容</a></li>
<li><a href="../../book/133/guide/components.html#片断实例">片断实例</a></li>
</ul> </li>
</ul>
<h3 id="replace">replace</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Boolean</code></p> </li>
<li> <p><strong>默认值：</strong> <code>true</code></p> </li>
<li> <p><strong>限制：</strong> 只能与 <strong>template</strong> 选项一起用</p> </li>
<li> <p><strong>详细：</strong></p> <p>决定是否用模板替换挂载元素。如果设为 <code>true</code>（这是默认值），模板将覆盖挂载元素，并合并挂载元素和模板根节点的 attributes。如果设为 <code>false</code> 模板将覆盖挂载元素的内容，不会替换挂载元素自身。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;div id="replace" class="foo"&gt;&lt;/div&gt;
</code></pre> <pre><code>new Vue({
  el: '#replace',
  template: '&lt;p class="bar"&gt;replaced&lt;/p&gt;'
})
</code></pre> <p>结果：</p> <pre><code>&lt;p class="foo bar" id="replace"&gt;replaced&lt;/p&gt;
</code></pre> <p><code>replace</code> 设为 <code>false</code>：</p> <pre><code>&lt;div id="insert" class="foo"&gt;&lt;/div&gt;
</code></pre> <pre><code>new Vue({
  el: '#insert',
  replace: false,
  template: '&lt;p class="bar"&gt;inserted&lt;/p&gt;'
})
</code></pre> <p>结果：</p> <pre><code>&lt;div id="insert" class="foo"&gt;
  &lt;p class="bar"&gt;inserted&lt;/p&gt;
&lt;/div&gt;
</code></pre> </li>
</ul>
<h2 id="选项--生命周期钩子">选项 / 生命周期钩子</h2>
<h3 id="init">init</h3>
<ul>
<li> <p><strong>类型:</strong> <code>Function</code></p> </li>
<li> <p><strong>详细:</strong></p> <p>在实例开始初始化时同步调用。此时数据观测、事件和 watcher 都尚未初始化。</p> </li>
<li> <p><strong>另见:</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="created">created</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定，计算属性，方法，watcher/事件回调。但是还没有开始 DOM 编译，<code>$el</code> 还不存在。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="beforecompile">beforeCompile</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在编译开始前调用。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="compiled">compiled</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在编译结束后调用。此时所有的指令已生效，因而数据的变化将触发 DOM 更新。但是不担保 <code>$el</code> 已插入文档。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="ready">ready</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在编译结束和** <code>$el</code> 第一次插入文档**之后调用，如在第一次 <code>attached</code> 钩子之后调用。注意必须是由 Vue 插入（如 <code>vm.$appendTo()</code> 等方法或指令更新）才触发 <code>ready</code> 钩子。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="attached">attached</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在 <code>vm.$el</code> 插入 DOM 时调用。必须是由指令或实例方法（如 <code>$appendTo()</code>）插入，直接操作 <code>vm.$el</code> <strong>不会</strong> 触发这个钩子。</p> </li>
</ul>
<h3 id="detached">detached</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在 <code>vm.$el</code> 从 DOM 中删除时调用。必须是由指令或实例方法删除，直接操作 <code>vm.$el</code> <strong>不会</strong> 触发这个钩子。</p> </li>
</ul>
<h3 id="beforedestroy">beforeDestroy</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在开始销毁实例时调用。此时实例仍然有功能。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="destroyed">destroyed</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，所有的子实例也已经被销毁。</p> <p>如果有离开过渡，<code>destroyed</code> 钩子在过渡完成<strong>之后</strong>调用。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h2 id="选项--资源">选项 / 资源</h2>
<h3 id="directives">directives</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含指令。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/custom-directive.html">自定义指令</a></li>
<li><a href="../../book/133/guide/components.html#资源命名约定">资源命名约定</a></li>
</ul> </li>
</ul>
<h3 id="elementdirectives">elementDirectives</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含元素指令。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/custom-directive.html#Element-Directives">元素指令</a></li>
<li><a href="../../book/133/guide/components.html#资源命名约定">资源命名约定</a></li>
</ul> </li>
</ul>
<h3 id="filters">filters</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含过滤器。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/custom-filter.html">自定义过滤器</a></li>
<li><a href="../../book/133/guide/components.html#资源命名约定">资源命名约定</a></li>
</ul> </li>
</ul>
<h3 id="components">components</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含组件。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/components.html">组件</a></li>
</ul> </li>
</ul>
<h3 id="transitions">transitions</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含过渡。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/transitions.html">过渡</a></li>
</ul> </li>
</ul>
<h3 id="partials">partials</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含 partial。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="#partial">特殊元素 - partial</a></li>
</ul> </li>
</ul>
<h2 id="选项--杂项">选项 / 杂项</h2>
<h3 id="parent">parent</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Vue 实例</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>指定实例的父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html#父子组件通信">父子组件通信</a></p> </li>
</ul>
<h3 id="events">events</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，键是监听的事件，值是相应的回调。注意这些事件是 Vue 事件而不是 DOM 事件。值也可以是方法的名字。在实例化的过程中，Vue 实例会调用对象的每个键。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var vm = new Vue({
  events: {
    'hook:created': function () {
      console.log('created!')
    },
    greeting: function (msg) {
      console.log(msg)
    },
    // 也可以是方法的名字
    bye: 'sayGoodbye'
  },
  methods: {
    sayGoodbye: function () {
      console.log('goodbye!')
    }
  }
}) // -&gt; created!
vm.$emit('greeting', 'hi!') // -&gt; hi!
vm.$emit('bye')             // -&gt; goodbye!
</code></pre> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="#实例方法-事件">实例方法 - 事件</a></li>
<li><a href="../../book/133/guide/components.html#父子组件通信">父子组件通信</a></li>
</ul> </li>
</ul>
<h3 id="mixins">mixins</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Array</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个数组，包含混合对象。这些混合对象可以像普通实例对象一样包含实例选项，它们将合并成一个最终选项对象，合并策略同 <code>Vue.extend()</code>。比如，如果混合对象包含一个 <code>created</code> 钩子，组件自身也包含一个，两个钩子函数都会被调用。</p> <p>混合后的钩子按它们出现顺序调用，并且是在调用组件自己的钩子之前调用。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var mixin = {
  created: function () { console.log(1) }
}
var vm = new Vue({
  created: function () { console.log(2) },
  mixins: [mixin]
})
// -&gt; 1
// -&gt; 2
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/mixins.html">混合</a></p> </li>
</ul>
<h3 id="name">name</h3>
<ul>
<li> <p><strong>类型：</strong> <code>String</code></p> </li>
<li> <p><strong>限制：</strong> 只能用在 <code>Vue.extend()</code> 中。</p> </li>
<li> <p><strong>详细：</strong></p> <p>允许组件在它的模板内递归地调用它自己。注意如果组件是由 <code>Vue.component()</code> 全局注册，全局 ID 自动作为它的名字。</p> <p>指定 <code>name</code> 选项的另一个好处是方便检查。当在控制台检查组件时，默认的构造器名字是 <code>VueComponent</code> ，不大有用。在向 <code>Vue.extend()</code> 传入 <code>name</code> 选项后，可以知道正在检查哪个组件。值会被转换为驼峰形式，并用作组件构造器的名字。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var Ctor = Vue.extend({
  name: 'stack-overflow',
  template:
    '&lt;div&gt;' +
      // 递归地调用自己
      '&lt;stack-overflow&gt;&lt;/stack-overflow&gt;' +
    '&lt;/div&gt;'
})

// 将导致错误：Maximum call stack size exceeded
// 不过我们假定没问题...
var vm = new Ctor()

console.log(vm) // -&gt; StackOverflow {$el: null, ...}
</code></pre> </li>
</ul>
<h3 id="extends">extends</h3>
<blockquote>
<p>1.0.22+</p>
</blockquote>
<ul>
<li> <p><strong>类型：</strong> <code>Object | Function</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>声明式的扩展另一个组件（可以是选项对象或者构造器），而不必使用 <code>Vue.extend</code>。主要作用是更容易的扩展单文件组件。</p> <p>这类似于 <code>mixins</code>，不同的是组件的选项比待扩展的源组件的选项优先。</p> </li>
<li> <p><em>示例：</em>*</p> <pre><code>var CompA = { ... }

// 扩展 CompA，不用调用 Vue.extend
var CompB = {
  extends: CompA,
  ...
}
</code></pre> </li>
</ul>
<h2 id="实例属性">实例属性</h2>
<h3 id="vmdata">vm.$data</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>Vue 实例观察的数据对象。可以用一个新的对象替换。实例代理了它的数据对象的属性。</p> </li>
</ul>
<h3 id="vmel">vm.$el</h3>
<ul>
<li> <p><strong>类型：</strong> <code>HTMLElement</code></p> </li>
<li> <p><strong>只读</strong></p> </li>
<li> <p><strong>详细：</strong></p> <p>Vue 实例的挂载元素。注意对于<a href="../../book/133/guide/components.html#片断实例">片段实例</a>，<code>vm.$el</code> 返回一个锚节点，指示片断的开始位置。</p> </li>
</ul>
<h3 id="vmoptions">vm.$options</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>只读</strong></p> </li>
<li> <p><strong>详细：</strong></p> <p>当前实例的初始化选项。在选项中包含自定义属性时有用处：</p> <pre><code>new Vue({
  customOption: 'foo',
  created: function () {
    console.log(this.$options.customOption) // -&gt; 'foo'
  }
})
</code></pre> </li>
</ul>
<h3 id="vmparent">vm.$parent</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Vue 实例</code></p> </li>
<li> <p><strong>只读</strong></p> </li>
<li> <p><strong>详细：</strong></p> <p>父实例，如果当前实例有的话。</p> </li>
</ul>
<h3 id="vmroot">vm.$root</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Vue 实例</code></p> </li>
<li> <p><strong>只读</strong></p> </li>
<li> <p><strong>详细：</strong></p> <p>当前组件树的根 Vue 实例。如果当前实例没有父实例，值将是它自身。</p> </li>
</ul>
<h3 id="vmchildren">vm.$children</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Array&lt;Vue instance&gt;</code></p> </li>
<li> <p><strong>只读</strong></p> </li>
<li> <p><strong>详细：</strong></p> <p>当前实例的直接子组件。</p> </li>
</ul>
<h3 id="vmrefs">vm.$refs</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>只读</strong></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含注册有 <code>v-ref</code> 的子组件。</p> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/components.html#子组件索引">子组件索引</a></li>
<li><a href="#v-ref">v-ref</a></li>
</ul> </li>
</ul>
<h3 id="vmels">vm.$els</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Object</code></p> </li>
<li> <p><strong>只读</strong></p> </li>
<li> <p><strong>详细：</strong></p> <p>一个对象，包含注册有 <code>v-el</code> 的 DOM 元素。</p> </li>
<li> <p><strong>另见：</strong> <a href="#v-el">v-el</a>。</p> </li>
</ul>
<h2 id="实例方法--数据">实例方法 / 数据</h2>
<h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String | Function} expOrFn</code></li>
<li><code>{Function} callback</code></li>
<li><code>{Object} [options]</code>
<ul>
<li><code>{Boolean} deep</code></li>
<li><code>{Boolean} immediate</code></li>
</ul> </li>
</ul> </li>
<li> <p><strong>返回值：</strong> <code>{Function} unwatch</code></p> </li>
<li> <p><strong>用法：</strong></p> <p>观察 Vue 实例的一个表达式或计算函数。回调的参数为新值和旧值。表达式可以是某个键路径或任意合法绑定表达式。</p> </li>
</ul>
<p class="tip">注意：在修改（不是替换）对象或数组时，旧值将与新值相同，因为它们索引同一个对象/数组。Vue 不会保留修改之前值的副本。</p>
<ul>
<li> <p><strong>示例：</strong></p> <pre><code>// 键路径
vm.$watch('a.b.c', function (newVal, oldVal) {
  // 做点什么
})

// 表达式
vm.$watch('a + b', function (newVal, oldVal) {
  // 做点什么
})

// 函数
vm.$watch(
  function () {
    return this.a + this.b
  },
  function (newVal, oldVal) {
    // 做点什么
  }
)
</code></pre> <p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p> <pre><code>var unwatch = vm.$watch('a', cb)
// 之后取消观察
unwatch()
</code></pre> </li>
<li> <p><strong>Option: deep</strong></p> <p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code>。注意监听数组的变动不需要这么做。</p> <pre><code>vm.$watch('someObject', callback, {
  deep: true
})
vm.someObject.nestedValue = 123
// 触发回调
</code></pre> </li>
<li> <p><strong>Option: immediate</strong></p> <p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p> <pre><code>vm.$watch('a', callback, {
  immediate: true
})
// 立即以 `a` 的当前值触发回调
</code></pre> </li>
</ul>
<h3 id="vm-get">vm.$get( expression )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} expression</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>从 Vue 实例获取指定表达式的值。如果表达式抛出错误，则取消错误并返回 <code>undefined</code>。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var vm = new Vue({
  data: {
    a: {
      b: 1
    }
  }
})
vm.$get('a.b') // -&gt; 1
vm.$get('a.b + 1') // -&gt; 2
</code></pre> </li>
</ul>
<h3 id="vm-set">vm.$set( keypath, value )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} keypath</code></li>
<li><code>{*} value</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>设置 Vue 实例的属性值。多数情况下应当使用普通对象语法，如 <code>vm.a.b = 123</code>。这个方法只用于下面情况：</p>
<ol>
<li> <p>使用 keypath 动态地设置属性。</p> </li>
<li> <p>设置不存在的属性。</p> </li>
</ol> <p>如果 keypath 不存在，将递归地创建并建立追踪。如果用它创建一个顶级属性，实例将被强制进入“ digest 循环”，在此过程中重新计算所有的 watcher。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var vm = new Vue({
  data: {
    a: {
      b: 1
    }
  }
})

// keypath 存在
vm.$set('a.b', 2)
vm.a.b // -&gt; 2

// keypath 不存在
vm.$set('c', 3)
vm.c // -&gt; 3
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/reactivity.html">深入响应式原理</a></p> </li>
</ul>
<h3 id="vm-delete">vm.$delete( key )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} key</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>删除 Vue 实例（以及它的 <code>$data</code>）上的顶级属性。强制 digest 循环，不推荐使用。</p> </li>
</ul>
<h3 id="vm-eval">vm.$eval( expression )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} expression</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>计算当前实例上的合法的绑定表达式。表达式也可以包含过滤器。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>// 假定 vm.msg = 'hello'
vm.$eval('msg | uppercase') // -&gt; 'HELLO'
</code></pre> </li>
</ul>
<h3 id="vm-interpolate">vm.$interpolate( templateString )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} templateString</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>计算模板，模板包含 Mustache 标签。注意这个方法只是简单计算插值，模板内的指令将被忽略。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>// 假定 vm.msg = 'hello'
vm.$interpolate('{{msg}} world!') // -&gt; 'hello world!'
</code></pre> </li>
</ul>
<h3 id="vm-log">vm.$log( [keypath] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} [keypath]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>打印当前实例的数据，比起一堆 getter/setter 要友好。keypath 可选。</p> <pre><code>vm.$log() // 打印整个 ViewModel 的数据
vm.$log('item') // 打印 vm.item
</code></pre> </li>
</ul>
<h2 id="实例方法--事件">实例方法 / 事件</h2>
<h3 id="vm-on">vm.$on( event, callback )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} event</code></li>
<li><code>{Function} callback</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>监听当前实例上的自定义事件。事件可以由 <code>vm.$emit</code>, <code>vm.$dispatch</code> 或 <code>vm.$broadcast</code>触发。传入这些方法的附加参数都会传入这个方法的回调。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>vm.$on('test', function (msg) {
  console.log(msg)
})
vm.$emit('test', 'hi')
// -&gt; "hi"
</code></pre> </li>
</ul>
<h3 id="vm-once">vm.$once( event, callback )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} event</code></li>
<li><code>{Function} callback</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>监听一个自定义事件，但是只触发一次，在第一次触发之后删除监听器。</p> </li>
</ul>
<h3 id="vm-off">vm.$off( [event, callback] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} [event]</code></li>
<li><code>{Function} [callback]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>删除事件监听器。</p>
<ul>
<li> <p>如果没有参数，则删除所有的事件监听器；</p> </li>
<li> <p>如果只提供了事件，则删除这个事件所有的监听器；</p> </li>
<li> <p>如果同时提供了事件与回调，则只删除这个回调。</p> </li>
</ul> </li>
</ul>
<h3 id="vm-emit">vm.$emit( event, [...args] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} event</code></li>
<li><code>[...args]</code></li>
</ul> <p>触发当前实例上的事件。附加参数都会传给监听器回调。</p> </li>
</ul>
<h3 id="vm-dispatch">vm.$dispatch( event, [...args] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} event</code></li>
<li><code>[...args]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>派发事件，首先在实例上触发它，然后沿着父链向上冒泡在触发一个监听器后停止，除非它返回 <code>true</code>。附加参数都会传给监听器回调。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>// 创建父链
var parent = new Vue()
var child1 = new Vue({ parent: parent })
var child2 = new Vue({ parent: child1 })

parent.$on('test', function () {
  console.log('parent notified')
})
child1.$on('test', function () {
  console.log('child1 notified')
})
child2.$on('test', function () {
  console.log('child2 notified')
})

child2.$dispatch('test')
// -&gt; "child2 notified"
// -&gt; "child1 notified"
// 没有通知 parent，因为 child1 的回调没有返回 true
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html#父子组件通信">父子组件通信</a></p> </li>
</ul>
<h3 id="vm-broadcast">vm.$broadcast( event, [...args] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} event</code></li>
<li><code>[...args]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>广播事件，通知给当前实例的全部后代。因为后代有多个枝杈，事件将沿着各“路径”通知。每条路径上的通知在触发一个监听器后停止，除非它返回 <code>true</code>。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var parent = new Vue()
// child1 和 child2 是兄弟
var child1 = new Vue({ parent: parent })
var child2 = new Vue({ parent: parent })
// child3 在 child2 内
var child3 = new Vue({ parent: child2 })

child1.$on('test', function () {
  console.log('child1 notified')
})
child2.$on('test', function () {
  console.log('child2 notified')
})
child3.$on('test', function () {
  console.log('child3 notified')
})

parent.$broadcast('test')
// -&gt; "child1 notified"
// -&gt; "child2 notified"
// 没有通知 child3，因为 child2 的回调没有返回 true
</code></pre> </li>
</ul>
<h2 id="实例方法--dom">实例方法 / DOM</h2>
<h3 id="vm-appendTo">vm.$appendTo( elementOrSelector, [callback] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Element | String} elementOrSelector</code></li>
<li><code>{Function} [callback]</code></li>
</ul> </li>
<li> <p><strong>返回值：</strong> <code>vm</code>——实例自身</p> </li>
<li> <p><strong>用法：</strong></p> <p>将实例的 DOM 元素或片断插入目标元素内。第一个参数可以是一个元素或选择器字符串。如果有过渡则触发过渡。回调在过渡完成后执行，如果没有触发过渡则立即执行。</p> </li>
</ul>
<h3 id="vm-before">vm.$before( elementOrSelector, [callback] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Element | String} elementOrSelector</code></li>
<li><code>{Function} [callback]</code></li>
</ul> </li>
<li> <p><strong>返回值：</strong> <code>vm</code>——实例自身</p> </li>
<li> <p><strong>用法：</strong></p> <p>将实例的 DOM 元素或片断插到目标元素的前面。第一个参数可以是一个元素或选择器字符串。如果有过渡则触发过渡。回调在过渡完成后执行，如果没有触发过渡则立即执行。</p> </li>
</ul>
<h3 id="vm-after">vm.$after( elementOrSelector, [callback] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Element | String} elementOrSelector</code></li>
<li><code>{Function} [callback]</code></li>
</ul> </li>
<li> <p><strong>返回值：</strong> <code>vm</code>——实例自身</p> </li>
<li> <p><strong>用法：</strong></p> <p>将实例的 DOM 元素或片断插到目标元素的后面。第一个参数可以是一个元素或选择器字符串。如果有过渡则触发过渡。回调在过渡完成后执行，如果没有触发过渡则立即执行。</p> </li>
</ul>
<h3 id="vm-remove">vm.$remove( [callback] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
</ul> </li>
<li> <p><strong>返回值：</strong> <code>vm</code>——实例自身</p> </li>
<li> <p><strong>用法：</strong></p> <p>从 DOM 中删除实例的 DOM 元素或片断。如果有过渡则触发过渡。回调在过渡完成后执行，如果没有触发过渡则立即执行。</p> </li>
</ul>
<h3 id="vm-nextTick">vm.$nextTick( callback )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 <code>Vue.nextTick</code> 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>new Vue({
  // ...
  methods: {
    // ...
    example: function () {
      // 修改数据
      this.message = 'changed'
      // DOM 还没有更新
      this.$nextTick(function () {
        // DOM 现在更新了
        // `this` 绑定到当前实例
        this.doSomethingElse()
      })
    }
  }
})
</code></pre> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="#Vue-nextTick">Vue.nextTick</a></li>
<li><a href="../../book/133/guide/reactivity.html#异步更新队列">异步更新队列</a></li>
</ul> </li>
</ul>
<h2 id="实例方法--生命周期">实例方法 / 生命周期</h2>
<h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Element | String} [elementOrSelector]</code></li>
</ul> </li>
<li> <p><strong>返回值：</strong> <code>vm</code>——实例自身</p> </li>
<li> <p><strong>用法：</strong></p> <p>如果 Vue 实例在实例化时没有收到 <code>el</code> 选项，则它处于“未挂载”状态，没有关联的 DOM 元素或片断。可以使用 <code>vm.$mount()</code> 手动地开始挂载/编译未挂载的实例。</p> <p>如果没有参数，模板将被创建为文档之外的的片断，需要手工用其它的 DOM 实例方法把它插入文档中。如果 <code>replace</code> 选项为 <code>false</code>，则自动创建一个空 <code>&lt;div&gt;</code>，作为包装元素。</p> <p>在已经挂载的实例上调用 <code>$mount()</code> 没有效果。这个方法返回实例自身，因而可以链式调用其它实例方法。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>var MyComponent = Vue.extend({
  template: '&lt;div&gt;Hello!&lt;/div&gt;'
})

// 创建并挂载到 #app (会替换 #app)
new MyComponent().$mount('#app')

// 同上
new MyComponent({ el: '#app' })

// 手动挂载
new MyComponent().$mount().$appendTo('#container')
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h3 id="vm-destroy">vm.$destroy( [remove] )</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Boolean} [remove] - default: false</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>完全销毁实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器，如果 <code>remove</code> 参数是 <code>true</code>，则从 DOM 中删除它关联的 DOM 元素或片断。</p> <p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 钩子。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/instance.html#生命周期图示">生命周期图示</a></p> </li>
</ul>
<h2 id="指令">指令</h2>
<h3 id="v-text">v-text</h3>
<ul>
<li> <p><strong>类型：</strong> <code>String</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>更新元素的 <code>textContent</code>。</p> <p>在内部， <code>{% raw %}{{ Mustache }}{% endraw %}</code> 插值也被编译为 textNode 的一个 <code>v-text</code> 指令。这个指令需要一个包装元素，不过性能稍好并且避免 FOUC (Flash of Uncompiled Content) 。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;span v-text="msg"&gt;&lt;/span&gt;
&lt;!-- same as --&gt;
&lt;span&gt;{{msg}}&lt;/span&gt;
</code></pre> </li>
</ul>
<h3 id="v-html">v-html</h3>
<ul>
<li> <p><strong>类型：</strong> <code>String</code></p> </li>
<li> <p><strong>详细：</strong></p> <p>更新元素的 <code>innerHTML</code>。内容按普通 HTML 插入——数据绑定被忽略。如果想复用模板片断，应当使用 <a href="#partial">partials</a>。</p> <p>在内部， <code>{% raw %}{{{ Mustache }}}{% endraw %}</code> 插值也会被编译为锚节点上的一个 <code>v-html</code> 指令。这个指令需要一个包装元素，不过性能稍好并且避免 FOUC (Flash of Uncompiled Content) 。</p> <p class="tip">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;div v-html="html"&gt;&lt;/div&gt;
&lt;!-- 相同 --&gt;
&lt;div&gt;{{{html}}}&lt;/div&gt;
</code></pre> </li>
</ul>
<h3 id="v-if">v-if</h3>
<ul>
<li> <p><strong>类型：</strong> <code>*</code></p> </li>
<li> <p><strong>用法：</strong></p> <p>根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code>，将提出它的内容作为条件块。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/conditional.html">条件渲染</a></p> </li>
</ul>
<h3 id="v-show">v-show</h3>
<ul>
<li> <p><strong>类型：</strong> <code>*</code></p> </li>
<li> <p><strong>用法：</strong></p> <p>根据表达式的值的真假切换元素的 <code>display</code> CSS 属性，如果有过渡将触发它。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/conditional.html#v-show">条件渲染 - v-show</a></p> </li>
</ul>
<h3 id="v-else">v-else</h3>
<ul>
<li> <p><strong>不需要表达式</strong></p> </li>
<li> <p><strong>限制：</strong> 前一兄弟元素必须有 <code>v-if</code> 或 <code>v-show</code>。</p> </li>
<li> <p><strong>用法：</strong></p> <p>为 <code>v-if</code> 和 <code>v-show</code> 添加 “else 块”。</p> <pre><code>&lt;div v-if="Math.random() &gt; 0.5"&gt;
  Sorry
&lt;/div&gt;
&lt;div v-else&gt;
  Not sorry
&lt;/div&gt;
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/conditional.html#v-else">条件渲染 - v-else</a></p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/conditional.html#组件警告">条件渲染 - 组件警告</a></p> </li>
</ul>
<h3 id="v-for">v-for</h3>
<ul>
<li> <p><strong>类型：</strong> <code>Array | Object | Number | String</code></p> </li>
<li> <p><strong>Param Attributes:</strong></p>
<ul>
<li><a href="../../book/133/guide/list.html#track-by"><code>track-by</code></a></li>
<li><a href="../../book/133/guide/transitions.html#渐变过渡"><code>stagger</code></a></li>
<li><a href="../../book/133/guide/transitions.html#渐变过渡"><code>enter-stagger</code></a></li>
<li><a href="../../book/133/guide/transitions.html#渐变过渡"><code>leave-stagger</code></a></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>基于源数据将元素或模板块重复数次。指令的值必须使用特定语法 <code>alias (in|of) expression</code>，为当前遍历的元素提供别名：</p> <pre><code>&lt;div v-for="item in items"&gt;
  {{ item.text }}
&lt;/div&gt;
</code></pre> <p>1.0.17+ 支持 <code>of</code> 分隔符。</p> <p>另外也可以为数组索引指定别名（如果值是对象可以为键指定别名）：</p> <pre><code>&lt;div v-for="(index, item) in items"&gt;&lt;/div&gt;
&lt;div v-for="(key, val) in object"&gt;&lt;/div&gt;
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/list.html">列表渲染</a></p> </li>
</ul>
<h3 id="v-on">v-on</h3>
<ul>
<li> <p><strong>缩写：</strong> <code>@</code></p> </li>
<li> <p><strong>类型：</strong> <code>Function | Inline Statement</code></p> </li>
<li> <p><strong>参数：</strong> <code>event (required)</code></p> </li>
<li> <p><strong>修饰符：</strong></p>
<ul>
<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>
<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>
<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li>
<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li><code>.{keyCode | keyAlias}</code> - 只在指定按键上触发回调。</li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p> <p>用在普通元素上时，只能监听<strong>原生 DOM 事件</strong>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p> <p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> 属性： <code>v-on:click="handle('ok', $event)"</code>。</p> <p><strong>1.0.11+</strong> 在监听自定义事件时，内联语句可以访问一个 <code>$arguments</code> 属性，它是一个数组，包含传给子组件的 <code>$emit</code> 回调的参数。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;!-- 方法处理器 --&gt;
&lt;button v-on:click="doThis"&gt;&lt;/button&gt;

&lt;!-- 内联语句 --&gt;
&lt;button v-on:click="doThat('hello', $event)"&gt;&lt;/button&gt;

&lt;!-- 缩写 --&gt;
&lt;button @click="doThis"&gt;&lt;/button&gt;

&lt;!-- 停止冒泡 --&gt;
&lt;button @click.stop="doThis"&gt;&lt;/button&gt;

&lt;!-- 阻止默认行为 --&gt;
&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;

&lt;!-- 阻止默认行为，没有表达式 --&gt;
&lt;form @submit.prevent&gt;&lt;/form&gt;

&lt;!-- 串联修饰符 --&gt;
&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;

&lt;!-- 键修饰符，键别名 --&gt;
&lt;input @keyup.enter="onEnter"&gt;

&lt;!-- 键修饰符，键代码 --&gt;
&lt;input @keyup.13="onEnter"&gt;
</code></pre> <p>在子组件上监听自定义事件（当子组件触发 "my-event" 时将调用事件处理器）：</p> <pre><code>&lt;my-component @my-event="handleThis"&gt;&lt;/my-component&gt;

&lt;!-- 内联语句 --&gt;
&lt;my-component @my-event="handleThis(123, $arguments)"&gt;&lt;/my-component&gt;
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/events.html">方法与事件处理器</a></p> </li>
</ul>
<h3 id="v-bind">v-bind</h3>
<ul>
<li> <p><strong>缩写：</strong> <code>:</code></p> </li>
<li> <p><strong>类型：</strong> <code>* (with argument) | Object (without argument)</code></p> </li>
<li> <p><strong>参数：</strong> <code>attrOrProp (optional)</code></p> </li>
<li> <p><strong>修饰符：</strong></p>
<ul>
<li><code>.sync</code> - 双向绑定，只能用于 prop 绑定。</li>
<li><code>.once</code> - 单次绑定，只能用于 prop 绑定。</li>
<li><code>.camel</code> - 将绑定的特性名字转回驼峰命名。只能用于普通 HTML 特性的绑定，通常用于绑定用驼峰命名的 SVG 特性，比如 <code>viewBox</code>。</li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p> <p>在绑定 <code>class</code> 或 <code>style</code> 时，支持其它类型的值，如数组或对象。</p> <p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p> <p>没有参数时，可以绑定到一个对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;!-- 绑定 attribute --&gt;
&lt;img v-bind:src="imageSrc"&gt;

&lt;!-- 缩写 --&gt;
&lt;img :src="imageSrc"&gt;

&lt;!-- 绑定 class --&gt;
&lt;div :class="{ red: isRed }"&gt;&lt;/div&gt;
&lt;div :class="[classA, classB]"&gt;&lt;/div&gt;
&lt;div :class="[classA, { classB: isB, classC: isC }]"&gt;&lt;/div&gt;

&lt;!-- 绑定 style --&gt;
&lt;div :style="{ fontSize: size + 'px' }"&gt;&lt;/div&gt;
&lt;div :style="[styleObjectA, styleObjectB]"&gt;&lt;/div&gt;

&lt;!-- 绑定到一个对象 --&gt;
&lt;div v-bind="{ id: someProp, 'other-attr': otherProp }"&gt;&lt;/div&gt;

&lt;!-- prop 绑定，"prop" 必须在 my-component 组件内声明 --&gt;
&lt;my-component :prop="someThing"&gt;&lt;/my-component&gt;

&lt;!-- 双向 prop 绑定 --&gt;
&lt;my-component :prop.sync="someThing"&gt;&lt;/my-component&gt;

&lt;!-- 单次 prop 绑定 --&gt;
&lt;my-component :prop.once="someThing"&gt;&lt;/my-component&gt;
</code></pre> </li>
<li> <p><strong>另见：</strong></p>
<ul>
<li><a href="../../book/133/guide/class-and-style.html">Class 和 Style 绑定</a></li>
<li><a href="../../book/133/guide/components.html#Props">组件 Props</a></li>
</ul> </li>
</ul>
<h3 id="v-model">v-model</h3>
<ul>
<li> <p><strong>类型：</strong> 随表单控件类型不同而不同。</p> </li>
<li> <p><strong>限制：</strong></p>
<ul>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
</ul> </li>
<li> <p><strong>Param Attributes:</strong></p>
<ul>
<li><a href="../../book/133/guide/forms.html#lazy"><code>lazy</code></a></li>
<li><a href="../../book/133/guide/forms.html#number"><code>number</code></a></li>
<li><a href="../../book/133/guide/forms.html#debounce"><code>debounce</code></a></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>在表单控件上创建双向绑定。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/forms.html">表单控件绑定</a></p> </li>
</ul>
<h3 id="v-ref">v-ref</h3>
<ul>
<li> <p><strong>不需要表达式</strong></p> </li>
<li> <p><strong>限制：</strong> 子组件</p> </li>
<li> <p><strong>参数：</strong> <code>id (required)</code></p> </li>
<li> <p><strong>用法：</strong></p> <p>在父组件上注册一个子组件的索引，便于直接访问。不需要表达式。必须提供参数 id。可以通过父组件的 <code>$refs</code> 对象访问子组件。</p> <p>在和 <code>v-for</code> 一起用时，注册的值将是一个数组，包含所有的子组件，对应于绑定数组。如果 <code>v-for</code> 用在一个对象上，注册的值将是一个对象，包含所有的子组件，对应于绑定对象。</p> </li>
<li> <p><strong>注意：</strong></p> <p>因为 HTML 不区分大小写，camelCase 名字比如 <code>v-ref:someRef</code> 将全转为小写。可以用 <code>v-ref:some-ref</code> 设置 <code>this.$els.someRef</code>。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;comp v-ref:child&gt;&lt;/comp&gt;
&lt;comp v-ref:some-child&gt;&lt;/comp&gt;
</code></pre> <pre><code>// 从父组件访问
this.$refs.child
this.$refs.someChild
</code></pre> <p>使用 <code>v-for</code>：</p> <pre><code>&lt;comp v-ref:list v-for="item in list"&gt;&lt;/comp&gt;
</code></pre> <pre><code>// 值是一个数组
this.$refs.list
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html#子组件索引">子组件索引</a></p> </li>
</ul>
<h3 id="v-el">v-el</h3>
<ul>
<li> <p><strong>不需要表达式</strong></p> </li>
<li> <p><strong>参数：</strong> <code>id</code>（必需）</p> </li>
<li> <p><strong>用法：</strong></p> <p>为 DOM 元素注册一个索引，方便通过所属实例的 <code>$els</code> 访问这个元素。</p> </li>
<li> <p><strong>注意：</strong></p> <p>因为 HTML 不区分大小写，camelCase 名字比如 <code>v-el:someEl</code> 将转为全小写。可以用 <code>v-el:some-el</code> 设置 <code>this.$els.someEl</code>。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;span v-el:msg&gt;hello&lt;/span&gt;
&lt;span v-el:other-msg&gt;world&lt;/span&gt;
</code></pre> <pre><code>this.$els.msg.textContent // -&gt; "hello"
this.$els.otherMsg.textContent // -&gt; "world"
</code></pre> </li>
</ul>
<h3 id="v-pre">v-pre</h3>
<ul>
<li> <p><strong>不需要表达式</strong></p> </li>
<li> <p><strong>用法：</strong></p> <p>跳过编译这个元素和它的子元素。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;
</code></pre> </li>
</ul>
<h3 id="v-cloak">v-cloak</h3>
<ul>
<li> <p><strong>不需要表达式</strong></p> </li>
<li> <p><strong>用法：</strong></p> <p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code class="language-css">[v-cloak] {
  display: none;
}
</code></pre> <pre><code>&lt;div v-cloak&gt;
  {{ message }}
&lt;/div&gt;
</code></pre> <p><code>&lt;div&gt;</code> 不会显示，直到编译结束。</p> </li>
</ul>
<h2 id="特殊元素">特殊元素</h2>
<h3 id="component">component</h3>
<ul>
<li> <p><strong>特性：</strong></p>
<ul>
<li><code>is</code></li>
<li><a href="../../book/133/guide/components.html#keep-alive"><code>keep-alive</code></a></li>
<li><a href="../../book/133/guide/components.html#transition-mode"><code>transition-mode</code></a></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>另一种调用组件的语法。主要是和 <code>is</code> 特性一起用于动态组件。</p> <pre><code>&lt;!-- 动态组件 --&gt;
&lt;!-- 由实例的 `componentId` 属性控制 --&gt;
&lt;component :is="componentId"&gt;&lt;/component&gt;
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html#动态组件">动态组件</a></p> </li>
</ul>
<h3 id="slot">slot</h3>
<ul>
<li> <p><strong>特性：</strong></p>
<ul>
<li><code>name</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。这个元素自身将被替换。</p> <p>有 <code>name</code> 特性的 slot 称为具名 slot。 有 <code>slot</code> 特性的内容将分发到名字相匹配的具名 slot。</p> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/components.html#使用-Slot-分发内容">使用 slot 分发内容</a></p> </li>
</ul>
<h3 id="partial">partial</h3>
<ul>
<li> <p><strong>特性：</strong></p>
<ul>
<li><code>name</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p><code>&lt;partial&gt;</code> 元素是已注册的 partial 的插槽，partial 在插入时被 Vue 编译。 <code>&lt;partial&gt;</code> 元素本身会被替换。<code>&lt;partial&gt;</code> 元素需要指定 <code>name</code> 特性。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>// 注册 partial
Vue.partial('my-partial', '&lt;p&gt;This is a partial! {{msg}}&lt;/p&gt;')
</code></pre> <pre><code>&lt;!-- 静态 partial --&gt;
&lt;partial name="my-partial"&gt;&lt;/partial&gt;

&lt;!-- 动态 partial --&gt;
&lt;!-- 渲染 partial，id === vm.partialId --&gt;
&lt;partial v-bind:name="partialId"&gt;&lt;/partial&gt;

&lt;!-- 动态 partial，使用 v-bind 缩写语法 --&gt;
&lt;partial :name="partialId"&gt;&lt;/partial&gt;
</code></pre> </li>
</ul>
<h2 id="过滤器">过滤器</h2>
<h3 id="capitalize">capitalize</h3>
<ul>
<li> <p><strong>示例：</strong></p> <pre><code>{{ msg | capitalize }}
</code></pre> <p><em>'abc' =&gt; 'Abc'</em></p> </li>
</ul>
<h3 id="uppercase">uppercase</h3>
<ul>
<li> <p><strong>示例：</strong></p> <pre><code>{{ msg | uppercase }}
</code></pre> <p><em>'abc' =&gt; 'ABC'</em></p> </li>
</ul>
<h3 id="lowercase">lowercase</h3>
<ul>
<li> <p><strong>示例：</strong></p> <pre><code>{{ msg | lowercase }}
</code></pre> <p><em>'ABC' =&gt; 'abc'</em></p> </li>
</ul>
<h3 id="currency">currency</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} [货币符号] - 默认值: '$'</code></li>
<li><strong>1.0.22+</strong> <code>{Number} [小数位] - 默认值: 2</code></li>
</ul> </li>
<li> <p><strong>示例：</strong></p> <pre><code>{{ amount | currency }}
</code></pre> <p><em>12345 =&gt; $12,345.00</em></p> <p>使用其它符号：</p> <pre><code>{{ amount | currency '£' }}
</code></pre> <p><em>12345 =&gt; £12,345.00</em></p> <p>一些货币使用 3 或 4 个小数位，而一些货币不会，例如日元（¥）、越南盾（₫）：</p> <pre><code>{{ amount | currency '₫' 0 }}
</code></pre> <p><em>12345 =&gt; ₫12,345</em></p> </li>
</ul>
<h3 id="pluralize">pluralize</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String} single, [double, triple, ...]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>如果只有一个参数，复数形式只是简单地在末尾添加一个 "s"。如果有多个参数，参数被当作一个字符串数组，对应一个、两个、三个...复数词。如果值的个数多于参数的个数，多出的使用最后一个参数。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>{{count}} {{count | pluralize 'item'}}
</code></pre> <p><em>1 =&gt; '1 item'</em> <em>2 =&gt; '2 items'</em></p> <pre><code>{{date}}{{date | pluralize 'st' 'nd' 'rd' 'th'}}
</code></pre> <p>结果：</p> <p><em>1 =&gt; '1st'</em> <em>2 =&gt; '2nd'</em> <em>3 =&gt; '3rd'</em> <em>4 =&gt; '4th'</em> <em>5 =&gt; '5th'</em></p> </li>
</ul>
<h3 id="json">json</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Number} [indent] - 默认值：2</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>输出经 <code>JSON.stringify()</code> 处理后的结果，而不是输出 <code>toString()</code> 的结果（如 <code>[object Object]</code>）。</p> </li>
<li> <p><strong>示例：</strong></p> <p>以四个空格的缩进打印一个对象：</p> <pre><code>&lt;pre&gt;{{ nestedObject | json 4 }}&lt;/pre&gt;
</code></pre> </li>
</ul>
<h3 id="debounce">debounce</h3>
<ul>
<li> <p><strong>限制：</strong> 指令的值须是函数，如 <code>v-on</code></p> </li>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Number} [wait] - 默认值： 300</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>包装处理器，让它延迟执行 <code>x</code> ms， 默认延迟 300ms。包装后的处理器在调用之后至少将延迟 <code>x</code> ms， 如果在延迟结束前再次调用，延迟时长重置为 <code>x</code> ms。</p> </li>
<li> <p><strong>示例：</strong></p> <pre><code>&lt;input @keyup="onKeyup | debounce 500"&gt;
</code></pre> </li>
</ul>
<h3 id="limitby">limitBy</h3>
<ul>
<li> <p><strong>限制：</strong> 指令的值须是数组，如 <code>v-for</code></p> </li>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Number} limit</code></li>
<li><code>{Number} [offset]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> </li>
</ul>
<p>限制数组为开始 N 个元素，N 由第一个参数指定。第二个参数是可选的，指定开始的偏移量。</p>
<pre><code>&lt;!-- 只显示开始 10 个元素 --&gt;
&lt;div v-for="item in items | limitBy 10"&gt;&lt;/div&gt;

&lt;!-- 显示第 5 到 15 元素--&gt;
&lt;div v-for="item in items | limitBy 10 5"&gt;&lt;/div&gt;
</code></pre>
<h3 id="filterby">filterBy</h3>
<ul>
<li> <p><strong>限制：</strong> 指令的值须是数组，如 <code>v-for</code></p> </li>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String | Function} targetStringOrFunction</code></li>
<li><code>"in" (optional delimiter)</code></li>
<li><code>{String} [...searchKeys]</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>返回过滤后的数组。第一个参数可以是字符串或函数。</p> <p>如果第一个参数是字符串，则在每个数组元素中搜索它：</p> <pre><code>&lt;div v-for="item in items | filterBy 'hello'"&gt;
</code></pre> <p>在上例中，只显示包含字符串 <code>"hello"</code> 的元素。</p> <p>如果 item 是一个对象，过滤器将递归地在它所有属性中搜索。为了缩小搜索范围，可以指定一个搜索字段：</p> <pre><code>&lt;div v-for="user in users | filterBy 'Jack' in 'name'"&gt;
</code></pre> <p>在上例中，过滤器只在用户对象的 <code>name</code> 属性中搜索 <code>"Jack"</code>。<strong>为了更好的性能，最好始终限制搜索范围。</strong></p> <p>上例使用静态参数，当然可以使用动态参数作为搜索目标或搜索字段。配合 <code>v-model</code> 我们可以轻松实现输入提示效果：</p> <pre><code>&lt;div id="filter-by-example"&gt;
  &lt;input v-model="name"&gt;
  &lt;ul&gt;
    &lt;li v-for="user in users | filterBy name in 'name'"&gt;
      {{ user.name }}
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre> <pre><code>new Vue({
  el: '#filter-by-example',
  data: {
    name: '',
    users: [
      { name: 'Bruce' },
      { name: 'Chuck' },
      { name: 'Jackie' }
    ]
  }
})
</code></pre> <p>{% raw %}</p>
<div id="filter-by-example" class="demo">
<input v-model="name">
<ul>
<li v-for="user in users | filterBy name in 'name'"> {{ user.name }} </li>
</ul>
</div> <script>new Vue({el:'#filter-by-example',data:{name:'',users:[{name:'Bruce' },{name:'Chuck' },{name:'Jackie' }]
}
})
</script> {% endraw %} </li>
<li> <p><strong>另一个示例：</strong></p> <p>多搜索字段：</p> <pre><code>&lt;li v-for="user in users | filterBy searchText in 'name' 'phone'"&gt;&lt;/li&gt;
</code></pre> <p>多搜索字段为一个动态数组：</p> <pre><code>&lt;!-- fields = ['fieldA', 'fieldB'] --&gt;
&lt;div v-for="user in users | filterBy searchText in fields"&gt;
</code></pre> <p>使用自定义过滤函数：</p> <pre><code>&lt;div v-for="user in users | filterBy myCustomFilterFunction"&gt;
</code></pre> </li>
</ul>
<h3 id="orderby">orderBy</h3>
<ul>
<li> <p><strong>限制：</strong> 指令的值须是数组，如 <code>v-for</code></p> </li>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{String | Array&lt;String&gt; | Function} ...sortKeys</code></li>
<li><code>{String} [order] - 默认值：1</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>返回排序后的数组。你可以传入多个键名。你也可以传入一个数组，此数组包含排序的键名。如果你想使用自己的排序策略，可以传入一个函数。可选参数 <code>order</code> 决定结果升序（<code>order &gt;= 0</code>）或降序（<code>order &lt; 0</code>）。</p> <p>对于原始类型数组，可以忽略 <code>sortKey</code> ，只提供排序，例如 <code>orderBy 1</code>。</p> </li>
<li> <p><strong>示例：</strong></p> <p>按名字排序用户：</p> <pre><code>&lt;ul&gt;
  &lt;li v-for="user in users | orderBy 'name'"&gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre> <p>降序：</p> <pre><code>&lt;ul&gt;
  &lt;li v-for="user in users | orderBy 'name' -1"&gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre> <p>原始类型数组：</p> <pre><code>&lt;ul&gt;
  &lt;li v-for="n in numbers | orderBy true"&gt;
    {{ n }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre> <p>动态排序：</p> <pre><code>&lt;div id="orderby-example"&gt;
  &lt;button @click="order = order * -1"&gt;Reverse Sort Order&lt;/button&gt;
  &lt;ul&gt;
    &lt;li v-for="user in users | orderBy 'name' order"&gt;
      {{ user.name }}
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre> <pre><code>new Vue({
  el: '#orderby-example',
  data: {
    order: 1,
    users: [{ name: 'Bruce' }, { name: 'Chuck' }, { name: 'Jackie' }]
  }
})
</code></pre> <p>使用两个键名排序：</p> <pre><code>&lt;ul&gt;
  &lt;li v-for="user in users | orderBy 'lastName' 'firstName'"&gt;
    {{ user.lastName }} {{ user.firstName }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre> <pre><code>&lt;div id="orderby-example" class="demo"&gt;
  &lt;button @click="order = order * -1"&gt;Reverse Sort Order&lt;/button&gt;
  &lt;ul&gt;
    &lt;li v-for="user in users | orderBy 'name' order"&gt;
      {{ user.name }}
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
new Vue({
  el: '#orderby-example',
  data: {
    order: 1,
    users: [{ name: 'Bruce' }, { name: 'Chuck' }, { name: 'Jackie' }]
  }
})
&lt;/script&gt;
</code></pre> <p>使用一个函数排序：</p> <pre><code>&lt;div id="orderby-compare-example" class="demo"&gt;
  &lt;button @click="order = order * -1"&gt;Reverse Sort Order&lt;/button&gt;
  &lt;ul&gt;
    &lt;li v-for="user in users | orderBy ageByTen order"&gt;
      {{ user.name }} - {{ user.age }}
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre> <pre><code>new Vue({
  el: '#orderby-compare-example',
  data: {
    order: 1,
    users: [
      {
        name: 'Jackie',
        age: 62
      },
      {
        name: 'Chuck',
        age: 76
      },
      {
        name: 'Bruce',
        age: 61
      }
    ]
  },
  methods: {
    ageByTen: function (a, b) {
      return Math.floor(a.age / 10) - Math.floor(b.age / 10)
    }
  }
})
</code></pre> <pre><code>&lt;div id="orderby-compare-example" class="demo"&gt;
  &lt;button @click="order = order * -1"&gt;Reverse Sort Order&lt;/button&gt;
  &lt;ul id="orderby-compare-example"&gt;
    &lt;li v-for="user in users | orderBy ageByTen order"&gt;
      {{ user.name }} - {{ user.age }}
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
new Vue({
  el: '#orderby-compare-example',
  data: {
    order: 1,
    users: [
      {
        name: 'Jackie',
        age: 62
      },
      {
        name: 'Chuck',
        age: 76
      },
      {
        name: 'Bruce',
        age: 61
      }
    ]
  },
  methods: {
    ageByTen: function (a, b) {
      return Math.floor(a.age / 10) - Math.floor(b.age / 10)
    }
  }
})
&lt;/script&gt;
</code></pre> </li>
</ul>
<h2 id="数组扩展方法">数组扩展方法</h2>
<p>Vue.js 在 <code>Array.prototype</code> 上添加了两个方法，以方便常见的数组操作，并且能触发视图更新。</p>
<h3 id="arraysetindex-value">array.$set(index, value)</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Number} index</code></li>
<li><code>{*} value</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>通过索引设置数组元素并触发视图更新。</p> <pre><code>vm.animals.$set(0, { name: 'Aardvark' })
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/list.html#问题">数组检测问题</a></p> </li>
</ul>
<h3 id="arrayremovereference">array.$remove(reference)</h3>
<ul>
<li> <p><strong>参数：</strong></p>
<ul>
<li><code>{Reference} reference</code></li>
</ul> </li>
<li> <p><strong>用法：</strong></p> <p>通过索引删除数组元素并触发视图更新。这个方法先在数组中搜索这个元素，如果找到了则调用 <code>array.splice(index, 1)</code>。</p> <pre><code>var aardvark = vm.animals[0]
vm.animals.$remove(aardvark)
</code></pre> </li>
<li> <p><strong>另见：</strong> <a href="../../book/133/guide/list.html#变异方法">变异方法</a></p> </li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/132/index.html">
<img class="uk-book-cover" src="../../static/icons/48/vuejs_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/132/index.html">vue-router文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/71.html">srzyhead</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="vuejs">vuejs</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">30页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/12/index.html">
<img class="uk-book-cover" src="../../static/icons/48/swift_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/12/index.html">Swift 官方教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/8.html">numbbbbb</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="swift">swift</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">51页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 18022个">18022</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/16/index.html">
<img class="uk-book-cover" src="../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/16/index.html">Go语言web编程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/9.html">astaxie</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">97页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 23774个">23774</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/95/index.html">
<img class="uk-book-cover" src="../../static/icons/48/spring_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/95/index.html">Spring Framework 5 中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/58.html">lfvepclr</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="spring">spring</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">134页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 25个">25</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/164/index.html">
<img class="uk-book-cover" src="../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/164/index.html">Go 开发者路线图</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/93.html">Alikhll</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 4583个">4583</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/37/index.html">
<img class="uk-book-cover" src="../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/37/index.html">安卓逆向系列教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 87个">87</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/133/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/133/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/133/README.html" title="Introduction" data-book-page-rel-url="README.html" data-book-page-id="10016">Introduction</a>
</li>
<li>
<a class="pjax" href="../../book/133/installation.html" title="安装" data-book-page-rel-url="installation.html" data-book-page-id="10017">安装</a>
</li>
<li>
<a class="pjax" href="../../book/133/index.html" title="起步" data-book-page-rel-url="index.html" data-book-page-id="10018">起步</a>
</li>
<li>
<a class="pjax" href="../../book/133/overview.html" title="概述" data-book-page-rel-url="overview.html" data-book-page-id="10019">概述</a>
</li>
<li>
<a class="pjax" href="../../book/133/instance.html" title="Vue 实例" data-book-page-rel-url="instance.html" data-book-page-id="10020">Vue 实例</a>
</li>
<li>
<a class="pjax" href="../../book/133/syntax.html" title="数据绑定语法" data-book-page-rel-url="syntax.html" data-book-page-id="10021">数据绑定语法</a>
</li>
<li>
<a class="pjax" href="../../book/133/computed.html" title="计算属性" data-book-page-rel-url="computed.html" data-book-page-id="10022">计算属性</a>
</li>
<li>
<a class="pjax" href="../../book/133/class-and-style.html" title="Class 与 Style 绑定" data-book-page-rel-url="class-and-style.html" data-book-page-id="10023">Class 与 Style 绑定</a>
</li>
<li>
<a class="pjax" href="../../book/133/conditional.html" title="条件渲染" data-book-page-rel-url="conditional.html" data-book-page-id="10024">条件渲染</a>
</li>
<li>
<a class="pjax" href="../../book/133/list.html" title="列表渲染" data-book-page-rel-url="list.html" data-book-page-id="10025">列表渲染</a>
</li>
<li>
<a class="pjax" href="../../book/133/events.html" title="方法与事件处理器" data-book-page-rel-url="events.html" data-book-page-id="10026">方法与事件处理器</a>
</li>
<li>
<a class="pjax" href="../../book/133/forms.html" title="表单控件绑定" data-book-page-rel-url="forms.html" data-book-page-id="10027">表单控件绑定</a>
</li>
<li>
<a class="pjax" href="../../book/133/transitions.html" title="过渡" data-book-page-rel-url="transitions.html" data-book-page-id="10028">过渡</a>
</li>
<li>
<a class="pjax" href="../../book/133/components.html" title="组件" data-book-page-rel-url="components.html" data-book-page-id="10029">组件</a>
</li>
<li>
<a class="pjax" href="../../book/133/reactivity.html" title="深入响应式原理" data-book-page-rel-url="reactivity.html" data-book-page-id="10030">深入响应式原理</a>
</li>
<li>
<a class="pjax" href="../../book/133/custom-directive.html" title="自定义指令" data-book-page-rel-url="custom-directive.html" data-book-page-id="10031">自定义指令</a>
</li>
<li>
<a class="pjax" href="../../book/133/custom-filter.html" title="自定义过滤器" data-book-page-rel-url="custom-filter.html" data-book-page-id="10032">自定义过滤器</a>
</li>
<li>
<a class="pjax" href="../../book/133/mixins.html" title="混合" data-book-page-rel-url="mixins.html" data-book-page-id="10033">混合</a>
</li>
<li>
<a class="pjax" href="../../book/133/plugins.html" title="插件" data-book-page-rel-url="plugins.html" data-book-page-id="10034">插件</a>
</li>
<li>
<a class="pjax" href="../../book/133/application.html" title="构建大型应用" data-book-page-rel-url="application.html" data-book-page-id="10035">构建大型应用</a>
</li>
<li>
<a class="pjax" href="../../book/133/comparison.html" title="对比其它框架" data-book-page-rel-url="comparison.html" data-book-page-id="10036">对比其它框架</a>
</li>
<li>
<a class="pjax" href="../../book/133/api.html" title="API" data-book-page-rel-url="api.html" data-book-page-id="10037">API</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =133;var bookPageId =10037;var bookPageRelUrl ='api.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>