
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>5.7.错误处理-Rust 程序设计语言 中文版</title>
<meta content='5.7.错误处理,Rust 程序设计语言 中文版' name='keywords'>
<meta content='5.7.错误处理,Rust 程序设计语言 中文版' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/55/content/Concurrency%20并发.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">5.6.并发</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/55/content/Choosing%20your%20Guarantees%20选择你的保证.html">
<span class="">5.8.选择你的保证</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/55/index.html">Rust 程序设计语言 中文版</a>
<a target="_blank" rel="nofollow" href="https://github.com/hltj/rust-book-chinese" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="错误处理">错误处理</h1>
<blockquote>
<p><a href="https://github.com/rust-lang/rust/blob/master/src/doc/book/error-handling.html">error-handling.html</a> <br> commit e26279db48cc5510a13f0e97bde97ccd2d2a1854</p>
</blockquote>
<p>就像大多数编程语言，Rust 鼓励程序猿以特定的方式处理错误。一般来讲，错误处理被分割为两个大类：异常和返回值。Rust 选择了返回值。</p>
<p>在这一部分，我们试图提供一个全面的 Rust 如何处理错误的解决方案。不仅如此，我们也尝试一次一点的介绍错误处理，这样当你离开时会有一个所有东西如何协调的坚实理解。</p>
<p>Rust 的错误处理天生是冗长而烦人的。这一部分将会探索这些坑并展示如何使用标准库来让错误处理变得准确和符合工程原理。</p>
<h2 id="内容列表">内容列表</h2>
<p>这一部分灰常的长，大部分因为我们从最基础的和类型和组合入手，并尝试一点一点的解释 Rust 错误处理的动机。为此，对有其他类似类型系统经验的童鞋可能想要跳过一些内容。</p>
<ul>
<li><a href="#the-basics">基础</a>
<ul>
<li><a href="#unwrapping-explained">理解 unwrapping</a></li>
<li><a href="#the-option-type"><code>Option</code>类型</a>
<ul>
<li><a href="#composing-optiont-values">组合<code>Option&lt;T&gt;</code>值</a></li>
</ul> </li>
<li><a href="#the-result-type"><code>Result</code>类型</a>
<ul>
<li><a href="#parsing-integers">解析整型</a></li>
<li><a href="#the-result-type-alias-idiom"><code>Result</code>类型别名习惯</a></li>
</ul> </li>
<li><a href="#a-brief-interlude-unwrapping-isnt-evil">小插曲：unwrapping 并不邪恶</a></li>
</ul> </li>
<li><a href="#working-with-multiple-error-types">处理多种错误类型</a>
<ul>
<li><a href="#composing-option-and-result">组合<code>Option</code>和<code>Result</code></a></li>
<li><a href="#the-limits-of-combinators">组合的限制</a></li>
<li><a href="#early-returns">提早返回</a></li>
<li><a href="#the-try-macro"><code>try!</code>宏</a></li>
<li><a href="#defining-your-own-error-type">定义你自己的错误类型</a></li>
</ul> </li>
<li><a href="#standard-library-traits-used-for-error-handling">用于错误处理的标准库 trait</a>
<ul>
<li><a href="#the-error-trait"><code>Error</code>trait</a></li>
<li><a href="#the-from-trait"><code>From</code>trait</a></li>
<li><a href="#the-real-try-macro">真正的<code>try!</code>宏</a></li>
<li><a href="#composing-custom-error-types">组合自定义错误类型</a></li>
<li><a href="#advice-for-library-writers">给库编写者的建议</a></li>
</ul> </li>
<li><a href="#case-study-a-program-to-read-population-data">案例学习：一个读取人口数据的程序</a>
<ul>
<li><a href="#initial-setup">初始化</a></li>
<li><a href="#argument-parsing">参数解析</a></li>
<li><a href="#writing-the-logic">编写逻辑</a></li>
<li><a href="#error-handling-with-boxerror">使用<code>Box&lt;Error&gt;</code>处理错误</a></li>
<li><a href="#reading-from-stdin">从标准输入读取</a></li>
<li><a href="#error-handling-with-a-custom-type">用自定义类型处理错误</a></li>
<li><a href="#adding-functionality">增加功能</a></li>
</ul> </li>
<li><a href="#the-short-story">精简版</a></li>
</ul>
<h2 id="基础"><a name="the-basics"></a>基础</h2>
<p>你可以认为错误处理是用事例分析（case analysis）来决定一个计算成功与否。如你所见，工程性的错误处理就是要减少程序猿显式的事例分析的同时保持代码的可组合性。</p>
<p>保持代码的可组合性是很重要的，因为没有这个要求，我们可能在遇到没想到的情况时<a href="http://doc.rust-lang.org/std/macro.panic!.html">panic</a>。（<code>panic</code>导致当前线程结束，而在大多数情况，导致整个程序结束。）这是一个例子：</p>
<pre><code class="language-rust">// Guess a number between 1 and 10.
// If it matches the number we had in mind, return true. Else, return false.
fn guess(n: i32) -&gt; bool {
    if n &lt; 1 || n &gt; 10 {
        panic!("Invalid number: {}", n);
    }
    n == 5
}

fn main() {
    guess(11);
}
</code></pre>
<p>如果你运行这段代码，程序会崩溃并输出类似如下信息：</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5
</code></pre>
<p>这是另一个稍微不那么违和的例子。一个接受一个整型作为参数，乘以二并打印的程序。</p>
<p><a name="code-unwrap-double"></a></p>
<pre><code class="language-rust">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!("{}", 2 * n);
}
</code></pre>
<p>如果你给这个程序 0 个参数（错误 1）或者 第一个参数并不是整型（错误 2），这个程序也会像第一个例子那样 panic。</p>
<p>你可以认为这种风格的错误处理类似于冲进瓷器店的公牛。它会冲向任何它想去的地方，不过会毁掉过程中的一切。</p>
<h3 id="理解-unwrapping"><a name="unwrapping-explained"></a>理解 unwrapping</h3>
<p>在之前的例子中，我们声称程序如果遇到两个错误情况之一会直接 panic，不过，程序并不像第一个程序那样包括一个显式的<code>panic</code>调用。这是因为 panic 嵌入到了<code>unwrap</code>的调用中。</p>
<p>Rust 中“unwrap”是说，“给我计算的结果，并且如果有错误，panic 并停止程序。”因为他们很简单如果我们能展示 unwrap 的代码就更好了，不过在这么做之前，我们首先需要探索<code>Option</code>和<code>Result</code>类型。他们俩都定义了一个叫<code>unwrap</code>的方法。</p>
<h3 id="option类型"><a name="the-option-type"></a><code>Option</code>类型</h3>
<p><code>Option</code>类型<a href="http://doc.rust-lang.org/std/option/enum.Option.html">定义在标准库中</a>：</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p><code>Option</code>类型是一个 Rust 类型系统用于表达*不存在的可能性（possibility of absence）*的方式。将不存在的可能性编码进类型系统是一个重要概念，因为它会强迫编译器处理不存在的情况。让我们看看一个尝试在一个字符串中找一个字符的例子：</p>
<p><a name="code-option-ex-string-find"></a></p>
<pre><code class="language-rust">// Searches `haystack` for the Unicode character `needle`. If one is found, the
// byte offset of the character is returned. Otherwise, `None` is returned.
fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
</code></pre>
<p>注意当函数找到一个匹配的字符，它并不仅仅返回<code>offset</code>。相反，它返回<code>Some(offset)</code>。<code>Some</code>是一个<code>Option</code>类型的一个变体或一个值构造器。你可以认为它是一个<code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>类型的函数。同理，<code>None</code>也是一个值构造器，除了它并没有参数。你可以认为<code>None</code>是一个<code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>类型的函数。</p>
<p>这可能看起来并没有什么，不过这是故事的一半。另一半是使用我们编写的<code>find</code>函数。让我们尝试用它查找文件名的扩展名。</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
fn main() {
    let file_name = "foobar.rs";
    match find(file_name, '.') {
        None =&gt; println!("No file extension found."),
        Some(i) =&gt; println!("File extension: {}", &amp;file_name[i+1..]),
    }
}
</code></pre>
<p>这段代码使用[模式识别](Patterns 模式.html)来对<code>find</code>函数的返回的<code>Option&lt;usize&gt;</code>进行 case analysis。事实上，case analysis 是唯一能获取<code>Option&lt;T&gt;</code>中存储的值的方式。这意味着你，作为一个程序猿，必须处理当<code>Option&lt;T&gt;</code>是<code>None</code>而不是<code>Some(t)</code>的情况。</p>
<p>不过稍等，那我们<a href="#code-unwrap-double">之前</a>使用的<code>unwrap</code>呢？那里并没有 case analysis！相反，case analysis 被放入了<code>unwrap</code>方法中。如果你想的话你可以自己定义它：</p>
<p><a name="code-option-def-unwrap"></a></p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Option::Some(val) =&gt; val,
            Option::None =&gt;
              panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
</code></pre>
<p><code>unwrap</code>方法抽象出了 case analysis。这正是<code>unwrap</code>的工程化用法。不幸的是，<code>panic!</code>意味着<code>unwrap</code>并不是可组合的：它是瓷器店中的公牛。</p>
<h4 id="组合optiont值"><a name="composing-optiont-values"></a>组合<code>Option&lt;T&gt;</code>值</h4>
<p>在<a href="#code-option-ex-string-find">之前的例子</a>中，我们看到了如何用<code>find</code>发现文件名的扩展名。当然，并不是所有文件名都有一个<code>.</code>，所以可能文件名并没有扩展名。不存在的可能性被编码进了使用<code>Option&lt;T&gt;</code>的类型。换句话说，编译器将会强制我们描述一个扩展名不存在的可能性。在我们的例子中，我们只打印出一个说明情况的信息。</p>
<p>获取一个文件名的扩展名是一个很常见的操作，所以把它放进一个函数是很有道理的：</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match find(file_name, '.') {
        None =&gt; None,
        Some(i) =&gt; Some(&amp;file_name[i+1..]),
    }
}
</code></pre>
<p>（专业建议：不要用这段代码，相反使用标准库的<a href="http://doc.rust-lang.org/std/path/struct.Path.html#method.extension">extension</a>方法。）</p>
<p>代码是简单的，不过重要的是注意到<code>find</code>的类型强迫我们考虑不存在的可能性。这是一个好事，因为这意味着编译器不会让我们不小心忘记了文件名没有扩展名的情况。另一方面，每次都像<code>extension_explicit</code>那样进行显式 case analysis 会变得有点无聊。</p>
<p>事实上，<code>extension_explicit</code>的 case analysis 遵循一个非常常见的模式：将<code>Option&lt;T&gt;</code>中的值映射为一个函数，除非它是<code>None</code>，这时，返回<code>None</code>。</p>
<p>Rust 拥有参数多态（parametric polymorphism），所以定义一个组合来抽象这个模式是很容易的：</p>
<p><a name="code-option-map"></a></p>
<pre><code class="language-rust">fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {
    match option {
        None =&gt; None,
        Some(value) =&gt; Some(f(value)),
    }
}
</code></pre>
<p>事实上，<code>map</code>是标准库中的<code>Option&lt;T&gt;</code><a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map">定义的一个方法</a>。</p>
<p>用我们的新组合，我们可以重写我们的<code>extension_explicit</code>方法来去掉 case analysis：</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, '.').map(|i| &amp;file_name[i+1..])
}
</code></pre>
<p>我们通常会发现的另一个模式是为一个<code>Option</code>为<code>None</code>时赋一个默认值。例如，也许你的程序假设即便一个文件没有扩展名则它的扩展名是<code>rs</code>。正如你可能想象到的，这里的 case analysis 并不特定用于文件扩展名 - 它可以用于任何<code>Option&lt;T&gt;</code>：</p>
<pre><code class="language-rust">fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
    match option {
        None =&gt; default,
        Some(value) =&gt; value,
    }
}
</code></pre>
<p>这里要注意的是默认值的类型必须与可能出现在<code>Option&lt;T&gt;</code>中的值类型相同。在我们的例子中使用它是非常简单的：</p>
<pre><code class="language-rust"># fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
#     for (offset, c) in haystack.char_indices() {
#         if c == needle {
#             return Some(offset);
#         }
#     }
#     None
# }
#
# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
#     find(file_name, '.').map(|i| &amp;file_name[i+1..])
# }
fn main() {
    assert_eq!(extension("foobar.csv").unwrap_or("rs"), "csv");
    assert_eq!(extension("foobar").unwrap_or("rs"), "rs");
}
</code></pre>
<p>（注意<code>unwrap_or</code>是标准库中的<code>Option&lt;T&gt;</code><a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">定义的一个方法</a>，所以这里我们使用它而不是我们上面定义的独立的函数。别忘了看看更通用的<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a>方法。）</p>
<p>还有另一个我们认为值得特别注意的 组合：<code>and_then</code>。它让我们更容易的组合不同的承认不存在的可能性的计算。例如，这一部分的很多代码是关于找到一个给定文件的扩展名的。为此，你首先需要一个通常截取自文件路径的文件名。虽然大部分文件路径都有一个文件名，但并不是都有。例如，<code>.</code>，<code>..</code>，<code>/</code>。</p>
<p>所以，我们面临着从一个给定的文件路径找出一个扩展名的挑战。让我们从显式 case analysis 开始：</p>
<pre><code class="language-rust"># fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match file_name(file_path) {
        None =&gt; None,
        Some(name) =&gt; match extension(name) {
            None =&gt; None,
            Some(ext) =&gt; Some(ext),
        }
    }
}

fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
  // implementation elided
  unimplemented!()
}
</code></pre>
<p>你可能认为我们应该用<code>map</code>组合来减少 case analysis，不过它的类型并不匹配。也就是说，<code>map</code>获取一个只处理（Option）内部值的函数。这导致那个函数总是<a href="#code-option-map">重新映射成了<code>Some</code></a>。因此，我们需要一些类似<code>map</code>，不过允许调用者返回另一个<code>Option</code>的方法。它的泛型实现甚至比<code>map</code>更简单：</p>
<pre><code class="language-rust">fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
        where F: FnOnce(T) -&gt; Option&lt;A&gt; {
    match option {
        None =&gt; None,
        Some(value) =&gt; f(value),
    }
}
</code></pre>
<p>现在我们可以不用显式 case analysis 重写我们的<code>file_path_ext</code>函数了：</p>
<pre><code class="language-rust"># fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
# fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).and_then(extension)
}
</code></pre>
<p><code>Option</code>类型有很多其他<a href="http://doc.rust-lang.org/std/option/enum.Option.html">定义在标准库中的</a>组合。过一边这个列表并熟悉他们的功能是一个好主意 —— 通常他们可以减少你的 case analysis。熟悉这些组合将会得到回报，因为他们很多也为<code>Result</code>类型定义了实现（相似的语义），而我们接下来会讲<code>Result</code>。</p>
<p>组合使用像<code>Option</code>这样的符合工程学的类型来减少显式 case analysis。他们也是可组合的因为他们允许调用者以他们自己的方式处理不存在的可能性。像<code>unwrap</code>这样的方法去掉了选择因为当<code>Option&lt;T&gt;</code>为<code>None</code>他们会 panic。</p>
<h3 id="result类型"><a name="the-result-type"></a><code>Result</code>类型</h3>
<p><code>Result</code>类型也<a href="http://doc.rust-lang.org/std/result/index.html">定义于标准库中</a>：</p>
<p><a name="code-result-def"></a></p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p><code>Result</code>是<code>Option</code>的高级版本。相比于像<code>Option</code>那样表示不存在的可能性，<code>Result</code>表示错误的可能性。通常，错误用来解释为什么一些计算会失败。严格的说这是一个更通用的<code>Option</code>。考虑如下类型别名，它的语义在任何地方都与真正的<code>Option&lt;T&gt;</code>相同：</p>
<pre><code class="language-rust">type Option&lt;T&gt; = Result&lt;T, ()&gt;;
</code></pre>
<p>它把<code>Result</code>的第二个类型参数改为总是<code>()</code>（读作“单元”或“空元组”）。<code>()</code>类型只有一个值：<code>()</code>（没错，类型和值级别的形式是一样的！）</p>
<p><code>Result</code>类型是一个代表一个计算的两个可能结果的方式。通常，一个结果是期望的值或者“<code>Ok</code>”而另一个意味着非预期的或者“<code>Err</code>”。</p>
<p>就像<code>Option</code>，<code>Result</code>在标准库中也<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap">定义了一个<code>unwrap</code>方法</a>。让我们定义它：</p>
<pre><code class="language-rust"># enum Result&lt;T, E&gt; { Ok(T), Err(E) }
impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Result::Ok(val) =&gt; val,
            Result::Err(err) =&gt;
              panic!("called `Result::unwrap()` on an `Err` value: {:?}", err),
        }
    }
}
</code></pre>
<p>这实际上与<a href="#code-option-def-unwrap"><code>Option::unwrap</code>的定义</a>一样，除了它在<code>panic!</code>信息中包含了错误信息。这让调试变得简单，不过也要求我们为<code>E</code>类型参数（它代表我们的错误类型）添加一个<a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>限制。因为绝大部分类型应该满足<code>Debug</code>限制，这使得它可以在实际中使用。（<code>Debug</code>简单的意味着这个类型有合理的方式可以打印出人类可读的描述。）</p>
<p>OK，让我们开始一个例子。</p>
<h4 id="解析整型"><a name="parsing-integers"></a>解析整型</h4>
<p>Rust 标准库中让字符串转换为整型变得异常简单。事实上它太简单了，以至于你可以写出如下代码：</p>
<pre><code class="language-rust">fn double_number(number_str: &amp;str) -&gt; i32 {
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let n: i32 = double_number("10");
    assert_eq!(n, 20);
}
</code></pre>
<p>在这里，你应该对调用<code>unwrap</code>持怀疑态度。例如，如果字符串并不能解析为一个数字，它会 panic：</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
</code></pre>
<p>这是很难堪的，而且如果这在你所使用的库中出现了的话，可以理解你会很烦躁。相反，我们应该尝试在我们的函数里处理错误并让调用者决定该怎么做。这意味着改变<code>double_number</code>的返回值类型。不过改编成什么呢？好吧，这需要我们看看标准库中<a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code>方法</a>的签名：</p>
<pre><code class="language-rust">impl str {
    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;
}
</code></pre>
<p>额嗯。所以至少我们知道了我们需要使用一个<code>Result</code>。当然，也可以返回一个<code>Option</code>。毕竟，一个字符串要么能解析成一个数字要么不能，不是吗？这当然是一个合理的方式，不过实现内部区别了为什么字符串不能解析成数字。（要么是一个空字符串，一个无效的数位，太大或太小。）因此，使用<code>Result</code>更有道理因为我们想要比单纯的“不存在”提供更多信息。我们想要表明<em>为什么</em>解析会失败。你应该尝试再现这样的推理，当你面对一个<code>Option</code>和<code>Result</code>之间的选择时。如果你可以提供详细的错误信息，那么大概你也应该提供。（我们会在后面详细讲到。）</p>
<p>好的，不过我们的返回值类型该怎么写呢？上面定义的<code>parse</code>方法对所有不同的标准库定义的数字类型是泛型的。我们也可以（应该）让我们的函数也是泛型的，不过这回让我们享受显式定义的好处。我们只关心<code>i32</code>，所以我们需要寻找<a href="http://doc.rust-lang.org/std/primitive.i32.html"><code>FromStr</code>的实现</a>（在你的浏览器中用<code>CTRL-F</code>搜索“FromStr”）和<a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html">与它相关的类型<code>](Associated Types 关联类型.html)</code>Err<code>。这么做我可以找出具体的错误类型。在这个例子中，它是[</code>std::num::ParseIntError`</a>。最后我们可以重写函数：</p>
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n) =&gt; Ok(2 * n),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    match double_number("10") {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!("Error: {:?}", err),
    }
}
</code></pre>
<p>这比之前有些进步，不过现在我们写的代码有点多了！case analysis 又一次坑了我们。</p>
<p>组合是救星！就像<code>Option</code>一样，<code>Result</code>有很多定义的组合方法。<code>Result</code>和<code>Option</code>之间的常用组合有很大的交集。特别的，<code>map</code>就是其中之一：</p>
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn main() {
    match double_number("10") {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!("Error: {:?}", err),
    }
}
</code></pre>
<p>常见的组合<code>Result</code>都有，包括<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or">unwrap_or</a>和<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.and_then">and_then</a>。另外，因为<code>Result</code>有第二个类型参数，所以有一些只影响错误类型的组合，例如<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err">map_err</a>（相对于<code>map</code>）和<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else">or_else</a>（相对于<code>and_then</code>）。</p>
<h4 id="result类型别名习惯"><a name="the-result-type-alias-idiom"></a><code>Result</code>类型别名习惯</h4>
<p>在标准库中，你可能经常看到像<code>Result&lt;i32&gt;</code>这样的类型。不过等等，<a href="#code-result-def">我们定义的<code>Result</code></a>有两个类型参数。我么怎么能只指定一个呢？这里的关键是定义一个<code>Result</code>类型别名来对一个特定类型固定其中一个类型参数。通常固定的类型是错误类型。例如，我们之前的解析整数例子可以重写成这样：</p>
<pre><code class="language-rust">use std::num::ParseIntError;
use std::result;

type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {
    unimplemented!();
}
</code></pre>
<p>为什么我们应该这么做？好吧，如果我们有很多可能返回<code>ParseIntError</code>的函数，那么定义一个总是使用<code>ParseIntError</code>的别名就比每回都写一遍要方便很多。</p>
<p>这个习惯最突出的一点是标准库中的<a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>。通常，当你使用<code>io::Result&lt;T&gt;</code>，很明显你就是在使用<code>io</code>模块的类型别名而不是<code>std::result</code>的原始定义。（这个习惯也用于<a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>。）</p>
<h3 id="小插曲unwrapping-并不邪恶"><a name="a-brief-interlude-unwrapping-isnt-evil"></a>小插曲：unwrapping 并不邪恶</h3>
<p>如果你一路跟了过来，你可能注意到我们花了很大力气反对使用像<code>unwrap</code>这样会<code>panic</code>并终止你的程序的方法。通常来说，这是一个好的建议。</p>
<p>然而，<code>unwrap</code>仍然可以被明智的使用。具体如何正当化<code>unwrap</code>的使用是一个灰色区域并且理性的人可能不会同意。我会简述这个问题的一些个人看法。</p>
<ul>
<li>**在例子和简单快速的编码中。**有时你要写一个例子或小程序，这时错误处理一点也不重要。这种情形要击败<code>unwrap</code>的方便易用是很难的，所以它显得很合适。</li>
<li>**当 panic 就意味着程序中有 bug 的时候。**当你代码中的不变量应该阻止特定情况发生的时候（比如，从一个空的栈上弹出一个值），那么 panic 就是可行的。这是因为它暴露了程序的一个 bug。这可以是显式的，例如一个<code>assert!</code>失败，或者因为一个数组越界。</li>
</ul>
<p>这可能并不是一个完整的列表。另外，当使用<code>Option</code>的时候，通常使用<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect</code></a>方法更好。<code>expect</code>做了<code>unwrap</code>同样的工作，除了<code>expect</code>会打印你给它的信息。这让 panic 的结果更容易处理，因为相比“called unwrap on a None value.”会提供一个信息。</p>
<p>我的建议浓缩如下：运用你良好的判断。我的文字中并没有出现“永远不要做 X”或“Y 被认为是有害的”是有原因的。所有这些都是权衡取舍，并且这是你们程序猿的工作去决定在你的用例中哪个是可以接受的。我们目标只是尽可能的帮助你进行权衡。</p>
<p>现在我们介绍了 Rust 的基本的错误处理，并解释了 unwrap，让我们开始更多的探索标准库。</p>
<h2 id="处理多种错误类型"><a name="working-with-multiple-error-types"></a>处理多种错误类型</h2>
<p>到目前为止，我看到了不是<code>Option&lt;T&gt;</code>就是<code>Result&lt;T, SomeError&gt;</code>的错误处理。不过当你同时使用<code>Option</code>和<code>Result</code>时会发生什么呢？或者如果你使用<code>Result&lt;T, Error1&gt;</code>和<code>Result&lt;T, Error2&gt;</code>呢？我们接下来的挑战是处理<em>不同错误类型的组合</em>，这将会是贯穿本章余下部分的主要主题。</p>
<h3 id="组合option和result"><a name="composing-option-and-result"></a>组合<code>Option</code>和<code>Result</code></h3>
<p>到目前为止，我们讲到了为<code>Option</code>和<code>Result</code>定义的组合。我们可以用这些组合来处理不同的计算结果而不用进行显式的 case analysis。</p>
<p>当然，在实际的代码中，事情并不总是这么明显。有时你遇到一个<code>Option</code>和<code>Result</code>的混合类型。我们是必须求助于显式 case analysis，或者我们可以使用组合呢？</p>
<p>现在，让我们重温这一部分的第一个例子：</p>
<pre><code class="language-rust">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!("{}", 2 * n);
}
</code></pre>
<p>基于我们新掌握的关于<code>Option</code>，<code>Result</code>和他们的组合的知识，我们应该尝试重写它来适当的处理错误这样出错时程序就不会 panic 了。</p>
<p>这里的坑是<code>argv.nth(1)</code>产生一个<code>Option</code>而<code>arg.parse()</code>产生一个<code>Result</code>。他们不是直接可组合的。当同时遇到<code>Option</code>和<code>Result</code>的时候，解决办法通常是把<code>Option</code>转换为一个<code>Result</code>。在我们的例子中，缺少命令行参数（来自<code>env::args()</code>）意味着我们的用户没有正确调用我们的程序。我们可以用一个<code>String</code>来描述这个错误。让我们试试：</p>
<p><a name="code-error-double-string"></a></p>
<pre><code class="language-rust">use std::env;

fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {
    argv.nth(1)
        .ok_or("Please give at least one argument".to_owned())
        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) =&gt; println!("{}", n),
        Err(err) =&gt; println!("Error: {}", err),
    }
}
</code></pre>
<p>这个例子中有几个新东西。第一个是使用了<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a>组合。这是一个把<code>Option</code>转换为<code>Result</code>的方法。这个转换要求你指定当<code>Option</code>为<code>None</code>时的错误。就像我们见过的其他组合一样，它的定义是非常简单的：</p>
<pre><code class="language-rust">fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
    match option {
        Some(val) =&gt; Ok(val),
        None =&gt; Err(err),
    }
}
</code></pre>
<p>另一个新使用的组合是<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>。这就像<code>Result::map</code>，除了它映射一个函数到<code>Result</code>的 error 部分。如果<code>Result</code>是一个<code>Ok(...)</code>，那么它什么也不修改。</p>
<p>这里我们使用<code>map_err</code>是因为它对保证相同的错误类型（因为我们使用了<code>and_then</code>）是必要的。因为我们选择把<code>Option&lt;String&gt;</code>（来自<code>argv.nth(1)</code>）转换为<code>Result&lt;String, String&gt;</code>，我们也必须把来自<code>arg.parse()</code>的<code>ParseIntError</code>转换为<code>String</code>。</p>
<h3 id="组合的限制"><a name="the-limits-of-combinators"></a>组合的限制</h3>
<p>IO 和 解析输入是非常常见的任务，这也是我个人在 Rust 经常做的。因此，我们将使用（并一直使用）IO 和多种解析工作作为例子讲解错误处理。</p>
<p>让我们从简单的开始。我们的任务是打开一个文件，读取所有的内容并把他们转换为一个数字。接着我们把它乘以<code>2</code>并打印结果。</p>
<p>虽然我们劝告过你不要用<code>unwrap</code>，不过开始写代码的时候<code>unwrap</code>也是有用的。它允许你关注你的问题而不是错误处理，并且暴露出需要错误处理的点。让我们开始试试手感，再接着用更好的错误处理重构。</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {
    let mut file = File::open(file_path).unwrap(); // error 1
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap(); // error 2
    let n: i32 = contents.trim().parse().unwrap(); // error 3
    2 * n
}

fn main() {
    let doubled = file_double("foobar");
    println!("{}", doubled);
}
</code></pre>
<p>（附注：<code>AsRef&lt;Path&gt;</code>被使用是因为它与<a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code>有着相同的 bound</a>。这让我们可以用任何类型的字符串作为一个文件路径。）</p>
<p>这里可能出现三个不同错误：</p>
<ol>
<li>打开文件出错。</li>
<li>从文件读数据出错。</li>
<li>将数据解析为数字出错。</li>
</ol>
<p>头两个错误被描述为<a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a>类型。我们知道这些因为返回类型是<a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a>和<a href="http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a>。（注意他们都使用了之前描述的<a href="#the-result-type-alias-idiom"><code>Result</code>类型别名习惯</a>。如果你点击<code>Result</code>类型，你将会<a href="http://doc.rust-lang.org/std/io/type.Result.html">看到这个类型别名</a>，以及底层的<code>io::Error</code>类型。）第三个问题被描述为<a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>。特别的<code>io::Error</code>被广泛的用于标准库中。你会一次又一次的看到它。</p>
<p>让我们着手重构<code>file_double</code>函数。为了让这个函数可以与程序的其他组件组合，它必须不能在上述错误情况下 panic。事实上，这意味着它在任何操作失败时应该返回一个错误。我们的问题是<code>file_double</code>的返回类型是<code>i32</code>，它并没有给我们一个有效的报告错误的途径。因此，我们必须以把返回类型<code>i32</code>改成别的什么的开始。</p>
<p>我们需要决定的第一件事：我们应该用<code>Option</code>还是<code>Result</code>？当然我们可以简单的选择<code>Option</code>。如果出现任何错误了，我们可以简单的返回<code>None</code>。它可以工作并且比 panic 好多了，不过我们可以做的更好。我们应该在错误发生时传递一些细节。因为我们想要表达<em>错误的可能性</em>，我们应该使用<code>Result&lt;i32, E&gt;</code>。不过<code>E</code>应该是什么呢？因为可能出现两种不同的错误，我们需要把他们转换为一种通用类型。其中之一就是<code>String</code>。让我们看看这如何影响我们的代码：</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&lt;i32&gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) =&gt; println!("{}", n),
        Err(err) =&gt; println!("Error: {}", err),
    }
}
</code></pre>
<p>这些代码看起来有点难以理解。在能轻松编写这样的代码前可能需要更多一些实践。我们写代码的方式遵循<em>跟着类型走（following the types）</em>。一旦我们把<code>file_double</code>的返回类型改为<code>Result&lt;i32, String&gt;</code>，我们就不得不开始寻找正确的组合。在这个例子中，我们只用到了三个不同的组合：<code>and_then</code>，<code>map</code>和<code>map_err</code>。</p>
<p><code>and_then</code>被用来连接多个计算，其中每一个都有可能返回一个错误。在打开文件后，还有另外两个可能失败的计算：从文件读取和把内容解析成数字。相应地，有两个<code>and_then</code>的调用。</p>
<p><code>map</code>用来把一个函数用于<code>Result</code>的<code>Ok(...)</code>值。例如，最后一个<code>map</code>调用把<code>Ok(...)</code>值（它是一个<code>i32</code>）乘以<code>2</code>。如果在这之前出现了错误，这里的操作会被省略，因为<code>map</code>是这么定义的。</p>
<p><code>map_err</code>是让一切可以工作的关键。<code>map_err</code>类似<code>map</code>，除了它把一个函数用于<code>Result</code>的<code>Err(...)</code>值。在这个例子中，我们想要把所有的错误转换为一个类型：<code>String</code>。因为<code>io::Error</code>和<code>num::ParseIntError</code>都实现了<code>ToString</code>，我们可以调用<code>to_string()</code>去转换他们。</p>
<p>说了这么多，代码仍然不好懂。掌握组合的应用是很重要的，不过他们也有限制。让我们尝试一个不同的方式：提早返回。</p>
<h3 id="提早返回"><a name="early-returns"></a>提早返回</h3>
<p>我想利用前一章节的代码并用提早返回重写它。提早返回让你提前退出函数。我们不能在另一个闭包中从<code>file_double</code>提前返回，所以我们需要退回到显式 case analysis。</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&gt; n,
        Err(err) =&gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) =&gt; println!("{}", n),
        Err(err) =&gt; println!("Error: {}", err),
    }
}
</code></pre>
<p>理性的同学可能不同意这个比使用组合的代码更好，不过如果你并不熟悉组合方式，这些代码阅读起来更简单。它通过<code>match</code>和<code>if let</code>进行了显式 case analysis。如果错误出现了，它简单的停止执行并返回错误（通过转换为一个字符串）。</p>
<p>这难道不是倒退吗？之前，我们说过工程性的错误处理的关键是减少显式 case analysis，不过这里我们又退回到了显式 case analysis。这表明，有多种方式可以减少显式 case analysis。组合并不是唯一的方法。</p>
<h3 id="try宏"><a name="the-try-macro"></a><code>try!</code>宏</h3>
<p>Rust 中错误处理的基石是<code>try!</code>宏。<code>try!</code>宏像组合一样抽象了 case analysis，不过不像组合，它也抽象了控制流。也就是说，它可以抽象我们之前看到的提早返回的模式。</p>
<p>这是一个简单化的<code>try!</code>宏定义：</p>
<p><a name="code-try-def-simple"></a></p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
</code></pre>
<p>（<a href="http://doc.rust-lang.org/std/macro.try!.html">实际的定义</a>有一点复杂。我们会在后面详述。）</p>
<p>使用<code>try!</code>宏让我们的最后的例子异常的简单。因为它为我们做了 case analysis 和提早返回，我们的代码更紧凑也更易于理解：</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) =&gt; println!("{}", n),
        Err(err) =&gt; println!("Error: {}", err),
    }
}
</code></pre>
<p>根据<a href="#code-try-def-simple">我们<code>try!</code>宏的定义</a><code>map_err</code>调用仍是必要的。这是因为错误类型仍然需要被转换为<code>String</code>。好消息是我们马上就会学到如何移除这些<code>map_err</code>调用！坏消息是在我们可以移除<code>map_err</code>调用之前我们需要更深入的学习一些标准库中的重要的 trait。</p>
<h3 id="定义你自己的错误类型"><a name="defining-your-own-error-type"></a>定义你自己的错误类型</h3>
<p>在我们深入学习一些标准库错误 trait 之前，我想要通过移除之前例子中的作为错误类型的<code>String</code>来结束本章节。</p>
<p>之前我们的例子中使用<code>String</code>是为了方便，因为把错误转换为字符串是简单的，甚至把我们自己的类型转换为字符串也是如此。然而，把<code>String</code>作为你的错误有一些缺点。</p>
<p>第一个缺点是错误信息会倾向于另你的代码变得凌乱。把错误信息定义在别处是可能的，不顾除非你非常的（qiang）自（po）律（zheng），你很容易就会把错误信息嵌入到你的代码中。事实上，我们<a href="#code-error-double-string">上一个例子</a>就是这么做的。</p>
<p>第二个也是更重要的缺点是<code>String</code>是<em>不完整的</em>。也就是说，如果所有错误都转换成了字符串，那么传递给调用者的错误就变得完全不透明了。调用者对于一个<code>String</code>类型的错误所能作的唯一可行的事就是把它展示给用户。当然，通过观察字符串来确定错误的类型是不健壮的。（对于一个库来说这个缺点公认要比在例如程序中来的更重要。）</p>
<p>例如，<code>io::Error</code>类型内嵌了一个<a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>，它是一个表示在 IO 操作期间错误信息的<em>结构化类型</em>。这很重要因为你可能根据错误做出不同的反应。（例如，<code>BrokenPipe</code>错误可能意味着可以温和的退出程序，而<code>NotFound</code>则意味着应该返回一个错误码并向用户展示错误。）通过<code>io::ErrorKind</code>，调用者可以用 case analysis 检查错误的类型，这完全优于尝试从<code>String</code>中梳理错误的细节。</p>
<p>除了在我们之前从文件读取一个数字的例子中使用<code>String</code>作为错误类型外，我们可以定义我们自己的错误类型来用结构化数据代表错误。我们尽量不丢掉底层错误的信息以防调用者想要检视细节。</p>
<p>表示多种可能性的理想方法是用<code>enum</code>来定义我们的集合类型。在我们的例子里，错误要么是<code>io::Error</code>要么是<code>num::ParseIntError</code>，所以自然的定义如下：</p>
<pre><code class="language-rust">use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</code></pre>
<p>修改我们代码非常简单。与其把错误转为字符串，我们简单的用相应的值构造器把错误转换为我们的<code>CliError</code>类型：</p>
<pre><code class="language-rust"># #[derive(Debug)]
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) =&gt; println!("{}", n),
        Err(err) =&gt; println!("Error: {:?}", err),
    }
}
</code></pre>
<p>这里唯一的修改是从<code>map_err(|e| e.to_string())</code>（它把错误转换为字符串）变为<code>map_err(CliError::Io)</code>或者<code>map_err(CliError::Parse)</code>。调用者要决定报告给用户的细节的级别。实际上，使用<code>String</code>作为错误类型剥夺了调用者的选择，而用一个像<code>CliError</code>这样的<code>enum</code>类型除了一个描述错误的结构化数据之外还给了调用者所有的便利。</p>
<p>经验之谈是定义你自己的错误类型，不过必要时<code>String</code>也能行，特别是你在写一个程序时。如果你在编写一个库，强烈建议你定义自己的错误类型这样你就不会不必要的剥夺了调用者选择。</p>
<h2 id="用于错误处理的标准库-trait"><a name="standard-library-traits-used-for-error-handling"></a>用于错误处理的标准库 trait</h2>
<p>标准库定义了两个完整 trait 用于错误处理：<a href="std::error::Error"><code>http://doc.rust-lang.org/std/error/trait.Error.html</code></a>和<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a>。<code>Error</code>被专门设计为描述通用错误，<code>From</code> trait 更多的用于在两个不同类型值之间转换。</p>
<h3 id="errortrait"><a name="the-error-trait"></a><code>Error</code>trait</h3>
<p><code>Error</code> trait <a href="http://doc.rust-lang.org/std/error/trait.Error.html">定义于标准库中</a>：</p>
<pre><code class="language-rust">use std::fmt::{Debug, Display};

trait Error: Debug + Display {
  /// A short description of the error.
  fn description(&amp;self) -&gt; &amp;str;

  /// The lower level cause of this error, if any.
  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }
}
</code></pre>
<p>这个 trait 非常泛用因为它被设计为为所有类型实现来代表错误。它被证明对编写可组合的代码非常有帮助，正如我们将要看到的。这个 trait 允许你至少做如下事情：</p>
<ul>
<li>获取一个错误的<code>Debug</code>表示。</li>
<li>获取一个错误的面向用户的<code>Display</code>表示</li>
<li>获取一个错误的简短描述（通过<code>description</code>方法）</li>
<li>查看错误的调用链，如果存在的话（通过<code>cause</code>方法）</li>
</ul>
<p>头两个是因为<code>Error</code>要求实现<code>Debug</code>和<code>Display</code>。后两个来自于定义于<code>Error</code>的方法。<code>Error</code>的力量来自于所有错误类型都实现了<code>Error</code>的事实，这意味着错误可以被量化一个[trait 对象](Trait Objects trait 对象.html)。表现为<code>Box&lt;Error&gt;</code>或<code>&amp;Error</code>。事实上,<code>cause</code>返回一个<code>&amp;Error</code>，它自身就是一个 trait 对象。我们将在后面再次讨论<code>Error</code>作为 trait 对象的功能。</p>
<p>目前，展示一个实现了<code>Error</code> trait 的例子是足够的。让我们使用<a href="#defining-your-own-error-type">上一部分</a>我们定义的错误类型：</p>
<pre><code class="language-rust">use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</code></pre>
<p>这个特定的错误类型表示出现两种错误类型的可能性：一个进行 I/O 操作的错误或者一个把字符串转换为数字的错误。这个类型可以表示任何你想要添加的错误类型，通过向<code>enum</code>定义添加变量。</p>
<p>实现<code>Error</code>是非常直观的。这会有很多的显式 case analysis。</p>
<pre><code class="language-rust">use std::error;
use std::fmt;

impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            // Both underlying errors already impl `Display`, so we defer to
            // their implementations.
            CliError::Io(ref err) =&gt; write!(f, "IO error: {}", err),
            CliError::Parse(ref err) =&gt; write!(f, "Parse error: {}", err),
        }
    }
}

impl error::Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
        // Both underlying errors already impl `Error`, so we defer to their
        // implementations.
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Parse(ref err) =&gt; err.description(),
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {
            // N.B. Both of these implicitly cast `err` from their concrete
            // types (either `&amp;io::Error` or `&amp;num::ParseIntError`)
            // to a trait object `&amp;Error`. This works because both error types
            // implement `Error`.
            CliError::Io(ref err) =&gt; Some(err),
            CliError::Parse(ref err) =&gt; Some(err),
        }
    }
}
</code></pre>
<p>我们注意到这是一个非常典型的<code>Error</code>的实现：为你不同的错误类型做匹配并满足<code>description</code>和<code>cause</code>定义的限制。</p>
<h3 id="fromtrait"><a name="the-from-trait"></a><code>From</code>trait</h3>
<p><code>std::convert::From</code> trait <a href="http://doc.rust-lang.org/std/convert/trait.From.html">定义于标准库中</a>：</p>
<p><a name="code-from-def"></a></p>
<pre><code class="language-rust">trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
</code></pre>
<p>非常简单吧？<code>From</code>很有用因为它给了我们一个通用的方式来处理从一个特定类型<code>T</code>到其他类型的转换（在这个例子中，“其他类型”是实现的主体，或者<code>Self</code>）。<code>From</code>的核心是<a href="http://doc.rust-lang.org/std/convert/trait.From.html">标准库提供的一系列实现</a>。</p>
<p>这里是几个展示<code>From</code>如何工作的小例子：</p>
<pre><code class="language-rust">let string: String = From::from("foo");
let bytes: Vec&lt;u8&gt; = From::from("foo");
let cow: ::std::borrow::Cow&lt;str&gt; = From::from("foo");
</code></pre>
<p>好的，这么说<code>From</code>用来处理字符串转换，那么错误怎么办？他被证明是一个关键实现：</p>
<pre><code class="language-rust">impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt;
</code></pre>
<p>这个实现说任何实现了<code>Error</code>的类型，我们可以把它转换一个 trait 对象<code>Box&lt;Error&gt;</code>。这可能看起来并不怎么令人吃惊，不过它在泛型环境中很有用。</p>
<p>记的我们之前处理的两个错误吗？<code>io::Error</code>和<code>num::ParseIntError</code>。因为他们都实现了<code>Error</code>，他们也能用于<code>From</code>：</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs;
use std::io;
use std::num;

// We have to jump through some hoops to actually get error values.
let io_err: io::Error = io::Error::last_os_error();
let parse_err: num::ParseIntError = "not a number".parse::&lt;i32&gt;().unwrap_err();

// OK, here are the conversions.
let err1: Box&lt;Error&gt; = From::from(io_err);
let err2: Box&lt;Error&gt; = From::from(parse_err);
</code></pre>
<p>这里有一个非常重要的模式。<code>err1</code>和<code>err2</code>有着相同的类型。这是因为他们实际上是定量类型，或者 trait 对象。尤其是，对编译器来说他们的底层类型被抹掉了，所以编译器认为<code>err1</code>和<code>err2</code>是完全一样的。另外，我们用完全一样的函数调用构建<code>err1</code>和<code>err2</code>：<code>From::from</code>。这是因为<code>From::from</code>的参数和返回值都可以重载。</p>
<p>这个模式很重要，因为它解决了一个我们之前遇到过的问题：它给了我们一个可靠的用相同的函数把错误转换为相同类型的方法。</p>
<p>是时候重新看看我们的老朋友：<code>try!</code>宏了。</p>
<h3 id="真正的try宏"><a name="the-real-try-macro"></a>真正的<code>try!</code>宏</h3>
<p>之前我们展示了<code>try!</code>的定义：</p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
</code></pre>
<p>这并不是它真正的定义。它的实际定义<a href="http://doc.rust-lang.org/std/macro.try!.html">位于标准库中</a>：</p>
<p><a name="code-try-def"></a></p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(::std::convert::From::from(err)),
    });
}
</code></pre>
<p>这是一个很小但很有效的修改：错误值被通过<code>From::from</code>传递。这让<code>try!</code>宏变得更强大了一点，因为它免费提供给你自动类型转换。</p>
<p>有了更强大的<code>try!</code>宏的支持，让我们再看一眼我们之前写的读一个文件并把内容转换为数字的代码：</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}
</code></pre>
<p>之前，我们承诺我们可以去掉<code>map_err</code>调用。实际上，所有我们需要做的就是选一个可以用于<code>From</code>的类型。一如我们在上一个部分看到的，<code>From</code>有一个可以转换任意错误类型为<code>Box&lt;Error&gt;</code>的实现：</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n = try!(contents.trim().parse::&lt;i32&gt;());
    Ok(2 * n)
}
</code></pre>
<p>我们已经非常接近理想的错误处理了。我们的代码处理错误只造成了很小的成本，因为<code>try!</code>宏同时封装了三个东西：</p>
<ul>
<li>case analysis。</li>
<li>控制流。</li>
<li>错误类型转换。</li>
</ul>
<p>当结合所有这些东西，我们的代码不再受组合，<code>unwrap</code>调用或 case analysis 的困扰了。</p>
<p>这里还剩一点东西：<code>Box&lt;Error&gt;</code>是不透明的。如果我们返回一个<code>Box&lt;Error&gt;</code>给调用者，调用者并不能（轻易地）观察底层错误类型。当然这种情形比<code>String</code>要好，因为调用者可以调用像<a href="http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description"><code>description</code></a>和<a href="http://doc.rust-lang.org/std/error/trait.Error.html#method.cause"><code>cause</code></a>这样的方法，不过这是有限制的：<code>Box&lt;Error&gt;</code>是不透明的。（附注：这并不是完全正确，因为 Rust 并没有运行时反射，这在某些场景是有用的不过<a href="https://crates.io/crates/error">超出了本部分的范畴</a>。）</p>
<p>是时候重写我们的<code>CliError</code>类型并将一切连起来了。</p>
<h3 id="组合自定义错误类型"><a name="composing-custom-error-types"></a>组合自定义错误类型</h3>
<p>在这最后一部分，我们看看真正的<code>try!</code>宏以及如何通过调用<code>From::from</code>自动转换错误类型。具体的，我们把错误转换为<code>Box&lt;Error&gt;</code>，这是可以的，不过这个类型对调用者是不透明的。</p>
<p>为了修改这个问题，我们使用我们已经熟知的补救方法：一个自定义错误类型。再一次，这是读取文件内容并将其转换为数字的代码：</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}
</code></pre>
<p>注意我们仍然有<code>map_err</code>的调用。为神马？好吧，回忆<a href="#code-try-def"><code>try!</code></a>和<a href="#code-from-def"><code>From</code></a>的定义。问题是这里并没有<code>impl</code>的实现允许我们将一些像<code>io::Error</code>和<code>num::ParseIntError</code>这样的错误类型转换为我们的自定义类型<code>CliError</code>。当然，这个问题很好修改！<code>CliError</code>都是我们定义的，我们可以为其实现<code>From</code>。</p>
<pre><code class="language-rust"># #[derive(Debug)]
# enum CliError { Io(io::Error), Parse(num::ParseIntError) }
use std::io;
use std::num;

impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(err: num::ParseIntError) -&gt; CliError {
        CliError::Parse(err)
    }
}
</code></pre>
<p>所有这些实现都是告诉<code>From</code>如何从其他类型创建一个<code>CliError</code>。在我们的例子中，构造函数就像调用相应的值构造器那样简单。讲道理，这确实很简单。</p>
<p>最后我们可以重写<code>file_double</code>：</p>
<pre><code class="language-rust"># use std::io;
# use std::num;
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
# impl From&lt;io::Error&gt; for CliError {
#     fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }
# }
# impl From&lt;num::ParseIntError&gt; for CliError {
#     fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }
# }

use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n: i32 = try!(contents.trim().parse());
    Ok(2 * n)
}
</code></pre>
<p>我们做的唯一一件事就是去掉了<code>map_err</code>调用。他们不再必要因为<code>try!</code>宏对错误类型调用了<code>From::from</code>。这一切可以工作因为我们对所有可能出现的错误类型提供了<code>From</code>实现。</p>
<p>如果我们修改我们的<code>file_double</code>函数来进行一些其他操作，例如，把自付出转换为浮点，那么我们需要给我们的错误类型增加一个新变量：</p>
<pre><code class="language-rust">use std::io;
use std::num;

enum CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
</code></pre>
<p>并增加一个新的<code>From</code>实现：</p>
<pre><code class="language-rust"># enum CliError {
#     Io(::std::io::Error),
#     ParseInt(num::ParseIntError),
#     ParseFloat(num::ParseFloatError),
# }

use std::num;

impl From&lt;num::ParseFloatError&gt; for CliError {
    fn from(err: num::ParseFloatError) -&gt; CliError {
        CliError::ParseFloat(err)
    }
}
</code></pre>
<p>一切搞定！</p>
<h3 id="给库编写者的建议"><a name="advice-for-library-writers"></a>给库编写者的建议</h3>
<p>如果你的库需要报告一些自定义错误，那么你可能应该定义你自己的错误类型。由你决定是否暴露它的表示（例如<a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>）或者把它隐藏起来（例如<a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>）。不过你怎么做，相比<code>String</code>表示多少提供一些关于错误的信息通常是好的实践。不过说实话，这根据使用情况大有不同。</p>
<p>最少，你可能应该实现<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>trait。这会给你的库的用户以<a href="#the-real-try-macro">处理错误</a>的最小灵活性。实现<code>Error</code>trait 也意味着可以确保用户能够获得一个错误的字符串表示（因为它实现了<code>fmt::Debug</code>和<code>fmt::Display</code>）。</p>
<p>不仅如此，为你的错误类型提供<code>From</code>实现也是很有用的。这允许你（库作者）和你的用户<a href="#composing-custom-error-types">组合更详细的错误</a>。例如，<a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a>提供了<code>io::Error</code>和<code>byteorder::Error</code>。</p>
<p>最后，根据你的风格，你也许想要定义一个<a href="#the-result-type-alias-idiom"><code>Result</code>类型别名</a>，尤其是如果你的库定义了一个单一的错误类型。这被用在了标准库的<a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>和<a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>中。</p>
<h2 id="案例学习一个读取人口数据的程序"><a name="case-study-a-program-to-read-population-data"></a>案例学习：一个读取人口数据的程序</h2>
<p>这一部分很长，并且根据你的背景，它可能显得更加复杂。虽然有很多示例代码以及散文一样的解释，但大部分都被设计为教科书式的。那么，我们要开始点新东西了：一个案例学习。</p>
<p>为此，为此我们将要建立一个可以让你查询真实世界人口数据的命令行程序。目标是简单的：你给出一个地点接着它会告诉你人口。虽然这很简单，但仍有很多地方我们可能犯错。</p>
<p>我们将使用的数据来自<a href="https://github.com/petewarden/dstkdata">Data Science Toolkit</a>。我为这个练习准备了一些数据。你要么可以获取<a href="http://burntsushi.net/stuff/worldcitiespop.csv.gz">世界人口数据</a>（41 MB gzip 压缩，145 MB 未压缩）或者只使用<a href="http://burntsushi.net/stuff/uscitiespop.csv.gz">US 人口数据</a>（2.2 MB gzip 压缩，7.2 MB 未压缩）。</p>
<p>直到目前为止，我们的代码一直限制在 Rust 标准库之内。但是对于一个像这样的真实的任务，我们至少想要一些解析 CSV 数据，解析程序参数以及将其自动转换为 Rust 类型的东西。为此，我们将使用<a href="https://crates.io/crates/csv"><code>csv</code></a>，以及<a href="https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a>crate。</p>
<h3 id="初始化"><a name="initial-setup"></a>初始化</h3>
<p>我们不打算花很多时间在使用 Cargo 创建一个项目上，因为这在 [Cargo 部分](Getting Started 准备.html#hello-cargo)和 <a href="http://doc.crates.io/guide.html">Cargo 文档</a>中已被讲解。</p>
<p>为了从头开始，运行<code>cargo new --bin city-pop</code>并确保你的<code>Cargo.toml</code>看起来像这样：</p>
<pre><code class="language-toml">[package]
name = "city-pop"
version = "0.1.0"
authors = ["Andrew Gallant &lt;jamslam@gmail.com&gt;"]

[[bin]]
name = "city-pop"

[dependencies]
csv = "0.*"
rustc-serialize = "0.*"
getopts = "0.*"
</code></pre>
<p>你应该已经可以运行了：</p>
<pre><code class="language-bash">cargo build --release
./target/release/city-pop
# Outputs: Hello, world!
</code></pre>
<h3 id="参数解析"><a name="argument-parsing"></a>参数解析</h3>
<p>让我们搞定参数解析，我们不会涉及太多关于 Getopts 的细节，不过有<a href="http://doc.rust-lang.org/getopts/getopts/index.html">一些不错的文档</a>。简单的说就是 Getopts 生成了一个参数解析器并通过要给选项的 vector（事实是一个隐藏于一个结构体和一堆方法之下的 vector）生成了一个帮助信息。一旦解析结束，我们可以解码程序参数到一个 Rust 结构体中。从这里我们可以互获取 flag，实例，任何程序传递给我们的，以及他们都有什么参数。这是我们的程序，它有合适的<code>extern crate</code>语句以及 Getopts 的基本参数操作：</p>
<pre><code class="language-rust">extern crate getopts;
extern crate rustc_serialize;

use getopts::Options;
use std::env;

fn print_usage(program: &amp;str, opts: Options) {
    println!("{}", opts.usage(&amp;format!("Usage: {} [options] &lt;data-path&gt; &lt;city&gt;", program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Show this usage message.");

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present("h") {
        print_usage(&amp;program, opts);
        return;
    }
    let data_path = args[1].clone();
    let city = args[2].clone();

    // Do stuff with information
}
</code></pre>
<p>首先，我们获取一个传递给我们程序的 vector。接着我们我们储存第一个参数，因为我们知道那是程序名。当一切搞定，我们设置我们的参数 flag，在这里是一个简单的提示信息 flag。当我们设置了参数 flag 之后，我们使用<code>Options.parse</code>解析参数列表（从 1 开始，因为 0 是程序名）。如果这成功了，我们被解析的对象赋值给<code>matches</code>，如果失败了，我们 panic。接着，我们检查用户是否传递了帮助 flag，如果是就打印使用帮助信息。帮助信息选项是 Getopts 构建的，所以为了打印用法信息所有我们需要做的就是告诉它我们想要打印什么名字和模板。如果用户并没有传递帮助 flag，我们把相应的参数赋值给合适的变量。</p>
<h3 id="编写逻辑"><a name="writing-the-logic"></a>编写逻辑</h3>
<p>每个人写代码的方式各有不同，不过一般错误处理都是我们最后会思考的事情。这对程序整体的设计并不好，不过它对快速原型有帮助。因为 Rust 强制我们进行显示的错误处理（通过让我们调用<code>unwrap</code>），这样很容易看出我们的程序的那一部分可以造成错误。</p>
<p>在这个案例学习中，逻辑真的很简单。所有我们要做的就是解析给我们的 CSV 数据并打印出匹配的行的一个字段。让我们开始吧。（确保在你的文件开头加上<code>extern crate csv;</code>。）</p>
<pre><code class="language-rust">// This struct represents the data in each row of the CSV file.
// Type based decoding absolves us of a lot of the nitty gritty error
// handling, like parsing strings as integers or floats.
#[derive(Debug, RustcDecodable)]
struct Row {
    country: String,
    city: String,
    accent_city: String,
    region: String,

    // Not every row has data for the population, latitude or longitude!
    // So we express them as `Option` types, which admits the possibility of
    // absence. The CSV parser will fill in the correct value for us.
    population: Option&lt;u64&gt;,
    latitude: Option&lt;f64&gt;,
    longitude: Option&lt;f64&gt;,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!("{}", opts.usage(&amp;format!("Usage: {} [options] &lt;data-path&gt; &lt;city&gt;", program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Show this usage message.");

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };

    if matches.opt_present("h") {
        print_usage(&amp;program, opts);
        return;
    }

    let data_file = args[1].clone();
    let data_path = Path::new(&amp;data_file);
    let city = args[2].clone();

    let file = fs::File::open(data_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);

    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();

        if row.city == city {
            println!("{}, {}: {:?}",
                row.city, row.country,
                row.population.expect("population count"));
        }
    }
}
</code></pre>
<p>让我们概括下错误。我们可以从明显的开始：三个<code>unwrap</code>被调用的地方：</p>
<ol>
<li> <p><a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>File::open</code></a>可能返回<a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>io::Error</code></a>。</p> </li>
<li> <p><a href="http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a>一次解码一行，而且<a href="http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">解码一个记录</a>（查看<code>Iterator</code>实现的关联类型<code>Item</code>）可能产生一个<a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a>。</p> </li>
<li> <p>如果<code>row.population</code>是<code>None</code>，那么调用<code>expect</code>会 panic。</p> </li>
</ol>
<p>还有其他的吗？如果我们无法找到一个匹配的城市呢？想<code>grep</code>这样的工具会返回一个错误码，所以可能我们也应该这么做。所以我们有特定于我们的问题，IO 错误和 CSV 解析错误的逻辑错误。我们将探索两个不同方式来处理这个问题。</p>
<p>我像从<code>Box&lt;Error&gt;</code>开始。接着，我们看看如何定义有用的自定义错误类型。</p>
<h3 id="使用boxerror处理错误"><a name="error-handling-with-boxerror"></a>使用<code>Box&lt;Error&gt;</code>处理错误</h3>
<p><code>Box&lt;Error&gt;</code>的好处是它刚刚够用。你并不需要定义你自己的错误类型而且也不需要任何<code>From</code>实现。缺点是因为<code>Box&lt;Error&gt;</code>是一个 trait 对象，这意味着编译器无法再推导出底层类型。</p>
<p><a href="#the-limits-of-combinators">之前</a>我们开始了把我们函数类型从<code>T</code>变成<code>Result&lt;T, OurErrorType&gt;</code>的重构。在这个例子中，<code>OurErrorType</code>就是<code>Box&lt;Error&gt;</code>。不过<code>T</code>是什么？或者我们可以给<code>main</code>添加一个返回类型吗？</p>
<p>第二个问题的答案是不行，我们不能这么做。这意味着我们需要写一个新函数。不过<code>T</code>是什么？最简单的办法是返回一个作为<code>Vec&lt;Row&gt;</code>的匹配上的<code>Row</code>的值。（更好的代码会返回一个迭代器，不过这是一个留给读者的练习。）</p>
<p>让我们重构函数，不过保持对<code>unwrap</code>的调用。注意我们选择处理一个不存在的人口数行的方式是单纯的忽略它。</p>
<pre><code class="language-rust">struct Row {
    // unchanged
}

struct PopulationCount {
    city: String,
    country: String,
    // This is no longer an `Option` because values of this type are only
    // constructed if they have a population count.
    count: u64,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!("{}", opts.usage(&amp;format!("Usage: {} [options] &lt;data-path&gt; &lt;city&gt;", program)));
}

fn search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;str) -&gt; Vec&lt;PopulationCount&gt; {
    let mut found = vec![];
    let file = fs::File::open(file_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();
        match row.population {
            None =&gt; { } // skip it
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    found
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Show this usage message.");

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present("h") {
        print_usage(&amp;program, opts);
        return;
    }

    let data_file = args[1].clone();
    let data_path = Path::new(&amp;data_file);
    let city = args[2].clone();
    for pop in search(&amp;data_path, &amp;city) {
        println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
    }
}
</code></pre>
<p>虽然我们去掉了一个<code>expect</code>调用（它是一个比<code>unwrap</code>要好的变体），我们仍要处理任何不存在的搜索结果。</p>
<p>为了把这转化为合适的错误处理，我们需要做如下事情：</p>
<ol>
<li>把<code>search</code>的返回值类型改为<code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>.</li>
<li>使用<a href=""><code>try!</code>宏</a>这样会返回错误给调用者而不是使程序 panic。</li>
<li>处理<code>mian</code>中的错误。</li>
</ol>
<p>让我们试试：</p>
<pre><code class="language-rust">fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: P, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
    let mut found = vec![];
    let file = try!(fs::File::open(file_path));
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = try!(row);
        match row.population {
            None =&gt; { } // skip it
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(From::from("No matching cities with a population were found."))
    } else {
        Ok(found)
    }
}
</code></pre>
<p>现在我们用<code>try!(x)</code>代替了<code>x.unwrap()</code>。因为我们的函数返回一个<code>Result&lt;T, E&gt;</code>，<code>try!</code>宏在出现错误时会提早返回。</p>
<p>代码中还有另一个大的需要注意的地方：我们用了<code>Box&lt;Error + Send + Sync&gt;</code>而不是<code>Box&lt;Error&gt;</code>。这么做是因为我们可以把一个字符串转换为一个错误类型。我们需要这些额外的 bound，这样我们就可以使用<a href="http://doc.rust-lang.org/std/convert/trait.From.html">相应的<code>From</code>实现</a>了：</p>
<pre><code class="language-rust">// We are making use of this impl in the code above, since we call `From::from`
// on a `&amp;'static str`.
impl&lt;'a, 'b&gt; From&lt;&amp;'b str&gt; for Box&lt;Error + Send + Sync + 'a&gt;

// But this is also useful when you need to allocate a new string for an
// error message, usually with `format!`.
impl From&lt;String&gt; for Box&lt;Error + Send + Sync&gt;
</code></pre>
<p>因为<code>search</code>现在返回<code>Result&lt;T, E&gt;</code>，<code>main</code>应该在调用<code>search</code>时使用 case analysis：</p>
<pre><code class="language-rust">...
match search(&amp;data_file, &amp;city) {
    Ok(pops) =&gt; {
        for pop in pops {
            println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
        }
    }
    Err(err) =&gt; println!("{}", err)
}
...
</code></pre>
<p>现在你看到了我们如何正确的处理<code>Box&lt;Error&gt;</code>，让我们尝试一种使用我们自定义错误类型的不同方式。不过首先，让我们先放下错误处理并快速的添加从<code>stdin</code>读取的功能。</p>
<h3 id="从标准输入读取"><a name="reading-from-stdin"></a>从标准输入读取</h3>
<p>在我们的程序中，我们接受一个单文件输入并进行一次数据解析。这意味着我们可能需要能够接受标准输入。不过你可能也喜欢现在的格式——所以让我们同时拥有两者吧！</p>
<p>添加标准输入支持是非常简单的。我们只必需做三件事：</p>
<ol>
<li>修改程序参数，这样一个单独的参数——城市——可以被接受，同时人口数据从标准输入读取。</li>
<li>修改程序，这样一个<code>-f</code>选项可以接受文件，如果它没有从标准输入传递。</li>
<li>修改<code>search</code>函数接受一个可选的文件路径。当为<code>None</code>时，它应该知道从标准输入读取。</li>
</ol>
<p>首先，这是新的使用方法函数：</p>
<pre><code class="language-rust">fn print_usage(program: &amp;str, opts: Options) {
    println!("{}", opts.usage(&amp;format!("Usage: {} [options] &lt;city&gt;", program)));
}
</code></pre>
<p>下一部分只会变得稍微难一点：</p>
<pre><code class="language-rust">...
let mut opts = Options::new();
opts.optopt("f", "file", "Choose an input file, instead of using STDIN.", "NAME");
opts.optflag("h", "help", "Show this usage message.");
...
let file = matches.opt_str("f");
let data_file = file.as_ref().map(Path::new);

let city = if !matches.free.is_empty() {
    matches.free[0].clone()
} else {
    print_usage(&amp;program, opts);
    return;
};

for pop in search(&amp;data_file, &amp;city) {
    println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
}
...
</code></pre>
<p>在这段代码中，我们获取<code>file</code>（它的类型是<code>Option&lt;String&gt;</code>），并转换为一个<code>search</code>可用的类型，在这个例子中，是<code>&amp;Option&lt;AsRef&lt;Path&gt;&gt;</code>。为此，我们获取一个文件的引用，并执行映射<code>Path::new</code>。在这里，<code>as_ref()</code>把<code>Option&lt;String&gt;</code>转换为<code>Option&lt;&amp;str&gt;</code>，而且从这开始，我们可以对内容的<code>Option</code>执行<code>Path::new</code>，并返回新值的<code>Option</code>。当一切搞定，这就变为简单的获取<code>city</code>参数并执行<code>search</code>函数了。</p>
<p>修改<code>search</code>需要一点技巧。<code>csv</code>crate 可以用<a href="">任何实现了<code>io::Read</code>的类型</a>构建一个解析器。不过我们如何对这两个类型（注：因该是<code>Option</code>的两个值）使用相同的代码呢？事实上有多种方法可以做到。其中之一是重写<code>search</code>为接受一个满足<code>io::Read</code>的<code>R</code>类型参数的泛型。另一个办法是使用 trait 对象：</p>
<pre><code class="language-rust">fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
    let mut found = vec![];
    let input: Box&lt;io::Read&gt; = match *file_path {
        None =&gt; Box::new(io::stdin()),
        Some(ref file_path) =&gt; Box::new(try!(fs::File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    // The rest remains unchanged!
}
</code></pre>
<h3 id="用自定义类型处理错误"><a name="error-handling-with-a-custom-type"></a>用自定义类型处理错误</h3>
<p>之前，我们学习了如何<a href="#composing-custom-error-types">用自定义错误类型组合错误</a>。我们定义了一个<code>enum</code>的错误类型并实现了<code>Error</code>和<code>From</code>。</p>
<p>因为我们有三个不同的错误（IO，CSV 解析和未找到），让我们定义一个三个变体的<code>enum</code>：</p>
<pre><code class="language-rust">#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Csv(csv::Error),
    NotFound,
}
</code></pre>
<p>现在让我们实现<code>Display</code>和<code>Error</code>：</p>
<pre><code class="language-rust">impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            CliError::Io(ref err) =&gt; err.fmt(f),
            CliError::Csv(ref err) =&gt; err.fmt(f),
            CliError::NotFound =&gt; write!(f, "No matching cities with a \
                                             population were found."),
        }
    }
}

impl Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Csv(ref err) =&gt; err.description(),
            CliError::NotFound =&gt; "not found",
        }
    }
}
</code></pre>
<p>在我们可以在<code>search</code>函数中使用<code>CliError</code>之前，我们需要提供一系列的<code>From</code>实现。我们如何知晓该提供那个实现呢？好吧，我们得把<code>io::Error</code>和<code>csv::Error</code>都转换为<code>CliError</code>。他们都只是外部错误，所以目前我们只需要两个<code>From</code>实现：</p>
<pre><code class="language-rust">impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;csv::Error&gt; for CliError {
    fn from(err: csv::Error) -&gt; CliError {
        CliError::Csv(err)
    }
}
</code></pre>
<p>因为<a href="#code-try-def"><code>try!</code>的定义</a><code>From</code>的实现是很重要的。尤其是在这个例子中，如果出现错误，错误的<code>From::from</code>被调用，将被转换为我们的错误类型<code>CliError</code>。</p>
<p>当实现了<code>From</code>，我们只需要对<code>search</code>函数进行两个小的修改：返回值类型和“未找到”错误。这是全部的代码：</p>
<pre><code class="language-rust">fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {
    let mut found = vec![];
    let input: Box&lt;io::Read&gt; = match *file_path {
        None =&gt; Box::new(io::stdin()),
        Some(ref file_path) =&gt; Box::new(try!(fs::File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = try!(row);
        match row.population {
            None =&gt; { } // skip it
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(CliError::NotFound)
    } else {
        Ok(found)
    }
}
</code></pre>
<p>不再需要其他的修改。</p>
<h3 id="增加功能"><a name="adding-functionality"></a>增加功能</h3>
<p>编写泛型代码是很好的，因为泛用性是很酷的，并且之后会变得很有用。不过有时并不值得这么做。看看我们上一部分我们是怎么做的：</p>
<ol>
<li>定义了一个新的错误类型。 2.增加<code>Error</code>，<code>Display</code>和两个<code>From</code>实现。</li>
</ol>
<p>这里最大的缺点是我们的程序并没有改进多少。这里仍然有很多用<code>enum</code>代表错误的额外操作，特别是在这样短小的程序里。</p>
<p>像我们这样使用自定义错误类型的一个有用的方面是<code>main</code>函数现在可以选择不同的处理错误的方式。之前使用<code>Box&lt;Error&gt;</code>的时候并没有什么选择：只能打印信息。我们现在仍可以这么做，不过只是在我们想这么做的时候，例如，添加一个<code>--quiet</code> flag？<code>--quiet</code> flag 应该能够消除任何冗余的输出。</p>
<p>现在如果程序不能匹配一个城市，它会打印一个信息说它不能。这可能有点蠢，尤其是你想要你的程序能在 shell 脚本中使用的时候。</p>
<p>所以让我们开始增加 flag。就像之前一样，我们需要修改用法字符串，并给选项变量添加 flag。当我们写完这些，Getopts 会搞定剩下的操作：</p>
<pre><code class="language-rust">...
let mut opts = Options::new();
opts.optopt("f", "file", "Choose an input file, instead of using STDIN.", "NAME");
opts.optflag("h", "help", "Show this usage message.");
opts.optflag("q", "quiet", "Silences errors and warnings.");
...
</code></pre>
<p>现在我们只需要实现我们的“安静”功能。这要求我们修改<code>mian</code>中的 case analysis：</p>
<pre><code class="language-rust">match search(&amp;args.arg_data_path, &amp;args.arg_city) {
    Err(CliError::NotFound) if args.flag_quiet =&gt; process::exit(1),
    Err(err) =&gt; panic!("{}", err),
    Ok(pops) =&gt; for pop in pops {
        println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
    }
}
</code></pre>
<p>当然，在出现 IO 错误或者数据解析失败时我们并不想变得安静。因此，我们用 case analysis 来检查错误类型是否是<code>NotFound</code>以及<code>--quiet</code>是否被启用。如果，搜索失败了，我们仍然使用一个错误码退出（使用<code>grep</code>的传统）。</p>
<p>如果我们还在用<code>Box&lt;Error&gt;</code>，那么实现<code>--quiet</code>功能将变得很复杂。</p>
<p>我们的案例学习讲了很多东西。从这时起，你应该能够在现实生活中编写带有合适错误处理的程序和库了。</p>
<h2 id="精简版"><a name="the-short-story"></a>精简版</h2>
<p>因为这个章节很长，有一个 Rust 错误处理的快速总结是很有帮助的。有很多好的“拇指规则”。需要强调的是他们<em>并非</em>教条。这里每一个建议都可能有适当的理由予以反驳！</p>
<ul>
<li> <p>如果你在写小的事例代码这时错误处理显得负担过重，可能使用<code>unwrap</code>（<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>，<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>，或是更可取的<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>）是足够的。你的代码的客户应该知道如何正确的处理错误。（如果他们并不知道，教会他们吧！）</p> </li>
<li> <p>如果你在 hack（quick 'n' dirty）程序，不要为你使用<code>unwrap</code>而感羞愧。不过你被警告过了：如果别人踩到了坑，不要因为他们对糟糕的错误信息火冒三丈而感到惊讶！</p> </li>
<li> <p>如果你在 hack 程序并对 panic 感到羞愧，那么使用<code>String</code>或者<code>Box&lt;Error + Send + Sync&gt;</code>作为你的错误类型（选择<code>Box&lt;Error + Send + Sync&gt;</code>是因为它有<a href="http://doc.rust-lang.org/std/convert/trait.From.html">可用的<code>From</code>实现</a>）。</p> </li>
<li> <p>否则，在程序中，定义你自己的错误类型并实现合适的<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>和<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>来让<a href="http://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a>宏变得更工程化。</p> </li>
<li> <p>如果你在写一个库并且它可能产生错误，定义你自己的错误类型并实现<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> trait。如果可以的话，实现<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>来让你的库代码和调用者的代码更加容易编写。（因为 Rust 的一致性规则，调用者不能为你的错误类型实现<code>From</code>，所以你的库应该实现。）</p> </li>
<li> <p>学习定义于<a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>和<a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>中的组合。只使用他们有时可能比较累人，不过我个人发现合理的结合<code>try!</code>和组合是比较诱人的。<code>and_then</code>，<code>map</code>和<code>unwrap_or</code>是我们的最爱。</p> </li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/192/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/rust_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/192/index.html">Rust 程序设计语言（第二版 & 2018 edition）</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/108.html">KaiserY</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="rust">rust</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">105页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2020年3月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/119/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/119/index.html">给小白看的设计模式书</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">13页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/143/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/intellij_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/143/index.html">IntelliJ IDEA 简体中文专题教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/76.html">judasn</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="intellij">intellij</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">43页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 10995个">10995</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/199/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/markdown_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/199/index.html">什么是 Markdown</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/112.html">frank-lam</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="markdown">markdown</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">38页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/65/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/65/index.html">更先进的Java - Java 8指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/41.html">winterbe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 9341个">9341</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/104/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/104/index.html">Linux 内核揭密</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/63.html">ye11ow</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">83页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/55/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/55/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/55/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="5072">前言</a>
</li>
<li>
<a class="pjax" href="../../../book/55/CONTRIBUTING.html" title="贡献者" data-book-page-rel-url="CONTRIBUTING.html" data-book-page-id="5073">贡献者</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/README%20介绍.html" title="1.介绍" data-book-page-rel-url="content/README%20介绍.html" data-book-page-id="5074">1.介绍</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Getting%20Started%20准备.html" title="2.准备" data-book-page-rel-url="content/Getting%20Started%20准备.html" data-book-page-id="5075">2.准备</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Learn%20Rust%20学习%20Rust.html" title="3.学习 Rust" data-book-page-rel-url="content/Learn%20Rust%20学习%20Rust.html" data-book-page-id="5076">3.学习 Rust</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Guessing%20Game%20猜猜看.html" title="3.1.猜猜看" data-book-page-rel-url="content/Guessing%20Game%20猜猜看.html" data-book-page-id="5077">3.1.猜猜看</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Dining%20Philosophers%20哲学家就餐问题.html" title="3.2.哲学家就餐问题" data-book-page-rel-url="content/Dining%20Philosophers%20哲学家就餐问题.html" data-book-page-id="5078">3.2.哲学家就餐问题</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Rust%20Inside%20Other%20Languages%20其它语言中的%20Rust.html" title="3.3.其它语言中的 Rust" data-book-page-rel-url="content/Rust%20Inside%20Other%20Languages%20其它语言中的%20Rust.html" data-book-page-id="5079">3.3.其它语言中的 Rust</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Syntax%20and%20Semantics%20语法和语义.html" title="4.语法和语义" data-book-page-rel-url="content/Syntax%20and%20Semantics%20语法和语义.html" data-book-page-id="5080">4.语法和语义</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Variable%20Bindings%20变量绑定.html" title="4.1.变量绑定" data-book-page-rel-url="content/Variable%20Bindings%20变量绑定.html" data-book-page-id="5081">4.1.变量绑定</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Functions%20函数.html" title="4.2.函数" data-book-page-rel-url="content/Functions%20函数.html" data-book-page-id="5082">4.2.函数</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Primitive%20Types%20原生类型.html" title="4.3.原生类型" data-book-page-rel-url="content/Primitive%20Types%20原生类型.html" data-book-page-id="5083">4.3.原生类型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Comments%20注释.html" title="4.4.注释" data-book-page-rel-url="content/Comments%20注释.html" data-book-page-id="5084">4.4.注释</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/If%20If语句.html" title="4.5.If语句" data-book-page-rel-url="content/If%20If语句.html" data-book-page-id="5085">4.5.If语句</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Loops%20循环.html" title="4.6.循环" data-book-page-rel-url="content/Loops%20循环.html" data-book-page-id="5086">4.6.循环</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Ownership%20所有权.html" title="4.7.所有权" data-book-page-rel-url="content/Ownership%20所有权.html" data-book-page-id="5087">4.7.所有权</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/References%20and%20Borrowing%20引用和借用.html" title="4.8.引用和借用" data-book-page-rel-url="content/References%20and%20Borrowing%20引用和借用.html" data-book-page-id="5088">4.8.引用和借用</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Lifetimes%20生命周期.html" title="4.9.生命周期" data-book-page-rel-url="content/Lifetimes%20生命周期.html" data-book-page-id="5089">4.9.生命周期</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Mutability%20可变性.html" title="4.10.可变性" data-book-page-rel-url="content/Mutability%20可变性.html" data-book-page-id="5090">4.10.可变性</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Structs%20结构体.html" title="4.11.结构体" data-book-page-rel-url="content/Structs%20结构体.html" data-book-page-id="5091">4.11.结构体</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Enums%20枚举.html" title="4.12.枚举" data-book-page-rel-url="content/Enums%20枚举.html" data-book-page-id="5092">4.12.枚举</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Match%20匹配.html" title="4.13.匹配" data-book-page-rel-url="content/Match%20匹配.html" data-book-page-id="5093">4.13.匹配</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Patterns%20模式.html" title="4.14.模式" data-book-page-rel-url="content/Patterns%20模式.html" data-book-page-id="5094">4.14.模式</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Method%20Syntax%20方法语法.html" title="4.15.方法语法" data-book-page-rel-url="content/Method%20Syntax%20方法语法.html" data-book-page-id="5095">4.15.方法语法</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Vectors.html" title="4.16.Vectors" data-book-page-rel-url="content/Vectors.html" data-book-page-id="5096">4.16.Vectors</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Strings%20字符串.html" title="4.17.字符串" data-book-page-rel-url="content/Strings%20字符串.html" data-book-page-id="5097">4.17.字符串</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Generics%20泛型.html" title="4.18.泛型" data-book-page-rel-url="content/Generics%20泛型.html" data-book-page-id="5098">4.18.泛型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Traits.html" title="4.19.Traits" data-book-page-rel-url="content/Traits.html" data-book-page-id="5099">4.19.Traits</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Drop.html" title="4.20.Drop" data-book-page-rel-url="content/Drop.html" data-book-page-id="5100">4.20.Drop</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/if%20let.html" title="4.21.if let" data-book-page-rel-url="content/if%20let.html" data-book-page-id="5101">4.21.if let</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Trait%20Objects%20trait%20对象.html" title="4.22.trait 对象" data-book-page-rel-url="content/Trait%20Objects%20trait%20对象.html" data-book-page-id="5102">4.22.trait 对象</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Closures%20闭包.html" title="4.23.闭包" data-book-page-rel-url="content/Closures%20闭包.html" data-book-page-id="5103">4.23.闭包</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Universal%20Function%20Call%20Syntax%20通用函数调用语法.html" title="4.24.通用函数调用语法" data-book-page-rel-url="content/Universal%20Function%20Call%20Syntax%20通用函数调用语法.html" data-book-page-id="5104">4.24.通用函数调用语法</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Crates%20and%20Modules%20crate%20和模块.html" title="4.25.crate 和模块" data-book-page-rel-url="content/Crates%20and%20Modules%20crate%20和模块.html" data-book-page-id="5105">4.25.crate 和模块</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.26.`const`和`static`" disabled data-book-page-rel-url="content/`const`%20and%20`static`.html" data-book-page-id="5106">4.26.`const`和`static`</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Attributes%20属性.html" title="4.27.属性" data-book-page-rel-url="content/Attributes%20属性.html" data-book-page-id="5107">4.27.属性</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.28.`type`别名" disabled data-book-page-rel-url="content/`type`%20Aliases%20`type`别名.html" data-book-page-id="5108">4.28.`type`别名</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Casting%20Between%20Types%20类型转换.html" title="4.29.类型转换" data-book-page-rel-url="content/Casting%20Between%20Types%20类型转换.html" data-book-page-id="5109">4.29.类型转换</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Associated%20Types%20关联类型.html" title="4.30.关联类型" data-book-page-rel-url="content/Associated%20Types%20关联类型.html" data-book-page-id="5110">4.30.关联类型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Unsized%20Types%20不定长类型.html" title="4.31.不定长类型" data-book-page-rel-url="content/Unsized%20Types%20不定长类型.html" data-book-page-id="5111">4.31.不定长类型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Operators%20and%20Overloading%20运算符和重载.html" title="4.32.运算符和重载" data-book-page-rel-url="content/Operators%20and%20Overloading%20运算符和重载.html" data-book-page-id="5112">4.32.运算符和重载</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.33.`Deref`强制多态" disabled data-book-page-rel-url="content/`Deref`%20coercions%20`Deref`强制多态.html" data-book-page-id="5113">4.33.`Deref`强制多态</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Macros%20宏.html" title="4.34.宏" data-book-page-rel-url="content/Macros%20宏.html" data-book-page-id="5114">4.34.宏</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Raw%20Pointers%20裸指针.html" title="4.35.裸指针" data-book-page-rel-url="content/Raw%20Pointers%20裸指针.html" data-book-page-id="5115">4.35.裸指针</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.36.不安全代码" disabled data-book-page-rel-url="content/`unsafe`%20不安全代码.html" data-book-page-id="5116">4.36.不安全代码</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Effective%20Rust%20高效%20Rust.html" title="5.高效 Rust" data-book-page-rel-url="content/Effective%20Rust%20高效%20Rust.html" data-book-page-id="5117">5.高效 Rust</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/The%20Stack%20and%20the%20Heap%20栈和堆.html" title="5.1.栈和堆" data-book-page-rel-url="content/The%20Stack%20and%20the%20Heap%20栈和堆.html" data-book-page-id="5118">5.1.栈和堆</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Testing%20测试.html" title="5.2.测试" data-book-page-rel-url="content/Testing%20测试.html" data-book-page-id="5119">5.2.测试</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Conditional%20Compilation%20条件编译.html" title="5.3.条件编译" data-book-page-rel-url="content/Conditional%20Compilation%20条件编译.html" data-book-page-id="5120">5.3.条件编译</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Documentation%20文档.html" title="5.4.文档" data-book-page-rel-url="content/Documentation%20文档.html" data-book-page-id="5121">5.4.文档</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Iterators%20迭代器.html" title="5.5.迭代器" data-book-page-rel-url="content/Iterators%20迭代器.html" data-book-page-id="5122">5.5.迭代器</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Concurrency%20并发.html" title="5.6.并发" data-book-page-rel-url="content/Concurrency%20并发.html" data-book-page-id="5123">5.6.并发</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Error%20Handling%20错误处理.html" title="5.7.错误处理" data-book-page-rel-url="content/Error%20Handling%20错误处理.html" data-book-page-id="5124">5.7.错误处理</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Choosing%20your%20Guarantees%20选择你的保证.html" title="5.8.选择你的保证" data-book-page-rel-url="content/Choosing%20your%20Guarantees%20选择你的保证.html" data-book-page-id="5125">5.8.选择你的保证</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Foreign%20Function%20Interface%20外部函数接口.html" title="5.9.外部函数接口" data-book-page-rel-url="content/Foreign%20Function%20Interface%20外部函数接口.html" data-book-page-id="5126">5.9.外部函数接口</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Borrow%20and%20AsRef%20Borrow%20和%20AsRef.html" title="5.10.Borrow 和 AsRef" data-book-page-rel-url="content/Borrow%20and%20AsRef%20Borrow%20和%20AsRef.html" data-book-page-id="5127">5.10.Borrow 和 AsRef</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Release%20Channels%20发布途径.html" title="5.11.发布途径" data-book-page-rel-url="content/Release%20Channels%20发布途径.html" data-book-page-id="5128">5.11.发布途径</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Nightly%20Rust%20Rust%20开发版.html" title="6.Rust 开发版" data-book-page-rel-url="content/Nightly%20Rust%20Rust%20开发版.html" data-book-page-id="5130">6.Rust 开发版</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Compiler%20Plugins%20编译器插件.html" title="6.1.编译器插件" data-book-page-rel-url="content/Compiler%20Plugins%20编译器插件.html" data-book-page-id="5131">6.1.编译器插件</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Inline%20Assembly%20内联汇编.html" title="6.2.内联汇编" data-book-page-rel-url="content/Inline%20Assembly%20内联汇编.html" data-book-page-id="5132">6.2.内联汇编</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/No%20stdlib%20不使用标准库.html" title="6.3.不使用标准库" data-book-page-rel-url="content/No%20stdlib%20不使用标准库.html" data-book-page-id="5129">6.3.不使用标准库</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Intrinsics%20固有功能.html" title="6.4.固有功能" data-book-page-rel-url="content/Intrinsics%20固有功能.html" data-book-page-id="5133">6.4.固有功能</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Lang%20items%20语言项.html" title="6.5.语言项" data-book-page-rel-url="content/Lang%20items%20语言项.html" data-book-page-id="5134">6.5.语言项</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Advanced%20Linking%20链接进阶.html" title="6.6.链接进阶" data-book-page-rel-url="content/Advanced%20Linking%20链接进阶.html" data-book-page-id="5135">6.6.链接进阶</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Benchmark%20tests%20基准测试.html" title="6.7.基准测试" data-book-page-rel-url="content/Benchmark%20tests%20基准测试.html" data-book-page-id="5136">6.7.基准测试</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Box%20Syntax%20and%20Patterns%20装箱语法和模式.html" title="6.8.装箱语法和模式" data-book-page-rel-url="content/Box%20Syntax%20and%20Patterns%20装箱语法和模式.html" data-book-page-id="5137">6.8.装箱语法和模式</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Slice%20patterns%20切片模式.html" title="6.9.切片模式" data-book-page-rel-url="content/Slice%20patterns%20切片模式.html" data-book-page-id="5138">6.9.切片模式</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Associated%20Constants%20关联常量.html" title="6.10.关联常量" data-book-page-rel-url="content/Associated%20Constants%20关联常量.html" data-book-page-id="5139">6.10.关联常量</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Custom%20Allocators%20自定义内存分配器.html" title="6.11.自定义内存分配器" data-book-page-rel-url="content/Custom%20Allocators%20自定义内存分配器.html" data-book-page-id="5140">6.11.自定义内存分配器</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Glossary%20词汇表.html" title="7.词汇表" data-book-page-rel-url="content/Glossary%20词汇表.html" data-book-page-id="5141">7.词汇表</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Syntax%20Index%20语法索引.html" title="8.语法索引" data-book-page-rel-url="content/Syntax%20Index%20语法索引.html" data-book-page-id="5142">8.语法索引</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Bibliography%20参考文献.html" title="9.参考文献" data-book-page-rel-url="content/Bibliography%20参考文献.html" data-book-page-id="5143">9.参考文献</a>
</li>
<li>
<a class="pjax" href="../../../book/55/名词中英文对照.html" title="附录：名词中英文对照" data-book-page-rel-url="名词中英文对照.html" data-book-page-id="5144">附录：名词中英文对照</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =55;var bookPageId =5124;var bookPageRelUrl ='content/Error%20Handling%20错误处理.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>