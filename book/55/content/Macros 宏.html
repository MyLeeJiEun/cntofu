
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>4.34.宏-Rust 程序设计语言 中文版</title>
<meta content='4.34.宏,Rust 程序设计语言 中文版' name='keywords'>
<meta content='4.34.宏,Rust 程序设计语言 中文版' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/55/content/Operators%20and%20Overloading%20运算符和重载.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">4.32.运算符和重载</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/55/content/Raw%20Pointers%20裸指针.html">
<span class="">4.35.裸指针</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/55/index.html">Rust 程序设计语言 中文版</a>
<a target="_blank" rel="nofollow" href="https://github.com/hltj/rust-book-chinese" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="宏">宏</h1>
<blockquote>
<p><a href="https://github.com/rust-lang/rust/blob/master/src/doc/book/macros.html">macros.html</a> <br> commit 7fd7b5b7fc628b3cd19c56daf84dbe9b2b9db1c0</p>
</blockquote>
<p>到目前为止你已经学到了不少Rust提供的抽象和重用代码的工具了。这些代码重用单元有丰富的语义结构。例如，函数有类型签名，类型参数有特性限制并且能重载的函数必须属于一个特定的特性。</p>
<p>这些结构意味着Rust核心抽象拥有强大的编译时正确性检查。不过作为代价的是灵活性的减少。如果你识别出一个重复代码的模式，你会发现把它们解释为泛型函数，特性或者任何Rust语义中的其它结构很难或者很麻烦。</p>
<p>宏允许我们在<em>句法</em>水平上进行抽象。宏是一个“展开后的”句法形式的速记。这个展开发生在编译的早期，在任何静态检查之前。因此，宏可以实现很多Rust核心抽象不能做到的代码重用模式。</p>
<p>缺点是基于宏的代码更难懂，因为它很少利用Rust的内建规则。就像常规函数，一个良好的宏可以在不知道其实现的情况下使用。然而，设计一个良好的宏困难的！另外，在宏中的编译错误更难解释，因为它在展开后的代码上描述问题，不是在开发者使用的代码级别。</p>
<p>这些缺点让宏成了所谓“最后求助于的功能”。这并不是说宏的坏话；只是因为它是Rust中需要真正简明，良好抽象的代码的部分。切记权衡取舍。</p>
<h2 id="定义一个宏">定义一个宏</h2>
<p>你可能见过<code>vec!</code>宏。用来初始化一个任意数量元素的<a href="Vectors.html">vector</a>。</p>
<pre><code class="language-rust">let x: Vec&lt;u32&gt; = vec![1, 2, 3];
# assert_eq!(x, [1, 2, 3]);
</code></pre>
<p>这不可能是一个常规函数，因为它可以接受任何数量的参数。不过我们可以想象的到它是这些代码的句法简写：</p>
<pre><code class="language-rust">let x: Vec&lt;u32&gt; = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
# assert_eq!(x, [1, 2, 3]);
</code></pre>
<p>我们可以使用宏来实现这么一个简写：<sup id="fnref-1"><a class="footnote-ref" href="#fn-1">1</a></p>
<pre><code class="language-rust">macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
# fn main() {
#     assert_eq!(vec![1,2,3], [1, 2, 3]);
# }
</code></pre>
<p>哇哦，这里有好多新语法！让我们分开来看。</p>
<pre><code class="language-rust">macro_rules! vec { ... }
</code></pre>
<p>这里我们定义了一个叫做<code>vec</code>的宏，跟用<code>fn vec</code>定义一个<code>vec</code>函数很相似。再罗嗦一句，我们通常写宏的名字时带上一个感叹号，例如<code>vec!</code>。感叹号是调用语法的一部分用来区别宏和常规函数。</p>
<h2 id="匹配">匹配</h2>
<p>宏通过一系列<em>规则</em>定义，它们是模式匹配的分支。上面我们有：</p>
<pre><code class="language-rust">( $( $x:expr ),* ) =&gt; { ... };
</code></pre>
<p>这就像一个<code>match</code>表达式分支，不过匹配发生在编译时Rust的语法树中。最后一个分支（这里只有一个分支）的分号是可选的。<code>=&gt;</code>左侧的“模式”叫<em>匹配器</em>（<em>matcher</em>）。它有<a href="http://doc.rust-lang.org/reference.html#macros">自己的语法</a>。</p>
<p><code>$x:expr</code>匹配器将会匹配任何Rust表达式，把它的语法树绑定到元变量<code>$x</code>上。<code>expr</code>标识符是一个<em>片段分类符</em>（<em>fragment specifier</em>）。在<a href="http://doc.rust-lang.org/book/advanced-macros.html">宏进阶章节</a>（已被本章合并，坐等官方文档更新）中列举了所有可能的分类符。匹配器写在<code>$(...)</code>中，<code>*</code>会匹配0个或多个表达式，表达式之间用逗号分隔。</p>
<p>除了特殊的匹配器语法，任何出现在匹配器中的Rust标记必须完全相符。例如：</p>
<pre><code class="language-rust">macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!("mode X: {}", $e));
    (y =&gt; $e:expr) =&gt; (println!("mode Y: {}", $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</code></pre>
<p>将会打印：</p>
<pre><code class="language-text">mode Y: 3
</code></pre>
<p>而这个：</p>
<pre><code class="language-rust">foo!(z =&gt; 3);
</code></pre>
<p>我们会得到编译错误：</p>
<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>
<h2 id="展开">展开</h2>
<p>宏规则的右边是正常的Rust语法，大部分是。不过我们可以拼接一些匹配器中的语法。例如最开始的例子：</p>
<pre><code class="language-rust">$(
    temp_vec.push($x);
)*
</code></pre>
<p>每个匹配的<code>$x</code>表达式都会在宏展开中产生一个单独<code>push</code>语句。展开中的重复与匹配器中的重复“同步”进行（稍后介绍更多）。</p>
<p>因为<code>$x</code>已经在表达式匹配中声明了，我们并不在右侧重复<code>:expr</code>。另外，我们并不将用来分隔的逗号作为重复操作的一部分。相反，我们在重复块中使用一个结束用的分号。</p>
<p>另一个细节：<code>vec!</code>宏的右侧有<em>两对</em>大括号。它们经常像这样结合起来：</p>
<pre><code class="language-rust">macro_rules! foo {
    () =&gt; {{
        ...
    }}
}
</code></pre>
<p>外层的大括号是<code>macro_rules!</code>语法的一部分。事实上，你也可以<code>()</code>或者<code>[]</code>。它们只是用来界定整个右侧结构的。</p>
<p>内层大括号是展开语法的一部分。记住，<code>vec!</code>在表达式上下文中使用。要写一个包含多个语句，包括<code>let</code>绑定，的表达式，我们需要使用块。如果你的宏只展开一个单独的表达式，你不需要内层的大括号。</p>
<p>注意我们从未<em>声明</em>宏产生一个表达式。事实上，直到宏被展开之前我们都无法知道。足够小心的话，你可以编写一个能在多个上下文中展开的宏。例如，一个数据类型的简写可以作为一个表达式或一个模式。</p>
<h2 id="重复repetition">重复（Repetition）</h2>
<p>重复运算符遵循两个原则：</p>
<ol>
<li><code>$(...)*</code>对它包含的所有<code>$name</code>都执行“一层”重复</li>
<li>每个<code>$name</code>必须有至少这么多的<code>$(...)*</code>与其相对。如果多了，它将是多余的。</li>
</ol>
<p>这个巴洛克宏展示了外层重复中多余的变量。</p>
<pre><code class="language-rust">macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</code></pre>
<p>这就是匹配器的大部分语法。这些例子使用了<code>$(...)*</code>，它指“0次或多次”匹配。另外你可以用<code>$(...)+</code>代表“1次或多次”匹配。每种形式都可以包括一个分隔符，分隔符可以使用任何除了<code>+</code>和<code>*</code>的符号。</p>
<p>这个系统基于<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>（PDF链接）。</p>
<h2 id="卫生hygiene">卫生（Hygiene）</h2>
<p>一些语言使用简单的文本替换来实现宏，它导致了很多问题。例如，这个C程序打印<code>13</code>而不是期望的<code>25</code>。</p>
<pre><code class="language-c">#define FIVE_TIMES(x) 5 * x

int main() {
    printf("%d\n", FIVE_TIMES(2 + 3));
    return 0;
}
</code></pre>
<p>展开之后我们得到<code>5 * 2 + 3</code>，并且乘法比加法有更高的优先级。如果你经常使用C的宏，你可能知道标准的习惯来避免这个问题，或更多其它的问题。在Rust中，你不需要担心这个问题。</p>
<pre><code class="language-rust">macro_rules! five_times {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
</code></pre>
<p>元变量<code>$x</code>被解析成一个单独的表达式节点，并且在替换后依旧在语法树中保持原值。</p>
<p>宏系统中另一个常见的问题是<em>变量捕捉</em>（<em>variable capture</em>）。这里有一个C的宏，使用了<a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">GNU C 扩展</a>来模拟Rust表达式块。</p>
<pre><code class="language-c">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf("log(%d): %s\n", state, msg); \
    } \
})
</code></pre>
<p>这是一个非常糟糕的用例：</p>
<pre><code class="language-c">const char *state = "reticulating splines";
LOG(state)
</code></pre>
<p>它展开为：</p>
<pre><code class="language-c">const char *state = "reticulating splines";
{
    int state = get_log_state();
    if (state &gt; 0) {
        printf("log(%d): %s\n", state, state);
    }
}
</code></pre>
<p>第二个叫做<code>state</code>的参数参数被替换为了第一个。当打印语句需要用到这两个参数时会出现问题。</p>
<p>等价的Rust宏则会有理想的表现：</p>
<pre><code class="language-rust"># fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!("log({}): {}", state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = "reticulating splines";
    log!(state);
}
</code></pre>
<p>这之所以能工作时因为Rust有一个<a href="http://en.wikipedia.org/wiki/Hygienic_macro">卫生宏系统</a>。每个宏展开都在一个不同的<em>语法上下文</em>（<em>syntax context</em>）中，并且每个变量在引入的时候都在语法上下文中打了标记。这就好像是<code>main</code>中的<code>state</code>和宏中的<code>state</code>被画成了不同的“颜色”，所以它们不会冲突。</p>
<p>这也限制了宏在被执行时引入新绑定的能力。像这样的代码是不能工作的：</p>
<pre><code class="language-rust">macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!("{}", x);
}
</code></pre>
<p>相反你需要在执行时传递变量的名字，这样它会在语法上下文中被正确标记。</p>
<pre><code class="language-rust">macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!("{}", x);
}
</code></pre>
<p>这对<code>let</code>绑定和loop标记有效，对<a href="http://doc.rust-lang.org/reference.html#items">items</a>无效。所以下面的代码可以编译：</p>
<pre><code class="language-rust">macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</code></pre>
<h2 id="递归宏">递归宏</h2>
<p>一个宏展开中可以包含更多的宏，包括被展开的宏自身。这种宏对处理树形结构输入时很有用的，正如这这个（简化了的）HTML简写所展示的那样：</p>
<pre><code class="language-rust"># #![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, "{}", $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, "&lt;{}&gt;", stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, "&lt;/{}&gt;", stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
#   // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title["Macros guide"]]
            body[h1["Macros are the best!"]]
        ]);

    assert_eq!(out,
        "&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;");
}
</code></pre>
<h2 id="调试宏代码">调试宏代码</h2>
<p>运行<code>rustc --pretty expanded</code>来查看宏展开后的结果。输出表现为一个完整的包装箱，所以你可以把它反馈给<code>rustc</code>，它会有时会比原版产生更好的错误信息。注意如果在同一作用域中有多个相同名字（不过在不同的语法上下文中）的变量的话<code>--pretty expanded</code>的输出可能会有不同的意义。这种情况下<code>--pretty expanded,hygiene</code>将会告诉你有关语法上下文的信息。</p>
<p><code>rustc</code>提供两种语法扩展来帮助调试宏。目前为止，它们是不稳定的并且需要功能入口（feature gates）。</p>
<ul>
<li><code>log_syntax!(...)</code>会打印它的参数到标准输出，在编译时，并且不“展开”任何东西。</li>
<li><code>trace_macros!(true)</code>每当一个宏被展开时会启用一个编译器信息。在展开后使用<code>trace_macros!(false)</code>来关闭它。</li>
</ul>
<h2 id="句法要求">句法要求</h2>
<p>即使Rust代码中含有未展开的宏，它也可以被解析为一个完整的[语法树](7.Glossary 词汇表.html#abstract-syntax-tree)。这个属性对于编辑器或其它处理代码的工具来说十分有用。这里也有一些关于Rust宏系统设计的推论。</p>
<p>一个推论是Rust必须确定，当它解析一个宏展开时，宏是否代替了</p>
<ul>
<li>0个或多个项</li>
<li>0个或多个方法</li>
<li>一个表达式</li>
<li>一个语句</li>
<li>一个模式</li>
</ul>
<p>一个块中的宏展开代表一些项，或者一个表达式/语句。Rust使用一个简单的规则来解决这些二义性。一个代表项的宏展开必须是</p>
<ul>
<li>用大括号界定的，例如<code>foo! { ... }</code></li>
<li>分号结尾的，例如<code>foo!(...);</code></li>
</ul>
<p>另一个展开前解析的推论是宏展开必须包含有效的Rust记号。更进一步，括号，中括号，大括号在宏展开中必须是封闭的。例如，<code>foo!([)</code>是不允许的。这让Rust知道宏何时结束。</p>
<p>更正式一点，宏展开体必须是一个<em>记号树</em>（<em>token trees</em>）的序列。一个记号树是一系列递归的</p>
<ul>
<li>一个由<code>()</code>，<code>[]</code>或<code>{}</code>包围的记号树序列</li>
<li>任何其它单个记号</li>
</ul>
<p>在一个匹配器中，每一个元变量都有一个<em>片段分类符</em>（<em>fragment specifier</em>），确定它匹配的哪种句法。</p>
<ul>
<li><code>ident</code>：一个标识符。例如：<code>x</code>，<code>foo</code></li>
<li><code>path</code>：一个受限的名字。例如：<code>T::SpecialA</code></li>
<li><code>expr</code>：一个表达式。例如：<code>2 + 2</code>；<code>if true then { 1 } else { 2 }</code>；<code>f(42)</code></li>
<li><code>ty</code>：一个类型。例如：<code>i32</code>；<code>Vec&lt;(char, String)&gt;</code>；<code>&amp;T</code></li>
<li><code>pat</code>：一个模式。例如：<code>Some(t)</code>；<code>(17, 'a')</code>；<code>_</code></li>
<li><code>stmt</code>：一个单独语句。例如：<code>let x = 3</code></li>
<li><code>block</code>：一个大括号界定的语句序列。例如：<code>{ log(error, "hi"); return 12; }</code></li>
<li><code>item</code>：一个<a href="http://doc.rust-lang.org/stable/reference.html#items">项</a>。例如：<code>fn foo() { }</code>，<code>struct Bar</code></li>
<li><code>meta</code>：一个“元数据项”，可以在属性中找到。例如：<code>cfg(target_os = "windows")</code></li>
<li><code>tt</code>：一个单独的记号树</li>
</ul>
<p>对于一个元变量（metavariable）后面的一个记号有一些额外的规则：</p>
<ul>
<li><code>expr</code>和<code>stmt</code>变量必须后跟任意一个：<code>=&gt; , ;</code></li>
<li><code>ty</code>和<code>path</code>变量必须后跟任意一个：<code>=&gt; , = | ; : &gt; [ { as where</code></li>
<li><code>pat</code>变量必须后跟任意一个：<code>=&gt; , = | if in</code></li>
<li>其它变量可以后跟任何记号</li>
</ul>
<p>这些规则为 Rust 语法提供了一些灵活性以便将来的展开不会破坏现有的宏。</p>
<p>宏系统完全不处理解析模糊。例如，<code>$($t:ty)* $e:expr</code>语法总是会解析失败，因为解析器会被强制在解析<code>$t</code>和解析<code>$e</code>之间做出选择。改变展开在它们之前分别加上一个记号可以解决这个问题。在这个例子中，你可以写成<code>$(T $t:ty)* E $e:exp</code>。</p>
<h2 id="范围和宏导入导出">范围和宏导入/导出</h2>
<p>宏在编译的早期阶段被展开，在命名解析之前。这有一个缺点是与语言中其它结构相比，范围对宏的作用不一样。</p>
<p>定义和展开都发生在同一个深度优先、字典顺序的包装箱的代码遍历中。那么在模块范围内定义的宏对同模块的接下来的代码是可见的，这包括任何接下来的子<code>mod</code>项。</p>
<p>一个定义在<code>fn</code>函数体内的宏，或者任何其它不在模块范围内的地方，只在它的范围内可见。</p>
<p>如果一个模块有<code>macro_use</code>属性，它的宏在子<code>mod</code>项之后的父模块也是可见的。如果它的父模块也有<code>macro_use</code>属性那么在父<code>mod</code>项之后的祖父模块中也是可见的，以此类推。</p>
<p><code>macro_use</code>属性也可以出现在<code>extern crate</code>处。在这个上下文中它控制那些宏从外部包装箱中装载，例如</p>
<pre><code class="language-rust">#[macro_use(foo, bar)]
extern crate baz;
</code></pre>
<p>如果属性只是简单的写成<code>#[macro_use]</code>，所有的宏都会被装载。如果没有<code>#[macro_use]</code>属性那么没有宏被装载。只有被定义为<code>#[macro_export]</code>的宏可能被装载。</p>
<p>装载一个包装箱的宏<em>而不</em>链接到输出，使用<code>#[no_link]</code>。</p>
<p>一个例子：</p>
<pre><code class="language-rust">macro_rules! m1 { () =&gt; (()) }

// visible here: m1

mod foo {
    // visible here: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // visible here: m1, m2
}

// visible here: m1

macro_rules! m3 { () =&gt; (()) }

// visible here: m1, m3

#[macro_use]
mod bar {
    // visible here: m1, m3

    macro_rules! m4 { () =&gt; (()) }

    // visible here: m1, m3, m4
}

// visible here: m1, m3, m4
# fn main() { }
</code></pre>
<p>当这个库被用<code>#[macro_use] extern crate</code>装载时，只有<code>m2</code>会被导入。</p>
<p>Rust参考中有一个<a href="http://doc.rust-lang.org/stable/reference.html#macro-related-attributes">宏相关的属性列表</a>。</p>
<h2 id="crate变量"><code>$crate</code>变量</h2>
<p>当一个宏在多个包装箱中使用时会产生另一个困难。来看<code>mylib</code>定义了</p>
<pre><code class="language-rust">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mylib::increment($x) )
}
# fn main() { }
</code></pre>
<p><code>inc_a</code>只能在<code>mylib</code>内工作，同时<code>inc_b</code>只能在库外工作。进一步说，如果用户有另一个名字导入<code>mylib</code>时<code>inc_b</code>将不能工作。</p>
<p>Rust（目前）还没有针对包装箱引用的卫生系统，不过它确实提供了一个解决这个问题的变通方法。当从一个叫<code>foo</code>的包装箱总导入宏时，特殊宏变量<code>$crate</code>会展开为<code>::foo</code>。相反，当这个宏在同一包装箱内定义和使用时，<code>$crate</code>将展开为空。这意味着我们可以写</p>
<pre><code class="language-rust">#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
# fn main() { }
</code></pre>
<p>来定义一个可以在库内外都能用的宏。这个函数名字会展开为<code>::increment</code>或<code>::mylib::increment</code>。</p>
<p>为了保证这个系统简单和正确，<code>#[macro_use] extern crate ...</code>应只出现在你包装箱的根中，而不是在<code>mod</code>中。这保证了<code>$crate</code>展开为一个单独的标识符。</p>
<h2 id="深入the-deep-end">深入（The deep end）</h2>
<p>之前的介绍章节提到了递归宏，但并没有给出完整的介绍。还有一个原因令递归宏是有用的：每一次递归都给你匹配宏参数的机会。</p>
<p>作为一个极端的例子，可以，但极端不推荐，用Rust宏系统来实现一个<a href="http://esolangs.org/wiki/Bitwise_Cyclic_Tag">位循环标记</a>自动机。 <a name="1"></a></p>
<pre><code class="language-rust">macro_rules! bct {
    // cmd 0:  d ... =&gt; ...
    (0, $($ps:tt),* ; $_d:tt)
        =&gt; (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 0 ; $($ds),*));

    // cmd 1p:  1 ... =&gt; 1 ... p
    (1, $p:tt, $($ps:tt),* ; 1)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

    // cmd 1p:  0 ... =&gt; 0 ...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));

    // halt on empty data string
    ( $($ps:tt),* ; )
        =&gt; (());
}
</code></pre>
<p>练习：使用宏来减少上面<code>bct!</code>宏定义中的重复。</p>
<h2 id="常用宏common-macros">常用宏（Common macros）</h2>
<p>这里有一些你会在Rust代码中看到的常用宏。</p>
<h3 id="panic"><code>panic!</code></h3>
<p>这个宏导致当前线程恐慌。你可以传给这个宏一个信息通过：</p>
<pre><code class="language-rust">panic!("oh no!");
</code></pre>
<h3 id="vec"><code>vec!</code></h3>
<p><code>vec!</code>的应用遍及本书，所以你可能已经见过它了。它方便创建<code>Vec&lt;T&gt;</code>：</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5];
</code></pre>
<p>它也让你可以用重复值创建vector。例如，100个<code>0</code>：</p>
<pre><code class="language-rust">let v = vec![0; 100];
</code></pre>
<h3 id="assert和assert-eq"><code>assert!</code>和<code>assert_eq!</code></h3>
<p>这两个宏用在测试中。<code>assert!</code>获取一个布尔值，而<code>assert_eq!</code>获取两个值并比较它们。<code>true</code> 就通过，<code>false</code>就<code>panic!</code>。像这样：</p>
<pre><code class="language-rust">// A-ok!

assert!(true);
assert_eq!(5, 3 + 2);

// nope :(

assert!(5 &lt; 3);
assert_eq!(5, 3);
</code></pre>
<h3 id="try"><code>try!</code></h3>
<p><code>try!</code>用来进行错误处理。它获取一些可以返回<code>Result&lt;T, E&gt;</code>的数据，并返回<code>T</code>如果它是<code>Ok&lt;T&gt;</code>，或<code>return</code>一个<code>Err(E)</code>如果出错了。像这样：</p>
<pre><code class="language-rust">use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = try!(File::create("foo.txt"));

    Ok(())
}
</code></pre>
<p>它比这么写要更简明：</p>
<pre><code class="language-rust">use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = File::create("foo.txt");

    let f = match f {
        Ok(t) =&gt; t,
        Err(e) =&gt; return Err(e),
    };

    Ok(())
}
</code></pre>
<h3 id="unreachable"><code>unreachable!</code></h3>
<p>这个宏用于当你认为一些代码不应该被执行的时候：</p>
<pre><code class="language-rust">if false {
    unreachable!();
}
</code></pre>
<p>有时，编译器可能会让你编写一个你认为将永远不会执行的不同分支。在这个例子中，用这个宏，这样如果最终你错了，你会为此得到一个<code>panic!</code>。</p>
<pre><code class="language-rust">let x: Option&lt;i32&gt; = None;

match x {
    Some(_) =&gt; unreachable!(),
    None =&gt; println!("I know x is None!"),
}
</code></pre>
<h3 id="unimplemented"><code>unimplemented!</code></h3>
<p><code>unimplemented!</code>宏可以被用来当你尝试去让你的函数通过类型检查，同时你又不想操心去写函数体的时候。一个这种情况的例子是实现一个要求多个方法的特性，而你只想一次搞定一个。用<code>unimplemented!</code>定义其它的直到你准备好去写它们了。</p>
<h2 id="宏程序procedural-macros">宏程序（Procedural macros）</h2>
<p>如果Rust宏系统不能做你想要的，你可能想要写一个[编译器插件](Compiler Plugins 编译器插件.html)。与<code>macro_rules!</code>宏相比，它能做更多的事，接口也更不稳定，并且bug将更难以追踪。相反你得到了可以在编译器中运行任意Rust代码的灵活性。为此语法扩展插件有时被称为<em>宏程序</em>（<em>procedural macros</em>）。</p>
<hr>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1"> <p><code>vec!</code>在 libcollections 中的实际定义跟这里的表现并不相同，出于效率和复用的考虑。</p> <a href="#fnref-1" class="footnote-backref">↩</a> </li>
</ol>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/192/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/rust_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/192/index.html">Rust 程序设计语言（第二版 & 2018 edition）</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/108.html">KaiserY</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="rust">rust</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">105页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2020年3月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/204/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/204/index.html">系统重构与迁移指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">183页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/147/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/147/index.html">JSON风格指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/79.html">darcyliu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1139个">1139</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/203/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/203/index.html">Java Web 入门开发教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/115.html">skyline75489</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">22页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 647个">647</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/23/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/cplusplus_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/23/index.html">数据结构思维</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="cplusplus">cplusplus</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 286个">286</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/110/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/react_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/110/index.html">React 学习之道</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="react">react</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">11页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/55/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/55/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/55/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="5072">前言</a>
</li>
<li>
<a class="pjax" href="../../../book/55/CONTRIBUTING.html" title="贡献者" data-book-page-rel-url="CONTRIBUTING.html" data-book-page-id="5073">贡献者</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/README%20介绍.html" title="1.介绍" data-book-page-rel-url="content/README%20介绍.html" data-book-page-id="5074">1.介绍</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Getting%20Started%20准备.html" title="2.准备" data-book-page-rel-url="content/Getting%20Started%20准备.html" data-book-page-id="5075">2.准备</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Learn%20Rust%20学习%20Rust.html" title="3.学习 Rust" data-book-page-rel-url="content/Learn%20Rust%20学习%20Rust.html" data-book-page-id="5076">3.学习 Rust</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Guessing%20Game%20猜猜看.html" title="3.1.猜猜看" data-book-page-rel-url="content/Guessing%20Game%20猜猜看.html" data-book-page-id="5077">3.1.猜猜看</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Dining%20Philosophers%20哲学家就餐问题.html" title="3.2.哲学家就餐问题" data-book-page-rel-url="content/Dining%20Philosophers%20哲学家就餐问题.html" data-book-page-id="5078">3.2.哲学家就餐问题</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Rust%20Inside%20Other%20Languages%20其它语言中的%20Rust.html" title="3.3.其它语言中的 Rust" data-book-page-rel-url="content/Rust%20Inside%20Other%20Languages%20其它语言中的%20Rust.html" data-book-page-id="5079">3.3.其它语言中的 Rust</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Syntax%20and%20Semantics%20语法和语义.html" title="4.语法和语义" data-book-page-rel-url="content/Syntax%20and%20Semantics%20语法和语义.html" data-book-page-id="5080">4.语法和语义</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Variable%20Bindings%20变量绑定.html" title="4.1.变量绑定" data-book-page-rel-url="content/Variable%20Bindings%20变量绑定.html" data-book-page-id="5081">4.1.变量绑定</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Functions%20函数.html" title="4.2.函数" data-book-page-rel-url="content/Functions%20函数.html" data-book-page-id="5082">4.2.函数</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Primitive%20Types%20原生类型.html" title="4.3.原生类型" data-book-page-rel-url="content/Primitive%20Types%20原生类型.html" data-book-page-id="5083">4.3.原生类型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Comments%20注释.html" title="4.4.注释" data-book-page-rel-url="content/Comments%20注释.html" data-book-page-id="5084">4.4.注释</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/If%20If语句.html" title="4.5.If语句" data-book-page-rel-url="content/If%20If语句.html" data-book-page-id="5085">4.5.If语句</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Loops%20循环.html" title="4.6.循环" data-book-page-rel-url="content/Loops%20循环.html" data-book-page-id="5086">4.6.循环</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Ownership%20所有权.html" title="4.7.所有权" data-book-page-rel-url="content/Ownership%20所有权.html" data-book-page-id="5087">4.7.所有权</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/References%20and%20Borrowing%20引用和借用.html" title="4.8.引用和借用" data-book-page-rel-url="content/References%20and%20Borrowing%20引用和借用.html" data-book-page-id="5088">4.8.引用和借用</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Lifetimes%20生命周期.html" title="4.9.生命周期" data-book-page-rel-url="content/Lifetimes%20生命周期.html" data-book-page-id="5089">4.9.生命周期</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Mutability%20可变性.html" title="4.10.可变性" data-book-page-rel-url="content/Mutability%20可变性.html" data-book-page-id="5090">4.10.可变性</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Structs%20结构体.html" title="4.11.结构体" data-book-page-rel-url="content/Structs%20结构体.html" data-book-page-id="5091">4.11.结构体</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Enums%20枚举.html" title="4.12.枚举" data-book-page-rel-url="content/Enums%20枚举.html" data-book-page-id="5092">4.12.枚举</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Match%20匹配.html" title="4.13.匹配" data-book-page-rel-url="content/Match%20匹配.html" data-book-page-id="5093">4.13.匹配</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Patterns%20模式.html" title="4.14.模式" data-book-page-rel-url="content/Patterns%20模式.html" data-book-page-id="5094">4.14.模式</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Method%20Syntax%20方法语法.html" title="4.15.方法语法" data-book-page-rel-url="content/Method%20Syntax%20方法语法.html" data-book-page-id="5095">4.15.方法语法</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Vectors.html" title="4.16.Vectors" data-book-page-rel-url="content/Vectors.html" data-book-page-id="5096">4.16.Vectors</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Strings%20字符串.html" title="4.17.字符串" data-book-page-rel-url="content/Strings%20字符串.html" data-book-page-id="5097">4.17.字符串</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Generics%20泛型.html" title="4.18.泛型" data-book-page-rel-url="content/Generics%20泛型.html" data-book-page-id="5098">4.18.泛型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Traits.html" title="4.19.Traits" data-book-page-rel-url="content/Traits.html" data-book-page-id="5099">4.19.Traits</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Drop.html" title="4.20.Drop" data-book-page-rel-url="content/Drop.html" data-book-page-id="5100">4.20.Drop</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/if%20let.html" title="4.21.if let" data-book-page-rel-url="content/if%20let.html" data-book-page-id="5101">4.21.if let</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Trait%20Objects%20trait%20对象.html" title="4.22.trait 对象" data-book-page-rel-url="content/Trait%20Objects%20trait%20对象.html" data-book-page-id="5102">4.22.trait 对象</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Closures%20闭包.html" title="4.23.闭包" data-book-page-rel-url="content/Closures%20闭包.html" data-book-page-id="5103">4.23.闭包</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Universal%20Function%20Call%20Syntax%20通用函数调用语法.html" title="4.24.通用函数调用语法" data-book-page-rel-url="content/Universal%20Function%20Call%20Syntax%20通用函数调用语法.html" data-book-page-id="5104">4.24.通用函数调用语法</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Crates%20and%20Modules%20crate%20和模块.html" title="4.25.crate 和模块" data-book-page-rel-url="content/Crates%20and%20Modules%20crate%20和模块.html" data-book-page-id="5105">4.25.crate 和模块</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.26.`const`和`static`" disabled data-book-page-rel-url="content/`const`%20and%20`static`.html" data-book-page-id="5106">4.26.`const`和`static`</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Attributes%20属性.html" title="4.27.属性" data-book-page-rel-url="content/Attributes%20属性.html" data-book-page-id="5107">4.27.属性</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.28.`type`别名" disabled data-book-page-rel-url="content/`type`%20Aliases%20`type`别名.html" data-book-page-id="5108">4.28.`type`别名</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Casting%20Between%20Types%20类型转换.html" title="4.29.类型转换" data-book-page-rel-url="content/Casting%20Between%20Types%20类型转换.html" data-book-page-id="5109">4.29.类型转换</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Associated%20Types%20关联类型.html" title="4.30.关联类型" data-book-page-rel-url="content/Associated%20Types%20关联类型.html" data-book-page-id="5110">4.30.关联类型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Unsized%20Types%20不定长类型.html" title="4.31.不定长类型" data-book-page-rel-url="content/Unsized%20Types%20不定长类型.html" data-book-page-id="5111">4.31.不定长类型</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Operators%20and%20Overloading%20运算符和重载.html" title="4.32.运算符和重载" data-book-page-rel-url="content/Operators%20and%20Overloading%20运算符和重载.html" data-book-page-id="5112">4.32.运算符和重载</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.33.`Deref`强制多态" disabled data-book-page-rel-url="content/`Deref`%20coercions%20`Deref`强制多态.html" data-book-page-id="5113">4.33.`Deref`强制多态</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Macros%20宏.html" title="4.34.宏" data-book-page-rel-url="content/Macros%20宏.html" data-book-page-id="5114">4.34.宏</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Raw%20Pointers%20裸指针.html" title="4.35.裸指针" data-book-page-rel-url="content/Raw%20Pointers%20裸指针.html" data-book-page-id="5115">4.35.裸指针</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.36.不安全代码" disabled data-book-page-rel-url="content/`unsafe`%20不安全代码.html" data-book-page-id="5116">4.36.不安全代码</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Effective%20Rust%20高效%20Rust.html" title="5.高效 Rust" data-book-page-rel-url="content/Effective%20Rust%20高效%20Rust.html" data-book-page-id="5117">5.高效 Rust</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/The%20Stack%20and%20the%20Heap%20栈和堆.html" title="5.1.栈和堆" data-book-page-rel-url="content/The%20Stack%20and%20the%20Heap%20栈和堆.html" data-book-page-id="5118">5.1.栈和堆</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Testing%20测试.html" title="5.2.测试" data-book-page-rel-url="content/Testing%20测试.html" data-book-page-id="5119">5.2.测试</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Conditional%20Compilation%20条件编译.html" title="5.3.条件编译" data-book-page-rel-url="content/Conditional%20Compilation%20条件编译.html" data-book-page-id="5120">5.3.条件编译</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Documentation%20文档.html" title="5.4.文档" data-book-page-rel-url="content/Documentation%20文档.html" data-book-page-id="5121">5.4.文档</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Iterators%20迭代器.html" title="5.5.迭代器" data-book-page-rel-url="content/Iterators%20迭代器.html" data-book-page-id="5122">5.5.迭代器</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Concurrency%20并发.html" title="5.6.并发" data-book-page-rel-url="content/Concurrency%20并发.html" data-book-page-id="5123">5.6.并发</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Error%20Handling%20错误处理.html" title="5.7.错误处理" data-book-page-rel-url="content/Error%20Handling%20错误处理.html" data-book-page-id="5124">5.7.错误处理</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Choosing%20your%20Guarantees%20选择你的保证.html" title="5.8.选择你的保证" data-book-page-rel-url="content/Choosing%20your%20Guarantees%20选择你的保证.html" data-book-page-id="5125">5.8.选择你的保证</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Foreign%20Function%20Interface%20外部函数接口.html" title="5.9.外部函数接口" data-book-page-rel-url="content/Foreign%20Function%20Interface%20外部函数接口.html" data-book-page-id="5126">5.9.外部函数接口</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Borrow%20and%20AsRef%20Borrow%20和%20AsRef.html" title="5.10.Borrow 和 AsRef" data-book-page-rel-url="content/Borrow%20and%20AsRef%20Borrow%20和%20AsRef.html" data-book-page-id="5127">5.10.Borrow 和 AsRef</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Release%20Channels%20发布途径.html" title="5.11.发布途径" data-book-page-rel-url="content/Release%20Channels%20发布途径.html" data-book-page-id="5128">5.11.发布途径</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Nightly%20Rust%20Rust%20开发版.html" title="6.Rust 开发版" data-book-page-rel-url="content/Nightly%20Rust%20Rust%20开发版.html" data-book-page-id="5130">6.Rust 开发版</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Compiler%20Plugins%20编译器插件.html" title="6.1.编译器插件" data-book-page-rel-url="content/Compiler%20Plugins%20编译器插件.html" data-book-page-id="5131">6.1.编译器插件</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Inline%20Assembly%20内联汇编.html" title="6.2.内联汇编" data-book-page-rel-url="content/Inline%20Assembly%20内联汇编.html" data-book-page-id="5132">6.2.内联汇编</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/No%20stdlib%20不使用标准库.html" title="6.3.不使用标准库" data-book-page-rel-url="content/No%20stdlib%20不使用标准库.html" data-book-page-id="5129">6.3.不使用标准库</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Intrinsics%20固有功能.html" title="6.4.固有功能" data-book-page-rel-url="content/Intrinsics%20固有功能.html" data-book-page-id="5133">6.4.固有功能</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Lang%20items%20语言项.html" title="6.5.语言项" data-book-page-rel-url="content/Lang%20items%20语言项.html" data-book-page-id="5134">6.5.语言项</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Advanced%20Linking%20链接进阶.html" title="6.6.链接进阶" data-book-page-rel-url="content/Advanced%20Linking%20链接进阶.html" data-book-page-id="5135">6.6.链接进阶</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Benchmark%20tests%20基准测试.html" title="6.7.基准测试" data-book-page-rel-url="content/Benchmark%20tests%20基准测试.html" data-book-page-id="5136">6.7.基准测试</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Box%20Syntax%20and%20Patterns%20装箱语法和模式.html" title="6.8.装箱语法和模式" data-book-page-rel-url="content/Box%20Syntax%20and%20Patterns%20装箱语法和模式.html" data-book-page-id="5137">6.8.装箱语法和模式</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Slice%20patterns%20切片模式.html" title="6.9.切片模式" data-book-page-rel-url="content/Slice%20patterns%20切片模式.html" data-book-page-id="5138">6.9.切片模式</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Associated%20Constants%20关联常量.html" title="6.10.关联常量" data-book-page-rel-url="content/Associated%20Constants%20关联常量.html" data-book-page-id="5139">6.10.关联常量</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Custom%20Allocators%20自定义内存分配器.html" title="6.11.自定义内存分配器" data-book-page-rel-url="content/Custom%20Allocators%20自定义内存分配器.html" data-book-page-id="5140">6.11.自定义内存分配器</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Glossary%20词汇表.html" title="7.词汇表" data-book-page-rel-url="content/Glossary%20词汇表.html" data-book-page-id="5141">7.词汇表</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Syntax%20Index%20语法索引.html" title="8.语法索引" data-book-page-rel-url="content/Syntax%20Index%20语法索引.html" data-book-page-id="5142">8.语法索引</a>
</li>
<li>
<a class="pjax" href="../../../book/55/content/Bibliography%20参考文献.html" title="9.参考文献" data-book-page-rel-url="content/Bibliography%20参考文献.html" data-book-page-id="5143">9.参考文献</a>
</li>
<li>
<a class="pjax" href="../../../book/55/名词中英文对照.html" title="附录：名词中英文对照" data-book-page-rel-url="名词中英文对照.html" data-book-page-id="5144">附录：名词中英文对照</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =55;var bookPageId =5114;var bookPageRelUrl ='content/Macros%20宏.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>