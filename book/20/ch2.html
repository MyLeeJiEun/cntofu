
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Java 8 数据流教程-Java 8 简明教程</title>
<meta content='Java 8 数据流教程,Java 8 简明教程' name='keywords'>
<meta content='Java 8 数据流教程,Java 8 简明教程' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/20/ch1.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">Java 8 简明教程</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/20/ch3.html">
<span class="">Java 8 Nash..</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/20/index.html">Java 8 简明教程</a>
<a target="_blank" rel="nofollow" href="https://github.com/wizardforcel/modern-java-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="java-8-数据流教程">Java 8 数据流教程</h1>
<blockquote>
<p>原文：<a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">Java 8 Stream Tutorial</a></p>
</blockquote>
<blockquote>
<p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p>
</blockquote>
<blockquote>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p>
</blockquote>
<p>这个示例驱动的教程是Java8数据流（Stream）的深入总结。当我第一次看到<code>Stream</code>API时，我非常疑惑，因为它听起来和Java IO的<code>InputStream</code> 和 <code>OutputStream</code>一样。但是Java8的数据流是完全不同的东西。数据流是单体（Monad），并且在Java8函数式编程中起到重要作用。</p>
<blockquote>
<p>在函数式编程中，单体是一个结构，表示定义为步骤序列的计算。单体结构的类型定义了它对链式操作，或具有相同类型的嵌套函数的含义。</p>
</blockquote>
<p>这个教程教给你如何使用Java8数据流，以及如何使用不同种类的可用的数据流操作。你将会学到处理次序以及流操作的次序如何影响运行时效率。这个教程也会详细讲解更加强大的流操作，<code>reduce</code>、<code>collect</code>和<code>flatMap</code>。最后，这个教程会深入探讨并行流。</p>
<p>如果你还不熟悉Java8的lambda表达式，函数式接口和方法引用，你可能需要在开始这一章之前，首先阅读我的<a href="ch1.html">Java8教程</a>。</p>
<p>更新 - 我现在正在编写用于浏览器的Java8数据流API的JavaScript实现。如果你对此感兴趣，请在Github上访问<a href="https://github.com/winterbe/streamjs">Stream.js</a>。非常期待你的反馈。</p>
<h2 id="数据流如何工作">数据流如何工作</h2>
<p>数据流表示元素的序列，并支持不同种类的操作来执行元素上的计算：</p>
<pre><code class="language-java">List&lt;String&gt; myList =
    Arrays.asList("a1", "a2", "b1", "c2", "c1");

myList
    .stream()
    .filter(s -&gt; s.startsWith("c"))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);

// C1
// C2
</code></pre>
<p>数据流操作要么是衔接操作，要么是终止操作。衔接操作返回数据流，所以我们可以把多个衔接操作不使用分号来链接到一起。终止操作无返回值，或者返回一个不是流的结果。在上面的例子中，<code>filter</code>、<code>map</code>和<code>sorted</code>都是衔接操作，而<code>forEach</code>是终止操作。列表上的所有流式操作请见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">数据流的Javadoc</a>。你在上面例子中看到的这种数据流的链式操作也叫作操作流水线。</p>
<p>多数数据流操作都接受一些lambda表达式参数，函数式接口用来指定操作的具体行为。这些操作的大多数必须是无干扰而且是无状态的。它们是什么意思呢？</p>
<p>当一个函数不修改数据流的底层数据源，它就是<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference">无干扰的</a>。例如，在上面的例子中，没有任何lambda表达式通过添加或删除集合元素修改<code>myList</code>。</p>
<p>当一个函数的操作的执行是确定性的，它就是<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Statelessness">无状态的</a>。例如，在上面的例子中，没有任何lambda表达式依赖于外部作用域中任何在操作过程中可变的变量或状态。</p>
<h2 id="数据流的不同类型">数据流的不同类型</h2>
<p>数据流可以从多种数据源创建，尤其是集合。<code>List</code>和<code>Set</code>支持新方法<code>stream()</code> 和 <code>parallelStream()</code>，来创建串行流或并行流。并行流能够在多个线程上执行操作，它们会在之后的章节中讲到。我们现在来看看串行流：</p>
<pre><code class="language-java">Arrays.asList("a1", "a2", "a3")
    .stream()
    .findFirst()
    .ifPresent(System.out::println);  // a1
</code></pre>
<p>在对象列表上调用<code>stream()</code>方法会返回一个通常的对象流。但是我们不需要创建一个集合来创建数据流，就像下面那样：</p>
<pre><code class="language-java">Stream.of("a1", "a2", "a3")
    .findFirst()
    .ifPresent(System.out::println);  // a1
</code></pre>
<p>只要使用<code>Stream.of()</code>，就可以从一系列对象引用中创建数据流。</p>
<p>除了普通的对象数据流，Java8还自带了特殊种类的流，用于处理基本数据类型<code>int</code>、<code>long</code> 和 <code>double</code>。你可能已经猜到了它是<code>IntStream</code>、<code>LongStream</code> 和 <code>DoubleStream</code>。</p>
<p><code>IntStream</code>可以使用<code>IntStream.range()</code>替换通常的<code>for</code>循环：</p>
<pre><code class="language-java">IntStream.range(1, 4)
    .forEach(System.out::println);

// 1
// 2
// 3
</code></pre>
<p>所有这些基本数据流都像通常的对象数据流一样，但有一些不同。基本的数据流使用特殊的lambda表达式，例如，<code>IntFunction</code>而不是<code>Function</code>，<code>IntPredicate</code>而不是<code>Predicate</code>。而且基本数据流支持额外的聚合终止操作<code>sum()</code>和<code>average()</code>：</p>
<pre><code class="language-java">Arrays.stream(new int[] {1, 2, 3})
    .map(n -&gt; 2 * n + 1)
    .average()
    .ifPresent(System.out::println);  // 5.0
</code></pre>
<p>有时需要将通常的对象数据流转换为基本数据流，或者相反。出于这种目的，对象数据流支持特殊的映射操作<code>mapToInt()</code>、<code>mapToLong()</code> 和 <code>mapToDouble()</code>：</p>
<pre><code class="language-java">Stream.of("a1", "a2", "a3")
    .map(s -&gt; s.substring(1))
    .mapToInt(Integer::parseInt)
    .max()
    .ifPresent(System.out::println);  // 3
</code></pre>
<p>基本数据流可以通过<code>mapToObj()</code>转换为对象数据流：</p>
<pre><code class="language-java">IntStream.range(1, 4)
    .mapToObj(i -&gt; "a" + i)
    .forEach(System.out::println);

// a1
// a2
// a3
</code></pre>
<p>下面是组合示例：浮点数据流首先映射为整数数据流，之后映射为字符串的对象数据流：</p>
<pre><code class="language-java">Stream.of(1.0, 2.0, 3.0)
    .mapToInt(Double::intValue)
    .mapToObj(i -&gt; "a" + i)
    .forEach(System.out::println);

// a1
// a2
// a3
</code></pre>
<h2 id="处理顺序">处理顺序</h2>
<p>既然我们已经了解了如何创建并使用不同种类的数据流，让我们深入了解数据流操作在背后如何执行吧。</p>
<p>衔接操作的一个重要特性就是延迟性。观察下面没有终止操作的例子：</p>
<pre><code class="language-java">Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -&gt; {
        System.out.println("filter: " + s);
        return true;
    });
</code></pre>
<p>执行这段代码时，不向控制台打印任何东西。这是因为衔接操作只在终止操作调用时被执行。</p>
<p>让我们通过添加终止操作<code>forEach</code>来扩展这个例子：</p>
<pre><code class="language-java">Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -&gt; {
        System.out.println("filter: " + s);
        return true;
    })
    .forEach(s -&gt; System.out.println("forEach: " + s));
</code></pre>
<p>执行这段代码会得到如下输出：</p>
<pre><code>filter:  d2
forEach: d2
filter:  a2
forEach: a2
filter:  b1
forEach: b1
filter:  b3
forEach: b3
filter:  c
forEach: c
</code></pre>
<p>结果的顺序可能出人意料。原始的方法会在数据流的所有元素上，一个接一个地水平执行所有操作。但是每个元素在调用链上垂直移动。第一个字符串<code>"d2"</code>首先经过<code>filter</code>然后是<code>forEach</code>，执行完后才开始处理第二个字符串<code>"a2"</code>。</p>
<p>这种行为可以减少每个元素上所执行的实际操作数量，就像我们在下个例子中看到的那样：</p>
<pre><code class="language-java">Stream.of("d2", "a2", "b1", "b3", "c")
    .map(s -&gt; {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .anyMatch(s -&gt; {
        System.out.println("anyMatch: " + s);
        return s.startsWith("A");
    });

// map:      d2
// anyMatch: D2
// map:      a2
// anyMatch: A2
</code></pre>
<p>只要提供的数据元素满足了谓词，<code>anyMatch</code>操作就会返回<code>true</code>。对于第二个传递<code>"A2"</code>的元素，它的结果为真。由于数据流的链式调用是垂直执行的，<code>map</code>这里只需要执行两次。所以<code>map</code>会执行尽可能少的次数，而不是把所有元素都映射一遍。</p>
<h3 id="为什么顺序如此重要">为什么顺序如此重要</h3>
<p>下面的例子由两个衔接操作<code>map</code>和<code>filter</code>，以及一个终止操作<code>forEach</code>组成。让我们再来看看这些操作如何执行：</p>
<pre><code class="language-java">Stream.of("d2", "a2", "b1", "b3", "c")
    .map(s -&gt; {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .filter(s -&gt; {
        System.out.println("filter: " + s);
        return s.startsWith("A");
    })
    .forEach(s -&gt; System.out.println("forEach: " + s));

// map:     d2
// filter:  D2
// map:     a2
// filter:  A2
// forEach: A2
// map:     b1
// filter:  B1
// map:     b3
// filter:  B3
// map:     c
// filter:  C
</code></pre>
<p>就像你可能猜到的那样，<code>map</code>和<code>filter</code>会对底层集合的每个字符串调用五次，而<code>forEach</code>只会调用一次。</p>
<p>如果我们调整操作顺序，将<code>filter</code>移动到调用链的顶端，就可以极大减少操作的执行次数:</p>
<pre><code class="language-java">Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -&gt; {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .map(s -&gt; {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .forEach(s -&gt; System.out.println("forEach: " + s));

// filter:  d2
// filter:  a2
// map:     a2
// forEach: A2
// filter:  b1
// filter:  b3
// filter:  c
</code></pre>
<p>现在，<code>map</code>只会调用一次，所以操作流水线对于更多的输入元素会执行更快。在整合复杂的方法链时，要记住这一点。</p>
<p>让我们通过添加额外的方法<code>sorted</code>来扩展上面的例子：</p>
<pre><code class="language-java">Stream.of("d2", "a2", "b1", "b3", "c")
    .sorted((s1, s2) -&gt; {
        System.out.printf("sort: %s; %s\n", s1, s2);
        return s1.compareTo(s2);
    })
    .filter(s -&gt; {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .map(s -&gt; {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .forEach(s -&gt; System.out.println("forEach: " + s));
</code></pre>
<p>排序是一类特殊的衔接操作。它是有状态的操作，因为你需要在处理中保存状态来对集合中的元素排序。</p>
<p>执行这个例子会得到如下输入：</p>
<pre><code class="language-java">sort:    a2; d2
sort:    b1; a2
sort:    b1; d2
sort:    b1; a2
sort:    b3; b1
sort:    b3; d2
sort:    c; b3
sort:    c; d2
filter:  a2
map:     a2
forEach: A2
filter:  b1
filter:  b3
filter:  c
filter:  d2
</code></pre>
<p>首先，排序操作在整个输入集合上执行。也就是说，<code>sorted</code>以水平方式执行。所以这里<code>sorted</code>对输入集合中每个元素的多种组合调用了八次。</p>
<p>我们同样可以通过重排调用链来优化性能：</p>
<pre><code class="language-java">Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -&gt; {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .sorted((s1, s2) -&gt; {
        System.out.printf("sort: %s; %s\n", s1, s2);
        return s1.compareTo(s2);
    })
    .map(s -&gt; {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .forEach(s -&gt; System.out.println("forEach: " + s));

// filter:  d2
// filter:  a2
// filter:  b1
// filter:  b3
// filter:  c
// map:     a2
// forEach: A2
</code></pre>
<p>这个例子中<code>sorted</code>永远不会调用，因为<code>filter</code>把输入集合减少至只有一个元素。所以对于更大的输入集合会极大提升性能。</p>
<h2 id="复用数据流">复用数据流</h2>
<p>Java8的数据流不能被复用。一旦你调用了任何终止操作，数据流就关闭了：</p>
<pre><code class="language-java">Stream&lt;String&gt; stream =
    Stream.of("d2", "a2", "b1", "b3", "c")
        .filter(s -&gt; s.startsWith("a"));

stream.anyMatch(s -&gt; true);    // ok
stream.noneMatch(s -&gt; true);   // exception
</code></pre>
<p>在相同数据流上，在<code>anyMatch</code>之后调用<code>noneMatch</code>会产生下面的异常：</p>
<pre><code>java.lang.IllegalStateException: stream has already been operated upon or closed
    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)
    at com.winterbe.java8.Streams5.test7(Streams5.java:38)
    at com.winterbe.java8.Streams5.main(Streams5.java:28)
</code></pre>
<p>要克服这个限制，我们需要为每个我们想要执行的终止操作创建新的数据流调用链。例如，我们创建一个数据流供应器，来构建新的数据流，并且设置好所有衔接操作：</p>
<pre><code class="language-java">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =
    () -&gt; Stream.of("d2", "a2", "b1", "b3", "c")
            .filter(s -&gt; s.startsWith("a"));

streamSupplier.get().anyMatch(s -&gt; true);   // ok
streamSupplier.get().noneMatch(s -&gt; true);  // ok
</code></pre>
<p>每次对<code>get()</code>的调用都构造了一个新的数据流，我们将其保存来调用终止操作。</p>
<h2 id="高级操作">高级操作</h2>
<p>数据流执行大量的不同操作。我们已经了解了一些最重要的操作，例如<code>filter</code>和<code>map</code>。我将它们留给你来探索所有其他的可用操作（请见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">数据流的Javadoc</a>）。下面让我们深入了解一些更复杂的操作：<code>collect</code>、<code>flatMap</code>和<code>reduce</code>。</p>
<p>这一节的大部分代码示例使用下面的<code>Person</code>列表来演示：</p>
<pre><code class="language-java">class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name;
    }
}

List&lt;Person&gt; persons =
    Arrays.asList(
        new Person("Max", 18),
        new Person("Peter", 23),
        new Person("Pamela", 23),
        new Person("David", 12));
</code></pre>
<h3 id="collect"><code>collect</code></h3>
<p><code>collect</code>是非常有用的终止操作，将流中的元素存放在不同类型的结果中，例如<code>List</code>、<code>Set</code>或者<code>Map</code>。<code>collect</code>接受收集器（Collector），它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。这在开始听起来十分复杂，但是Java8通过内置的<code>Collectors</code>类支持多种内置的收集器。所以对于大部分常见操作，你并不需要自己实现收集器。</p>
<p>让我们以一个非常常见的用例来开始：</p>
<pre><code class="language-java">List&lt;Person&gt; filtered =
    persons
        .stream()
        .filter(p -&gt; p.name.startsWith("P"))
        .collect(Collectors.toList());

System.out.println(filtered);    // [Peter, Pamela]
</code></pre>
<p>就像你看到的那样，它非常简单，只是从流的元素中构造了一个列表。如果需要以<code>Set</code>来替代<code>List</code>，只需要使用<code>Collectors.toSet()</code>就好了。</p>
<p>下面的例子按照年龄对所有人进行分组：</p>
<pre><code class="language-java">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons
    .stream()
    .collect(Collectors.groupingBy(p -&gt; p.age));

personsByAge
    .forEach((age, p) -&gt; System.out.format("age %s: %s\n", age, p));

// age 18: [Max]
// age 23: [Peter, Pamela]
// age 12: [David]
</code></pre>
<p>收集器十分灵活。你也可以在流的元素上执行聚合，例如，计算所有人的平均年龄：</p>
<pre><code class="language-java">Double averageAge = persons
    .stream()
    .collect(Collectors.averagingInt(p -&gt; p.age));

System.out.println(averageAge);     // 19.0
</code></pre>
<p>如果你对更多统计学方法感兴趣，概要收集器返回一个特殊的内置概要统计对象，所以我们可以简单计算最小年龄、最大年龄、算术平均年龄、总和和数量。</p>
<pre><code class="language-java">IntSummaryStatistics ageSummary =
    persons
        .stream()
        .collect(Collectors.summarizingInt(p -&gt; p.age));

System.out.println(ageSummary);
// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}
</code></pre>
<p>下面的例子将所有人连接为一个字符串：</p>
<pre><code class="language-java">String phrase = persons
    .stream()
    .filter(p -&gt; p.age &gt;= 18)
    .map(p -&gt; p.name)
    .collect(Collectors.joining(" and ", "In Germany ", " are of legal age."));

System.out.println(phrase);
// In Germany Max and Peter and Pamela are of legal age.
</code></pre>
<p>连接收集器接受分隔符，以及可选的前缀和后缀。</p>
<p>为了将数据流中的元素转换为映射，我们需要指定键和值如何被映射。要记住键必须是唯一的，否则会抛出<code>IllegalStateException</code>异常。你可以选择传递一个合并函数作为额外的参数来避免这个异常。</p>
<p>既然我们知道了一些最强大的内置收集器，让我们来尝试构建自己的特殊收集器吧。我们希望将流中的所有人转换为一个字符串，包含所有大写的名称，并以<code>|</code>分割。为了完成它，我们通过<code>Collector.of()</code>创建了一个新的收集器。我们需要传递一个收集器的四个组成部分：供应器、累加器、组合器和终止器。</p>
<pre><code class="language-java">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =
    Collector.of(
        () -&gt; new StringJoiner(" | "),          // supplier
        (j, p) -&gt; j.add(p.name.toUpperCase()),  // accumulator
        (j1, j2) -&gt; j1.merge(j2),               // combiner
        StringJoiner::toString);                // finisher

String names = persons
    .stream()
    .collect(personNameCollector);

System.out.println(names);  // MAX | PETER | PAMELA | DAVID
</code></pre>
<p>由于Java中的字符串是不可变的，我们需要一个助手类<code>StringJointer</code>。让收集器构造我们的字符串。供应器最开始使用相应的分隔符构造了这样一个<code>StringJointer</code>。累加器用于将每个人的大写名称加到<code>StringJointer</code>中。组合器知道如何把两个<code>StringJointer</code>合并为一个。最后一步，终结器从<code>StringJointer</code>构造出预期的字符串。</p>
<h3 id="flatmap"><code>flatMap</code></h3>
<p>我们已经了解了如何通过使用<code>map</code>操作，将流中的对象转换为另一种类型。<code>map</code>有时十分受限，因为每个对象只能映射为一个其它对象。但如何我希望将一个对象转换为多个或零个其他对象呢？<code>flatMap</code>这时就会派上用场。</p>
<p><code>flatMap</code>将流中的每个元素，转换为其它对象的流。所以每个对象会被转换为零个、一个或多个其它对象，以流的形式返回。这些流的内容之后会放进<code>flatMap</code>所返回的流中。</p>
<p>在我们了解<code>flatMap</code>如何使用之前，我们需要相应的类型体系：</p>
<pre><code class="language-java">class Foo {
    String name;
    List&lt;Bar&gt; bars = new ArrayList&lt;&gt;();

    Foo(String name) {
        this.name = name;
    }
}

class Bar {
    String name;

    Bar(String name) {
        this.name = name;
    }
}
</code></pre>
<p>下面，我们使用我们自己的关于流的知识来实例化一些对象：</p>
<pre><code class="language-java">List&lt;Foo&gt; foos = new ArrayList&lt;&gt;();

// create foos
IntStream
    .range(1, 4)
    .forEach(i -&gt; foos.add(new Foo("Foo" + i)));

// create bars
foos.forEach(f -&gt;
    IntStream
        .range(1, 4)
        .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));
</code></pre>
<p>现在我们拥有了含有三个<code>foo</code>的列表，每个都含有三个<code>bar</code>。</p>
<p><code>flatMap</code>接受返回对象流的函数。所以为了处理每个<code>foo</code>上的<code>bar</code>对象，我们需要传递相应的函数：</p>
<pre><code class="language-java">foos.stream()
    .flatMap(f -&gt; f.bars.stream())
    .forEach(b -&gt; System.out.println(b.name));

// Bar1 &lt;- Foo1
// Bar2 &lt;- Foo1
// Bar3 &lt;- Foo1
// Bar1 &lt;- Foo2
// Bar2 &lt;- Foo2
// Bar3 &lt;- Foo2
// Bar1 &lt;- Foo3
// Bar2 &lt;- Foo3
// Bar3 &lt;- Foo3
</code></pre>
<p>像你看到的那样，我们成功地将含有三个<code>foo</code>对象中的流转换为含有九个<code>bar</code>对象的流。</p>
<p>最后，上面的代码示例可以简化为流式操作的单一流水线：</p>
<pre><code class="language-java">IntStream.range(1, 4)
    .mapToObj(i -&gt; new Foo("Foo" + i))
    .peek(f -&gt; IntStream.range(1, 4)
        .mapToObj(i -&gt; new Bar("Bar" + i + " &lt;- " + f.name))
        .forEach(f.bars::add))
    .flatMap(f -&gt; f.bars.stream())
    .forEach(b -&gt; System.out.println(b.name));
</code></pre>
<p><code>flatMap</code>也可用于Java8引入的<code>Optional</code>类。<code>Optional</code>的<code>flatMap</code>操作返回一个<code>Optional</code>或其他类型的对象。所以它可以用于避免烦人的<code>null</code>检查。</p>
<p>考虑像这样更复杂的层次结构：</p>
<pre><code class="language-java">class Outer {
    Nested nested;
}

class Nested {
    Inner inner;
}

class Inner {
    String foo;
}
</code></pre>
<p>为了处理外层示例上的内层字符串<code>foo</code>，你需要添加多个<code>null</code>检查来避免潜在的<code>NullPointerException</code>：</p>
<pre><code class="language-java">Outer outer = new Outer();
if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) {
    System.out.println(outer.nested.inner.foo);
}
</code></pre>
<p>可以使用<code>Optional</code>的<code>flatMap</code>操作来完成相同的行为：</p>
<pre><code class="language-java">Optional.of(new Outer())
    .flatMap(o -&gt; Optional.ofNullable(o.nested))
    .flatMap(n -&gt; Optional.ofNullable(n.inner))
    .flatMap(i -&gt; Optional.ofNullable(i.foo))
    .ifPresent(System.out::println);
</code></pre>
<p>如果存在的话，每个<code>flatMap</code>的调用都会返回预期对象的<code>Optional</code>包装，否则为<code>null</code>的<code>Optional</code>包装。</p>
<h3 id="reduce"><code>reduce</code></h3>
<p>归约操作将所有流中的元素组合为单一结果。Java8支持三种不同类型的<code>reduce</code>方法。第一种将流中的元素归约为流中的一个元素。让我们看看我们如何使用这个方法来计算出最老的人：</p>
<pre><code class="language-java">persons
    .stream()
    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)
    .ifPresent(System.out::println);    // Pamela
</code></pre>
<p><code>reduce</code>方法接受<code>BinaryOperator</code>积累函数。它实际上是两个操作数类型相同的<code>BiFunction</code>。<code>BiFunction</code>就像是<code>Function</code>，但是接受两个参数。示例中的函数比较两个人的年龄，来返回年龄较大的人。</p>
<p>第二个<code>reduce</code>方法接受一个初始值，和一个<code>BinaryOperator</code>累加器。这个方法可以用于从流中的其它<code>Person</code>对象中构造带有聚合后名称和年龄的新<code>Person</code>对象。</p>
<pre><code class="language-java">Person result =
    persons
        .stream()
        .reduce(new Person("", 0), (p1, p2) -&gt; {
            p1.age += p2.age;
            p1.name += p2.name;
            return p1;
        });

System.out.format("name=%s; age=%s", result.name, result.age);
// name=MaxPeterPamelaDavid; age=76
</code></pre>
<p>第三个<code>reduce</code>对象接受三个参数：初始值，<code>BiFunction</code>累加器和<code>BinaryOperator</code>类型的组合器函数。由于初始值的类型不一定为<code>Person</code>，我们可以使用这个归约函数来计算所有人的年龄总和。：</p>
<pre><code class="language-java">Integer ageSum = persons
    .stream()
    .reduce(0, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);

System.out.println(ageSum);  // 76
</code></pre>
<p>你可以看到结果是76。但是背后发生了什么？让我们通过添加一些调试输出来扩展上面的代码：</p>
<pre><code class="language-java">Integer ageSum = persons
    .stream()
    .reduce(0,
        (sum, p) -&gt; {
            System.out.format("accumulator: sum=%s; person=%s\n", sum, p);
            return sum += p.age;
        },
        (sum1, sum2) -&gt; {
            System.out.format("combiner: sum1=%s; sum2=%s\n", sum1, sum2);
            return sum1 + sum2;
        });

// accumulator: sum=0; person=Max
// accumulator: sum=18; person=Peter
// accumulator: sum=41; person=Pamela
// accumulator: sum=64; person=David
</code></pre>
<p>你可以看到，累加器函数做了所有工作。它首先使用初始值<code>0</code>和第一个人Max来调用累加器。接下来的三步中<code>sum</code>会持续增加，直到76。</p>
<p>等一下。好像组合器从来没有调用过？以并行方式执行相同的流会揭开这个秘密：</p>
<pre><code class="language-java">Integer ageSum = persons
    .parallelStream()
    .reduce(0,
        (sum, p) -&gt; {
            System.out.format("accumulator: sum=%s; person=%s\n", sum, p);
            return sum += p.age;
        },
        (sum1, sum2) -&gt; {
            System.out.format("combiner: sum1=%s; sum2=%s\n", sum1, sum2);
            return sum1 + sum2;
        });

// accumulator: sum=0; person=Pamela
// accumulator: sum=0; person=David
// accumulator: sum=0; person=Max
// accumulator: sum=0; person=Peter
// combiner: sum1=18; sum2=23
// combiner: sum1=23; sum2=12
// combiner: sum1=41; sum2=35
</code></pre>
<p>这个流的并行执行行为会完全不同。现在实际上调用了组合器。由于累加器被并行调用，组合器需要用于计算部分累加值的总和。</p>
<p>下一节我们会深入了解并行流。</p>
<h2 id="并行流">并行流</h2>
<p>流可以并行执行，在大量输入元素上可以提升运行时的性能。并行流使用公共的<code>ForkJoinPool</code>，由<code>ForkJoinPool.commonPool()</code>方法提供。底层线程池的大小最大为五个线程 -- 取决于CPU的物理核数。</p>
<pre><code class="language-java">ForkJoinPool commonPool = ForkJoinPool.commonPool();
System.out.println(commonPool.getParallelism());    // 3
</code></pre>
<p>在我的机器上，公共池默认初始化为3。这个值可以通过设置下列JVM参数来增减：</p>
<pre><code>-Djava.util.concurrent.ForkJoinPool.common.parallelism=5
</code></pre>
<p>集合支持<code>parallelStream()</code>方法来创建元素的并行流。或者你可以在已存在的数据流上调用衔接方法<code>parallel()</code>，将串行流转换为并行流。</p>
<p>为了描述并行流的执行行为，下面的例子向<code>sout</code>打印了当前线程的信息。</p>
<pre><code class="language-java">Arrays.asList("a1", "a2", "b1", "c2", "c1")
    .parallelStream()
    .filter(s -&gt; {
        System.out.format("filter: %s [%s]\n",
            s, Thread.currentThread().getName());
        return true;
    })
    .map(s -&gt; {
        System.out.format("map: %s [%s]\n",
            s, Thread.currentThread().getName());
        return s.toUpperCase();
    })
    .forEach(s -&gt; System.out.format("forEach: %s [%s]\n",
        s, Thread.currentThread().getName()));
</code></pre>
<p>通过分析调试输出，我们可以对哪个线程用于执行流式操作拥有更深入的理解：</p>
<pre><code>filter:  b1 [main]
filter:  a2 [ForkJoinPool.commonPool-worker-1]
map:     a2 [ForkJoinPool.commonPool-worker-1]
filter:  c2 [ForkJoinPool.commonPool-worker-3]
map:     c2 [ForkJoinPool.commonPool-worker-3]
filter:  c1 [ForkJoinPool.commonPool-worker-2]
map:     c1 [ForkJoinPool.commonPool-worker-2]
forEach: C2 [ForkJoinPool.commonPool-worker-3]
forEach: A2 [ForkJoinPool.commonPool-worker-1]
map:     b1 [main]
forEach: B1 [main]
filter:  a1 [ForkJoinPool.commonPool-worker-3]
map:     a1 [ForkJoinPool.commonPool-worker-3]
forEach: A1 [ForkJoinPool.commonPool-worker-3]
forEach: C1 [ForkJoinPool.commonPool-worker-2]
</code></pre>
<p>就像你看到的那样，并行流使用了所有公共的<code>ForkJoinPool</code>中的可用线程来执行流式操作。在连续的运行中输出可能有所不同，因为所使用的特定线程是非特定的。</p>
<p>让我们通过添加额外的流式操作<code>sort</code>来扩展这个示例：</p>
<pre><code class="language-java">Arrays.asList("a1", "a2", "b1", "c2", "c1")
    .parallelStream()
    .filter(s -&gt; {
        System.out.format("filter: %s [%s]\n",
            s, Thread.currentThread().getName());
        return true;
    })
    .map(s -&gt; {
        System.out.format("map: %s [%s]\n",
            s, Thread.currentThread().getName());
        return s.toUpperCase();
    })
    .sorted((s1, s2) -&gt; {
        System.out.format("sort: %s &lt;&gt; %s [%s]\n",
            s1, s2, Thread.currentThread().getName());
        return s1.compareTo(s2);
    })
    .forEach(s -&gt; System.out.format("forEach: %s [%s]\n",
        s, Thread.currentThread().getName()));
</code></pre>
<p>结果起初可能比较奇怪：</p>
<pre><code>filter:  c2 [ForkJoinPool.commonPool-worker-3]
filter:  c1 [ForkJoinPool.commonPool-worker-2]
map:     c1 [ForkJoinPool.commonPool-worker-2]
filter:  a2 [ForkJoinPool.commonPool-worker-1]
map:     a2 [ForkJoinPool.commonPool-worker-1]
filter:  b1 [main]
map:     b1 [main]
filter:  a1 [ForkJoinPool.commonPool-worker-2]
map:     a1 [ForkJoinPool.commonPool-worker-2]
map:     c2 [ForkJoinPool.commonPool-worker-3]
sort:    A2 &lt;&gt; A1 [main]
sort:    B1 &lt;&gt; A2 [main]
sort:    C2 &lt;&gt; B1 [main]
sort:    C1 &lt;&gt; C2 [main]
sort:    C1 &lt;&gt; B1 [main]
sort:    C1 &lt;&gt; C2 [main]
forEach: A1 [ForkJoinPool.commonPool-worker-1]
forEach: C2 [ForkJoinPool.commonPool-worker-3]
forEach: B1 [main]
forEach: A2 [ForkJoinPool.commonPool-worker-2]
forEach: C1 [ForkJoinPool.commonPool-worker-1]
</code></pre>
<p><code>sort</code>看起来只在主线程上串行执行。实际上，并行流上的<code>sort</code>在背后使用了Java8中新的方法<code>Arrays.parallelSort()</code>。如<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelSort-T:A-">javadoc</a>所说，这个方法会参照数据长度来决定以串行或并行来执行。</p>
<blockquote>
<p>如果指定数据的长度小于最小粒度，它使用相应的<code>Arrays.sort</code>方法来排序。</p>
</blockquote>
<p>返回上一节中<code>reduce</code>的例子。我们已经发现了组合器函数只在并行流中调用，而不在串行流中调用。让我们来观察实际上涉及到哪个线程：</p>
<pre><code class="language-java">List&lt;Person&gt; persons = Arrays.asList(
    new Person("Max", 18),
    new Person("Peter", 23),
    new Person("Pamela", 23),
    new Person("David", 12));

persons
    .parallelStream()
    .reduce(0,
        (sum, p) -&gt; {
            System.out.format("accumulator: sum=%s; person=%s [%s]\n",
                sum, p, Thread.currentThread().getName());
            return sum += p.age;
        },
        (sum1, sum2) -&gt; {
            System.out.format("combiner: sum1=%s; sum2=%s [%s]\n",
                sum1, sum2, Thread.currentThread().getName());
            return sum1 + sum2;
        });
</code></pre>
<p>控制台的输出表明，累加器和组合器都在所有可用的线程上并行执行：</p>
<pre><code>accumulator: sum=0; person=Pamela; [main]
accumulator: sum=0; person=Max;    [ForkJoinPool.commonPool-worker-3]
accumulator: sum=0; person=David;  [ForkJoinPool.commonPool-worker-2]
accumulator: sum=0; person=Peter;  [ForkJoinPool.commonPool-worker-1]
combiner:    sum1=18; sum2=23;     [ForkJoinPool.commonPool-worker-1]
combiner:    sum1=23; sum2=12;     [ForkJoinPool.commonPool-worker-2]
combiner:    sum1=41; sum2=35;     [ForkJoinPool.commonPool-worker-2]
</code></pre>
<p>总之，并行流对拥有大量输入元素的数据流具有极大的性能提升。但是要记住一些并行流的操作，例如<code>reduce</code>和<code>collect</code>需要额外的计算（组合操作），这在串行执行时并不需要。</p>
<p>此外我们已经了解，所有并行流操作都共享相同的JVM相关的公共<code>ForkJoinPool</code>。所以你可能需要避免实现又慢又卡的流式操作，因为它可能会拖慢你应用中严重依赖并行流的其它部分。</p>
<h2 id="到此为止">到此为止</h2>
<p>我的Java8数据流编程教程就此告一段落。如果你对深入了解Java8数据流感兴趣，我向你推荐<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference">数据流的Javadoc</a>。如果你希望学到更多底层机制，你可能需要阅读Martin Fowler关于<a href="http://martinfowler.com/articles/collection-pipeline/">集合流水线</a>的文章。</p>
<p>如果你对JavaScript也感兴趣，你可能希望看一看<a href="https://github.com/winterbe/streamjs">Stream.js</a> -- 一个Java8数据流API的JavaScript实现。你也可能希望阅读我的<a href="ch1.html">Java8简明教程</a>，和我的<a href="ch3.html">Java8Nashron教程</a>。</p>
<p>我希望你会喜欢这篇文章。如果你有任何的问题都可以在下面评论或者通过 <a href="https://twitter.com/winterbe_">Twitter</a> 给我回复。</p>
<p>祝编程愉快！</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/58/index.html">
<img class="uk-book-cover" src="../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/58/index.html">guava学习记录项目</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/34.html">tiantiangao</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">24页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 70个">70</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/9/index.html">
<img class="uk-book-cover" src="../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/9/index.html">分布式 Java</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/6.html">waylau</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">27页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 176个">176</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/78/index.html">
<img class="uk-book-cover" src="../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/78/index.html">阿里巴巴Java开发手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/49.html">Alibaba</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">24页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 9831个">9831</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/39/index.html">
<img class="uk-book-cover" src="../../static/icons/48/git_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/39/index.html">Pro Git 简体中文第二版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/20.html">Pro Git Book</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="git">git</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">118页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 838个">838</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/10/index.html">
<img class="uk-book-cover" src="../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/10/index.html">Java 编码规范</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/6.html">waylau</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">12页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 127个">127</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/19/index.html">
<img class="uk-book-cover" src="../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/19/index.html">Go命令教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/14.html">hyper0x</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1478个">1478</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/20/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/20/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Java 8 简明教程" disabled data-book-page-rel-url="REAMDE.html" data-book-page-id="1621">Java 8 简明教程</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch1.html" title="Java 8 简明教程" data-book-page-rel-url="ch1.html" data-book-page-id="1622">Java 8 简明教程</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch2.html" title="Java 8 数据流教程" data-book-page-rel-url="ch2.html" data-book-page-id="1623">Java 8 数据流教程</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch3.html" title="Java 8 Nashorn 教程" data-book-page-rel-url="ch3.html" data-book-page-id="1624">Java 8 Nashorn 教程</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch4.html" title="Java 8 并发教程：线程和执行器" data-book-page-rel-url="ch4.html" data-book-page-id="1625">Java 8 并发教程：线程和执行器</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch5.html" title="Java 8 并发教程：同步和锁" data-book-page-rel-url="ch5.html" data-book-page-id="1626">Java 8 并发教程：同步和锁</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch6.html" title="Java 8 并发教程：原子变量和 ConcurrentMap" data-book-page-rel-url="ch6.html" data-book-page-id="1627">Java 8 并发教程：原子变量和 ConcurrentMap</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch7.html" title="Java 8 API 示例：字符串、数值、算术和文件" data-book-page-rel-url="ch7.html" data-book-page-id="1628">Java 8 API 示例：字符串、数值、算术和文件</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch8.html" title="在 Java 8 中避免 Null 检查" data-book-page-rel-url="ch8.html" data-book-page-id="1629">在 Java 8 中避免 Null 检查</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch9.html" title="使用 Intellij IDEA 解决 Java 8 的数据流问题" data-book-page-rel-url="ch9.html" data-book-page-id="1630">使用 Intellij IDEA 解决 Java 8 的数据流问题</a>
</li>
<li>
<a class="pjax" href="../../book/20/ch10.html" title="在 Nashron 中使用 Backbone.js" data-book-page-rel-url="ch10.html" data-book-page-id="1631">在 Nashron 中使用 Backbone.js</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =20;var bookPageId =1623;var bookPageRelUrl ='ch2.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>