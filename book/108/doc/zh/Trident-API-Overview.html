
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Trident API 概述-Apache Storm 官方文档中文版</title>
<meta content='Trident API 概述,Apache Storm 官方文档中文版' name='keywords'>
<meta content='Trident API 概述,Apache Storm 官方文档中文版' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../../book/108/doc/zh/Trident-tutorial.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">Trident 教程</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../../book/108/doc/zh/Trident-state.html">
<span class="">Trident Sta..</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../../book/108/index.html">Apache Storm 官方文档中文版</a>
<a target="_blank" rel="nofollow" href="https://github.com/tzivanmoe/storm-doc-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<hr>
<h2 id="title-trident-api-综述layout-documentationdocumentation-true">title: Trident API 综述 layout: documentation documentation: true</h2>
<p>"Stream" 是 Trident 中的核心数据模型, 它被当做一系列的 batch 来处理.在 Storm 集群的节点之间, 一个 stream 被划分成很多 partition （分区）, 对流的 operation （操作）是在每个 partition 上并行进行的.</p>
<p>注:</p>
<ol>
<li>"Stream" 是 Trident 中的核心数据模型:有些地方也说是 TridentTuple , 没有个标准的说法.</li>
<li>一个 stream 被划分成很多 partition : partition 是 stream 的一个子集, 里面可能有多个 batch , 一个 batch 也可能位于不同的 partition 上.</li>
</ol>
<p>Trident 有 5 类操作:</p>
<ol>
<li>Partition-local operations , 对每个 partition 的局部操作, 不产生网络传输</li>
<li>Repartitioning operations: 对 stream （数据流）的重新划分（仅仅是划分, 但不改变内容）, 产生网络传输</li>
<li>作为 operation （操作）的一部分进行网络传输的 Aggregation operations （聚合操作）.</li>
<li>Operations on grouped streams （作用在分组流上的操作）</li>
<li>Merges 和 joins 操作</li>
</ol>
<h2 id="partition-local-operations">Partition-local operations</h2>
<p>Partition-local operations （分区本地操作）不涉及网络传输, 并且独立地应用于每个 batch partition （批处理分区）.</p>
<h3 id="functions">Functions</h3>
<p>一个 function 收到一个输入 tuple 后可以输出 0 或多个 tuple , 输出 tuple 的字段被追加到接收到的输入 tuple 后面.如果对某个 tuple 执行 function 后没有输出 tuple, 则该 tuple 被 filter（过滤）, 否则, 就会为每个输出 tuple 复制一份输入 tuple 的副本.假设有如下的 function :</p>
<pre><code class="language-java">public class MyFunction extends BaseFunction {
    public void execute(TridentTuple tuple, TridentCollector collector) {
        for(int i=0; i &lt; tuple.getInteger(0); i++) {
            collector.emit(new Values(i));
        }
    }
}
</code></pre>
<p>假设有个叫 "mystream" 的 stream （流）, 该流中有如下 tuple （ tuple 的字段为["a", "b", "c"] ）:</p>
<pre><code>[1, 2, 3]
[4, 1, 6]
[3, 0, 8]
</code></pre>
<p>如果您运行下面的代码:</p>
<pre><code class="language-java">mystream.each(new Fields("b"), new MyFunction(), new Fields("d")))
</code></pre>
<p>则 resulting tuples （输出 tuple ）中的字段为 ["a", "b", "c", "d"], 如下所示:</p>
<pre><code>[1, 2, 3, 0]
[1, 2, 3, 1]
[4, 1, 6, 0]
</code></pre>
<h3 id="filters">Filters</h3>
<p>Filters 收到一个输入 tuple , 并决定是否保留该 tuple .假设nin拥有这个 filters:</p>
<pre><code class="language-java">public class MyFilter extends BaseFilter {
    public boolean isKeep(TridentTuple tuple) {
        return tuple.getInteger(0) == 1 &amp;&amp; tuple.getInteger(1) == 2;
    }
}
</code></pre>
<p>现在, 假设您有如下这些 tuple , 包含字段 ["a", "b", "c"]:</p>
<pre><code>[1, 2, 3]
[2, 1, 1]
[2, 3, 4]
</code></pre>
<p>如果您运行如下代码:</p>
<pre><code class="language-java">mystream.filter(new MyFilter())
</code></pre>
<p>则得到的 resulting tuples （结果 tuples）为:</p>
<pre><code>[1, 2, 3]
</code></pre>
<h3 id="map-and-flatmap">map and flatMap</h3>
<p><code>map</code> 返回一个 stream , 它包含将给定的 mapping function （映射函数）应用到 stream 的 tuples 的结果. 这个可以用来对 tuples 应用 one-one transformation （一一变换）.</p>
<p>例如, 如果有一个 stream of words （单词流）, 并且您想将其转换为 stream of upper case words （大写字母的流）, 你可以定义一个 mapping function （映射函数）如下,</p>
<pre><code class="language-java">public class UpperCase extends MapFunction {
 @Override
 public Values execute(TridentTuple input) {
   return new Values(input.getString(0).toUpperCase());
 }
}
</code></pre>
<p>然后可以将 mapping function （映射函数）应用于 stream 以产生 stream of uppercase words （大写字的流）.</p>
<pre><code class="language-java">mystream.map(new UpperCase())
</code></pre>
<p><code>flatMap</code> 类似于 <code>map</code> , 但具有将 one-to-many transformation （一对多变换）应用于 values of the stream （流的值）的效果, 然后将所得到的元素 flattening （平坦化）为新的 stream .</p>
<p>例如, 如果有 stream of sentences （句子流）, 并且您想将其转换成 stream of words （单词流）, 你可以定义一个 flatMap 函数如下,</p>
<pre><code class="language-java">public class Split extends FlatMapFunction {
  @Override
  public Iterable&lt;Values&gt; execute(TridentTuple input) {
    List&lt;Values&gt; valuesList = new ArrayList&lt;&gt;();
    for (String word : input.getString(0).split(" ")) {
      valuesList.add(new Values(word));
    }
    return valuesList;
  }
}
</code></pre>
<p>然后可以将 flatMap 函数应用于 stream of sentences （句子流）以产生一个 stream of words （单词流）,</p>
<pre><code class="language-java">mystream.flatMap(new Split())
</code></pre>
<p>当然这些操作可以被 chained （链接）, 因此可以从如下的 stream of sentences （句子流）中获得 stream of uppercase words （大写字的流）,</p>
<pre><code class="language-java">mystream.flatMap(new Split()).map(new UpperCase())
</code></pre>
<p>如果不将 output fields （输出字段）作为 parameter （参数）传递, 则 map 和 flatMap 会将 input fields （输入字段）保留为 output fields （输出字段）.</p>
<p>如果要使用 MapFunction 或 FlatMapFunction 使用 new output fields （新的输出字段）替换 old fields （旧字段）, 您可以使用附加的 Fields 参数调用 map/flatMap , 如下所示,</p>
<pre><code class="language-java">mystream.map(new UpperCase(), new Fields("uppercased"))
</code></pre>
<p>Output stream （输出流）只有一个 output field （输出字段） "uppercased" , 而不管以前的流有什么输出字段. 同样的事情适用于 flatMap, 所以以下是有效的,</p>
<pre><code class="language-java">mystream.flatMap(new Split(), new Fields("word"))
</code></pre>
<h3 id="peek">peek</h3>
<p><code>peek</code> 可用于在每个 trident tuple 流过 stream 时对其执行 additional action （附加操作）. &nbsp; 这可能对于在流经 pipeline 中 certain point （某一点）的元组来 debugging （调试） tuples 是有用的.</p>
<p>例如, 下面的代码将打印在将这些单词转换为 <code>groupBy</code> 之前将单词转换为大写的结果</p>
<pre><code class="language-java"> mystream.flatMap(new Split()).map(new UpperCase())
         .peek(new Consumer() {
                @Override
                public void accept(TridentTuple input) {
                  System.out.println(input.getString(0));
                }
         })
         .groupBy(new Fields("word"))
         .persistentAggregate(new MemoryMapState.Factory(), new Count(), new Fields("count"))
</code></pre>
<h3 id="min-and-minby">min and minBy</h3>
<p><code>min</code> 和 <code>minBy</code> operations （操作）在 trident stream 中的 a batch of tuples （一批元组）的每个 partition （分区）上返回 minimum value （最小值）.</p>
<p>假设 trident stream 包含字段 ["device-id", "count"] 和 partitions of tuples （元组的以下分区）</p>
<pre><code>Partition 0:
[123, 2]
[113, 54]
[23,  28]
[237, 37]
[12,  23]
[62,  17]
[98,  42]

Partition 1:
[64,  18]
[72,  54]
[2,   28]
[742, 71]
[98,  45]
[62,  12]
[19,  174]


Partition 2:
[27,  94]
[82,  23]
[9,   86]
[53,  71]
[74,  37]
[51,  49]
[37,  98]

</code></pre>
<p><code>minBy</code> operation （操作）可以应用在上面的 stream of tuples （元组流）中, 如下所示, 这导致在每个 partition （分区）中以最小值 <code>count</code> field （字段）发出 tuples .</p>
<pre><code class="language-java">  mystream.minBy(new Fields("count"))
</code></pre>
<p>上述代码在上述 partitions （分区）上的结果是:</p>
<pre><code>Partition 0:
[123, 2]


Partition 1:
[62,  12]


Partition 2:
[82,  23]

</code></pre>
<p>您可以在 Stream 上查看其他 <code>min</code> 和 <code>minBy</code> 操作</p>
<pre><code class="language-java">      public &lt;T&gt; Stream minBy(String inputFieldName, Comparator&lt;T&gt; comparator) 
      public Stream min(Comparator&lt;TridentTuple&gt; comparator) 
</code></pre>
<p>下面的示例显示了如何使用这些 API 来使用 tuple 上的 respective Comparators （相应比较器）来找到 minimum （最小值）.</p>
<pre><code class="language-java">
        FixedBatchSpout spout = new FixedBatchSpout(allFields, 10, Vehicle.generateVehicles(20));

        TridentTopology topology = new TridentTopology();
        Stream vehiclesStream = topology.newStream("spout1", spout).
                each(allFields, new Debug("##### vehicles"));
                
        Stream slowVehiclesStream =
                vehiclesStream
                        .min(new SpeedComparator()) // Comparator w.r.t speed on received tuple.
                        .each(vehicleField, new Debug("#### slowest vehicle"));

        vehiclesStream
                .minBy(Vehicle.FIELD_NAME, new EfficiencyComparator()) // Comparator w.r.t efficiency on received tuple.
                .each(vehicleField, new Debug("#### least efficient vehicle"));

</code></pre>
<p>这些 API 的示例应用程序可以位于 <a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfDevicesTopology.java">TridentMinMaxOfDevicesTopology</a> 和 <a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfVehiclesTopology.java">TridentMinMaxOfVehiclesTopology</a> .</p>
<h3 id="max-and-maxby">max and maxBy</h3>
<p><code>max</code> 和 <code>maxBy</code> operations （操作）在 trident stream 中的一 batch of tuples （批元组）的每个 partition （分区）上返回 maximum （最大值）.</p>
<p>假设 trident stream 包含上述部分所述的字段 ["device-id", "count"] .</p>
<p><code>max</code> 和 <code>maxBy</code> operations （操作）可以应用于上面的 stream of tuples （元组流）, 如下所示, 这导致每个分区的最大值为 <code>count</code> 字段的元组.</p>
<pre><code class="language-java">  mystream.maxBy(new Fields("count"))
</code></pre>
<p>上述代码在上述 partitions （分区）上的结果是:</p>
<pre><code>Partition 0:
[113, 54]


Partition 1:
[19,  174]


Partition 2:
[37,  98]

</code></pre>
<p>您可以在 Stream 上查看其他 <code>max</code> 和 <code>maxBy</code> 函数</p>
<pre><code class="language-java">
      public &lt;T&gt; Stream maxBy(String inputFieldName, Comparator&lt;T&gt; comparator) 
      public Stream max(Comparator&lt;TridentTuple&gt; comparator) 
      
</code></pre>
<p>下面的示例显示了如何使用这些 API 来使用元组上的 respective Comparators （相应比较器）来找到 maximum （最大值）.</p>
<pre><code class="language-java">
        FixedBatchSpout spout = new FixedBatchSpout(allFields, 10, Vehicle.generateVehicles(20));

        TridentTopology topology = new TridentTopology();
        Stream vehiclesStream = topology.newStream("spout1", spout).
                each(allFields, new Debug("##### vehicles"));

        vehiclesStream
                .max(new SpeedComparator()) // Comparator w.r.t speed on received tuple.
                .each(vehicleField, new Debug("#### fastest vehicle"))
                .project(driverField)
                .each(driverField, new Debug("##### fastest driver"));
        
        vehiclesStream
                .maxBy(Vehicle.FIELD_NAME, new EfficiencyComparator()) // Comparator w.r.t efficiency on received tuple.
                .each(vehicleField, new Debug("#### most efficient vehicle"));

</code></pre>
<p>这些 API 的示例应用程序可以位于 <a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfDevicesTopology.java">TridentMinMaxOfDevicesTopology</a> 和 <a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfVehiclesTopology.java">TridentMinMaxOfVehiclesTopology</a></p>
<h3 id="windowing">Windowing</h3>
<p>Trident streams 可以 batches （批处理）同一个 windowing （窗口）的元组, 并将 aggregated result （聚合结果）发送到下一个 operation （操作）. 有 2 种支持的 windowing （窗口）是基于 processing time （处理时间）或 tuples count （元组数）: 1. Tumbling window 2. Sliding window</p>
<h4 id="tumbling-window">Tumbling window</h4>
<p>基于 processing time （处理时间）或 count （计数）, 元组在 single window （单个窗口）中分组. 任何 tuple （元组）只属于其中一个 windows （窗口）.</p>
<pre><code class="language-java">
    /**
     * Returns a stream of tuples which are aggregated results of a tumbling window with every {@code windowCount} of tuples.
     */
    public Stream tumblingWindow(int windowCount, WindowsStoreFactory windowStoreFactory,
                                      Fields inputFields, Aggregator aggregator, Fields functionFields);
    
    /**
     * Returns a stream of tuples which are aggregated results of a window that tumbles at duration of {@code windowDuration}
     */
    public Stream tumblingWindow(BaseWindowedBolt.Duration windowDuration, WindowsStoreFactory windowStoreFactory,
                                     Fields inputFields, Aggregator aggregator, Fields functionFields);
                                     
</code></pre>
<h4 id="sliding-window">Sliding window</h4>
<p>每个 sliding interval （滑动间隔）, Tuples （元组）被分组在 windows （窗口）和 window slides 中.元组可以属于多个 window （窗口）.</p>
<pre><code class="language-java"> 
    /**
     * Returns a stream of tuples which are aggregated results of a sliding window with every {@code windowCount} of tuples
     * and slides the window after {@code slideCount}.
     */
    public Stream slidingWindow(int windowCount, int slideCount, WindowsStoreFactory windowStoreFactory,
                                      Fields inputFields, Aggregator aggregator, Fields functionFields);
     
    /**
     * Returns a stream of tuples which are aggregated results of a window which slides at duration of {@code slidingInterval}
     * and completes a window at {@code windowDuration}
     */
    public Stream slidingWindow(BaseWindowedBolt.Duration windowDuration, BaseWindowedBolt.Duration slidingInterval,
                                    WindowsStoreFactory windowStoreFactory, Fields inputFields, Aggregator aggregator, Fields functionFields);
</code></pre>
<p>tumbling 和 sliding windows 的示例可以在 <a href="Windowing.html">这里</a> 被找到.</p>
<h4 id="通用-windowing-api">通用 windowing API</h4>
<p>以下是通用的 windowing API, 它为任何支持的 windowing 配置提供了 <code>WindowConfig</code> .</p>
<pre><code class="language-java">
    public Stream window(WindowConfig windowConfig, WindowsStoreFactory windowStoreFactory, Fields inputFields,
                         Aggregator aggregator, Fields functionFields)
                         
</code></pre>
<p><code>windowConfig</code> 可以是下面的任何一个.</p>
<ul>
<li><code>SlidingCountWindow.of(int windowCount, int slidingCount)</code></li>
<li><code>SlidingDurationWindow.of(BaseWindowedBolt.Duration windowDuration, BaseWindowedBolt.Duration slidingDuration)</code></li>
<li><code>TumblingCountWindow.of(int windowLength)</code></li>
<li><code>TumblingDurationWindow.of(BaseWindowedBolt.Duration windowLength)</code></li>
</ul>
<p>Trident windowing APIs 需要 <code>WindowsStoreFactory</code> 来存储接收的 tuples 和 aggregated values （聚合值）. 目前, HBase 的基本实现由 <code>HBaseWindowsStoreFactory</code> 提供. 可以进一步扩展以解决各自的用途. 使用 <code>HBaseWindowStoreFactory</code> 进行 windowing 的例子可以在下面看到.</p>
<pre><code class="language-java">
    // window-state table should already be created with cf:tuples column
    HBaseWindowsStoreFactory windowStoreFactory = new HBaseWindowsStoreFactory(new HashMap&lt;String, Object&gt;(), "window-state", "cf".getBytes("UTF-8"), "tuples".getBytes("UTF-8"));
    FixedBatchSpout spout = new FixedBatchSpout(new Fields("sentence"), 3, new Values("the cow jumped over the moon"),
            new Values("the man went to the store and bought some candy"), new Values("four score and seven years ago"),
            new Values("how many apples can you eat"), new Values("to be or not to be the person"));
    spout.setCycle(true);

    TridentTopology topology = new TridentTopology();

    Stream stream = topology.newStream("spout1", spout).parallelismHint(16).each(new Fields("sentence"),
            new Split(), new Fields("word"))
            .window(TumblingCountWindow.of(1000), windowStoreFactory, new Fields("word"), new CountAsAggregator(), new Fields("count"))
            .peek(new Consumer() {
                @Override
                public void accept(TridentTuple input) {
                    LOG.info("Received tuple: [{}]", input);
                }
            });

    StormTopology stormTopology =  topology.build();
    
</code></pre>
<p>可以在 <a href="javadocs/org/apache/storm/trident/Stream.html">这里</a> 中找到本节中所有上述 API 的详细说明.</p>
<h4 id="示例应用程序">示例应用程序</h4>
<p>这些 API 的示例应用程序位于 <a href="{{page.git-blob-base}}/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentHBaseWindowingStoreTopology.java">TridentHBaseWindowingStoreTopology</a> 和 <a href="{{page.git-blob-base}}/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentWindowingInmemoryStoreTopology.java">TridentWindowingInmemoryStoreTopology</a></p>
<h3 id="partitionaggregate">partitionAggregate</h3>
<p>partitionAggregate 在每个 batch of tuples （批量元组） partition 上执行一个 function 操作（实际上是聚合操作）, 但它又不同于上面的 functions 操作, partitionAggregate 的输出 tuple 将会取代收到的输入 tuple , 如下面的例子:</p>
<pre><code class="language-java">mystream.partitionAggregate(new Fields("b"), new Sum(), new Fields("sum"))
</code></pre>
<p>假设 input stream 包括字段 ["a", "b"] , 并有下面的 partitions of tuples （元组 partitions ）:</p>
<pre><code>Partition 0:
["a", 1]
["b", 2]

Partition 1:
["a", 3]
["c", 8]

Partition 2:
["e", 1]
["d", 9]
["d", 10]
</code></pre>
<p>则这段代码的 output stream 包含如下 tuple , 且只有一个 "sum" 的字段:</p>
<pre><code>Partition 0:
[3]

Partition 1:
[11]

Partition 2:
[20]
</code></pre>
<p>上面代码中的 new Sum() 实际上是一个 aggregator （聚合器）, 定义一个聚合器有三种不同的接口:CombinerAggregator, ReducerAggregator 和 Aggregator .</p>
<p>下面是 CombinerAggregator 接口:</p>
<pre><code class="language-java">public interface CombinerAggregator&lt;T&gt; extends Serializable {
    T init(TridentTuple tuple);
    T combine(T val1, T val2);
    T zero();
}
</code></pre>
<p>一个 CombinerAggregator 仅输出一个 tuple （该 tuple 也只有一个字段）.每收到一个输入 tuple, CombinerAggregator 就会执行 init() 方法（该方法返回一个初始值）, 并且用 combine() 方法汇总这些值, 直到剩下一个值为止（聚合值）.如果 partition 中没有 tuple, CombinerAggregator 会发送 zero() 的返回值.下面是聚合器 Count 的实现:</p>
<pre><code class="language-java">public class Count implements CombinerAggregator&lt;Long&gt; {
    public Long init(TridentTuple tuple) {
        return 1L;
    }

    public Long combine(Long val1, Long val2) {
        return val1 + val2;
    }

    public Long zero() {
        return 0L;
    }
}
</code></pre>
<p>当使用 aggregate() 方法代替 partitionAggregate() 方法时, 就能看到 CombinerAggregation 带来的好处.这种情况下, Trident 会自动优化计算:先做局部聚合操作, 然后再通过网络传输 tuple 进行全局聚合.</p>
<p>ReducerAggregator 接口如下:</p>
<pre><code class="language-java">public interface ReducerAggregator&lt;T&gt; extends Serializable {
    T init();
    T reduce(T curr, TridentTuple tuple);
}
</code></pre>
<p>ReducerAggregator 使用 init() 方法产生一个初始值, 对于每个输入 tuple , 依次迭代这个初始值, 最终产生一个单值输出 tuple .下面示例了如何将 Count 定义为 ReducerAggregator:</p>
<pre><code class="language-java">public class Count implements ReducerAggregator&lt;Long&gt; {
    public Long init() {
        return 0L;
    }
    
    public Long reduce(Long curr, TridentTuple tuple) {
        return curr + 1;
    }
}
</code></pre>
<p>ReducerAggregator 也可以与 persistentAggregate 一起使用, 稍后你会看到的.</p>
<p>用于 performing aggregations （执行聚合）的最通用的接口是 Aggregator , 如下所示:</p>
<pre><code class="language-java">public interface Aggregator&lt;T&gt; extends Operation {
    T init(Object batchId, TridentCollector collector);
    void aggregate(T state, TridentTuple tuple, TridentCollector collector);
    void complete(T state, TridentCollector collector);
}
</code></pre>
<p>Aggregator 可以输出任意数量的 tuple , 且这些 tuple 的字段也可以有多个.执行过程中的任何时候都可以输出 tuple （三个方法的参数中都有 collector ）. Aggregator 的执行方式如下:</p>
<ol>
<li>处理每个 batch 之前调用一次 init() 方法, 该方法的返回值是一个对象, 代表 aggregation 的状态, 并且会传递给下面的 aggregate() 和 complete() 方法.</li>
<li>每个收到一个该 batch 中的输入 tuple 就会调用一次 aggregate , 该方法中可以 update the state （更新状态）（第一点中 init() 方法的返回值）并 optionally emit tuples （可选地发出元组）.</li>
<li>当该 batch partition 中的所有 tuple 都被 aggregate() 方法处理完之后调用 complete 方法.</li>
</ol>
<p>注:理解 batch, partition 之间的区别将会更好的理解上面的几个方法.</p>
<p>下面的代码将 Count 作为 Aggregator 实现:</p>
<pre><code class="language-java">public class CountAgg extends BaseAggregator&lt;CountState&gt; {
    static class CountState {
        long count = 0;
    }

    public CountState init(Object batchId, TridentCollector collector) {
        return new CountState();
    }

    public void aggregate(CountState state, TridentTuple tuple, TridentCollector collector) {
        state.count+=1;
    }

    public void complete(CountState state, TridentCollector collector) {
        collector.emit(new Values(state.count));
    }
}
</code></pre>
<p>有时需要同时执行 multiple aggregators （多个聚合）操作, 这个可以使用 chaining （链式）操作完成:</p>
<pre><code class="language-java">mystream.chainedAgg()
        .partitionAggregate(new Count(), new Fields("count"))
        .partitionAggregate(new Fields("b"), new Sum(), new Fields("sum"))
        .chainEnd()
</code></pre>
<p>这段代码将会对每个 partition 执行 Count 和 Sum aggregators （聚合器）, 并输出一个tuple 字段 ["count", "sum"].</p>
<h3 id="statequery-and-partitionpersist">stateQuery and partitionPersist</h3>
<p>stateQuery 和 partitionPersist 分别 query （查询）和 update （更新） sources of state （状态源）. 您可以在 <a href="Trident-state.html">Trident state doc</a> 上阅读有关如何使用它们.</p>
<h3 id="projection">projection</h3>
<p>经 Stream 中的 project 方法处理后的 tuple 仅保持指定字段（相当于过滤字段）.如果你有一个包含字段 ["a", "b", "c", "d"] 的 stream , 执行下面代码:</p>
<pre><code class="language-java">mystream.project(new Fields("b", "d"))
</code></pre>
<p>则 output stream 将仅包含 ["b", "d"] 字段.</p>
<h2 id="repartitioning-operations">Repartitioning operations</h2>
<p>Repartitioning operations （重新分区操作）运行一个函数来 change how the tuples are partitioned across tasks （更改元组在任务之间的分区）. number of partitions （分区的数量）也可以由于 repartitioning （重新分区）而改变（例如, 如果并行提示在 repartioning （重新分配）后更大）. Repartitioning （重新分区）需要 network transfer （网络传输）. 以下是 repartitioning functions （重新分区功能）:</p>
<ol>
<li>shuffle: 随机将 tuple 均匀地分发到目标 partition 里.</li>
<li>broadcast: 每个 tuple 被复制到所有的目标 partition 里, 在 DRPC 中有用 — 你可以在每个 partition 上使用 stateQuery .</li>
<li>partitionBy: 对每个 tuple 选择 partition 的方法是:(该 tuple 指定字段的 hash 值) mod (目标 partition 的个数), 该方法确保指定字段相同的 tuple 能够被发送到同一个 partition .（但同一个 partition 里可能有字段不同的 tuple ）.</li>
<li>global: 所有的 tuple 都被发送到同一个 partition .</li>
<li>batchGlobal: 确保同一个 batch 中的 tuple 被发送到相同的 partition 中.</li>
<li>partition: 此方法采用实现 org.apache.storm.grouping.CustomStreamGrouping 的自定义分区函数.</li>
</ol>
<h2 id="aggregation-operations">Aggregation operations</h2>
<p>Trident 中有 aggregate() 和 persistentAggregate() 方法对流进行聚合操作. aggregate() 在每个 batch 上独立的执行, persistemAggregate() 对所有 batch 中的所有 tuple 进行聚合, 并将结果存入 state 源中.</p>
<p>aggregate() 对 Stream 做全局聚合, 当使用 ReduceAggregator 或者 Aggregator 聚合器时, 流先被重新划分成一个大分区(仅有一个 partition ), 然后对这个 partition 做聚合操作;另外, 当使用 CombinerAggregator 时, Trident 首先对每个 partition 局部聚合, 然后将所有这些 partition 重新划分到一个 partition 中, 完成全局聚合.相比而言, CombinerAggregator 更高效, 推荐使用.</p>
<p>下面的例子使用 aggregate() 对一个 batch 操作得到一个全局的 count:</p>
<pre><code class="language-java">mystream.aggregate(new Count(), new Fields("count"))
</code></pre>
<p>同在 partitionAggregate 中一样, aggregate 中的聚合器也可以使用链式用法.但是, 如果你将一个 CombinerAggregator 链到一个非 CombinerAggregator 后面, Trident 就不能做局部聚合优化.</p>
<p>关于 persistentAggregate 的用法请参见 <a href="Trident-state.html">Trident state doc</a> 一文.</p>
<h2 id="operations-on-grouped-streams">Operations on grouped streams</h2>
<p>groupBy 操作先对流中的指定字段做 partitionBy 操作, 让指定字段相同的 tuple 能被发送到同一个 partition 里.然后在每个 partition 里根据指定字段值对该分区里的 tuple 进行分组.下面演示了 groupBy 操作的过程:</p>
<p><a href="https://img.cntofu.com/book/storm-doc-zh/doc/zh/images/grouping.png" data-uk-lightbox><img src="https://img.cntofu.com/book/storm-doc-zh/doc/zh/images/grouping.png" alt="Grouping"></a></p>
<p>如果你在一个 grouped stream 上做聚合操作, 聚合操作将会在每个 group （分组）内进行, 而不是整个 batch 上. GroupStream 类中也有 persistentAggregate 方法, 该方法聚合的结果将会存储在一个 key 值为分组字段(即 groupBy 中指定的字段)的 <a href="{{page.git-blob-base}}/storm-core/src/jvm/org/apache/storm/trident/state/map/MapState.java">MapState</a> 中, 这些还是在 <a href="Trident-state.html">Trident state doc</a> 一文中讲解.</p>
<p>和普通的 stream 一样, groupstream 上的聚合操作也可以使用 chained （链式语法）.</p>
<h2 id="merges-and-joins">Merges and joins</h2>
<p>最后一部分 API 内容是关于将几个 stream 汇总到一起, 最简单的汇总方法是将他们合并成一个 stream , 这个可以通过 TridentTopology 中的 merge 方法完成, 就像这样:</p>
<pre><code class="language-java">topology.merge(stream1, stream2, stream3);
</code></pre>
<p>Trident 将把新的 merged stream 的 output fields 命名为第一个 stream 的 output fields （输出字段）.</p>
<p>另一种 combine streams （汇总方法）是使用 join （连接, 类似于 sql 中的连接操作, 需要有限的输入）.所以, 它们对于 infinite streams （无限流）是没有意义的. Joins in Trident 仅适用于从 spout 发出的每个 small batch 中.</p>
<p>以下是包含字段 ["key", "val1", "val2"] 的 stream 和包含 ["x", "val1"] 的另一个 stream 之间的 join 示例:</p>
<pre><code class="language-java">topology.join(stream1, new Fields("key"), stream2, new Fields("x"), new Fields("key", "a", "b", "c"));
</code></pre>
<p>使用 "key" 和 "x" 作为每个相应流的连接字段将 stream1 和 stream2 join 在一起.然后, Trident 要求命名 new stream 的所有 output fields , 因为 input streams 可能具有 overlapping field names （重叠的字段名称）.从 join 发出的 tuples 将包含:</p>
<ol>
<li>list of join fields （连接字段列表）.在这种情况下, "key" 对应于 stream1 的 "key" , stream2 对应于 "x" .</li>
<li>接下来, 按照 streams 如何传递到 join 方法的顺序, 所有流中的所有 non-join fields （非连接字段）的列表.在这种情况下, "a" 和 "b" 对应于来自 stream1 的 "val1" 和 "val2" , "c" 对应于来自 stream2 的 "val1" .</li>
</ol>
<p>当来自不同 spouts 的 stream 之间发生 join 时, 这些 spouts 将与它们如何 emit batches （发出批次）同步.也就是说, 一批处理将包括 tuples from each spout （每个 spout 的元组）.</p>
<p>你可能会想知道 - 你如何做一些像 "windowed join" 这样的事情, 其中从 join 的一边的 tuples 连接 join 另一边的最后一个小时的 tuples .</p>
<p>为此, 您将使用 partitionPersist 和 stateQuery .join 一端的元组的最后一小时将被存储并在 source of state （状态源）中旋转, 并由 join 字段键入.然后 stateQuery 将通过连接字段进行查找以执行 "join".</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/198/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/storm_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/198/index.html">大数据入门指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/113.html">heibaiying</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="storm">storm</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">98页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/161/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/161/index.html">关于python的面试题</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/92.html">jackfrued</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">271页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 33个">33</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/94/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/machine-learning_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/94/index.html">机器学习实战</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/57.html">RedstoneWill</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="machine-learning">machine-learning</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">24页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7个">7</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/171/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/171/index.html">[译] 写给不耐烦程序员的 JavaScript</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/18.html">ApacheCN</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">52页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 145个">145</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/148/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/148/index.html">移动前端开发收藏夹</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/80.html">hoosin</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1405个">1405</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/197/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/ubuntu_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/197/index.html">手把手教你，搭建内网穿透服务</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/112.html">frank-lam</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="ubuntu">ubuntu</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">45页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 189个">189</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../../" title="返回首页"><img class="" src="../../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../../book/108/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/README.html" title="Introduction" data-book-page-rel-url="README.html" data-book-page-id="7785">Introduction</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm 基础" disabled data-book-page-rel-url="" data-book-page-id="7786">Storm 基础</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Javadoc.html" title="Javadoc" data-book-page-rel-url="doc/zh/Javadoc.html" data-book-page-id="7787">Javadoc</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Concepts.html" title="概念" data-book-page-rel-url="doc/zh/Concepts.html" data-book-page-id="7788">概念</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Storm-Scheduler.html" title="调度器" data-book-page-rel-url="doc/zh/Storm-Scheduler.html" data-book-page-id="7789">调度器</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Configuration.html" title="配置" data-book-page-rel-url="doc/zh/Configuration.html" data-book-page-id="7790">配置</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Guaranteeing-message-processing.html" title="保证消息处理" data-book-page-rel-url="doc/zh/Guaranteeing-message-processing.html" data-book-page-id="7791">保证消息处理</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Daemon-Fault-Tolerance.html" title="Daemon（守护进程）容错" data-book-page-rel-url="doc/zh/Daemon-Fault-Tolerance.html" data-book-page-id="7792">Daemon（守护进程）容错</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Command-line-client.html" title="命令行 client（客户端）" data-book-page-rel-url="doc/zh/Command-line-client.html" data-book-page-id="7793">命令行 client（客户端）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/STORM-UI-REST-API.html" title="REST API" data-book-page-rel-url="doc/zh/STORM-UI-REST-API.html" data-book-page-id="7794">REST API</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Understanding-the-parallelism-of-a-Storm-topology.html" title="理解 Storm topology 的 parallelism（并行度）" data-book-page-rel-url="doc/zh/Understanding-the-parallelism-of-a-Storm-topology.html" data-book-page-id="7795">理解 Storm topology 的 parallelism（并行度）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/FAQ.html" title="FAQ" data-book-page-rel-url="doc/zh/FAQ.html" data-book-page-id="7796">FAQ</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm Trident" disabled data-book-page-rel-url="" data-book-page-id="7797">Storm Trident</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Layers on Top of Storm" disabled data-book-page-rel-url="" data-book-page-id="7798">Layers on Top of Storm</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Trident-tutorial.html" title="Trident 教程" data-book-page-rel-url="doc/zh/Trident-tutorial.html" data-book-page-id="7799">Trident 教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Trident-API-Overview.html" title="Trident API 概述" data-book-page-rel-url="doc/zh/Trident-API-Overview.html" data-book-page-id="7800">Trident API 概述</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Trident-state.html" title="Trident State（状态）" data-book-page-rel-url="doc/zh/Trident-state.html" data-book-page-id="7801">Trident State（状态）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Trident-spouts.html" title="Trident spouts" data-book-page-rel-url="doc/zh/Trident-spouts.html" data-book-page-id="7802">Trident spouts</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Trident-RAS-API.html" title="Trident RAS API" data-book-page-rel-url="doc/zh/Trident-RAS-API.html" data-book-page-id="7803">Trident RAS API</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm SQL" disabled data-book-page-rel-url="" data-book-page-id="7804">Storm SQL</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-sql.html" title="Storm SQL 概述" data-book-page-rel-url="doc/zh/storm-sql.html" data-book-page-id="7805">Storm SQL 概述</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-sql-example.html" title="Storm SQL 示例" data-book-page-rel-url="doc/zh/storm-sql-example.html" data-book-page-id="7806">Storm SQL 示例</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-sql-reference.html" title="Storm SQL 文献" data-book-page-rel-url="doc/zh/storm-sql-reference.html" data-book-page-id="7807">Storm SQL 文献</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-sql-internal.html" title="Storm SQL 结构" data-book-page-rel-url="doc/zh/storm-sql-internal.html" data-book-page-id="7808">Storm SQL 结构</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Flux" disabled data-book-page-rel-url="" data-book-page-id="7809">Flux</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/flux.html" title="Flux Data Driven Topology Builder" data-book-page-rel-url="doc/zh/flux.html" data-book-page-id="7810">Flux Data Driven Topology Builder</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm 安装和部署" disabled data-book-page-rel-url="" data-book-page-id="7811">Storm 安装和部署</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Setting-up-a-Storm-cluster.html" title="安装一个 Storm 集群" data-book-page-rel-url="doc/zh/Setting-up-a-Storm-cluster.html" data-book-page-id="7812">安装一个 Storm 集群</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Local-mode.html" title="Local mode（本地模式）" data-book-page-rel-url="doc/zh/Local-mode.html" data-book-page-id="7813">Local mode（本地模式）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Troubleshooting.html" title="问题排查" data-book-page-rel-url="doc/zh/Troubleshooting.html" data-book-page-id="7814">问题排查</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Running-topologies-on-a-production-cluster.html" title="在生产 cluster（集群）上运行 topologies（拓扑）" data-book-page-rel-url="doc/zh/Running-topologies-on-a-production-cluster.html" data-book-page-id="7815">在生产 cluster（集群）上运行 topologies（拓扑）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Maven.html" title="构建 Storm with Maven" data-book-page-rel-url="doc/zh/Maven.html" data-book-page-id="7816">构建 Storm with Maven</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/SECURITY.html" title="安装 Secure（安全的）Cluster（集群）" data-book-page-rel-url="doc/zh/SECURITY.html" data-book-page-id="7817">安装 Secure（安全的）Cluster（集群）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/cgroups_in_storm.html" title="CGroup 的实施" data-book-page-rel-url="doc/zh/cgroups_in_storm.html" data-book-page-id="7818">CGroup 的实施</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Pacemaker.html" title="Pacemaker 针对大集群减低在 zookeeper 上的负载" data-book-page-rel-url="doc/zh/Pacemaker.html" data-book-page-id="7819">Pacemaker 针对大集群减低在 zookeeper 上的负载</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Resource_Aware_Scheduler_overview.html" title="Resource Aware Scheduler（资源意识调度器）" data-book-page-rel-url="doc/zh/Resource_Aware_Scheduler_overview.html" data-book-page-id="7820">Resource Aware Scheduler（资源意识调度器）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-metrics-profiling-internal-actions.html" title="Daemon Metrics/Monitoring（守护进程的度量/监控）" data-book-page-rel-url="doc/zh/storm-metrics-profiling-internal-actions.html" data-book-page-id="7821">Daemon Metrics/Monitoring（守护进程的度量/监控）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/windows-users-guide.html" title="Windows 平台的用户指南" data-book-page-rel-url="doc/zh/windows-users-guide.html" data-book-page-id="7822">Windows 平台的用户指南</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm 中级" disabled data-book-page-rel-url="" data-book-page-id="7823">Storm 中级</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Serialization.html" title="Serialization（序列化）" data-book-page-rel-url="doc/zh/Serialization.html" data-book-page-id="7824">Serialization（序列化）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Common-patterns.html" title="Common patterns（常见模式）" data-book-page-rel-url="doc/zh/Common-patterns.html" data-book-page-id="7825">Common patterns（常见模式）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Clojure-DSL.html" title="Clojure DSL" data-book-page-rel-url="doc/zh/Clojure-DSL.html" data-book-page-id="7826">Clojure DSL</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Using-non-JVM-languages-with-Storm.html" title="与 Storm 一起使用非 JVM 的语言" data-book-page-rel-url="doc/zh/Using-non-JVM-languages-with-Storm.html" data-book-page-id="7827">与 Storm 一起使用非 JVM 的语言</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Distributed-RPC.html" title="分布式的 RPC" data-book-page-rel-url="doc/zh/Distributed-RPC.html" data-book-page-id="7828">分布式的 RPC</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Transactional-topologies.html" title="Transactional topologies（事务性的拓扑）" data-book-page-rel-url="doc/zh/Transactional-topologies.html" data-book-page-id="7829">Transactional topologies（事务性的拓扑）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Hooks.html" title="Hooks（钩子）" data-book-page-rel-url="doc/zh/Hooks.html" data-book-page-id="7830">Hooks（钩子）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Metrics.html" title="Metrics（度量）" data-book-page-rel-url="doc/zh/Metrics.html" data-book-page-id="7831">Metrics（度量）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/State-checkpointing.html" title="State Checkpointing" data-book-page-rel-url="doc/zh/State-checkpointing.html" data-book-page-id="7832">State Checkpointing</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Windowing.html" title="Windowing（窗口操作）" data-book-page-rel-url="doc/zh/Windowing.html" data-book-page-id="7833">Windowing（窗口操作）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Joins.html" title="Joining Streams" data-book-page-rel-url="doc/zh/Joins.html" data-book-page-id="7834">Joining Streams</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/distcache-blobstore.html" title="Blobstore(Distcahce)" data-book-page-rel-url="doc/zh/distcache-blobstore.html" data-book-page-id="7835">Blobstore(Distcahce)</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm 调试" disabled data-book-page-rel-url="" data-book-page-id="7836">Storm 调试</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/dynamic-log-level-settings.html" title="Dynamic Log Level Settings" data-book-page-rel-url="doc/zh/dynamic-log-level-settings.html" data-book-page-id="7837">Dynamic Log Level Settings</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Logs.html" title="Searching Worker Logs" data-book-page-rel-url="doc/zh/Logs.html" data-book-page-id="7838">Searching Worker Logs</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/dynamic-worker-profiling.html" title="Worker Profiling" data-book-page-rel-url="doc/zh/dynamic-worker-profiling.html" data-book-page-id="7839">Worker Profiling</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Eventlogging.html" title="Event Logging" data-book-page-rel-url="doc/zh/Eventlogging.html" data-book-page-id="7840">Event Logging</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm 与外部系统, 以及其它库的集成" disabled data-book-page-rel-url="" data-book-page-id="7841">Storm 与外部系统, 以及其它库的集成</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-kafka.html" title="Apache Kafka 集成" data-book-page-rel-url="doc/zh/storm-kafka.html" data-book-page-id="7842">Apache Kafka 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-kafka-client.html" title="新的 Kafka Consumer（消费者）集成" data-book-page-rel-url="doc/zh/storm-kafka-client.html" data-book-page-id="7843">新的 Kafka Consumer（消费者）集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-hbase.html" title="Apache HBase 集成" data-book-page-rel-url="doc/zh/storm-hbase.html" data-book-page-id="7844">Apache HBase 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-hdfs.html" title="Apache HDFS 集成" data-book-page-rel-url="doc/zh/storm-hdfs.html" data-book-page-id="7845">Apache HDFS 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-hive.html" title="Apache Hive 集成" data-book-page-rel-url="doc/zh/storm-hive.html" data-book-page-id="7846">Apache Hive 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-solr.html" title="Apache Solr 集成" data-book-page-rel-url="doc/zh/storm-solr.html" data-book-page-id="7847">Apache Solr 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-cassandra.html" title="Apache Cassandra 集成" data-book-page-rel-url="doc/zh/storm-cassandra.html" data-book-page-id="7848">Apache Cassandra 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-jdbc.html" title="JDBC 集成" data-book-page-rel-url="doc/zh/storm-jdbc.html" data-book-page-id="7849">JDBC 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-jms.html" title="JMS 集成" data-book-page-rel-url="doc/zh/storm-jms.html" data-book-page-id="7850">JMS 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-redis.html" title="Redis 集成" data-book-page-rel-url="doc/zh/storm-redis.html" data-book-page-id="7851">Redis 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-eventhubs.html" title="Event Hubs 集成" data-book-page-rel-url="doc/zh/storm-eventhubs.html" data-book-page-id="7852">Event Hubs 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-elasticsearch.html" title="Elasticsearch 集成" data-book-page-rel-url="doc/zh/storm-elasticsearch.html" data-book-page-id="7853">Elasticsearch 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-mqtt.html" title="MQTT 集成" data-book-page-rel-url="doc/zh/storm-mqtt.html" data-book-page-id="7854">MQTT 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-mongodb.html" title="Mongodb 集成" data-book-page-rel-url="doc/zh/storm-mongodb.html" data-book-page-id="7855">Mongodb 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-opentsdb.html" title="OpenTSDB 集成" data-book-page-rel-url="doc/zh/storm-opentsdb.html" data-book-page-id="7856">OpenTSDB 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-kinesis.html" title="Kinesis 集成" data-book-page-rel-url="doc/zh/storm-kinesis.html" data-book-page-id="7857">Kinesis 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-druid.html" title="Druid 集成" data-book-page-rel-url="doc/zh/storm-druid.html" data-book-page-id="7858">Druid 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Kestrel-and-Storm.html" title="Kestrel 集成" data-book-page-rel-url="doc/zh/Kestrel-and-Storm.html" data-book-page-id="7859">Kestrel 集成</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Container, Resource Management System Integration" disabled data-book-page-rel-url="" data-book-page-id="7860">Container, Resource Management System Integration</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/storm-yarn.html" title="YARN 集成" data-book-page-rel-url="doc/zh/storm-yarn.html" data-book-page-id="7861">YARN 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/mesos-storm.html" title="Mesos 集成" data-book-page-rel-url="doc/zh/mesos-storm.html" data-book-page-id="7862">Mesos 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/docker-storm.html" title="Docker 集成" data-book-page-rel-url="doc/zh/docker-storm.html" data-book-page-id="7863">Docker 集成</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/kubernetes-storm.html" title="Kubernetes 集成" data-book-page-rel-url="doc/zh/kubernetes-storm.html" data-book-page-id="7864">Kubernetes 集成</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Storm 高级" disabled data-book-page-rel-url="" data-book-page-id="7865">Storm 高级</a>
<ul>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Defining-a-non-jvm-language-dsl-for-storm.html" title="为 Storm 定义非 JVM 语言的 DSL" data-book-page-rel-url="doc/zh/Defining-a-non-jvm-language-dsl-for-storm.html" data-book-page-id="7866">为 Storm 定义非 JVM 语言的 DSL</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Multilang-protocol.html" title="多语言协议（如何为其它语言提供支持）" data-book-page-rel-url="doc/zh/Multilang-protocol.html" data-book-page-id="7867">多语言协议（如何为其它语言提供支持）</a>
</li>
<li>
<a class="pjax" href="../../../../book/108/doc/zh/Implementation-docs.html" title="实现文档" data-book-page-rel-url="doc/zh/Implementation-docs.html" data-book-page-id="7868">实现文档</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =108;var bookPageId =7800;var bookPageRelUrl ='doc/zh/Trident-API-Overview.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>