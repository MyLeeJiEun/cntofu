
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>torch.nn-PyTorch 1.0 中文文档 & 教程</title>
<meta content='torch.nn,PyTorch 1.0 中文文档 & 教程' name='keywords'>
<meta content='torch.nn,PyTorch 1.0 中文文档 & 教程' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../../book/169/docs/1.0/storage.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">torch.Stora..</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../../book/169/docs/1.0/nn_functional.html">
<span class="">torch.nn.fu..</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../../book/169/index.html">PyTorch 1.0 中文文档 & 教程</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/pytorch-doc-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="torchnn">torch.nn</h1>
<h2 id="parameters参数">Parameters（参数）</h2>
<pre><code class="language-py">class torch.nn.Parameter
</code></pre>
<p>Parameters对象是一种会被视为模块参数（module parameter）的Tensor张量。</p>
<p>Parameters类是<a href="tensors.html#torch.Tensor" title="torch.Tensor"><code>Tensor</code></a> 的子类, 不过相对于它的父类，Parameters类有一个很重要的特性就是当其在 <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类中被使用并被当做这个<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类的模块属性的时候，那么这个Parameters对象会被自动地添加到这个<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类的参数列表(list of parameters)之中，同时也就会被添加入此<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类的 <a href="#torch.nn.Module.parameters" title="torch.nn.Module.parameters"><code>parameters()</code></a>方法所返回的参数迭代器中。而Parameters类的父类Tensor类也可以被用为构建模块的属性，但不会被加入参数列表。这样主要是因为，有时可能需要在模型中存储一些非模型参数的临时状态，比如RNN中的最后一个隐状态。而通过使用非<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>的Tensor类，可以将这些临时变量注册(register)为模型的属性的同时使其不被加入参数列表。</p>
<p>Parameters:</p>
<ul>
<li><strong>data</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 参数张量(parameter tensor).</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 参数是否需要梯度， 默认为 <code>True</code>。更多细节请看 <a href="notes/autograd.html#excluding-subgraphs">如何将子图踢出反向传播过程</a>。</li>
</ul>
<h2 id="containers容器">Containers（容器）</h2>
<h3 id="module模块">Module（模块）</h3>
<pre><code class="language-py">class torch.nn.Module
</code></pre>
<p>模块（Module）是所有神经网络模型的基类。</p>
<p>你创建模型的时候也应该继承这个类哦。</p>
<p>模块(Module)中还可以包含其他的模块，你可以将一个模块赋值成为另一个模块的属性，从而成为这个模块的一个子模块。而通过不断的赋值，你可以将不同的模块组织成一个树结构:</p>
<pre><code class="language-py">import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5) # 当前的nn.Conv2d模块就被赋值成为Model模块的一个子模块，成为“树结构”的叶子
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
       x = F.relu(self.conv1(x))
       return F.relu(self.conv2(x))

</code></pre>
<p>通过赋值这种方式添加的子模块将会被模型注册(register)，而后当调用模块的一些参数转换函数（<a href="#torch.nn.Module.to" title="torch.nn.Module.to"><code>to()</code></a>）的时候，子模块的参数也会一并转换。</p>
<pre><code class="language-py">add_module(name, module)
</code></pre>
<p>向当前模块添加一个子模块。 此子模块可以作为当前模块的属性被访问到，而属性名就是add_module()函数中的name参数。</p>
<p>add_module()函数参数:</p>
<ul>
<li><strong>name</strong> (<em>string</em>) – 子模块的名字. 函数调用完成后，可以通过访问当前模块的此字段来访问该子模块。</li>
<li><strong>parameter</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – 要添加到当前模块的子模块。</li>
</ul>
<pre><code class="language-py">apply(fn)
</code></pre>
<p>apply()函数的主要作用是将 <code>fn</code> 递归地应用于模块的所有子模块（<code>.children()</code>函数的返回值）以及模块自身。此函数的一个经典应用就是初始化模型的所有参数这一过程(同样参见于 torch-nn-init)。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>fn</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> -&gt; None) – 要应用于所有子模型的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; def init_weights(m):
 print(m)
 if type(m) == nn.Linear:
 m.weight.data.fill_(1.0)
 print(m.weight)

&gt;&gt;&gt; net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
&gt;&gt;&gt; net.apply(init_weights) # 将init_weights()函数应用于模块的所有子模块
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
 [ 1.,  1.]])
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
 [ 1.,  1.]])
Sequential(
 (0): Linear(in_features=2, out_features=2, bias=True)
 (1): Linear(in_features=2, out_features=2, bias=True)
)
Sequential(
 (0): Linear(in_features=2, out_features=2, bias=True)
 (1): Linear(in_features=2, out_features=2, bias=True)
)

</code></pre>
<pre><code class="language-py">buffers(recurse=True)
</code></pre>
<p>返回模块的缓冲区的迭代器</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – 如果设置为True，产生的缓冲区迭代器会遍历模块自己与所有子模块，否则只会遍历模块的直连的成员。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Yields:</td>
<td><em>torch.Tensor</em> – 模型缓冲区</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>举例:</p>
<pre><code class="language-py">&gt;&gt;&gt; for buf in model.buffers():
&gt;&gt;&gt;     print(type(buf.data), buf.size())
&lt;class 'torch.FloatTensor'&gt; (20L,)
&lt;class 'torch.FloatTensor'&gt; (20L, 1L, 5L, 5L)

</code></pre>
<pre><code class="language-py">children()
</code></pre>
<p>返回一个当前所有子模块的迭代器 Returns an iterator over immediate children modules.</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>Module</em> – 子模块</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">cpu()
</code></pre>
<p>将模型的所有参数(parameter)和缓冲区(buffer)都转移到CPU内存中。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">cuda(device=None)
</code></pre>
<p>将模型的所有参数和缓冲区都转移到CUDA设备内存中。</p>
<p>因为cuda()函数同时会将处理模块中的所有参数并缓存这些参数的对象。所以如果想让模块在GPU上进行优化操作，一定要在构建优化器之前调用模块的cuda()函数。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>device</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 如果设备编号被指定，所有的参数都会被拷贝到编号指定设备上</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">double()
</code></pre>
<p>将所有的浮点数类型的参数(parameters)和缓冲区(buffers)转换为<code>double</code>数据类型。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">dump_patches = False
</code></pre>
<p>这个字段可以为<a href="#torch.nn.Module.load_state_dict" title="torch.nn.Module.load_state_dict"><code>load_state_dict()</code></a>提供 BC 支持（BC support实在不懂是什么意思-.-）。 在 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict()</code></a>函数返回的状态字典（state dict）中， 有一个名为<code>_metadata</code>的属性中存储了这个state_dict的版本号。<code>_metadata</code>是一个遵从了状态字典（state dict）的命名规范的关键字字典， 要想了解这个<code>_metadata</code>在加载状态（loading state dict）的时候是怎么用的，可以看一下 <code>_load_from_state_dict</code>部分的文档。</p>
<p>如果新的参数/缓冲区被添加于/移除自这个模块之中时，这个版本号数字会随之发生变化。同时模块的<code>_load_from_state_dict</code>方法会比较版本号的信息并依据此状态词典（state dict）的变化做出一些适当的调整。</p>
<pre><code class="language-py">eval()
</code></pre>
<p>将模块转换为测试模式。</p>
<p>这个函数只对特定的模块类型有效，如 <a href="#torch.nn.Dropout" title="torch.nn.Dropout"><code>Dropout</code></a>和<code>BatchNorm</code>等等。如果想了解这些特定模块在训练/测试模式下各自的运作细节，可以看一下这些特殊模块的文档部分。</p>
<pre><code class="language-py">extra_repr()
</code></pre>
<p>为模块设置额外的展示信息(extra representation)。</p>
<p>如果想要打印展示(print)你的模块的一些定制的额外信息，那你应该在你的模块中复现这个函数。单行和多行的字符串都可以被接受。</p>
<pre><code class="language-py">float()
</code></pre>
<p>将所有浮点数类型的参数(parameters)和缓冲区(buffers)转换为<code>float</code>数据类型。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">forward(*input)
</code></pre>
<p>定义了每次模块被调用之后所进行的计算过程。</p>
<p>应该被Module类的所有子类重写。</p>
<p>Note</p>
<p>尽管模块的前向操作都被定义在这个函数里面，但是当你要进行模块的前向操作的时候，还是要直接调用模块<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> 的实例函数，而不是直接调用这个forward()函数。这主要是因为前者会照顾到注册在此模块之上的钩子函数（the registered hooks）的运行，而后者则不会。</p>
<pre><code class="language-py">half()
</code></pre>
<p>将所有的浮点数类型的参数(parameters)和缓冲区(buffers)转换为<code>half</code>数据类型。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">load_state_dict(state_dict, strict=True)
</code></pre>
<p>将<a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a>中的参数（parameters）和缓冲区（buffers）拷贝到模块和其子模块之中。如果<code>strict</code>被设置为<code>True</code>，那么<a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a>中的键值（keys）必须与模型的[<code>state_dict()</code>]函数所返回的键值（keys）信息保持完全的一致。</p>
<p>load_state_dict()函数参数：</p>
<ul>
<li><strong>state_dict</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – 一个包含了参数和持久缓冲区的字典。</li>
<li><strong>strict</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 是否严格要求 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a> 中的键值（keys）与模型 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict()</code></a> 函数返回的键值（keys）信息保持完全一致。 默认： <code>True</code></li>
</ul>
<pre><code class="language-py">modules()
</code></pre>
<p>返回一个当前模块内所有模块（包括自身）的迭代器。</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>Module</em> – a module in the network</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Note</p>
<p>注意重复的模块只会被返回一次。比在下面这个例子中，<code>l</code>就只会被返回一次。</p>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.modules()):
 print(idx, '-&gt;', m)

0 -&gt; Sequential (
 (0): Linear (2 -&gt; 2)
 (1): Linear (2 -&gt; 2)
)
1 -&gt; Linear (2 -&gt; 2)

</code></pre>
<pre><code class="language-py">named_buffers(prefix='', recurse=True)
</code></pre>
<p>返回一个模块缓冲区的迭代器，每次返回的元素是由缓冲区的名字和缓冲区自身组成的元组。</p>
<p>named_buffers()函数的参数:</p>
<ul>
<li><strong>prefix</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – 要添加在所有缓冲区名字之前的前缀。</li>
<li><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – 如果设置为True，那样迭代器中不光会返回这个模块自身直连成员的缓冲区，同时也会递归返回其子模块的缓冲区。否则，只返回这个模块直连成员的缓冲区。</li>
</ul>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, torch.Tensor)</em> – 包含了缓冲区的名字和缓冲区自身的元组</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; for name, buf in self.named_buffers():
&gt;&gt;&gt;    if name in ['running_var']:
&gt;&gt;&gt;        print(buf.size())

</code></pre>
<pre><code class="language-py">named_children()
</code></pre>
<p>返回一个当前模型直连的子模块的迭代器，每次返回的元素是由子模块的名字和子模块自身组成的元组。</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Module)</em> – 包含了子模块的名字和子模块自身的元组</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>例子：</p>
<pre><code class="language-py">&gt;&gt;&gt; for name, module in model.named_children():
&gt;&gt;&gt;     if name in ['conv4', 'conv5']:
&gt;&gt;&gt;         print(module)

</code></pre>
<pre><code class="language-py">named_modules(memo=None, prefix='')
</code></pre>
<p>返回一个当前模块内所有模块（包括自身）的迭代器，每次返回的元素是由模块的名字和模块自身组成的元组。</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Module)</em> – 模块名字和模块自身组成的元组</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Note</p>
<p>重复的模块只会被返回一次。在下面的例子中，<code>l</code>只被返回了一次。</p>
<p>例子：</p>
<pre><code class="language-py">&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.named_modules()):
 print(idx, '-&gt;', m)

0 -&gt; ('', Sequential (
 (0): Linear (2 -&gt; 2)
 (1): Linear (2 -&gt; 2)
))
1 -&gt; ('0', Linear (2 -&gt; 2))

</code></pre>
<pre><code class="language-py">named_parameters(prefix='', recurse=True)
</code></pre>
<p>返回一个当前模块内所有参数的迭代器，每次返回的元素是由参数的名字和参数自身组成的元组。</p>
<p>named_parameters()函数参数：</p>
<ul>
<li><strong>prefix</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – 要在所有参数名字前面添加的前缀。</li>
<li><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – 如果设置为True，那样迭代器中不光会返回这个模块自身直连成员的参数，同时也会返回其子模块的参数。否则，只返回这个模块直连成员的参数。</li>
</ul>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Parameter)</em> – 参数名字和参数自身组成的元组</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; for name, param in self.named_parameters():
&gt;&gt;&gt;    if name in ['bias']:
&gt;&gt;&gt;        print(param.size())

</code></pre>
<pre><code class="language-py">parameters(recurse=True)
</code></pre>
<p>返回一个遍历模块所有参数的迭代器。 parameters()函数一个经典的应用就是实践中经常将此函数的返回值传入优化器。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – 如果设置为True，那样迭代器中不光会返回这个模块自身直连成员的参数，同时也会递归返回其子模块的参数。否则，只返回这个模块直连成员的参数。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Yields:</td>
<td><em>Parameter</em> – 模块参数</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; for param in model.parameters():
&gt;&gt;&gt;     print(type(param.data), param.size())
&lt;class 'torch.FloatTensor'&gt; (20L,)
&lt;class 'torch.FloatTensor'&gt; (20L, 1L, 5L, 5L)

</code></pre>
<pre><code class="language-py">register_backward_hook(hook)
</code></pre>
<p>在模块上注册一个挂载在反向操作之后的钩子函数。（挂载在backward之后这个点上的钩子函数）</p>
<p>对于每次输入，当模块关于此次输入的反向梯度的计算过程完成，该钩子函数都会被调用一次。此钩子函数需要遵从以下函数签名：</p>
<pre><code class="language-py">hook(module, grad_input, grad_output) -&gt; Tensor or None

</code></pre>
<p>如果模块的输入或输出是多重的（multiple inputs or outputs），那 <code>grad_input</code> 和 <code>grad_output</code> 应当是元组数据。 钩子函数不能对输入的参数<code>grad_input</code> 和 <code>grad_output</code>进行任何更改，但是可以选择性地根据输入的参数返回一个新的梯度回去，而这个新的梯度在后续的计算中会替换掉<code>grad_input</code>。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个句柄（handle），这个handle的特点就是通过调用<code>handle.remove()</code>函数就可以将这个添加于模块之上的钩子移除掉。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Warning</p>
<p>对于一些具有很多复杂操作的<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>，当前的hook实现版本还不能达到完全理想的效果。举个例子，有些错误的情况下，函数的输入参数<code>grad_input</code> 和 <code>grad_output</code>中可能只是真正的输入和输出变量的一个子集。对于此类的<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>，你应该使用[<code>torch.Tensor.register_hook()</code>]直接将钩子挂载到某个特定的输入输出的变量上，而不是当前的模块。</p>
<pre><code class="language-py">register_buffer(name, tensor)
</code></pre>
<p>往模块上添加一个持久缓冲区。</p>
<p>这个函数的经常会被用于向模块添加不会被认为是模块参数（model parameter）的缓冲区。举个栗子，BatchNorm的<code>running_mean</code>就不是一个参数，但却属于持久状态。</p>
<p>所添加的缓冲区可以通过给定的名字(name参数)以访问模块的属性的方式进行访问。</p>
<p>register_buffer()函数的参数:</p>
<ul>
<li><strong>name</strong> (<em>string</em>) – 要添加的缓冲区的名字。所添加的缓冲区可以通过此名字以访问模块的属性的方式进行访问。</li>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 需要注册到模块上的缓冲区。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; self.register_buffer('running_mean', torch.zeros(num_features))

</code></pre>
<pre><code class="language-py">register_forward_hook(hook)
</code></pre>
<p>在模块上注册一个挂载在前向操作之后的钩子函数。（挂载在forward操作结束之后这个点）</p>
<p>此钩子函数在每次模块的 <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a>函数运行结束产生output之后就会被触发。此钩子函数需要遵从以下函数签名：</p>
<pre><code class="language-py">hook(module, input, output) -&gt; None

</code></pre>
<p>此钩子函数不能进行会修改 input 和 output 这两个参数的操作。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个句柄（handle），这个handle的特点就是通过调用<code>handle.remove()</code>函数就可以将这个添加于模块之上的钩子移除掉。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">register_forward_pre_hook(hook)
</code></pre>
<p>在模块上注册一个挂载在前向操作之前的钩子函数。（挂载在forward操作开始之前这个点）</p>
<p>此钩子函数在每次模块的 <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a>函数运行开始之前会被触发。此钩子函数需要遵从以下函数签名： The hook will be called every time before <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> is invoked. It should have the following signature:</p>
<pre><code class="language-py">hook(module, input) -&gt; None

</code></pre>
<p>此钩子函数不能进行会修改 input 这个参数的操作。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个句柄（handle），这个handle的特点就是通过调用<code>handle.remove()</code>函数就可以将这个添加于模块之上的钩子移除掉。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">register_parameter(name, param)
</code></pre>
<p>向模块添加一个参数（parameter）。</p>
<p>所添加的参数（parameter）可以通过给定的名字(name参数)以访问模块的属性的方式进行访问。</p>
<p>register_parameter()函数的参数：</p>
<ul>
<li><strong>name</strong> (<em>string</em>) – 所添加的参数的名字. 所添加的参数（parameter）可以通过此名字以访问模块的属性的方式进行访问</li>
<li><strong>parameter</strong> (<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><em>Parameter</em></a>) – 要添加到模块之上的参数。</li>
</ul>
<pre><code class="language-py">state_dict(destination=None, prefix='', keep_vars=False)
</code></pre>
<p>返回一个包含了模块当前所有状态(state)的字典(dictionary)。</p>
<p>所有的参数和持久缓冲区都被囊括在其中。字典的键值就是响应的参数和缓冲区的名字(name)。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个包含了模块当前所有状态的字典</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)">dict</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; module.state_dict().keys()
['bias', 'weight']

</code></pre>
<pre><code class="language-py">to(*args, **kwargs)
</code></pre>
<p>移动 并且/或者（and/or）转换所有的参数和缓冲区。</p>
<p>这个函数可以这样调用：</p>
<pre><code class="language-py">to(device=None, dtype=None, non_blocking=False)
</code></pre>
<pre><code class="language-py">to(dtype, non_blocking=False)
</code></pre>
<pre><code class="language-py">to(tensor, non_blocking=False)
</code></pre>
<p>此函数的函数签名跟<a href="tensors.html#torch.Tensor.to" title="torch.Tensor.to"><code>torch.Tensor.to()</code></a>函数的函数签名很相似，只不过这个函数<code>dtype</code>参数只接受浮点数类型的dtype，如float， double， half（ floating point desired <code>dtype</code> s）。同时，这个方法只会将浮点数类型的参数和缓冲区（the floating point parameters and buffers）转化为<code>dtype</code>（如果输入参数中给定的话）的数据类型。而对于整数类型的参数和缓冲区（the integral parameters and buffers），即便输入参数中给定了<code>dtype</code>，也不会进行转换操作，而如果给定了 <code>device</code>参数，移动操作则会正常进行。当<code>non_blocking</code>参数被设置为True之后，此函数会尽可能地相对于 host 进行异步的 转换/移动 操作，比如，将存储在固定内存（pinned memory）上的CPU Tensors移动到CUDA设备上这一过程既是如此。</p>
<p>例子在下面。</p>
<p>Note</p>
<p>这个方法对模块的修改都是in-place操作。</p>
<p>to()函数的参数:</p>
<ul>
<li><strong>device</strong> (<code>torch.device</code>) – 想要将这个模块中的参数和缓冲区转移到的设备。</li>
<li><strong>dtype</strong> (<code>torch.dtype</code>) – 想要将这个模块中浮点数的参数和缓冲区转化为的浮点数数据类型。</li>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>torch.Tensor</em></a>) – 一个Tensor，如果被指定，其dtype和device信息，将分别起到上面两个参数的作用，也就是说，这个模块的浮点数的参数和缓冲区的数据类型将会被转化为这个Tensor的dtype类型，同时被转移到此Tensor所处的设备device上去。</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; linear = nn.Linear(2, 2)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1913, -0.3420],
 [-0.5113, -0.2325]])
&gt;&gt;&gt; linear.to(torch.double)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1913, -0.3420],
 [-0.5113, -0.2325]], dtype=torch.float64)
&gt;&gt;&gt; gpu1 = torch.device("cuda:1")
&gt;&gt;&gt; linear.to(gpu1, dtype=torch.half, non_blocking=True)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1914, -0.3420],
 [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
&gt;&gt;&gt; cpu = torch.device("cpu")
&gt;&gt;&gt; linear.to(cpu)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1914, -0.3420],
 [-0.5112, -0.2324]], dtype=torch.float16)

</code></pre>
<pre><code class="language-py">train(mode=True)
</code></pre>
<p>将模块转换成训练模式。</p>
<p>这个函数只对特定的模块类型有效，如 <a href="#torch.nn.Dropout" title="torch.nn.Dropout"><code>Dropout</code></a>和<code>BatchNorm</code>等等。如果想了解这些特定模块在训练/测试模式下各自的运作细节，可以看一下这些特殊模块的文档部分。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">type(dst_type)
</code></pre>
<p>将所有的参数和缓冲区转化为 <code>dst_type</code>的数据类型。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dst_type</strong> (<a href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><em>type</em></a> <em>or</em> <em>string</em>) – 要转化的数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">zero_grad()
</code></pre>
<p>讲模块所有参数的梯度设置为0。</p>
<h3 id="sequential">Sequential</h3>
<pre><code class="language-py">class torch.nn.Sequential(*args)
</code></pre>
<p>一种顺序容器。传入Sequential构造器中的模块会被按照他们传入的顺序依次添加到Sequential之上。相应的，一个由模块组成的顺序词典也可以被传入到Sequential的构造器中。</p>
<p>为了方便大家理解，举个简单的例子：</p>
<pre><code class="language-py"># 构建Sequential的例子
model = nn.Sequential(
          nn.Conv2d(1,20,5),
          nn.ReLU(),
          nn.Conv2d(20,64,5),
          nn.ReLU()
        )

# 利用OrderedDict构建Sequential的例子
model = nn.Sequential(OrderedDict([
          ('conv1', nn.Conv2d(1,20,5)),
          ('relu1', nn.ReLU()),
          ('conv2', nn.Conv2d(20,64,5)),
          ('relu2', nn.ReLU())
        ]))

</code></pre>
<h3 id="modulelist-模块列表">ModuleList (模块列表)</h3>
<pre><code class="language-py">class torch.nn.ModuleList(modules=None)
</code></pre>
<p>ModuleList的作用是将一堆模块（module）存储在一个列表之中。</p>
<p>ModuleList 可以按一般的python列表的索引方式进行索引，但ModuleList中的模块都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable</em>_,_ <em>optional</em>) – 一个要添加到ModuleList中的由模块组成的可迭代结构(an iterable of modules)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.linears = nn.ModuleList([nn.Linear(10, 10) for i in range(10)])

    def forward(self, x):
        # ModuleList可以被当作一个迭代器，同时也可以使用index索引
        for i, l in enumerate(self.linears):
            x = self.linears[i // 2](x) + l(x)
        return x

</code></pre>
<pre><code class="language-py">append(module)
</code></pre>
<p>将一个模块添加到ModuleList的末尾，与python list的append()一致。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – 要添加的模块</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">extend(modules)
</code></pre>
<p>将一个由模块组成的可迭代结构添加到ModuleList的末尾，与python list的extend()一致。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable</em>) – 要添加到ModuleList末尾的由模块组成的可迭代结构</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">insert(index, module)
</code></pre>
<p>将给定的<code>module</code>插入到ModuleList的<code>index</code>位置。</p>
<p>insert()函数的参数:</p>
<ul>
<li><strong>index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 要插入的位置</li>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – 要插入的模块</li>
</ul>
<h3 id="moduledict-模块词典">ModuleDict (模块词典)</h3>
<pre><code class="language-py">class torch.nn.ModuleDict(modules=None)
</code></pre>
<p>ModuleDict的作用是将一堆模块（module）存储在一个词典之中。</p>
<p>ModuleDict 可以按一般的python词典的索引方式进行索引，但ModuleDict中的模块都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable</em>_,_ <em>optional</em>) – 一个由(string: module)映射组成的映射集合（词典）或者 一个由(string, module)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.choices = nn.ModuleDict({
                'conv': nn.Conv2d(10, 10, 3),
                'pool': nn.MaxPool2d(3)
        })
        self.activations = nn.ModuleDict([
                ['lrelu', nn.LeakyReLU()],
                ['prelu', nn.PReLU()]
        ])

    def forward(self, x, choice, act):
        x = self.choices[choice](x)
        x = self.activations[act](x)
        return x

</code></pre>
<pre><code class="language-py">clear()
</code></pre>
<p>移除ModuleDict中所有的元素。</p>
<pre><code class="language-py">items()
</code></pre>
<p>返回一个由ModuleDict中的键/值对组成的可迭代结构。</p>
<pre><code class="language-py">keys()
</code></pre>
<p>返回一个由ModuleDict中的键组成的可迭代结构。</p>
<pre><code class="language-py">pop(key)
</code></pre>
<p>将<code>key</code>这个键从ModuleDict中删除，并将其对应的模块返回。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>key</strong> (<em>string</em>) – 要从ModuleDict中弹出的键</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">update(modules)
</code></pre>
<p>通过传入的映射或者由键/值对组成的可迭代结构对当前的ModuleDict进行更新，如果传入对象与当前ModuleDict中存在键重复，当前ModuleDict中这些重复的键所对应的值将被覆盖。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable</em>) – 一个由(string: <code>Module</code>)映射组成的映射集合（词典）或者 一个由(string: <code>Module</code>)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">values()
</code></pre>
<p>返回一个由ModuleDict中的值组成的可迭代结构。</p>
<h3 id="parameterlist-参数列表">ParameterList (参数列表)</h3>
<pre><code class="language-py">class torch.nn.ParameterList(parameters=None)
</code></pre>
<p>ParameterList的作用是将一堆参数（parameter）存储到一个列表中。</p>
<p>ParameterList 可以按一般的python列表的索引方式进行索引，但ParameterList中的参数（parameter）都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable</em>_,_ <em>optional</em>) – 要添加到ParameterList之上的由parameter组成的可迭代结构</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.params = nn.ParameterList([nn.Parameter(torch.randn(10, 10)) for i in range(10)])

    def forward(self, x):
        # ParameterList可以被当作一个迭代器，同时也可以使用index索引
        for i, p in enumerate(self.params):
            x = self.params[i // 2].mm(x) + p.mm(x)
        return x

</code></pre>
<pre><code class="language-py">append(parameter)
</code></pre>
<p>将一个parameter添加到ParameterList的末尾。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameter</strong> (<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><em>nn.Parameter</em></a>) – 要添加的参数</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">extend(parameters)
</code></pre>
<p>将一个由parameter组成的Python可迭代结构添加到ParameterList的末尾。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable</em>) – 要添加到ParameterList的末尾的由parameter组成的Python可迭代结构</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="parameterdict-参数词典">ParameterDict (参数词典)</h3>
<pre><code class="language-py">class torch.nn.ParameterDict(parameters=None)
</code></pre>
<p>ParameterDict的作用是将一堆参数（Parameter）存储在一个词典之中。</p>
<p>ParameterDict 可以按一般的python词典的索引方式进行索引，但ParameterDictt中的参数都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable</em>_,_ <em>optional</em>) – 一个由(string:<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)映射组成的映射集合（词典）或者 一个由(string, <a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.params = nn.ParameterDict({
                'left': nn.Parameter(torch.randn(5, 10)),
                'right': nn.Parameter(torch.randn(5, 10))
        })

    def forward(self, x, choice):
        x = self.params[choice].mm(x)
        return x

</code></pre>
<pre><code class="language-py">clear()
</code></pre>
<p>移除ParameterDict中所有的元素。</p>
<pre><code class="language-py">items()
</code></pre>
<p>返回一个由ParameterDict中的键/值对组成的可迭代结构。</p>
<pre><code class="language-py">keys()
</code></pre>
<p>返回一个由 ParameterDict中的键组成的可迭代结构。</p>
<pre><code class="language-py">pop(key)
</code></pre>
<p>将key这个键从ParameterDict中删除，并将其对应的模块返回。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>key</strong> (<em>string</em>) – 要从ParameterDict中弹出的键</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">update(parameters)
</code></pre>
<p>通过传入的映射或者由键/值对组成的可迭代结构对当前的ParameterDict进行更新，如果传入对象与当前ParameterDict中存在键重复，当前ParameterDict中这些重复的键所对应的值将被覆盖。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable</em>) – modules (iterable) – 一个由(string: <a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)映射组成的映射集合（词典）或者 一个由(string: <a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">values()
</code></pre>
<p>返回一个由ParameterDict中的值组成的可迭代结构。</p>
<h2 id="convolution-layers-卷积层">Convolution layers (卷积层)</h2>
<h3 id="conv1d">Conv1d</h3>
<pre><code class="language-py">class torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)
</code></pre>
<p>利用指定大小的一维卷积核对输入的多通道一维输入信号进行一维卷积操作的卷积层。</p>
<p>在最简单的情况下，对于输入大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1dad4f3ff614c986028f7100e0205f6d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1dad4f3ff614c986028f7100e0205f6d.jpg" alt=""></a>，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a03de8b18f61a493174a56530fb03f1d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a03de8b18f61a493174a56530fb03f1d.jpg" alt=""></a>的一维卷积层，其卷积计算过程可以如下表述：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/806f7530da55bf294a636b8c7ed38bcb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/806f7530da55bf294a636b8c7ed38bcb.jpg" alt=""></a></p>
<p>这里的<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" alt=""></a>符号实际上是一个互相关（<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>） 操作符（大家可以自己查一下互相关和真卷积的区别，互相关因为实现起来很简单，所以一般的深度学习框架都是用互相关操作取代真卷积）, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is a batch size, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> 代表通道的数量, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" alt=""></a> 代表信号序列的长度。</p>
<ul>
<li> <p><code>stride</code> 参数控制了互相关操作（伪卷积）的步长，参数的数据类型一般是单个数字或者一个只有一个元素的元组。</p> </li>
<li> <p><code>padding</code> 参数控制了要在一维卷积核的输入信号的各维度各边上要补齐0的层数。</p> </li>
<li> <p><code>dilation</code> 参数控制了卷积核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p> </li>
<li> <p><code>groups</code> 控制了输入输出之间的连接（connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p> <p>&gt; * 当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p> <p>&gt; * 当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p> <p>&gt; * 当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/19131f9f53448ae579b613bc7bc90158.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/19131f9f53448ae579b613bc7bc90158.jpg" alt=""></a></p> </li>
</ul>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列（最后几列）可能不会参与计算（比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p>当<code>groups == in_channels</code> 并且 <code>out_channels == K * in_channels</code>（其中K是正整数）的时候，这个操作也被称为深度卷积。 举个创建深度卷积层的例子，对于一个大小为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7db3e5e5d600c81e77756d5eee050505.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7db3e5e5d600c81e77756d5eee050505.jpg" alt=""></a> 的输入，要构建一个深度乘数为<code>K</code>的深度卷积层，可以通过以下参数来创建：<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eab8f2745761d762e48a59446243af90.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eab8f2745761d762e48a59446243af90.jpg" alt=""></a>。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法（nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性（可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Conv1d的参数:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输出通道个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输入数据各维度各边上要补齐0的层数。 默认： 0</li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7db3e5e5d600c81e77756d5eee050505.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7db3e5e5d600c81e77756d5eee050505.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3423094375906aa21d1b2e095e95c230.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3423094375906aa21d1b2e095e95c230.jpg" alt=""></a> 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/91d48a39a90c6b4ed37ac863c1a8ff7b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/91d48a39a90c6b4ed37ac863c1a8ff7b.jpg" alt=""></a></p> </li>
</ul>
<p>| 内部Variables： |</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Conv1d模块中的一个大小为(out_channels, in_channels, kernel_size)的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>， 其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" alt=""></a>。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为(out_channels)，可训练学习。如果构造Conv1d时构造函数中的<code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>， 其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" alt=""></a>。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Conv1d(16, 33, 3, stride=2)
&gt;&gt;&gt; input = torch.randn(20, 16, 50)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="conv2d">Conv2d</h3>
<pre><code class="language-py">class torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)
</code></pre>
<p>利用指定大小的二维卷积核对输入的多通道二维输入信号进行二维卷积操作的卷积层。</p>
<p>在最简单的情况下，对于输入大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a6c3a4e9779c159b39576bee3400a00b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a6c3a4e9779c159b39576bee3400a00b.jpg" alt=""></a>，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4b354af142fb0f01680d390ef552829f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4b354af142fb0f01680d390ef552829f.jpg" alt=""></a>的二维维卷积层，其卷积计算过程可以如下表述：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a4928651cb959fa7871eaebdb489b083.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a4928651cb959fa7871eaebdb489b083.jpg" alt=""></a></p>
<p>这里的<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" alt=""></a>符号实际上是一个二维互相关（<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>） 操作符（大家可以自己查一下互相关和真卷积的区别，互相关因为实现起来很简单，所以一般的深度学习框架都是用互相关操作取代真卷积）, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is a batch size, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> 代表通道的数量, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b7d9beafd65e2cf6493bdca741827a5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b7d9beafd65e2cf6493bdca741827a5.jpg" alt=""></a> 是输入的二维数据的像素高度，<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/90490a34512e9bd1843ed4da713d0813.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/90490a34512e9bd1843ed4da713d0813.jpg" alt=""></a> 是输入的二维数据的像素宽度。</p>
<ul>
<li> <p><code>stride</code> 参数控制了互相关操作（伪卷积）的步长，参数的数据类型一般是单个数字或者一个只有一个元素的元组。</p> </li>
<li> <p><code>padding</code> 参数控制了要在二维卷积核的输入信号的各维度各边上要补齐0的层数。</p> </li>
<li> <p><code>dilation</code> 参数控制了卷积核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p> </li>
<li> <p><code>groups</code> 控制了输入输出之间的连接（connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p> <p>&gt; * 当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p> <p>&gt; * 当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p> <p>&gt; * 当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/19131f9f53448ae579b613bc7bc90158.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/19131f9f53448ae579b613bc7bc90158.jpg" alt=""></a></p> </li>
</ul>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code>这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 二维数据的高和宽这两个维度都会采用这一个数字。</li>
<li>一个由两个int数字组成的<code>tuple</code>– 这种情况下，二维数据的高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列（最后几列）可能不会参与计算（比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note 当<code>groups == in_channels</code> 并且 <code>out_channels == K * in_channels</code>（其中K是正整数）的时候，这个操作也被称为深度卷积。</p>
<p>换句话说，对于一个大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0385ad868fed790d36381b9e8788c18b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0385ad868fed790d36381b9e8788c18b.jpg" alt=""></a>的输入，要构建一个深度乘数为<code>K</code>的深度卷积层，可以通过以下参数来创建：<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8aee041e54a302b342d50912ce67f44b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8aee041e54a302b342d50912ce67f44b.jpg" alt=""></a>。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法（nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性（可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Conv2d的参数:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输出通道个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) –卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输入数据各维度各边上要补齐0的层数。 默认： 0</li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) –卷积核各元素之间的距离。 默认： 1</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0385ad868fed790d36381b9e8788c18b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0385ad868fed790d36381b9e8788c18b.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d3edfe8a9bbdd73ba5c4b566353777f0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d3edfe8a9bbdd73ba5c4b566353777f0.jpg" alt=""></a> 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a89a5326ab89279b92f4720f63b4eaae.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a89a5326ab89279b92f4720f63b4eaae.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/03f69d6e3dffc3254359e41f8b310667.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/03f69d6e3dffc3254359e41f8b310667.jpg" alt=""></a></p> </li>
</ul>
<p>| 内部Variables: |</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Conv2d模块中的一个大小为 (out_channels, in_channels, kernel_size[0], kernel_size[1])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>， 其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" alt=""></a>。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 块的偏差项，大小为(out_channels)，可训练学习。如果构造Conv2d时构造函数中的<code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>，其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" alt=""></a>。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.Conv2d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding and dilation
&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="conv3d">Conv3d</h3>
<pre><code class="language-py">class torch.nn.Conv3d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)
</code></pre>
<p>利用指定大小的三维卷积核对输入的多通道三维输入信号进行三维卷积操作的卷积层。</p>
<p>最简单的情况下，对于输入大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ca863d6b44a0246998de77c7c423ec32.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ca863d6b44a0246998de77c7c423ec32.jpg" alt=""></a>，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" alt=""></a> 的三维卷积层，其卷积计算过程可以如下表述：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/39831867c152a21de6e580bf01c0cb7f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/39831867c152a21de6e580bf01c0cb7f.jpg" alt=""></a></p>
<p>这里的 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" alt=""></a>符号实际上是一个三维互相关 <a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a> 操作符。</p>
<ul>
<li> <p><code>stride</code> 数控制了互相关操作（伪卷积）的步长。</p> </li>
<li> <p><code>padding</code> 参数控制了要在三维卷积核的输入信号的各维度各边上要补齐0的层数。</p> </li>
<li> <p><code>dilation</code> 参数控制了卷积核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p> </li>
<li> <p><code>groups</code> 控制了输入输出之间的连接（connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p> </li>
</ul>
<p>&gt; * 当 groups=1, 此Conv3d层会使用一个卷积层进行对所有输入到输出的卷积操作。</p>
<p>&gt; * 当 groups=2, 此时Conv3d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv3d层的输出。</p>
<p>&gt; * 当 groups= in_channels, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" alt=""></a>.</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code>这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 三维维数据的深度，高和宽这三个维度都会采用这一个数字。</li>
<li>一个由三个int数字组成的<code>tuple</code>– 这种情况下，三维数据的深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列（最后几列）可能不会参与计算（比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p>当<code>groups == in_channels</code> 并且 <code>out_channels == K * in_channels</code>（其中K是正整数）的时候，这个操作也被称为深度卷积。</p>
<p>换句话说，对于一个大小为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8d71105bc4954eb54660bc5d37c23de.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8d71105bc4954eb54660bc5d37c23de.jpg" alt=""></a> 的输入，要构建一个深度乘数为<code>K</code>的深度卷积层，可以通过以下参数来创建：<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8aee041e54a302b342d50912ce67f44b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8aee041e54a302b342d50912ce67f44b.jpg" alt=""></a>。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法（nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性（可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输入数据各维度各边上要补齐0的层数。 默认： 0</li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8d71105bc4954eb54660bc5d37c23de.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8d71105bc4954eb54660bc5d37c23de.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" alt=""></a> where</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bbc2662490bb72269672fe81af1fe003.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bbc2662490bb72269672fe81af1fe003.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b7ca056f55603d0632bb03bdf9435d47.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b7ca056f55603d0632bb03bdf9435d47.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d040a26cd9a91c4d230afd4c15d0e1e6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d040a26cd9a91c4d230afd4c15d0e1e6.jpg" alt=""></a></p> </li>
</ul>
<p>| 内部Variables: |</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Conv3d模块中的一个大小为 (out_channels, in_channels, kernel_size[0], kernel_size[1], kernel_size[2]) 的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>，其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" alt=""></a>。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为(out_channels)，可训练学习。如果构造Conv1d时构造函数中的<code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> ，其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" alt=""></a>。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.Conv3d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.Conv3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(4, 2, 0))
&gt;&gt;&gt; input = torch.randn(20, 16, 10, 50, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="convtranspose1d">ConvTranspose1d</h3>
<pre><code class="language-py">class torch.nn.ConvTranspose1d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)
</code></pre>
<p>利用指定大小的一维转置卷积核对输入的多通道一维输入信号进行转置卷积（当然此卷积也是互相关操作，cross-correlation）操作的模块。</p>
<p>该模块可以看作是Conv1d相对于其输入的梯度(the gradient of Conv1d with respect to its input， 直译)， 转置卷积又被称为小数步长卷积或是反卷积（尽管这不是一个真正意义上的反卷积）。</p>
<ul>
<li> <p><code>stride</code> 控制了转置卷积操作的步长</p> </li>
<li> <p><code>padding</code> 控制了要在输入的各维度的各边上补齐0的层数，与Conv1d不同的地方，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>，详情请见下面的note。</p> </li>
<li> <p><code>output_padding</code> 控制了转置卷积操作输出的各维度的长度增量，但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出大小为根据此参数pad后的大小。更多的详情请见下面的note。</p> </li>
<li> <p><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了dilation的作用。</p> </li>
<li> <p><code>groups</code> 控制了输入输出之间的连接（connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p> <p>&gt; * 当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p> <p>&gt; * 当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p> <p>&gt; * 当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" alt=""></a>。</p> </li>
</ul>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列（最后几列）可能不会参与计算（比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p><code>padding</code> 参数控制了要在输入的各维度各边上补齐0的层数，与在Conv1d中不同的是，在转置卷积操作过程中，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>， 这样设置的主要原因是当使用相同的参数构建<a href="#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a> 和<a href="#torch.nn.ConvTranspose1d" title="torch.nn.ConvTranspose1d"><code>ConvTranspose1d</code></a>模块的时候，这种设置能够实现两个模块有正好相反的输入输出的大小，即Conv1d的输出大小是其对应的ConvTranspose1d模块的输入大小，而ConvTranspose1d的输出大小又恰好是其对应的Conv1d模块的输入大小。然而，当<code>stride &gt; 1</code>的时候，<a href="#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a> 的一个输出大小可能会对应多个输入大小，上一个note中就详细的介绍了这种情况，这样的情况下要保持前面提到两种模块的输入输出保持反向一致，那就要用到 <code>output_padding</code>参数了，这个参数可以增加转置卷积输出的某一维度的大小，以此来达到前面提到的同参数构建的<a href="#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a> 和<a href="#torch.nn.ConvTranspose1d" title="torch.nn.ConvTranspose1d"><code>ConvTranspose1d</code></a>模块的输入输出方向一致。 但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出各维度的大小为根据此参数pad后的大小。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法（nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性（可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – <code>kernel_size - 1 - padding</code> 层 0 会被补齐到输入数据的各边上。 默认： 0</li>
<li><strong>output_padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出的各维度要增加的大小。默认：0</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7db3e5e5d600c81e77756d5eee050505.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7db3e5e5d600c81e77756d5eee050505.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3423094375906aa21d1b2e095e95c230.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3423094375906aa21d1b2e095e95c230.jpg" alt=""></a> 其中，</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c37a7e44707d3c08522f44ab4e4d6841.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c37a7e44707d3c08522f44ab4e4d6841.jpg" alt=""></a></p> </li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块中的一个大小为 (in_channels, out_channels, kernel_size[0])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>，其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" alt=""></a>。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为 (out_channels)， 如果构造函数中的 <code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> ，其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" alt=""></a>。</li>
</ul>
<h3 id="convtranspose2d">ConvTranspose2d</h3>
<pre><code class="language-py">class torch.nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)
</code></pre>
<p>利用指定大小的二维转置卷积核对输入的多通道二维输入信号进行转置卷积（当然此卷积也是互相关操作，cross-correlation）操作的模块。</p>
<p>该模块可以看作是Conv2d相对于其输入的梯度(the gradient of Conv2d with respect to its input， 直译)， 转置卷积又被称为小数步长卷积或是反卷积（尽管这不是一个真正意义上的反卷积）。</p>
<ul>
<li> <p><code>stride</code> 控制了转置卷积操作的步长</p> </li>
<li> <p><code>padding</code> 控制了要在输入的各维度的各边上补齐0的层数，与Conv1d不同的地方，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>，详情请见下面的note。</p> </li>
<li> <p><code>output_padding</code> 控制了转置卷积操作输出的各维度的长度增量，但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出大小为根据此参数pad后的大小。更多的详情请见下面的note。</p> </li>
<li> <p><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了dilation的作用。</p> </li>
<li> <p><code>groups</code> 控制了输入输出之间的连接（connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p> <p>&gt; * 当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p> <p>&gt; * 当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p> <p>&gt; * 当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" alt=""></a>。</p> </li>
</ul>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>output_padding</code> 这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 二维维数据的高和宽这两个维度都会采用这一个数字。</li>
<li>一个由两个int数字组成的<code>tuple</code>– 这种情况下，二维数据的高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列（最后几列）可能不会参与计算（比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p><code>padding</code> 参数控制了要在输入的各维度各边上补齐0的层数，与在Conv1d中不同的是，在转置卷积操作过程中，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>， 这样设置的主要原因是当使用相同的参数构建<a href="#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a> 和<a href="#torch.nn.ConvTranspose2d" title="torch.nn.ConvTranspose2d"><code>ConvTranspose2d</code></a>模块的时候，这种设置能够实现两个模块有正好相反的输入输出的大小，即Conv2d的输出大小是其对应的ConvTranspose2d模块的输入大小，而ConvTranspose2d的输出大小又恰好是其对应的Conv2d模块的输入大小。然而，当<code>stride &gt; 1</code>的时候，<a href="#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a> 的一个输出大小可能会对应多个输入大小，上一个note中就详细的介绍了这种情况，这样的情况下要保持前面提到两种模块的输入输出保持反向一致，那就要用到 <code>output_padding</code>参数了，这个参数可以增加转置卷积输出的某一维度的大小，以此来达到前面提到的同参数构建的<a href="#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a> 和<a href="#torch.nn.ConvTranspose2d" title="torch.nn.ConvTranspose2d"><code>ConvTranspose2d</code></a>模块的输入输出方向一致。 但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出各维度的大小为根据此参数pad后的大小。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法（nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性（可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – <code>kernel_size - 1 - padding</code> 层 0 会被补齐到输入数据的各边上。 默认： 0</li>
<li><strong>output_padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出的各维度要增加的大小。默认：0</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0385ad868fed790d36381b9e8788c18b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0385ad868fed790d36381b9e8788c18b.jpg" alt=""></a></li>
<li>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d3edfe8a9bbdd73ba5c4b566353777f0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d3edfe8a9bbdd73ba5c4b566353777f0.jpg" alt=""></a> 其中</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a2616e3fb8e8e919b799c2e62921c374.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a2616e3fb8e8e919b799c2e62921c374.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dee6540c49e827b0ececaf0154154b54.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dee6540c49e827b0ececaf0154154b54.jpg" alt=""></a></p>
<p>| Variables: |</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块中的一个大小为 (in_channels, out_channels, kernel_size[0], kernel_size[1])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>，其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" alt=""></a>。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为 (out_channels)， 如果构造函数中的 <code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> ，其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c12e2153347b696ebb784e5675cc566e.jpg" alt=""></a>。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 100)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # exact output size can be also specified as an argument
&gt;&gt;&gt; input = torch.randn(1, 16, 12, 12)
&gt;&gt;&gt; downsample = nn.Conv2d(16, 16, 3, stride=2, padding=1)
&gt;&gt;&gt; upsample = nn.ConvTranspose2d(16, 16, 3, stride=2, padding=1)
&gt;&gt;&gt; h = downsample(input)
&gt;&gt;&gt; h.size()
torch.Size([1, 16, 6, 6])
&gt;&gt;&gt; output = upsample(h, output_size=input.size())
&gt;&gt;&gt; output.size()
torch.Size([1, 16, 12, 12])

</code></pre>
<h3 id="convtranspose3d">ConvTranspose3d</h3>
<pre><code class="language-py">class torch.nn.ConvTranspose3d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)
</code></pre>
<p>利用指定大小的三维转置卷积核对输入的多通道三维输入信号进行转置卷积（当然此卷积也是互相关操作，cross-correlation）操作的模块。转置卷积的操作本质是将各通道输入与卷积核做乘法，然后返回各通道与此卷积核乘积结果之和（卷积的定义）。</p>
<p>该模块可以看作是Conv3d相对于其输入的梯度(the gradient of Conv3d with respect to its input， 直译)， 转置卷积又被称为小数步长卷积或是反卷积（尽管这不是一个真正意义上的反卷积）。</p>
<ul>
<li> <p><code>stride</code> 控制了转置卷积操作的步长</p> </li>
<li> <p><code>padding</code> 控制了要在输入的各维度的各边上补齐0的层数，与Conv1d不同的地方，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>，详情请见下面的note。</p> </li>
<li> <p><code>output_padding</code> 控制了转置卷积操作输出的各维度的长度增量，但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出大小为根据此参数pad后的大小。更多的详情请见下面的note。</p> </li>
<li> <p><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了dilation的作用。</p> </li>
<li> <p><code>groups</code> 控制了输入输出之间的连接（connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p> <p>&gt; * 当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p> <p>&gt; * 当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p> <p>&gt; * 当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648a514da1dace3deacf3f078287e157.jpg" alt=""></a>。</p> </li>
</ul>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>output_padding</code> 这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 三维维数据的深度，高和宽这两个维度都会采用这一个数字。</li>
<li>一个由三个int数字组成的<code>tuple</code>– 这种情况下，三维数据的深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列（最后几列）可能不会参与计算（比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p><code>padding</code> 参数控制了要在输入的各维度各边上补齐0的层数，与在Conv3d中不同的是，在转置卷积操作过程中，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>， 这样设置的主要原因是当使用相同的参数构建<a href="#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a> 和<a href="#torch.nn.ConvTranspose3d" title="torch.nn.ConvTranspose3d"><code>ConvTranspose3d</code></a>模块的时候，这种设置能够实现两个模块有正好相反的输入输出的大小，即Conv3d的输出大小是其对应的ConvTranspose3d模块的输入大小，而ConvTranspose3d的输出大小又恰好是其对应的Conv3d模块的输入大小。然而，当<code>stride &gt; 1</code>的时候，<a href="#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a> 的一个输出大小可能会对应多个输入大小，上一个note中就详细的介绍了这种情况，这样的情况下要保持前面提到两种模块的输入输出保持反向一致，那就要用到 <code>output_padding</code>参数了，这个参数可以增加转置卷积输出的某一维度的大小，以此来达到前面提到的同参数构建的<a href="#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a> 和<a href="#torch.nn.ConvTranspose3d" title="torch.nn.ConvTranspose3d"><code>ConvTranspose3d</code></a>模块的输入输出方向一致。 但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出各维度的大小为根据此参数pad后的大小。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法（nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性（可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – <code>kernel_size - 1 - padding</code> 层 0 会被补齐到输入数据的各边上。 默认： 0</li>
<li><strong>output_padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出的各维度要增加的大小。默认：0</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8d71105bc4954eb54660bc5d37c23de.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8d71105bc4954eb54660bc5d37c23de.jpg" alt=""></a></li>
<li>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" alt=""></a> 其中</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/35234de680c85870881b7f5d9e8de589.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/35234de680c85870881b7f5d9e8de589.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/044bc4ee93fc4a1725b5b5dc5840b408.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/044bc4ee93fc4a1725b5b5dc5840b408.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/133b249f21b73617ee100c4c072eee15.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/133b249f21b73617ee100c4c072eee15.jpg" alt=""></a></p>
<p>| Variables: |</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块中的一个大小为 (in_channels, out_channels, kernel_size[0], kernel_size[1], kernel_size[2])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>，其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" alt=""></a>。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为 (out_channels)， 如果构造函数中的 <code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>，其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/378f5c5b47c36239b817ad23a612a9f7.jpg" alt=""></a>。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.ConvTranspose3d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.ConvTranspose3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(0, 4, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 10, 50, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="unfold">Unfold</h3>
<pre><code class="language-py">class torch.nn.Unfold(kernel_size, dilation=1, padding=0, stride=1)
</code></pre>
<p>将一个batch的输入张量展开成由多个滑动局部块组成的形式。（im2col的扩展模块，起到基本类似im2col的作用）</p>
<p>以一个大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2468b226c29a7e754a9c20f0214fa85f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2468b226c29a7e754a9c20f0214fa85f.jpg" alt=""></a>的批次化(batched)输入张量为例，其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a>是batch的大小，<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a>是通道数量，<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a>代表了任意空间维度。那Unfold这个操作在此张量上的操作就是，将这个张量展开成由多个<code>kernel_size</code>大小的滑动块组成的大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" alt=""></a>的三维张量，其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8846766f2e1b47021f1520993773ccb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8846766f2e1b47021f1520993773ccb.jpg" alt=""></a>是每个块中数的个数（每个块有<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8c7a54ca7193bc3a6c5ace8c3b07d24c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8c7a54ca7193bc3a6c5ace8c3b07d24c.jpg" alt=""></a>个空间位置，每个空间位置存储一个通道大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a>的向量），<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" alt=""></a>是块的个数：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d2c6a9103e2b33f725602aebf90364e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d2c6a9103e2b33f725602aebf90364e.jpg" alt=""></a> （这张图有问题啊，编辑整理的时候注意修正一下）</p>
<p>其中 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42a2dca8a9cb6104321cf29ae30fd56a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42a2dca8a9cb6104321cf29ae30fd56a.jpg" alt=""></a> 是由上面例子中的<code>input</code>各空间维度组成的，<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a>遍历了各个空间维度。</p>
<p>因此，索引Fold操作的<code>output</code>的最后一个维度等价于索引某一个block，而索引操作的返回值是这个索引到的block中的所有值。</p>
<p><code>padding</code>, <code>stride</code> 和 <code>dilation</code> 参数指明了滑动块的相关性质。</p>
<ul>
<li><code>stride</code> 控制了滑动块的步长。</li>
<li><code>padding</code> 控制了在变形之前要向input的各维度各边上补齐的0的层数。</li>
<li><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了dilation的作用。</li>
</ul>
<p>Parameters:</p>
<ul>
<li> <p><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 滑动块的大小</p> </li>
<li> <p><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 滑动块在输入各维度上的步长。默认: 1</p> </li>
<li> <p><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 在输入各维度各边上补齐0的层数。</p> </li>
<li> <p><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 控制了各元素之间的距离（没有指明元素具体指的是谁的元素，猜测是输出的）。默认：1</p> </li>
<li> <p>如果 <code>kernel_size</code>, <code>dilation</code>, <code>padding</code> 或者 <code>stride</code>的值是一个int，或是一个长度为1的int元组，在相关操作的时候各个空间维度上都会使用这同一个值。</p> </li>
<li> <p>如果输出向量有两个空间维度，那么此Fold操作有时又被称为<code>im2col</code>。</p> </li>
</ul>
<p>Note <a href="#torch.nn.Fold" title="torch.nn.Fold"><code>Fold</code></a>在执行类<code>col2im</code>的操作的时候，主要是是通过集成此im（输出张量）分裂出所有对应位置的col（输入的滑动块）来复原原im。而<a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>则是通过从输入张量中不断拷贝数值到相应的block中来生成由滑动块组成的输出张量。所以，如果滑动块之间如果有数值重叠，那这些滑动块之间并不是互逆的。</p>
<p>Warning</p>
<p>目前，只有四维张量（比如批次化的图像张量）支持这个操作。</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2468b226c29a7e754a9c20f0214fa85f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2468b226c29a7e754a9c20f0214fa85f.jpg" alt=""></a></li>
<li>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; unfold = nn.Unfold(kernel_size=(2, 3))
&gt;&gt;&gt; input = torch.randn(2, 5, 3, 4)
&gt;&gt;&gt; output = unfold(input)
&gt;&gt;&gt; # each patch contains 30 values (2x3=6 vectors, each of 5 channels)
&gt;&gt;&gt; # 4 blocks (2x3 kernels) in total in the 3x4 input
&gt;&gt;&gt; output.size()
torch.Size([2, 30, 4])

&gt;&gt;&gt; # Convolution is equivalent with Unfold + Matrix Multiplication + Fold (or view to output shape)
&gt;&gt;&gt; inp = torch.randn(1, 3, 10, 12)
&gt;&gt;&gt; w = torch.randn(2, 3, 4, 5)
&gt;&gt;&gt; inp_unf = torch.nn.functional.unfold(inp, (4, 5))
&gt;&gt;&gt; out_unf = inp_unf.transpose(1, 2).matmul(w.view(w.size(0), -1).t()).transpose(1, 2)
&gt;&gt;&gt; out = torch.nn.functional.fold(out_unf, (7, 8), (1, 1))
&gt;&gt;&gt; # or equivalently (and avoiding a copy),
&gt;&gt;&gt; # out = out_unf.view(1, 2, 7, 8)
&gt;&gt;&gt; (torch.nn.functional.conv2d(inp, w) - out).abs().max()
tensor(1.9073e-06)

</code></pre>
<h3 id="fold">Fold</h3>
<pre><code class="language-py">class torch.nn.Fold(output_size, kernel_size, dilation=1, padding=0, stride=1)
</code></pre>
<p>将由滑动局部块组成的数组集合为一个大张量。(类col2im)</p>
<p>考虑一个包含了很多个滑动局部块的输入张量，比如，一批图像分割块(patches of images)的集合，大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e56ff5e3827b936da5cfa3a5258b12e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e56ff5e3827b936da5cfa3a5258b12e.jpg" alt=""></a>，其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a>是batch大小， <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8846766f2e1b47021f1520993773ccb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a8846766f2e1b47021f1520993773ccb.jpg" alt=""></a> 是一个块中的数值个数（每个块有<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8c7a54ca7193bc3a6c5ace8c3b07d24c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8c7a54ca7193bc3a6c5ace8c3b07d24c.jpg" alt=""></a>个空间位置，每个空间位置存储一个通道大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a>的向量），<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" alt=""></a>是滑动块的个数。（这些大小参数严格遵循了<a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>操作的输出向量的大小规定。）Fold操作通过求和重叠值的方式来将这些局部块集合为一个大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2176aae9e099eeee07cc00c4dc7b7e7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2176aae9e099eeee07cc00c4dc7b7e7.jpg" alt=""></a>的<code>output</code>张量。与 <a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>类似，这些参数必须满足：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/465bba7070e80a7e5964f46f7f5ed8bb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/465bba7070e80a7e5964f46f7f5ed8bb.jpg" alt=""></a></p>
<p>其中<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a>遍历了各个空间维度。</p>
<ul>
<li><code>output_size</code> 描述了要生成的output的各空间维度的大小。有时，同样数量的滑动块，可能会产生多种<code>input</code>的形状，比如，当<code>stride &gt; 0</code>的时候，这时候，设置<code>output_size</code>参数就会显得极为重要。</li>
</ul>
<p><code>padding</code>, <code>stride</code> 和 <code>dilation</code> 参数指明了滑动块的相关性质。</p>
<ul>
<li><code>stride</code> 控制了滑动块的步长。</li>
<li><code>padding</code> 控制了在变形之前要向input的各维度各边上补齐的0的层数。</li>
<li><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了dilation的作用。</li>
</ul>
<p>Parameters:</p>
<ul>
<li> <p><strong>output_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 输出向量的各空间维度的大小 (i.e., <code>input.sizes()[2:]</code>)</p> </li>
<li> <p><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 滑动块的大小</p> </li>
<li> <p><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 滑动块在输入各维度上的步长。默认: 1</p> </li>
<li> <p><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 在输入各维度各边上补齐0的层数。</p> </li>
<li> <p><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 控制了各元素之间的距离（没有指明元素具体指的是谁的元素，猜测是输出的）。默认：1</p> </li>
<li> <p>如果<code>output_size</code>， <code>kernel_size</code>, <code>dilation</code>, <code>padding</code> 或者 <code>stride</code>是一个int或者长度为1的int元组，在相关操作的时候各个空间维度上都会使用这同一个值。</p> </li>
<li> <p>如果此输出向量的空间维度数为2，那么此Fold操作有时又被称为<code>col2im</code>。</p> </li>
</ul>
<p>Note <a href="#torch.nn.Fold" title="torch.nn.Fold"><code>Fold</code></a>在执行类<code>col2im</code>的操作的时候，主要是是通过集成此im（输出张量）分裂出所有对应位置的col（输入的滑动块）来复原原im。而<a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>则是通过从输入张量中不断拷贝数值到相应的block中来生成由滑动块组成的输出张量。所以，如果滑动块之间如果有数值重叠，那这些滑动块之间并不是互逆的。</p>
<p>Warning</p>
<p>目前，只有四维张量（比如批次化的图像张量）支持这个操作。</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" alt=""></a></li>
<li>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2176aae9e099eeee07cc00c4dc7b7e7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2176aae9e099eeee07cc00c4dc7b7e7.jpg" alt=""></a></li>
</ul>
<p>举例:</p>
<pre><code class="language-py">&gt;&gt;&gt; fold = nn.Fold(output_size=(4, 5), kernel_size=(2, 2))
&gt;&gt;&gt; input = torch.randn(1, 3 * 2 * 2, 1)
&gt;&gt;&gt; output = fold(input)
&gt;&gt;&gt; output.size()

</code></pre>
<p><code>卷积层部分Fold 与 Unfold 是1.0新增的内容，猜测其主要目的是开放col2im和im2col这两个通过矩阵乘法实现卷积操作的前序接口，要好好理解这部分可能要了解一下现在主流框架通过大矩阵乘法来实现卷积操作这一通用做法了，这一篇文章就介绍的很好[Implementing convolution as a matrix multiplication](https://buptldy.github.io/2016/10/01/2016-10-01-im2col/)，这一段如果感觉我的直译晦涩难懂，那我深感抱歉并建议看一下英文原版，虽然我觉得英文原版介绍的也是晦涩难懂</code></p>
<h2 id="池化层pooling-layers">池化层（Pooling layers）</h2>
<h3 id="maxpool1d">MaxPool1d</h3>
<pre><code class="language-py">class torch.nn.MaxPool1d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行一维最大池化操作。</p>
<p>最简单的情况下，对于输入大小为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a> ，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" alt=""></a>的池化操作，此池化过程可表述如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e414c5b7df992e54f3227bb130be349.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e414c5b7df992e54f3227bb130be349.jpg" alt=""></a></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。 <code>dilation</code> 参数控制了池化核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>dilation</strong> – 滑动窗中各元素之间的距离</li>
<li><strong>return_indices</strong> – 如果此参数被设置为<code>True</code>， 那么此池化层在返回输出信号的同时还会返回一连串滑动窗最大值的索引位置，即每个滑动窗的最大值位置信息。这些信息可以在后面的上采样<a href="#torch.nn.MaxUnpool1d" title="torch.nn.MaxUnpool1d"><code>torch.nn.MaxUnpool1d</code></a>中被用到。</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ceb415a2a1558bab9998c277f780ec3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ceb415a2a1558bab9998c277f780ec3.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" alt=""></a> 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff16cce6b4741640e8adc0a271cd4592.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff16cce6b4741640e8adc0a271cd4592.jpg" alt=""></a></p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool1d(3, stride=2)
&gt;&gt;&gt; input = torch.randn(20, 16, 50)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="maxpool2d">MaxPool2d</h3>
<pre><code class="language-py">class torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行二维最大池化操作。</p>
<p>最简单的情况下，对于输入大小为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a> ，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a>，<code>kernel_size</code>为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6384e001ad4c0989683deb86f6ffbd2f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6384e001ad4c0989683deb86f6ffbd2f.jpg" alt=""></a>的池化操作，此池化过程可表述如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/caa8cbcbb8bbbbc6b0e47f9daa80ab12.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/caa8cbcbb8bbbbc6b0e47f9daa80ab12.jpg" alt=""></a></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。 <code>dilation</code> 参数控制了池化核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的宽和高这两个维度的大小</li>
<li>一个由两个<code>int</code>组成的<code>tuple</code> – 这种情况下，高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>dilation</strong> – 滑动窗中各元素之间的距离</li>
<li><strong>return_indices</strong> – 如果此参数被设置为<code>True</code>， 那么此池化层在返回输出信号的同时还会返回一连串滑动窗最大值的索引位置，即每个滑动窗的最大值位置信息。这些信息可以在后面的上采样<a href="#torch.nn.MaxUnpool2d" title="torch.nn.MaxUnpool2d"><code>torch.nn.MaxUnpool2d</code></a>中被用到。</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/991d42318f90dcb68b26938c542b8457.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/991d42318f90dcb68b26938c542b8457.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1e35edf42ee6921adb435b5ca638d406.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1e35edf42ee6921adb435b5ca638d406.jpg" alt=""></a></p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool2d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.MaxPool2d((3, 2), stride=(2, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="maxpool3d">MaxPool3d</h3>
<pre><code class="language-py">class torch.nn.MaxPool3d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行三维最大池化操作。</p>
<p>最简单的情况下，对于输入大小为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a> ，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a>，<code>kernel_size</code>为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5dcdebf9a81b9d15227749ae7535eb7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5dcdebf9a81b9d15227749ae7535eb7.jpg" alt=""></a> 的池化操作，此池化过程可表述如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f0f7a770dcfb802e7fc0f8995cfad3d7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f0f7a770dcfb802e7fc0f8995cfad3d7.jpg" alt=""></a></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。 <code>dilation</code> 参数控制了池化核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.html">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的深度，宽和高这三个维度的大小</li>
<li>一个由三个<code>int</code>组成的<code>tuple</code> – 这种情况下，深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>dilation</strong> – 滑动窗中各元素之间的距离</li>
<li><strong>return_indices</strong> – 如果此参数被设置为<code>True</code>， 那么此池化层在返回输出信号的同时还会返回一连串滑动窗最大值的索引位置，即每个滑动窗的最大值位置信息。这些信息可以在后面的上采样<a href="#torch.nn.MaxUnpool3d" title="torch.nn.MaxUnpool3d"><code>torch.nn.MaxUnpool3d</code></a>中被用到。</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0e49f319aa911192458f7b02321eff3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0e49f319aa911192458f7b02321eff3a.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b8fbd329439d7eba62abdf0df19f464d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b8fbd329439d7eba62abdf0df19f464d.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb1d0c30d1cf681f38e8391bd7d03dff.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb1d0c30d1cf681f38e8391bd7d03dff.jpg" alt=""></a></p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool3d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.MaxPool3d((3, 2, 2), stride=(2, 1, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 50,44, 31)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="maxunpool1d">MaxUnpool1d</h3>
<pre><code class="language-py">class torch.nn.MaxUnpool1d(kernel_size, stride=None, padding=0)
</code></pre>
<p><a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>的逆过程，不过并不是完全的逆过程，因为在<a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>的过程中，池化窗区域内的非最大值都已经丢失。 <a href="#torch.nn.MaxUnpool1d" title="torch.nn.MaxUnpool1d"><code>MaxUnpool1d</code></a>的输入是<a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>的输出，其中也包括包括滑动窗最大值的索引（即return_indices所控制的输出），逆池化操作的过程就是将<a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>过程中产生的最大值插回到原来的位置，并将非最大值区域置为0。</p>
<p>Note</p>
<p><a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>操作可以将多个大小不同的输入映射到相同的输出大小。因此，池化操作的反过程，<a href="#torch.nn.MaxUnpool1d" title="torch.nn.MaxUnpool1d"><code>MaxUnpool1d</code></a>的上采样过程的输出大小就不唯一了。为了适应这一点，可以在设置控制上采样输出大小的（<code>output_size</code>）参数。 具体用法，请参阅下面的输入和示例</p>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的步长。默认<code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 输入信号的各维度各边要补齐0的层数</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<ul>
<li><code>input</code>: 要执行上采样操作的张量</li>
<li><code>indices</code>: <a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>池化过程中输出的池化窗最大值的位置索引</li>
<li><code>output_size</code> (选填): 指定的输出大小</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ccc1792005f1eb97a439118aeba930e9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ccc1792005f1eb97a439118aeba930e9.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1b0403b4ee318895368afc8fa37b9407.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1b0403b4ee318895368afc8fa37b9407.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9618fc866026e724d16c5481dd67dc4c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9618fc866026e724d16c5481dd67dc4c.jpg" alt=""></a></p> <p>也可以使用<code>output_size</code>指定输出的大小</p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; pool = nn.MaxPool1d(2, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool1d(2, stride=2)
&gt;&gt;&gt; input = torch.tensor([[[1., 2, 3, 4, 5, 6, 7, 8]]])
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices)
tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.]]])

&gt;&gt;&gt; # Example showcasing the use of output_size
&gt;&gt;&gt; input = torch.tensor([[[1., 2, 3, 4, 5, 6, 7, 8, 9]]])
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices, output_size=input.size())
tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.,  0.]]])

&gt;&gt;&gt; unpool(output, indices)
tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.]]])

</code></pre>
<h3 id="maxunpool2d">MaxUnpool2d</h3>
<pre><code class="language-py">class torch.nn.MaxUnpool2d(kernel_size, stride=None, padding=0)
</code></pre>
<p><a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>的逆过程，不过并不是完全的逆过程，因为在<a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>的过程中，池化窗区域内的非最大值都已经丢失。 <a href="#torch.nn.MaxUnpool2d" title="torch.nn.MaxUnpool2d"><code>MaxUnpool2d</code></a>的输入是<a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>的输出，其中也包括包括滑动窗最大值的索引（即return_indices所控制的输出），逆池化操作的过程就是将<a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>过程中产生的最大值插回到原来的位置，并将非最大值区域置为0。</p>
<p>Note</p>
<p><a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>操作可以将多个大小不同的输入映射到相同的输出大小。因此，池化操作的反过程，<a href="#torch.nn.MaxUnpool2d" title="torch.nn.MaxUnpool2d"><code>MaxUnpool2d</code></a>的上采样过程的输出大小就不唯一了。为了适应这一点，可以在设置控制上采样输出大小的（<code>output_size</code>）参数。 具体用法，请参阅下面的输入和示例</p>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的步长。默认<code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 输入信号的各维度各边要补齐0的层数</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<ul>
<li><code>input</code>: 要执行上采样操作的张量</li>
<li><code>indices</code>: <a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>池化过程中输出的池化窗最大值的位置索引</li>
<li><code>output_size</code> (选填): 指定的输出大小</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f6dd707e18ccbf75f607d05338443e87.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f6dd707e18ccbf75f607d05338443e87.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac5d54ef9922f9e0dbe2dc916bf9d80b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac5d54ef9922f9e0dbe2dc916bf9d80b.jpg" alt=""></a></p> <p>也可以使用<code>output_size</code>指定输出的大小</p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; pool = nn.MaxPool2d(2, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool2d(2, stride=2)
&gt;&gt;&gt; input = torch.tensor([[[[ 1.,  2,  3,  4],
 [ 5,  6,  7,  8],
 [ 9, 10, 11, 12],
 [13, 14, 15, 16]]]])
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices)
tensor([[[[  0.,   0.,   0.,   0.],
 [  0.,   6.,   0.,   8.],
 [  0.,   0.,   0.,   0.],
 [  0.,  14.,   0.,  16.]]]])

&gt;&gt;&gt; # specify a different output size than input size
&gt;&gt;&gt; unpool(output, indices, output_size=torch.Size([1, 1, 5, 5]))
tensor([[[[  0.,   0.,   0.,   0.,   0.],
 [  6.,   0.,   8.,   0.,   0.],
 [  0.,   0.,   0.,  14.,   0.],
 [ 16.,   0.,   0.,   0.,   0.],
 [  0.,   0.,   0.,   0.,   0.]]]])

</code></pre>
<h3 id="maxunpool3d">MaxUnpool3d</h3>
<pre><code class="language-py">class torch.nn.MaxUnpool3d(kernel_size, stride=None, padding=0)
</code></pre>
<p><a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>的逆过程，不过并不是完全的逆过程，因为在<a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>的过程中，池化窗区域内的非最大值都已经丢失。 <a href="#torch.nn.MaxUnpool3d" title="torch.nn.MaxUnpool3d"><code>MaxUnpool3d</code></a>的输入是<a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>的输出，其中也包括包括滑动窗最大值的索引（即return_indices所控制的输出），逆池化操作的过程就是将<a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>过程中产生的最大值插回到原来的位置，并将非最大值区域置为0。</p>
<p>Note</p>
<p><a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>操作可以将多个大小不同的输入映射到相同的输出大小。因此，池化操作的反过程，<a href="#torch.nn.MaxUnpool3d" title="torch.nn.MaxUnpool3d"><code>MaxUnpool3d</code></a>的上采样过程的输出大小就不唯一了。为了适应这一点，可以在设置控制上采样输出大小的（<code>output_size</code>）参数。 具体用法，请参阅下面的输入和示例</p>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的步长。默认<code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 输入信号的各维度各边要补齐0的层数</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<ul>
<li><code>input</code>: 要执行上采样操作的张量</li>
<li><code>indices</code>: <a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>池化过程中输出的池化窗最大值的位置索引</li>
<li><code>output_size</code> (选填): 指定的输出大小</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/190cbccb4ab554a9b19bfc3df956f982.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/190cbccb4ab554a9b19bfc3df956f982.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/785a4e892f32eee65446b4e269fc452b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/785a4e892f32eee65446b4e269fc452b.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e666e9d78ffab5d03b4cf1adf1a6e331.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e666e9d78ffab5d03b4cf1adf1a6e331.jpg" alt=""></a></p> <p>也可以使用<code>output_size</code>指定输出的大小</p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; pool = nn.MaxPool3d(3, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool3d(3, stride=2)
&gt;&gt;&gt; output, indices = pool(torch.randn(20, 16, 51, 33, 15))
&gt;&gt;&gt; unpooled_output = unpool(output, indices)
&gt;&gt;&gt; unpooled_output.size()
torch.Size([20, 16, 51, 33, 15])

</code></pre>
<h3 id="avgpool1d">AvgPool1d</h3>
<pre><code class="language-py">class torch.nn.AvgPool1d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)
</code></pre>
<p>对输入的多通道信号执行一维平均池化操作。</p>
<p>最简单的情况下，对于输入大小为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a> ，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" alt=""></a>，<code>kernel_size</code>为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a1c2f8d5b1226e67bdb44b12a6ddf18b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a1c2f8d5b1226e67bdb44b12a6ddf18b.jpg" alt=""></a>的池化操作，此池化过程可表述如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5df0036df168f4a16d4437d91968f640.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5df0036df168f4a16d4437d91968f640.jpg" alt=""></a></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 等参数均支持输入一个int或者由一个int组成的tuple。</p>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
<li><strong>count_include_pad</strong> – 如果被设置为True, 那么在进行平均运算的时候也会将用于补齐的0加入运算。</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ceb415a2a1558bab9998c277f780ec3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ceb415a2a1558bab9998c277f780ec3.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ad61a9298a545292682229fef2f1a910.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ad61a9298a545292682229fef2f1a910.jpg" alt=""></a></p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool with window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool1d(3, stride=2)
&gt;&gt;&gt; m(torch.tensor([[[1.,2,3,4,5,6,7]]]))
tensor([[[ 2.,  4.,  6.]]])

</code></pre>
<h3 id="avgpool2d">AvgPool2d</h3>
<pre><code class="language-py">class torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)
</code></pre>
<p>对输入的多通道信号执行二维平均池化操作。 最简单的情况下，对于输入大小为 <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a> ，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a>，<code>kernel_size</code>为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6384e001ad4c0989683deb86f6ffbd2f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6384e001ad4c0989683deb86f6ffbd2f.jpg" alt=""></a>的池化操作，此池化过程可表述如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b7a0e1d0a42a3626724c14d89a10a44f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b7a0e1d0a42a3626724c14d89a10a44f.jpg" alt=""></a></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的宽和高这两个维度的大小</li>
<li>一个由两个<code>int</code>组成的<code>tuple</code> – 这种情况下，高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
<li><strong>count_include_pad</strong> – 如果被设置为True, 那么在进行平均运算的时候也会将用于补齐的0加入运算。</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8b8b2b1a77c4f104a936efb1708366ef.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8b8b2b1a77c4f104a936efb1708366ef.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2792347200dabe493ae8baee428f9bf8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2792347200dabe493ae8baee428f9bf8.jpg" alt=""></a></p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool2d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.AvgPool2d((3, 2), stride=(2, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="avgpool3d">AvgPool3d</h3>
<pre><code class="language-py">class torch.nn.AvgPool3d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)
</code></pre>
<p>对输入的多通道信号执行三维平均池化操作。 最简单的情况下，对于输入大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a>，输出大小为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a>，<code>kernel_size</code>为<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5dcdebf9a81b9d15227749ae7535eb7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5dcdebf9a81b9d15227749ae7535eb7.jpg" alt=""></a>的池化操作，此池化过程可表述如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79acedd31cd18baac8d97ab96a7092e0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79acedd31cd18baac8d97ab96a7092e0.jpg" alt=""></a></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的深度，宽和高这两个维度的大小</li>
<li>一个由三个<code>int</code>组成的<code>tuple</code> – 这种情况下，深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
<li><strong>count_include_pad</strong> – 如果被设置为True, 那么在进行平均运算的时候也会将用于补齐的0加入运算。</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/443035401ce7a1144122a862f34493cf.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/443035401ce7a1144122a862f34493cf.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8488a299a75cb56e138e1dc5a24a10db.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8488a299a75cb56e138e1dc5a24a10db.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c799c115b670c02d039f828fe1afa443.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c799c115b670c02d039f828fe1afa443.jpg" alt=""></a></p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool3d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.AvgPool3d((3, 2, 2), stride=(2, 1, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 50,44, 31)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="fractionalmaxpool2d">FractionalMaxPool2d</h3>
<pre><code class="language-py">class torch.nn.FractionalMaxPool2d(kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)
</code></pre>
<p>对输入的多通道信号执行小数级二维最大池化操作。<code>小数级</code>指的是此操作的输出大小与输入大小成指定的小数倍数关系。</p>
<p>Ben Graham的这篇文章<a href="http://arxiv.org/abs/1412.6071">Fractional MaxPooling</a>中详细地介绍了小数级二维最大池化的基本思想和技术细节。</p>
<p>小数级二维最大池化的基本思想就是将最大池化操作应用于<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/52ec12db6613ee8a0f6f41143ab2e8a2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/52ec12db6613ee8a0f6f41143ab2e8a2.jpg" alt=""></a>个由随机步长大小采集的区域中，这些步长大小是由输出目标的大小决定的。小数级二维最大池化的输出特征的数量等于输入通道的数量。</p>
<p>Parameters:</p>
<ul>
<li><strong>kernel_size</strong> – 执行最大操作的窗口大小。支持的数据类型包括一个单独的数字k(生成一个大小为k x k的正方形kernal)，或者一个元组 <code>(kh x kw)</code></li>
<li><strong>output_size</strong> – 池化输出目标大小，具体形式是 <code>oH x oW</code>。支持的数据类型包括一个单独的数字<code>oH</code>，或者一个元组 <code>(oH, oW)</code>，注意此处<code>oH x oW</code>与<code>kernal_size</code>中的<code>kh x ow</code>相呼应，两者成一定的小数级倍数关系</li>
<li><strong>output_ratio</strong> – 如果想让输出目标的大小是输入目标大小的ratio倍，可以通过设置此参数来实现。此参数可以是一个小数数字或者小数元组，数字范围是(0, 1)</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool2d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, and target output size 13x12
&gt;&gt;&gt; m = nn.FractionalMaxPool2d(3, output_size=(13, 12))
&gt;&gt;&gt; # pool of square window and target output size being half of input image size
&gt;&gt;&gt; m = nn.FractionalMaxPool2d(3, output_ratio=(0.5, 0.5))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="lppool1d">LPPool1d</h3>
<pre><code class="language-py">class torch.nn.LPPool1d(norm_type, kernel_size, stride=None, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行一维幂平均池化操作。</p>
<p>对于每个池化窗口，此池化操作的计算方式如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e4451f809255881ee286970ddf3fb377.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e4451f809255881ee286970ddf3fb377.jpg" alt=""></a></p>
<ul>
<li>当p为无穷大的时候时，等价于最大池化操作</li>
<li>当<code>p=1</code>时，等价于求和池化操作（一定程度上等价于平均池化）</li>
</ul>
<p>Note</p>
<p>如果某个特殊的输入导致这个输入关于幂指数<code>p</code>的求和是0，那上述池化函数在这一点是没有意义的。在实际实现过程中，此点的梯度被设置为0。</p>
<p>Parameters:</p>
<ul>
<li>kernel_size: 池化窗口的大小</li>
<li>stride：池化窗口移动的步长。默认值是<code>kernel_size</code></li>
<li>ceil_mode: 当此参数被设置为<code>True</code>时，在计算输出大小的时候将使用向下取整代替向上取整</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ceb415a2a1558bab9998c277f780ec3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ceb415a2a1558bab9998c277f780ec3.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d131773750846713475c600aa8cd917a.jpg" alt=""></a>，其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5d246e9891509c48081bc89191e64418.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5d246e9891509c48081bc89191e64418.jpg" alt=""></a></p> </li>
</ul>
<pre><code class="language-py">例子:
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; # power-2 pool of window of length 3, with stride 2.
&gt;&gt;&gt; m = nn.LPPool1d(2, 3, stride=2)
&gt;&gt;&gt; input = torch.randn(20, 16, 50)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="lppool2d">LPPool2d</h3>
<pre><code class="language-py">class torch.nn.LPPool2d(norm_type, kernel_size, stride=None, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行二维幂平均池化操作。</p>
<p>对于每个池化窗口，此池化操作的计算方式如下：</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e4451f809255881ee286970ddf3fb377.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e4451f809255881ee286970ddf3fb377.jpg" alt=""></a></p>
<ul>
<li>当p等于<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b0c1b8fa38555e0b1ca3265b84bb3974.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b0c1b8fa38555e0b1ca3265b84bb3974.jpg" alt=""></a>时候时，等价于最大池化操作</li>
<li>当<code>p=1</code>时，等价于求和池化操作（一定程度上等价于平均池化）</li>
</ul>
<p>参数<code>kernel_size</code>, <code>stride</code>支持的数据类型：</p>
<ul>
<li><code>int</code>，池化窗口的宽和高相等</li>
<li><code>tuple</code>数组（两个数字的），第一个元素是池化窗口的高，第二个是宽</li>
</ul>
<p>Note</p>
<p>如果某个特殊的输入导致这个输入关于幂指数<code>p</code>的求和是0，那上述池化函数在这一点是没有意义的。在实际实现过程中，此点的梯度被设置为0。</p>
<p>Parameters:</p>
<ul>
<li>kernel_size: 池化窗口的大小</li>
<li>stride：池化窗口移动的步长。默认值是<code>kernel_size</code></li>
<li>ceil_mode: 当此参数被设置为<code>True</code>时，在计算输出大小的时候将使用向下取整代替向上取整</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>输入: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></p> </li>
<li> <p>输出: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a>, 其中</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/44bfdaa5e6b603085c2da3eddb558556.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/44bfdaa5e6b603085c2da3eddb558556.jpg" alt=""></a></p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d59b07475dea090e5f7110600d8f8bdc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d59b07475dea090e5f7110600d8f8bdc.jpg" alt=""></a></p> </li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # power-2 pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.LPPool2d(2, 3, stride=2)
&gt;&gt;&gt; # pool of non-square window of power 1.2
&gt;&gt;&gt; m = nn.LPPool2d(1.2, (3, 2), stride=(2, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivemaxpool1d">AdaptiveMaxPool1d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveMaxPool1d(output_size, return_indices=False)
</code></pre>
<p>对输入的多通道信号进行1维的自适应最大池化操作。</p>
<p>此池化层可以通过指定输出大小H，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters:</p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool1d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5
&gt;&gt;&gt; m = nn.AdaptiveMaxPool1d(5)
&gt;&gt;&gt; input = torch.randn(1, 64, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivemaxpool2d">AdaptiveMaxPool2d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveMaxPool2d(output_size, return_indices=False)
</code></pre>
<p>对输入的多通道信号进行2维的自适应最大池化操作。</p>
<p>此池化层可以通过指定输出大小H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters:</p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H x W。此参数支持的数据类型可以是一个元组(H, W)，又或者是一个单独的<code>int</code> H（等价于H x H）。H 和 W这两个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool2d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d((5,7))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7 (square)
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 10x7
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d((None, 7))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivemaxpool3d">AdaptiveMaxPool3d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveMaxPool3d(output_size, return_indices=False)
</code></pre>
<p>对输入的多通道信号进行3维的自适应最大池化操作。</p>
<p>此池化层可以通过指定输出大小D x H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters:</p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小D x H x W。此参数支持的数据类型可以是一个元组(D, H, W)，又或者是一个单独的<code>int</code> D（等价于D x D x D)。D, H 和 W这三个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool3d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7x9
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d((5,7,9))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9, 10)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7x7 (cube)
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x9x8
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d((7, None, None))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptiveavgpool1d">AdaptiveAvgPool1d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveAvgPool1d(output_size)
</code></pre>
<p>对输入的多通道信号进行1维的自适应平均池化操作。</p>
<p>此池化层可以通过指定输出大小H，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters:</p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H</li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5
&gt;&gt;&gt; m = nn.AdaptiveAvgPool1d(5)
&gt;&gt;&gt; input = torch.randn(1, 64, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptiveavgpool2d">AdaptiveAvgPool2d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveAvgPool2d(output_size)
</code></pre>
<p>对输入的多通道信号进行2维的自适应平均池化操作。</p>
<p>此池化层可以通过指定输出大小H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters:</p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H x W。此参数支持的数据类型可以是一个元组(H, W)，又或者是一个单独的<code>int</code> H（等价于H x H）。H 和 W这两个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7
&gt;&gt;&gt; m = nn.AdaptiveAvgPool2d((5,7))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7 (square)
&gt;&gt;&gt; m = nn.AdaptiveAvgPool2d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 10x7
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d((None, 7))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptiveavgpool3d">AdaptiveAvgPool3d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveAvgPool3d(output_size)
</code></pre>
<p>对输入的多通道信号进行3维的自适应平均池化操作。</p>
<p>此池化层可以通过指定输出大小D x H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters:</p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小D x H x W。此参数支持的数据类型可以是一个元组(D, H, W)，又或者是一个单独的<code>int</code> D（等价于D x D x D)。D, H 和 W这三个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7x9
&gt;&gt;&gt; m = nn.AdaptiveAvgPool3d((5,7,9))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9, 10)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7x7 (cube)
&gt;&gt;&gt; m = nn.AdaptiveAvgPool3d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x9x8
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d((7, None, None))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="padding-layers">Padding layers</h2>
<h3 id="reflectionpad1d">ReflectionPad1d</h3>
<pre><code class="language-py">class torch.nn.ReflectionPad1d(padding)
</code></pre>
<p>Pads the input tensor using the reflection of the input boundary.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 2-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReflectionPad1d(2)
&gt;&gt;&gt; input = torch.arange(8, dtype=torch.float).reshape(1, 2, 4)
&gt;&gt;&gt; input
tensor([[[0., 1., 2., 3.],
 [4., 5., 6., 7.]]])
&gt;&gt;&gt; m(input)
tensor([[[2., 1., 0., 1., 2., 3., 2., 1.],
 [6., 5., 4., 5., 6., 7., 6., 5.]]])
&gt;&gt;&gt; m(input)
tensor([[[2., 1., 0., 1., 2., 3., 2., 1.],
 [6., 5., 4., 5., 6., 7., 6., 5.]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReflectionPad1d((3, 1))
&gt;&gt;&gt; m(input)
tensor([[[3., 2., 1., 0., 1., 2., 3., 2.],
 [7., 6., 5., 4., 5., 6., 7., 6.]]])

</code></pre>
<h3 id="reflectionpad2d">ReflectionPad2d</h3>
<pre><code class="language-py">class torch.nn.ReflectionPad2d(padding)
</code></pre>
<p>Pads the input tensor using the reflection of the input boundary.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 4-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></p> </li>
<li> <p>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a> where</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></p> </li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReflectionPad2d(2)
&gt;&gt;&gt; input = torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)
&gt;&gt;&gt; input
tensor([[[[0., 1., 2.],
 [3., 4., 5.],
 [6., 7., 8.]]]])
&gt;&gt;&gt; m(input)
tensor([[[[8., 7., 6., 7., 8., 7., 6.],
 [5., 4., 3., 4., 5., 4., 3.],
 [2., 1., 0., 1., 2., 1., 0.],
 [5., 4., 3., 4., 5., 4., 3.],
 [8., 7., 6., 7., 8., 7., 6.],
 [5., 4., 3., 4., 5., 4., 3.],
 [2., 1., 0., 1., 2., 1., 0.]]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReflectionPad2d((1, 1, 2, 0))
&gt;&gt;&gt; m(input)
tensor([[[[7., 6., 7., 8., 7.],
 [4., 3., 4., 5., 4.],
 [1., 0., 1., 2., 1.],
 [4., 3., 4., 5., 4.],
 [7., 6., 7., 8., 7.]]]])

</code></pre>
<h3 id="replicationpad1d">ReplicationPad1d</h3>
<pre><code class="language-py">class torch.nn.ReplicationPad1d(padding)
</code></pre>
<p>Pads the input tensor using replication of the input boundary.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 2-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad1d(2)
&gt;&gt;&gt; input = torch.arange(8, dtype=torch.float).reshape(1, 2, 4)
&gt;&gt;&gt; input
tensor([[[0., 1., 2., 3.],
 [4., 5., 6., 7.]]])
&gt;&gt;&gt; m(input)
tensor([[[0., 0., 0., 1., 2., 3., 3., 3.],
 [4., 4., 4., 5., 6., 7., 7., 7.]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReplicationPad1d((3, 1))
&gt;&gt;&gt; m(input)
tensor([[[0., 0., 0., 0., 1., 2., 3., 3.],
 [4., 4., 4., 4., 5., 6., 7., 7.]]])

</code></pre>
<h3 id="replicationpad2d">ReplicationPad2d</h3>
<pre><code class="language-py">class torch.nn.ReplicationPad2d(padding)
</code></pre>
<p>Pads the input tensor using replication of the input boundary.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 4-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad2d(2)
&gt;&gt;&gt; input = torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)
&gt;&gt;&gt; input
tensor([[[[0., 1., 2.],
 [3., 4., 5.],
 [6., 7., 8.]]]])
&gt;&gt;&gt; m(input)
tensor([[[[0., 0., 0., 1., 2., 2., 2.],
 [0., 0., 0., 1., 2., 2., 2.],
 [0., 0., 0., 1., 2., 2., 2.],
 [3., 3., 3., 4., 5., 5., 5.],
 [6., 6., 6., 7., 8., 8., 8.],
 [6., 6., 6., 7., 8., 8., 8.],
 [6., 6., 6., 7., 8., 8., 8.]]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReplicationPad2d((1, 1, 2, 0))
&gt;&gt;&gt; m(input)
tensor([[[[0., 0., 1., 2., 2.],
 [0., 0., 1., 2., 2.],
 [0., 0., 1., 2., 2.],
 [3., 3., 4., 5., 5.],
 [6., 6., 7., 8., 8.]]]])

</code></pre>
<h3 id="replicationpad3d">ReplicationPad3d</h3>
<pre><code class="language-py">class torch.nn.ReplicationPad3d(padding)
</code></pre>
<p>Pads the input tensor using replication of the input boundary.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 6-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bffb266183e8fa640240e16a45076c34.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bffb266183e8fa640240e16a45076c34.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9138ac0ee6f6e96dfe795ead91ec0003.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9138ac0ee6f6e96dfe795ead91ec0003.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/006114d9c80210ede5da92f2f3a44bb7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/006114d9c80210ede5da92f2f3a44bb7.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad3d(3)
&gt;&gt;&gt; input = torch.randn(16, 3, 8, 320, 480)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReplicationPad3d((3, 3, 6, 6, 1, 1))
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="zeropad2d">ZeroPad2d</h3>
<pre><code class="language-py">class torch.nn.ZeroPad2d(padding)
</code></pre>
<p>Pads the input tensor boundaries with zero.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 4-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ZeroPad2d(2)
&gt;&gt;&gt; input = torch.randn(1, 1, 3, 3)
&gt;&gt;&gt; input
tensor([[[[-0.1678, -0.4418,  1.9466],
 [ 0.9604, -0.4219, -0.5241],
 [-0.9162, -0.5436, -0.6446]]]])
&gt;&gt;&gt; m(input)
tensor([[[[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000, -0.1678, -0.4418,  1.9466,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.9604, -0.4219, -0.5241,  0.0000,  0.0000],
 [ 0.0000,  0.0000, -0.9162, -0.5436, -0.6446,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ZeroPad2d((1, 1, 2, 0))
&gt;&gt;&gt; m(input)
tensor([[[[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000, -0.1678, -0.4418,  1.9466,  0.0000],
 [ 0.0000,  0.9604, -0.4219, -0.5241,  0.0000],
 [ 0.0000, -0.9162, -0.5436, -0.6446,  0.0000]]]])

</code></pre>
<h3 id="constantpad1d">ConstantPad1d</h3>
<pre><code class="language-py">class torch.nn.ConstantPad1d(padding, value)
</code></pre>
<p>Pads the input tensor boundaries with a constant value.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in both boundaries. If a 2-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ConstantPad1d(2, 3.5)
&gt;&gt;&gt; input = torch.randn(1, 2, 4)
&gt;&gt;&gt; input
tensor([[[-1.0491, -0.7152, -0.0749,  0.8530],
 [-1.3287,  1.8966,  0.1466, -0.2771]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000, -1.0491, -0.7152, -0.0749,  0.8530,  3.5000,
 3.5000],
 [ 3.5000,  3.5000, -1.3287,  1.8966,  0.1466, -0.2771,  3.5000,
 3.5000]]])
&gt;&gt;&gt; m = nn.ConstantPad1d(2, 3.5)
&gt;&gt;&gt; input = torch.randn(1, 2, 3)
&gt;&gt;&gt; input
tensor([[[ 1.6616,  1.4523, -1.1255],
 [-3.6372,  0.1182, -1.8652]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000,  3.5000],
 [ 3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000,  3.5000]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ConstantPad1d((3, 1), 3.5)
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000],
 [ 3.5000,  3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000]]])

</code></pre>
<h3 id="constantpad2d">ConstantPad2d</h3>
<pre><code class="language-py">class torch.nn.ConstantPad2d(padding, value)
</code></pre>
<p>Pads the input tensor boundaries with a constant value.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 4-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ConstantPad2d(2, 3.5)
&gt;&gt;&gt; input = torch.randn(1, 2, 2)
&gt;&gt;&gt; input
tensor([[[ 1.6585,  0.4320],
 [-0.8701, -0.4649]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  1.6585,  0.4320,  3.5000,  3.5000],
 [ 3.5000,  3.5000, -0.8701, -0.4649,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  1.6585,  0.4320,  3.5000,  3.5000],
 [ 3.5000,  3.5000, -0.8701, -0.4649,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ConstantPad2d((3, 0, 2, 1), 3.5)
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  1.6585,  0.4320],
 [ 3.5000,  3.5000,  3.5000, -0.8701, -0.4649],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])

</code></pre>
<h3 id="constantpad3d">ConstantPad3d</h3>
<pre><code class="language-py">class torch.nn.ConstantPad3d(padding, value)
</code></pre>
<p>Pads the input tensor boundaries with a constant value.</p>
<p>For <code>N</code>-dimensional padding, use <a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – the size of the padding. If is <code>int</code>, uses the same padding in all boundaries. If a 6-<code>tuple</code>, uses (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9f56071a00e2baa50d7fa9bde997852d.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65f6ce26141c225acd502a7bef164f66.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9a98061e27ba6ed06e846767b9c77c3a.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bffb266183e8fa640240e16a45076c34.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bffb266183e8fa640240e16a45076c34.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9138ac0ee6f6e96dfe795ead91ec0003.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9138ac0ee6f6e96dfe795ead91ec0003.jpg" alt=""></a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/006114d9c80210ede5da92f2f3a44bb7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/006114d9c80210ede5da92f2f3a44bb7.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" alt=""></a> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e2294a717e6d12035072d23c45273863.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ConstantPad3d(3, 3.5)
&gt;&gt;&gt; input = torch.randn(16, 3, 10, 20, 30)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ConstantPad3d((3, 3, 6, 6, 0, 1), 3.5)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="non-linear-activations-weighted-sum-nonlinearity">Non-linear activations (weighted sum, nonlinearity)</h2>
<h3 id="elu">ELU</h3>
<pre><code class="language-py">class torch.nn.ELU(alpha=1.0, inplace=False)
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1285687f031aec0751f4e0481f97b6b0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1285687f031aec0751f4e0481f97b6b0.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>alpha</strong> – the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" alt=""></a> value for the ELU formulation. Default: 1.0</li>
<li><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5d789140032850b13d5c00493bf62412.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5d789140032850b13d5c00493bf62412.jpg" alt="https://pytorch.org/docs/stable/_images//ELU.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ELU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="hardshrink">Hardshrink</h3>
<pre><code class="language-py">class torch.nn.Hardshrink(lambd=0.5)
</code></pre>
<p>Applies the hard shrinkage function element-wise:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f934a1a7fa1553c38403f2e010708ed9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f934a1a7fa1553c38403f2e010708ed9.jpg" alt=""></a></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>lambd</strong> – the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" alt=""></a> value for the Hardshrink formulation. Default: 0.5</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/45889773f687ed0d33a3ef9b66b0da32.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/45889773f687ed0d33a3ef9b66b0da32.jpg" alt="https://pytorch.org/docs/stable/_images//Hardshrink.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Hardshrink()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="hardtanh">Hardtanh</h3>
<pre><code class="language-py">class torch.nn.Hardtanh(min_val=-1.0, max_val=1.0, inplace=False, min_value=None, max_value=None)
</code></pre>
<p>Applies the HardTanh function element-wise</p>
<p>HardTanh is defined as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/988cd664634d88b1e654ea5e8fe27d9a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/988cd664634d88b1e654ea5e8fe27d9a.jpg" alt=""></a></p>
<p>The range of the linear region <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30fa7744d61427a11bf0e75b1557a16.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30fa7744d61427a11bf0e75b1557a16.jpg" alt=""></a> can be adjusted using <code>min_val</code> and <code>max_val</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b22ab176e5aca7ca2b17e84fe525620e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b22ab176e5aca7ca2b17e84fe525620e.jpg" alt="https://pytorch.org/docs/stable/_images//Hardtanh.png"></a></p>
<p>Parameters:</p>
<ul>
<li><strong>min_val</strong> – minimum value of the linear region range. Default: -1</li>
<li><strong>max_val</strong> – maximum value of the linear region range. Default: 1</li>
<li><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></li>
</ul>
<p>Keyword arguments <code>min_value</code> and <code>max_value</code> have been deprecated in favor of <code>min_val</code> and <code>max_val</code>.</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Hardtanh(-2, 2)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="leakyrelu">LeakyReLU</h3>
<pre><code class="language-py">class torch.nn.LeakyReLU(negative_slope=0.01, inplace=False)
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/92ce1c3da3211f30ef5273403da71c7a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/92ce1c3da3211f30ef5273403da71c7a.jpg" alt=""></a></p>
<p>or</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/377c237cda65f4c68e3138efcc2bfef4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/377c237cda65f4c68e3138efcc2bfef4.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>negative_slope</strong> – Controls the angle of the negative slope. Default: 1e-2</li>
<li><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7df3c1e498d7d00e9e32ce7716e15fc3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7df3c1e498d7d00e9e32ce7716e15fc3.jpg" alt="https://pytorch.org/docs/stable/_images//LeakyReLU.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LeakyReLU(0.1)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="logsigmoid">LogSigmoid</h3>
<pre><code class="language-py">class torch.nn.LogSigmoid
</code></pre>
<p>Applies the element-wise function:</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f03b653b702dcd536fbb404c6461b399.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f03b653b702dcd536fbb404c6461b399.jpg" alt="https://pytorch.org/docs/stable/_images//LogSigmoid.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LogSigmoid()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="prelu">PReLU</h3>
<pre><code class="language-py">class torch.nn.PReLU(num_parameters=1, init=0.25)
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/96fb709d31ba330ca192080e660d4cf1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/96fb709d31ba330ca192080e660d4cf1.jpg" alt=""></a></p>
<p>or</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f460dc15bedfa96b8a320033b3f4fd6f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f460dc15bedfa96b8a320033b3f4fd6f.jpg" alt=""></a></p>
<p>Here <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" alt=""></a> is a learnable parameter. When called without arguments, <code>nn.PReLU()</code> uses a single parameter <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" alt=""></a> across all input channels. If called with <code>nn.PReLU(nChannels)</code>, a separate <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" alt=""></a> is used for each input channel.</p>
<p>Note</p>
<p>weight decay should not be used when learning <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" alt=""></a> for good performance.</p>
<p>Note</p>
<p>Channel dim is the 2nd dim of input. When input has dims &lt; 2, then there is no channel dim and the number of channels = 1.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_parameters</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" alt=""></a> to learn. Although it takes an int as input, there is only two values are legitimate: 1, or the number of channels at input. Default: 1</li>
<li><strong>init</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the initial value of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" alt=""></a>. Default: 0.25</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the learnable weights of shape (attr:<code>num_parameters</code>). The attr:<code>dtype</code> is default to</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/59baba7257ac05b747455a25a3457baf.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/59baba7257ac05b747455a25a3457baf.jpg" alt="https://pytorch.org/docs/stable/_images//PReLU.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.PReLU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="relu">ReLU</h3>
<pre><code class="language-py">class torch.nn.ReLU(inplace=False)
</code></pre>
<p>Applies the rectified linear unit function element-wise <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f859c48107afb47986b3297459048c80.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f859c48107afb47986b3297459048c80.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6bfe295d2f51e4e33648ffb4273723a6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6bfe295d2f51e4e33648ffb4273723a6.jpg" alt="https://pytorch.org/docs/stable/_images//ReLU.png"></a></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReLU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="relu6">ReLU6</h3>
<pre><code class="language-py">class torch.nn.ReLU6(inplace=False)
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/38c45c0cb00fa6f9a372816012b26b01.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/38c45c0cb00fa6f9a372816012b26b01.jpg" alt=""></a></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3a82f9216f0db7d59f6c0f1c169156b0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3a82f9216f0db7d59f6c0f1c169156b0.jpg" alt="https://pytorch.org/docs/stable/_images//ReLU6.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReLU6()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="rrelu">RReLU</h3>
<pre><code class="language-py">class torch.nn.RReLU(lower=0.125, upper=0.3333333333333333, inplace=False)
</code></pre>
<p>Applies the randomized leaky rectified liner unit function, element-wise, as described in the paper:</p>
<p><a href="https://arxiv.org/abs/1505.00853">Empirical Evaluation of Rectified Activations in Convolutional Network</a>.</p>
<p>The function is defined as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aa6828f2f0bcd0ee1e173223ff4640.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/69aa6828f2f0bcd0ee1e173223ff4640.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/070b1af5eca3a5c5d72884b536090f17.jpg" alt=""></a> is randomly sampled from uniform distribution <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7323b93ed925c9e5b0ce10c8a6c99daf.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7323b93ed925c9e5b0ce10c8a6c99daf.jpg" alt=""></a>.</p>
<blockquote>
<p>See: <a href="https://arxiv.org/pdf/1505.00853.pdf">https://arxiv.org/pdf/1505.00853.pdf</a></p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><strong>lower</strong> – lower bound of the uniform distribution. Default: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/444fc0427eb64f0bd2c9c16edf680d4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/444fc0427eb64f0bd2c9c16edf680d4f.jpg" alt=""></a></li>
<li><strong>upper</strong> – upper bound of the uniform distribution. Default: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a90c89c913a1fe1e9462d60d8668936b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a90c89c913a1fe1e9462d60d8668936b.jpg" alt=""></a></li>
<li><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.RReLU(0.1, 0.3)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="selu">SELU</h3>
<pre><code class="language-py">class torch.nn.SELU(inplace=False)
</code></pre>
<p>Applied element-wise, as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c6753a504d14886a424af779f5906dc5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c6753a504d14886a424af779f5906dc5.jpg" alt=""></a></p>
<p>with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e97a0b3de4bafa3464e17a8d8f66fd9d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e97a0b3de4bafa3464e17a8d8f66fd9d.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/aa01199f9b814d719de1e728e4a44ac3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/aa01199f9b814d719de1e728e4a44ac3.jpg" alt=""></a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/10123138310ae40f4a78f55cefe37008.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/10123138310ae40f4a78f55cefe37008.jpg" alt="https://pytorch.org/docs/stable/_images//SELU.png"></a></p>
<p>More details can be found in the paper <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a> .</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – can optionally do the operation in-place. Default: <code>False</code></th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.SELU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="celu">CELU</h3>
<pre><code class="language-py">class torch.nn.CELU(alpha=1.0, inplace=False)
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/86d69b42683362b7781f1a5809c0d0d1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/86d69b42683362b7781f1a5809c0d0d1.jpg" alt=""></a></p>
<p>More details can be found in the paper <a href="https://arxiv.org/abs/1704.07483">Continuously Differentiable Exponential Linear Units</a> .</p>
<p>Parameters:</p>
<ul>
<li><strong>alpha</strong> – the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" alt=""></a> value for the CELU formulation. Default: 1.0</li>
<li><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d5fd8f893fb491c170f9a38af6edef9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d5fd8f893fb491c170f9a38af6edef9.jpg" alt="https://pytorch.org/docs/stable/_images//CELU.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.CELU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="sigmoid">Sigmoid</h3>
<pre><code class="language-py">class torch.nn.Sigmoid
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8bf3a718397550598124548beb8c6b23.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8bf3a718397550598124548beb8c6b23.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/961caeb46e669eb70392afd515f9bde7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/961caeb46e669eb70392afd515f9bde7.jpg" alt="https://pytorch.org/docs/stable/_images//Sigmoid.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Sigmoid()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softplus">Softplus</h3>
<pre><code class="language-py">class torch.nn.Softplus(beta=1, threshold=20)
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0855ca512a1ba09192648efd45082ad.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0855ca512a1ba09192648efd45082ad.jpg" alt=""></a></p>
<p>SoftPlus is a smooth approximation to the ReLU function and can be used to constrain the output of a machine to always be positive.</p>
<p>For numerical stability the implementation reverts to the linear function for inputs above a certain value.</p>
<p>Parameters:</p>
<ul>
<li><strong>beta</strong> – the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> value for the Softplus formulation. Default: 1</li>
<li><strong>threshold</strong> – values above this revert to a linear function. Default: 20</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/af06304134e1f56d7abc15570fa5adb9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/af06304134e1f56d7abc15570fa5adb9.jpg" alt="https://pytorch.org/docs/stable/_images//Softplus.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softplus()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softshrink">Softshrink</h3>
<pre><code class="language-py">class torch.nn.Softshrink(lambd=0.5)
</code></pre>
<p>Applies the soft shrinkage function elementwise:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5baf58b3007cf434725f41bf2dfae2ce.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5baf58b3007cf434725f41bf2dfae2ce.jpg" alt=""></a></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>lambd</strong> – the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" alt=""></a> value for the Softshrink formulation. Default: 0.5</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cec198ab680657d41c1d2ac2176e5664.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cec198ab680657d41c1d2ac2176e5664.jpg" alt="https://pytorch.org/docs/stable/_images//Softshrink.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softshrink()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softsign">Softsign</h3>
<pre><code class="language-py">class torch.nn.Softsign
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/39ba3e3786920ceb12bc26b08b00de1c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/39ba3e3786920ceb12bc26b08b00de1c.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b92a09469ce9fc0abfbe8c9af4228391.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b92a09469ce9fc0abfbe8c9af4228391.jpg" alt="https://pytorch.org/docs/stable/_images//Softsign.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softsign()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="tanh">Tanh</h3>
<pre><code class="language-py">class torch.nn.Tanh
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e3f58d9a8cbc89b247dd8de1c28bf7ce.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e3f58d9a8cbc89b247dd8de1c28bf7ce.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5605304fc1fec06669e17cc872d47580.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5605304fc1fec06669e17cc872d47580.jpg" alt="https://pytorch.org/docs/stable/_images//Tanh.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Tanh()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="tanhshrink">Tanhshrink</h3>
<pre><code class="language-py">class torch.nn.Tanhshrink
</code></pre>
<p>Applies the element-wise function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/136fda10bacf7ae9068ca487ba861805.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/136fda10bacf7ae9068ca487ba861805.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8aea39259742ccdb14701a8f3c351b56.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8aea39259742ccdb14701a8f3c351b56.jpg" alt="https://pytorch.org/docs/stable/_images//Tanhshrink.png"></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Tanhshrink()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="threshold">Threshold</h3>
<pre><code class="language-py">class torch.nn.Threshold(threshold, value, inplace=False)
</code></pre>
<p>Thresholds each element of the input Tensor</p>
<p>Threshold is defined as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3b32031caba73686c02a117e8e307c6f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3b32031caba73686c02a117e8e307c6f.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>threshold</strong> – The value to threshold at</li>
<li><strong>value</strong> – The value to replace with</li>
<li><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Threshold(0.1, 20)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="non-linear-activations-other">Non-linear activations (other)</h2>
<h3 id="softmin">Softmin</h3>
<pre><code class="language-py">class torch.nn.Softmin(dim=None)
</code></pre>
<p>Applies the Softmin function to an n-dimensional input Tensor rescaling them so that the elements of the n-dimensional output Tensor lie in the range <code>(0, 1)</code> and sum to 1</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/440f43280457a9287bbddf28553f8f70.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/440f43280457a9287bbddf28553f8f70.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: any shape</li>
<li>Output: same as input</li>
</ul>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – A dimension along which Softmin will be computed (so every slice along dim will sum to 1).</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a Tensor of the same dimension and shape as the input, with values in the range [0, 1]</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softmin()
&gt;&gt;&gt; input = torch.randn(2, 3)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softmax">Softmax</h3>
<pre><code class="language-py">class torch.nn.Softmax(dim=None)
</code></pre>
<p>Applies the Softmax function to an n-dimensional input Tensor rescaling them so that the elements of the n-dimensional output Tensor lie in the range (0,1) and sum to 1</p>
<p>Softmax is defined as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cbfd37534eccdda606d4f8494c31d2c0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cbfd37534eccdda606d4f8494c31d2c0.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: any shape</li>
<li>Output: same as input</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>a Tensor of the same dimension and shape as the input with values in the range [0, 1]</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters:</td>
<td><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – A dimension along which Softmax will be computed (so every slice along dim will sum to 1).</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>This module doesn’t work directly with NLLLoss, which expects the Log to be computed between the Softmax and itself. Use <code>LogSoftmax</code> instead (it’s faster and has better numerical properties).</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softmax()
&gt;&gt;&gt; input = torch.randn(2, 3)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softmax2d">Softmax2d</h3>
<pre><code class="language-py">class torch.nn.Softmax2d
</code></pre>
<p>Applies SoftMax over features to each spatial location.</p>
<p>When given an image of <code>Channels x Height x Width</code>, it will apply <code>Softmax</code> to each location <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b16a2a186bda385e5f0016f5fe5a5c36.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b16a2a186bda385e5f0016f5fe5a5c36.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a> (same shape as input)</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>a Tensor of the same dimension and shape as the input with values in the range [0, 1]</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softmax2d()
&gt;&gt;&gt; # you softmax over the 2nd dimension
&gt;&gt;&gt; input = torch.randn(2, 3, 12, 13)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="logsoftmax">LogSoftmax</h3>
<pre><code class="language-py">class torch.nn.LogSoftmax(dim=None)
</code></pre>
<p>Applies the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db163ba416e1349a426e6a137e082ae2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db163ba416e1349a426e6a137e082ae2.jpg" alt=""></a> function to an n-dimensional input Tensor. The LogSoftmax formulation can be simplified as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/397c4cfa2f291306d481811192d2d5d9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/397c4cfa2f291306d481811192d2d5d9.jpg" alt=""></a></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: any shape</li>
<li>Output: same as input</li>
</ul>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – A dimension along which Softmax will be computed (so every slice along dim will sum to 1).</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a Tensor of the same dimension and shape as the input with values in the range [-inf, 0)</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; input = torch.randn(2, 3)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivelogsoftmaxwithloss">AdaptiveLogSoftmaxWithLoss</h3>
<pre><code class="language-py">class torch.nn.AdaptiveLogSoftmaxWithLoss(in_features, n_classes, cutoffs, div_value=4.0, head_bias=False)
</code></pre>
<p>Efficient softmax approximation as described in <a href="https://arxiv.org/abs/1609.04309">Efficient softmax approximation for GPUs</a> by Edouard Grave, Armand Joulin, Moustapha Cissé, David Grangier, and Hervé Jégou.</p>
<p>Adaptive softmax is an approximate strategy for training models with large output spaces. It is most effective when the label distribution is highly imbalanced, for example in natural language modelling, where the word frequency distribution approximately follows the <a href="https://en.wikipedia.org/wiki/Zipf%27s_law">Zipf’s law</a>.</p>
<p>Adaptive softmax partitions the labels into several clusters, according to their frequency. These clusters may contain different number of targets each. Additionally, clusters containing less frequent labels assign lower dimensional embeddings to those labels, which speeds up the computation. For each minibatch, only clusters for which at least one target is present are evaluated.</p>
<p>The idea is that the clusters which are accessed frequently (like the first one, containing most frequent labels), should also be cheap to compute – that is, contain a small number of assigned labels.</p>
<p>We highly recommend taking a look at the original paper for more details.</p>
<ul>
<li><code>cutoffs</code> should be an ordered Sequence of integers sorted in the increasing order. It controls number of clusters and the partitioning of targets into clusters. For example setting <code>cutoffs = [10, 100, 1000]</code> means that first <code>10</code> targets will be assigned to the ‘head’ of the adaptive softmax, targets <code>11, 12, …, 100</code> will be assigned to the first cluster, and targets <code>101, 102, …, 1000</code> will be assigned to the second cluster, while targets <code>1001, 1002, …, n_classes - 1</code> will be assigned to the last, third cluster</li>
<li><code>div_value</code> is used to compute the size of each additional cluster, which is given as <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/32071c42affaaf731df4e3398b16de10.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/32071c42affaaf731df4e3398b16de10.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5df73ea97de3a7712b50ce2fecfea1a7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5df73ea97de3a7712b50ce2fecfea1a7.jpg" alt=""></a> is the cluster index (with clusters for less frequent words having larger indices, and indices starting from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" alt=""></a>).</li>
<li><code>head_bias</code> if set to True, adds a bias term to the ‘head’ of the adaptive softmax. See paper for details. Set to False in the official implementation.</li>
</ul>
<p>Warning</p>
<p>Labels passed as inputs to this module should be sorted accoridng to their frequency. This means that the most frequent label should be represented by the index <code>0</code>, and the least frequent label should be represented by the index <code>n_classes - 1</code>.</p>
<p>Note</p>
<p>This module returns a <code>NamedTuple</code> with <code>output</code> and <code>loss</code> fields. See further documentation for details.</p>
<p>Note</p>
<p>To compute log-probabilities for all classes, the <code>log_prob</code> method can be used.</p>
<p>Parameters:</p>
<ul>
<li><strong>in_features</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Number of features in the input tensor</li>
<li><strong>n_classes</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Number of classes in the dataset.</li>
<li><strong>cutoffs</strong> (<em>Sequence</em>) – Cutoffs used to assign targets to their buckets.</li>
<li><strong>div_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – value used as an exponent to compute sizes of the clusters. Default: 4.0</li>
</ul>
<p>| Returns: |</p>
<ul>
<li><strong>output</strong> is a Tensor of size <code>N</code> containing computed target log probabilities for each example</li>
<li><strong>loss</strong> is a Scalar representing the computed negative log likelihood loss</li>
</ul>
<table>
<thead>
<tr>
<th>Return type:</th>
<th><code>NamedTuple</code> with <code>output</code> and <code>loss</code> fields</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/768be7688f5f58f4766106ddb821b007.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/768be7688f5f58f4766106ddb821b007.jpg" alt=""></a></li>
<li>target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" alt=""></a> where each value satisfies <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fe1e80e9faca308456bc49d4e79013e0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fe1e80e9faca308456bc49d4e79013e0.jpg" alt=""></a></li>
<li>output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" alt=""></a></li>
<li>loss: <code>Scalar</code></li>
</ul>
<pre><code class="language-py">log_prob(input)
</code></pre>
<p>Computes log probabilities for all <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b285cfddea560d447d391e9d7ba660ba.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b285cfddea560d447d391e9d7ba660ba.jpg" alt=""></a></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – a minibatch of examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>log-probabilities of for each class <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/32624581da7de65d68eb11d4201f9bef.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/32624581da7de65d68eb11d4201f9bef.jpg" alt=""></a> in range <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e4201057f969a42a8d2de89e5f7c728.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4e4201057f969a42a8d2de89e5f7c728.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b285cfddea560d447d391e9d7ba660ba.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b285cfddea560d447d391e9d7ba660ba.jpg" alt=""></a> is a parameter passed to <code>AdaptiveLogSoftmaxWithLoss</code> constructor.</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/768be7688f5f58f4766106ddb821b007.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/768be7688f5f58f4766106ddb821b007.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f3bcbc1689556ad810d1c658d44bd970.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f3bcbc1689556ad810d1c658d44bd970.jpg" alt=""></a></li>
</ul>
<pre><code class="language-py">predict(input)
</code></pre>
<p>This is equivalent to <code>self.log_pob(input).argmax(dim=1)</code>, but is more efficient in some cases.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – a minibatch of examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a class with the highest probability for each example</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td>output (<a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>)</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/768be7688f5f58f4766106ddb821b007.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/768be7688f5f58f4766106ddb821b007.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" alt=""></a></li>
</ul>
<h2 id="normalization-layers">Normalization layers</h2>
<h3 id="batchnorm1d">BatchNorm1d</h3>
<pre><code class="language-py">class torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
</code></pre>
<p>Applies Batch Normalization over a 2D or 3D input (a mini-batch of 1D inputs with optional additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/beea63da4eceb7d4c8971e826bafbb1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/beea63da4eceb7d4c8971e826bafbb1a.jpg" alt=""></a></p>
<p>The mean and standard-deviation are calculated per-dimension over the mini-batches and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size). By default, the elements of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> are sampled from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7ad9c99a642c915c6d560cbca6352454.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7ad9c99a642c915c6d560cbca6352454.jpg" alt=""></a> and the elements of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are set to 0.</p>
<p>Also by default, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>If <code>track_running_stats</code> is set to <code>False</code>, this layer then does not keep running estimates, and batch statistics are instead used during evaluation time as well.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" alt=""></a> is the estimated statistic and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the new observed value.</p>
<p>Because the Batch Normalization is done over the <code>C</code> dimension, computing statistics on <code>(N, L)</code> slices, it’s common terminology to call this Temporal Batch Normalization.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_features</strong> – <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> from an expected input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" alt=""></a> from input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b6d0ccc6531c5d648e750c417c5cc72d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b6d0ccc6531c5d648e750c417c5cc72d.jpg" alt=""></a></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Can be set to <code>None</code> for cumulative moving average (i.e. simple average). Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters. Default: <code>True</code></li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm1d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm1d(100, affine=False)
&gt;&gt;&gt; input = torch.randn(20, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="batchnorm2d">BatchNorm2d</h3>
<pre><code class="language-py">class torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
</code></pre>
<p>Applies Batch Normalization over a 4D input (a mini-batch of 2D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" alt=""></a></p>
<p>The mean and standard-deviation are calculated per-dimension over the mini-batches and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size). By default, the elements of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> are sampled from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7ad9c99a642c915c6d560cbca6352454.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7ad9c99a642c915c6d560cbca6352454.jpg" alt=""></a> and the elements of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are set to 0.</p>
<p>Also by default, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>If <code>track_running_stats</code> is set to <code>False</code>, this layer then does not keep running estimates, and batch statistics are instead used during evaluation time as well.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" alt=""></a> is the estimated statistic and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the new observed value.</p>
<p>Because the Batch Normalization is done over the <code>C</code> dimension, computing statistics on <code>(N, H, W)</code> slices, it’s common terminology to call this Spatial Batch Normalization.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_features</strong> – <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> from an expected input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Can be set to <code>None</code> for cumulative moving average (i.e. simple average). Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters. Default: <code>True</code></li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm2d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm2d(100, affine=False)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="batchnorm3d">BatchNorm3d</h3>
<pre><code class="language-py">class torch.nn.BatchNorm3d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
</code></pre>
<p>Applies Batch Normalization over a 5D input (a mini-batch of 3D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" alt=""></a></p>
<p>The mean and standard-deviation are calculated per-dimension over the mini-batches and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size). By default, the elements of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> are sampled from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7ad9c99a642c915c6d560cbca6352454.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7ad9c99a642c915c6d560cbca6352454.jpg" alt=""></a> and the elements of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are set to 0.</p>
<p>Also by default, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>If <code>track_running_stats</code> is set to <code>False</code>, this layer then does not keep running estimates, and batch statistics are instead used during evaluation time as well.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" alt=""></a> is the estimated statistic and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the new observed value.</p>
<p>Because the Batch Normalization is done over the <code>C</code> dimension, computing statistics on <code>(N, D, H, W)</code> slices, it’s common terminology to call this Volumetric Batch Normalization or Spatio-temporal Batch Normalization.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_features</strong> – <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> from an expected input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Can be set to <code>None</code> for cumulative moving average (i.e. simple average). Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters. Default: <code>True</code></li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm3d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm3d(100, affine=False)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45, 10)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="groupnorm">GroupNorm</h3>
<pre><code class="language-py">class torch.nn.GroupNorm(num_groups, num_channels, eps=1e-05, affine=True)
</code></pre>
<p>Applies Group Normalization over a mini-batch of inputs as described in the paper <a href="https://arxiv.org/abs/1803.08494">Group Normalization</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2fee766f06767b7b87b3531029d92e1d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2fee766f06767b7b87b3531029d92e1d.jpg" alt=""></a></p>
<p>The input channels are separated into <code>num_groups</code> groups, each containing <code>num_channels / num_groups</code> channels. The mean and standard-deviation are calculated separately over the each group. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable per-channel affine transform parameter vectorss of size <code>num_channels</code> if <code>affine</code> is <code>True</code>.</p>
<p>This layer uses statistics computed from input data in both training and evaluation modes.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of groups to separate the channels into</li>
<li><strong>num_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of channels expected in input</li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable per-channel affine parameters initialized to ones (for weights) and zeros (for biases). Default: <code>True</code>.</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5be296779e9f325e5c8f0c2284bc073.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5be296779e9f325e5c8f0c2284bc073.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5be296779e9f325e5c8f0c2284bc073.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5be296779e9f325e5c8f0c2284bc073.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.randn(20, 6, 10, 10)
&gt;&gt;&gt; # Separate 6 channels into 3 groups
&gt;&gt;&gt; m = nn.GroupNorm(3, 6)
&gt;&gt;&gt; # Separate 6 channels into 6 groups (equivalent with InstanceNorm)
&gt;&gt;&gt; m = nn.GroupNorm(6, 6)
&gt;&gt;&gt; # Put all 6 channels into a single group (equivalent with LayerNorm)
&gt;&gt;&gt; m = nn.GroupNorm(1, 6)
&gt;&gt;&gt; # Activating the module
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="instancenorm1d">InstanceNorm1d</h3>
<pre><code class="language-py">class torch.nn.InstanceNorm1d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
</code></pre>
<p>Applies Instance Normalization over a 2D or 3D input (a mini-batch of 1D inputs with optional additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1607.08022">Instance Normalization: The Missing Ingredient for Fast Stylization</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" alt=""></a></p>
<p>The mean and standard-deviation are calculated per-dimension separately for each object in a mini-batch. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size) if <code>affine</code> is <code>True</code>.</p>
<p>By default, this layer uses instance statistics computed from input data in both training and evaluation modes.</p>
<p>If <code>track_running_stats</code> is set to <code>True</code>, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" alt=""></a> is the estimated statistic and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the new observed value.</p>
<p>Note</p>
<p><a href="#torch.nn.InstanceNorm1d" title="torch.nn.InstanceNorm1d"><code>InstanceNorm1d</code></a> and <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> are very similar, but have some subtle differences. <a href="#torch.nn.InstanceNorm1d" title="torch.nn.InstanceNorm1d"><code>InstanceNorm1d</code></a> is applied on each channel of channeled data like multidimensional time series, but <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> is usually applied on entire sample and often in NLP tasks. Additionaly, <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> applies elementwise affine transform, while <a href="#torch.nn.InstanceNorm1d" title="torch.nn.InstanceNorm1d"><code>InstanceNorm1d</code></a> usually don’t apply affine transform.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_features</strong> – <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> from an expected input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" alt=""></a> from input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b6d0ccc6531c5d648e750c417c5cc72d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b6d0ccc6531c5d648e750c417c5cc72d.jpg" alt=""></a></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters, initialized the same way as done for batch normalization. Default: <code>False</code>.</li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5816e96aa78b7425cf792435bba8bc29.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm1d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm1d(100, affine=True)
&gt;&gt;&gt; input = torch.randn(20, 100, 40)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="instancenorm2d">InstanceNorm2d</h3>
<pre><code class="language-py">class torch.nn.InstanceNorm2d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
</code></pre>
<p>Applies Instance Normalization over a 4D input (a mini-batch of 2D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1607.08022">Instance Normalization: The Missing Ingredient for Fast Stylization</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" alt=""></a></p>
<p>The mean and standard-deviation are calculated per-dimension separately for each object in a mini-batch. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size) if <code>affine</code> is <code>True</code>.</p>
<p>By default, this layer uses instance statistics computed from input data in both training and evaluation modes.</p>
<p>If <code>track_running_stats</code> is set to <code>True</code>, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" alt=""></a> is the estimated statistic and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the new observed value.</p>
<p>Note</p>
<p><a href="#torch.nn.InstanceNorm2d" title="torch.nn.InstanceNorm2d"><code>InstanceNorm2d</code></a> and <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> are very similar, but have some subtle differences. <a href="#torch.nn.InstanceNorm2d" title="torch.nn.InstanceNorm2d"><code>InstanceNorm2d</code></a> is applied on each channel of channeled data like RGB images, but <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> is usually applied on entire sample and often in NLP tasks. Additionaly, <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> applies elementwise affine transform, while <a href="#torch.nn.InstanceNorm2d" title="torch.nn.InstanceNorm2d"><code>InstanceNorm2d</code></a> usually don’t apply affine transform.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_features</strong> – <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> from an expected input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters, initialized the same way as done for batch normalization. Default: <code>False</code>.</li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm2d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm2d(100, affine=True)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="instancenorm3d">InstanceNorm3d</h3>
<pre><code class="language-py">class torch.nn.InstanceNorm3d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
</code></pre>
<p>Applies Instance Normalization over a 5D input (a mini-batch of 3D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1607.08022">Instance Normalization: The Missing Ingredient for Fast Stylization</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" alt=""></a></p>
<p>The mean and standard-deviation are calculated per-dimension separately for each object in a mini-batch. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable parameter vectors of size C (where C is the input size) if <code>affine</code> is <code>True</code>.</p>
<p>By default, this layer uses instance statistics computed from input data in both training and evaluation modes.</p>
<p>If <code>track_running_stats</code> is set to <code>True</code>, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d834e987d38585c39d150fe8f46bc74.jpg" alt=""></a> is the estimated statistic and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the new observed value.</p>
<p>Note</p>
<p><a href="#torch.nn.InstanceNorm3d" title="torch.nn.InstanceNorm3d"><code>InstanceNorm3d</code></a> and <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> are very similar, but have some subtle differences. <a href="#torch.nn.InstanceNorm3d" title="torch.nn.InstanceNorm3d"><code>InstanceNorm3d</code></a> is applied on each channel of channeled data like 3D models with RGB color, but <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> is usually applied on entire sample and often in NLP tasks. Additionaly, <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> applies elementwise affine transform, while <a href="#torch.nn.InstanceNorm3d" title="torch.nn.InstanceNorm3d"><code>InstanceNorm3d</code></a> usually don’t apply affine transform.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_features</strong> – <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6c8feca3b2da3d6cf371417edff4be4f.jpg" alt=""></a> from an expected input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters, initialized the same way as done for batch normalization. Default: <code>False</code>.</li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm3d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm3d(100, affine=True)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45, 10)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="layernorm">LayerNorm</h3>
<pre><code class="language-py">class torch.nn.LayerNorm(normalized_shape, eps=1e-05, elementwise_affine=True)
</code></pre>
<p>Applies Layer Normalization over a mini-batch of inputs as described in the paper <a href="https://arxiv.org/abs/1607.06450">Layer Normalization</a> .</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2fee766f06767b7b87b3531029d92e1d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2fee766f06767b7b87b3531029d92e1d.jpg" alt=""></a></p>
<p>The mean and standard-deviation are calculated separately over the last certain number dimensions which have to be of the shape specified by <code>normalized_shape</code>. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a> are learnable affine transform parameters of <code>normalized_shape</code> if <code>elementwise_affine</code> is <code>True</code>.</p>
<p>Note</p>
<p>Unlike Batch Normalization and Instance Normalization, which applies scalar scale and bias for each entire channel/plane with the <code>affine</code> option, Layer Normalization applies per-element scale and bias with <code>elementwise_affine</code>.</p>
<p>This layer uses statistics computed from input data in both training and evaluation modes.</p>
<p>Parameters:</p>
<ul>
<li> <p><strong>normalized_shape</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a> <em>or</em> <em>torch.Size</em>) –</p> <p>input shape from an expected input of size</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7058ab5ae52adb329c22fa5456ad910f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7058ab5ae52adb329c22fa5456ad910f.jpg" alt=""></a></p> <p>If a single integer is used, it is treated as a singleton list, and this module will normalize over the last dimension which is expected to be of that specific size.</p> </li>
<li> <p><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</p> </li>
<li> <p><strong>elementwise_affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable per-element affine parameters initialized to ones (for weights) and zeros (for biases). Default: <code>True</code>.</p> </li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.randn(20, 5, 10, 10)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.LayerNorm(input.size()[1:])
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.LayerNorm(input.size()[1:], elementwise_affine=False)
&gt;&gt;&gt; # Normalize over last two dimensions
&gt;&gt;&gt; m = nn.LayerNorm([10, 10])
&gt;&gt;&gt; # Normalize over last dimension of size 10
&gt;&gt;&gt; m = nn.LayerNorm(10)
&gt;&gt;&gt; # Activating the module
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="localresponsenorm">LocalResponseNorm</h3>
<pre><code class="language-py">class torch.nn.LocalResponseNorm(size, alpha=0.0001, beta=0.75, k=1.0)
</code></pre>
<p>Applies local response normalization over an input signal composed of several input planes, where channels occupy the second dimension. Applies normalization across channels.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5522547c6e594dc7c5ffe998f57ad26b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5522547c6e594dc7c5ffe998f57ad26b.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>size</strong> – amount of neighbouring channels used for normalization</li>
<li><strong>alpha</strong> – multiplicative factor. Default: 0.0001</li>
<li><strong>beta</strong> – exponent. Default: 0.75</li>
<li><strong>k</strong> – additive factor. Default: 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0113f670591e6e2a1a50722e1affdce5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0113f670591e6e2a1a50722e1affdce5.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0113f670591e6e2a1a50722e1affdce5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0113f670591e6e2a1a50722e1affdce5.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; lrn = nn.LocalResponseNorm(2)
&gt;&gt;&gt; signal_2d = torch.randn(32, 5, 24, 24)
&gt;&gt;&gt; signal_4d = torch.randn(16, 5, 7, 7, 7, 7)
&gt;&gt;&gt; output_2d = lrn(signal_2d)
&gt;&gt;&gt; output_4d = lrn(signal_4d)

</code></pre>
<h2 id="recurrent-layers">Recurrent layers</h2>
<h3 id="rnn">RNN</h3>
<pre><code class="language-py">class torch.nn.RNN(*args, **kwargs)
</code></pre>
<p>Applies a multi-layer Elman RNN with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/73b754b4f63e76c0f0327be51d4b263c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/73b754b4f63e76c0f0327be51d4b263c.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/86a6387f3ec09e33de3faaa24f784bca.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/86a6387f3ec09e33de3faaa24f784bca.jpg" alt=""></a> non-linearity to an input sequence.</p>
<p>For each element in the input sequence, each layer computes the following function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d1bd72124738a26685d33ce01c89beb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d1bd72124738a26685d33ce01c89beb.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" alt=""></a> is the hidden state at time <code>t</code>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the input at time <code>t</code>, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/722edd552cee200694a3bfccd4f755df.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/722edd552cee200694a3bfccd4f755df.jpg" alt=""></a> is the hidden state of the previous layer at time <code>t-1</code> or the initial hidden state at time <code>0</code>. If <code>nonlinearity</code> is <code>‘relu’</code>, then <code>ReLU</code> is used instead of <code>tanh</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>num_layers</strong> – Number of recurrent layers. E.g., setting <code>num_layers=2</code> would mean stacking two RNNs together to form a <code>stacked RNN</code>, with the second RNN taking in outputs of the first RNN and computing the final results. Default: 1</li>
<li><strong>nonlinearity</strong> – The non-linearity to use. Can be either ‘tanh’ or ‘relu’. Default: ‘tanh’</li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>batch_first</strong> – If <code>True</code>, then the input and output tensors are provided as <code>(batch, seq, feature)</code>. Default: <code>False</code></li>
<li><strong>dropout</strong> – If non-zero, introduces a <code>Dropout</code> layer on the outputs of each RNN layer except the last layer, with dropout probability equal to <code>dropout</code>. Default: 0</li>
<li><strong>bidirectional</strong> – If <code>True</code>, becomes a bidirectional RNN. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Inputs: input, h_0
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(seq_len, batch, input_size)</code>: tensor containing the features of the input sequence. The input can also be a packed variable length sequence. See <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> or <a href="#torch.nn.utils.rnn.pack_sequence" title="torch.nn.utils.rnn.pack_sequence"><code>torch.nn.utils.rnn.pack_sequence()</code></a> for details.</li>
<li><strong>h_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</li>
</ul>
<pre><code class="language-py">Outputs: output, h_n
</code></pre>
<ul>
<li> <p><strong>output</strong> of shape <code>(seq_len, batch, num_directions * hidden_size)</code>: tensor containing the output features (<code>h_k</code>) from the last layer of the RNN, for each <code>k</code>. If a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> has been given as the input, the output will also be a packed sequence.</p> <p>For the unpacked case, the directions can be separated using <code>output.view(seq_len, batch, num_directions, hidden_size)</code>, with forward and backward being direction <code>0</code> and <code>1</code> respectively. Similarly, the directions can be separated in the packed case.</p> </li>
<li> <p><strong>h_n</strong> (num_layers * num_directions, batch, hidden_size): tensor containing the hidden state for <code>k = seq_len</code>.</p> <p>Like <em>output</em>, the layers can be separated using <code>h_n.view(num_layers, num_directions, batch, hidden_size)</code>.</p> </li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight_ih_l[k]</strong> – the learnable input-hidden weights of the k-th layer, of shape <code>(hidden_size * input_size)</code> for <code>k = 0</code>. Otherwise, the shape is <code>(hidden_size * hidden_size)</code></li>
<li><strong>weight_hh_l[k]</strong> – the learnable hidden-hidden weights of the k-th layer, of shape <code>(hidden_size * hidden_size)</code></li>
<li><strong>bias_ih_l[k]</strong> – the learnable input-hidden bias of the k-th layer, of shape <code>(hidden_size)</code></li>
<li><strong>bias_hh_l[k]</strong> – the learnable hidden-hidden bias of the k-th layer, of shape <code>(hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" alt=""></a></p>
<p>Note</p>
<p>If the following conditions are satisfied: 1) cudnn is enabled, 2) input data is on the GPU 3) input data has dtype <code>torch.float16</code> 4) V100 GPU is used, 5) input data is not in <code>PackedSequence</code> format persistent algorithm can be selected to improve performance.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.RNN(10, 20, 2)
&gt;&gt;&gt; input = torch.randn(5, 3, 10)
&gt;&gt;&gt; h0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; output, hn = rnn(input, h0)

</code></pre>
<h3 id="lstm">LSTM</h3>
<pre><code class="language-py">class torch.nn.LSTM(*args, **kwargs)
</code></pre>
<p>Applies a multi-layer long short-term memory (LSTM) RNN to an input sequence.</p>
<p>For each element in the input sequence, each layer computes the following function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e45b4c4446dc36020077ab726cee248f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e45b4c4446dc36020077ab726cee248f.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" alt=""></a> is the hidden state at time <code>t</code>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a96fd1792ebb964c44e6a4802fe73a45.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a96fd1792ebb964c44e6a4802fe73a45.jpg" alt=""></a> is the cell state at time <code>t</code>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the input at time <code>t</code>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/722edd552cee200694a3bfccd4f755df.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/722edd552cee200694a3bfccd4f755df.jpg" alt=""></a> is the hidden state of the layer at time <code>t-1</code> or the initial hidden state at time <code>0</code>, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0c33b098890c73bacbf2dbe5476b8ea0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0c33b098890c73bacbf2dbe5476b8ea0.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/39e0c3cfa9742216d02b21de5ed57650.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/39e0c3cfa9742216d02b21de5ed57650.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8b4c3e8be7da971e832789294ddd61d4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8b4c3e8be7da971e832789294ddd61d4.jpg" alt=""></a> are the input, forget, cell, and output gates, respectively. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" alt=""></a> is the sigmoid function.</p>
<p>In a multilayer LSTM, the input <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3aef28832238eb9de1c3d226cc4f026e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3aef28832238eb9de1c3d226cc4f026e.jpg" alt=""></a> of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4c55f62a52ee5572ab96494e9e0a2876.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4c55f62a52ee5572ab96494e9e0a2876.jpg" alt=""></a> -th layer (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2c7ccc0042019ca7a1bb7d536da8a87.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2c7ccc0042019ca7a1bb7d536da8a87.jpg" alt=""></a>) is the hidden state <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/aa2a9f5361143e6f3a32d54920079b52.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/aa2a9f5361143e6f3a32d54920079b52.jpg" alt=""></a> of the previous layer multiplied by dropout <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e5fffda0db50ff1fedeef29921cdf85.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e5fffda0db50ff1fedeef29921cdf85.jpg" alt=""></a> where each <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5b70351b42153bea8ab63d8e783cc0ac.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5b70351b42153bea8ab63d8e783cc0ac.jpg" alt=""></a> is a Bernoulli random variable which is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" alt=""></a> with probability <code>dropout</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>num_layers</strong> – Number of recurrent layers. E.g., setting <code>num_layers=2</code> would mean stacking two LSTMs together to form a <code>stacked LSTM</code>, with the second LSTM taking in outputs of the first LSTM and computing the final results. Default: 1</li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>batch_first</strong> – If <code>True</code>, then the input and output tensors are provided as (batch, seq, feature). Default: <code>False</code></li>
<li><strong>dropout</strong> – If non-zero, introduces a <code>Dropout</code> layer on the outputs of each LSTM layer except the last layer, with dropout probability equal to <code>dropout</code>. Default: 0</li>
<li><strong>bidirectional</strong> – If <code>True</code>, becomes a bidirectional LSTM. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Inputs: input, (h_0, c_0)
</code></pre>
<ul>
<li> <p><strong>input</strong> of shape <code>(seq_len, batch, input_size)</code>: tensor containing the features of the input sequence. The input can also be a packed variable length sequence. See <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> or <a href="#torch.nn.utils.rnn.pack_sequence" title="torch.nn.utils.rnn.pack_sequence"><code>torch.nn.utils.rnn.pack_sequence()</code></a> for details.</p> </li>
<li> <p><strong>h_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</p> </li>
<li> <p><strong>c_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial cell state for each element in the batch.</p> <p>If <code>(h_0, c_0)</code> is not provided, both <strong>h_0</strong> and <strong>c_0</strong> default to zero.</p> </li>
</ul>
<pre><code class="language-py">Outputs: output, (h_n, c_n)
</code></pre>
<ul>
<li> <p><strong>output</strong> of shape <code>(seq_len, batch, num_directions * hidden_size)</code>: tensor containing the output features <code>(h_t)</code> from the last layer of the LSTM, for each t. If a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> has been given as the input, the output will also be a packed sequence.</p> <p>For the unpacked case, the directions can be separated using <code>output.view(seq_len, batch, num_directions, hidden_size)</code>, with forward and backward being direction <code>0</code> and <code>1</code> respectively. Similarly, the directions can be separated in the packed case.</p> </li>
<li> <p><strong>h_n</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the hidden state for <code>t = seq_len</code>.</p> <p>Like <em>output</em>, the layers can be separated using <code>h_n.view(num_layers, num_directions, batch, hidden_size)</code> and similarly for <em>c_n</em>.</p> </li>
<li> <p><strong>c_n</strong> (num_layers * num_directions, batch, hidden_size): tensor containing the cell state for <code>t = seq_len</code></p> </li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight_ih_l[k]</strong> – the learnable input-hidden weights of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer <code>(W_ii&amp;#124;W_if&amp;#124;W_ig&amp;#124;W_io)</code>, of shape <code>(4*hidden_size x input_size)</code></li>
<li><strong>weight_hh_l[k]</strong> – the learnable hidden-hidden weights of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer <code>(W_hi&amp;#124;W_hf&amp;#124;W_hg&amp;#124;W_ho)</code>, of shape <code>(4*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih_l[k]</strong> – the learnable input-hidden bias of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer <code>(b_ii&amp;#124;b_if&amp;#124;b_ig&amp;#124;b_io)</code>, of shape <code>(4*hidden_size)</code></li>
<li><strong>bias_hh_l[k]</strong> – the learnable hidden-hidden bias of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer <code>(b_hi&amp;#124;b_hf&amp;#124;b_hg&amp;#124;b_ho)</code>, of shape <code>(4*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" alt=""></a></p>
<p>Note</p>
<p>If the following conditions are satisfied: 1) cudnn is enabled, 2) input data is on the GPU 3) input data has dtype <code>torch.float16</code> 4) V100 GPU is used, 5) input data is not in <code>PackedSequence</code> format persistent algorithm can be selected to improve performance.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.LSTM(10, 20, 2)
&gt;&gt;&gt; input = torch.randn(5, 3, 10)
&gt;&gt;&gt; h0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; c0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; output, (hn, cn) = rnn(input, (h0, c0))

</code></pre>
<h3 id="gru">GRU</h3>
<pre><code class="language-py">class torch.nn.GRU(*args, **kwargs)
</code></pre>
<p>Applies a multi-layer gated recurrent unit (GRU) RNN to an input sequence.</p>
<p>For each element in the input sequence, each layer computes the following function:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76771dd2e48bad7097dc9524356200ef.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76771dd2e48bad7097dc9524356200ef.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" alt=""></a> is the hidden state at time <code>t</code>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/22c5ed7653e3fae804006a00210327fc.jpg" alt=""></a> is the input at time <code>t</code>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/722edd552cee200694a3bfccd4f755df.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/722edd552cee200694a3bfccd4f755df.jpg" alt=""></a> is the hidden state of the layer at time <code>t-1</code> or the initial hidden state at time <code>0</code>, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/33becaceee3dd4f30f106b6a8605226f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/33becaceee3dd4f30f106b6a8605226f.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/98ba4bd98c899c9f15a00fe76fe782b2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/98ba4bd98c899c9f15a00fe76fe782b2.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4d63033e7717e68b17fc937ffcbcde4b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4d63033e7717e68b17fc937ffcbcde4b.jpg" alt=""></a> are the reset, update, and new gates, respectively. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" alt=""></a> is the sigmoid function.</p>
<p>In a multilayer GRU, the input <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3aef28832238eb9de1c3d226cc4f026e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3aef28832238eb9de1c3d226cc4f026e.jpg" alt=""></a> of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4c55f62a52ee5572ab96494e9e0a2876.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4c55f62a52ee5572ab96494e9e0a2876.jpg" alt=""></a> -th layer (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2c7ccc0042019ca7a1bb7d536da8a87.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2c7ccc0042019ca7a1bb7d536da8a87.jpg" alt=""></a>) is the hidden state <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/aa2a9f5361143e6f3a32d54920079b52.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/aa2a9f5361143e6f3a32d54920079b52.jpg" alt=""></a> of the previous layer multiplied by dropout <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e5fffda0db50ff1fedeef29921cdf85.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5e5fffda0db50ff1fedeef29921cdf85.jpg" alt=""></a> where each <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5b70351b42153bea8ab63d8e783cc0ac.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5b70351b42153bea8ab63d8e783cc0ac.jpg" alt=""></a> is a Bernoulli random variable which is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" alt=""></a> with probability <code>dropout</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>num_layers</strong> – Number of recurrent layers. E.g., setting <code>num_layers=2</code> would mean stacking two GRUs together to form a <code>stacked GRU</code>, with the second GRU taking in outputs of the first GRU and computing the final results. Default: 1</li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>batch_first</strong> – If <code>True</code>, then the input and output tensors are provided as (batch, seq, feature). Default: <code>False</code></li>
<li><strong>dropout</strong> – If non-zero, introduces a <code>Dropout</code> layer on the outputs of each GRU layer except the last layer, with dropout probability equal to <code>dropout</code>. Default: 0</li>
<li><strong>bidirectional</strong> – If <code>True</code>, becomes a bidirectional GRU. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Inputs: input, h_0
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(seq_len, batch, input_size)</code>: tensor containing the features of the input sequence. The input can also be a packed variable length sequence. See <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> for details.</li>
<li><strong>h_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</li>
</ul>
<pre><code class="language-py">Outputs: output, h_n
</code></pre>
<ul>
<li> <p><strong>output</strong> of shape <code>(seq_len, batch, num_directions * hidden_size)</code>: tensor containing the output features h_t from the last layer of the GRU, for each t. If a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> has been given as the input, the output will also be a packed sequence. For the unpacked case, the directions can be separated using <code>output.view(seq_len, batch, num_directions, hidden_size)</code>, with forward and backward being direction <code>0</code> and <code>1</code> respectively.</p> <p>Similarly, the directions can be separated in the packed case.</p> </li>
<li> <p><strong>h_n</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the hidden state for <code>t = seq_len</code></p> <p>Like <em>output</em>, the layers can be separated using <code>h_n.view(num_layers, num_directions, batch, hidden_size)</code>.</p> </li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight_ih_l[k]</strong> – the learnable input-hidden weights of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer (W_ir|W_iz|W_in), of shape <code>(3*hidden_size x input_size)</code></li>
<li><strong>weight_hh_l[k]</strong> – the learnable hidden-hidden weights of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer (W_hr|W_hz|W_hn), of shape <code>(3*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih_l[k]</strong> – the learnable input-hidden bias of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer (b_ir|b_iz|b_in), of shape <code>(3*hidden_size)</code></li>
<li><strong>bias_hh_l[k]</strong> – the learnable hidden-hidden bias of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3daedae8ea4977a42453935c04c06ad0.jpg" alt=""></a> layer (b_hr|b_hz|b_hn), of shape <code>(3*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" alt=""></a></p>
<p>Note</p>
<p>If the following conditions are satisfied: 1) cudnn is enabled, 2) input data is on the GPU 3) input data has dtype <code>torch.float16</code> 4) V100 GPU is used, 5) input data is not in <code>PackedSequence</code> format persistent algorithm can be selected to improve performance.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.GRU(10, 20, 2)
&gt;&gt;&gt; input = torch.randn(5, 3, 10)
&gt;&gt;&gt; h0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; output, hn = rnn(input, h0)

</code></pre>
<h3 id="rnncell">RNNCell</h3>
<pre><code class="language-py">class torch.nn.RNNCell(input_size, hidden_size, bias=True, nonlinearity='tanh')
</code></pre>
<p>An Elman RNN cell with tanh or ReLU non-linearity.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e748fe354d996221dbfa5f8e3412451e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e748fe354d996221dbfa5f8e3412451e.jpg" alt=""></a></p>
<p>If <code>nonlinearity</code> is <code>‘relu’</code>, then ReLU is used in place of tanh.</p>
<p>Parameters:</p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>nonlinearity</strong> – The non-linearity to use. Can be either ‘tanh’ or ‘relu’. Default: ‘tanh’</li>
</ul>
<pre><code class="language-py">Inputs: input, hidden
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(batch, input_size)</code>: tensor containing input features</li>
<li><strong>hidden</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided.</li>
</ul>
<pre><code class="language-py">Outputs: h’
</code></pre>
<ul>
<li><strong>h’</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next hidden state for each element in the batch</li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight_ih</strong> – the learnable input-hidden weights, of shape <code>(hidden_size x input_size)</code></li>
<li><strong>weight_hh</strong> – the learnable hidden-hidden weights, of shape <code>(hidden_size x hidden_size)</code></li>
<li><strong>bias_ih</strong> – the learnable input-hidden bias, of shape <code>(hidden_size)</code></li>
<li><strong>bias_hh</strong> – the learnable hidden-hidden bias, of shape <code>(hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" alt=""></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.RNNCell(10, 20)
&gt;&gt;&gt; input = torch.randn(6, 3, 10)
&gt;&gt;&gt; hx = torch.randn(3, 20)
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
 hx = rnn(input[i], hx)
 output.append(hx)

</code></pre>
<h3 id="lstmcell">LSTMCell</h3>
<pre><code class="language-py">class torch.nn.LSTMCell(input_size, hidden_size, bias=True)
</code></pre>
<p>A long short-term memory (LSTM) cell.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fb4d6ec81b25bb8201fbedd23b71b45f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fb4d6ec81b25bb8201fbedd23b71b45f.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" alt=""></a> is the sigmoid function.</p>
<p>Parameters:</p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Inputs: input, (h_0, c_0)
</code></pre>
<ul>
<li> <p><strong>input</strong> of shape <code>(batch, input_size)</code>: tensor containing input features</p> </li>
<li> <p><strong>h_0</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch.</p> </li>
<li> <p><strong>c_0</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial cell state for each element in the batch.</p> <p>If <code>(h_0, c_0)</code> is not provided, both <strong>h_0</strong> and <strong>c_0</strong> default to zero.</p> </li>
</ul>
<pre><code class="language-py">Outputs: h_1, c_1
</code></pre>
<ul>
<li><strong>h_1</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next hidden state for each element in the batch</li>
<li><strong>c_1</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next cell state for each element in the batch</li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight_ih</strong> – the learnable input-hidden weights, of shape <code>(4*hidden_size x input_size)</code></li>
<li><strong>weight_hh</strong> – the learnable hidden-hidden weights, of shape <code>(4*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih</strong> – the learnable input-hidden bias, of shape <code>(4*hidden_size)</code></li>
<li><strong>bias_hh</strong> – the learnable hidden-hidden bias, of shape <code>(4*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" alt=""></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.LSTMCell(10, 20)
&gt;&gt;&gt; input = torch.randn(6, 3, 10)
&gt;&gt;&gt; hx = torch.randn(3, 20)
&gt;&gt;&gt; cx = torch.randn(3, 20)
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
 hx, cx = rnn(input[i], (hx, cx))
 output.append(hx)

</code></pre>
<h3 id="grucell">GRUCell</h3>
<pre><code class="language-py">class torch.nn.GRUCell(input_size, hidden_size, bias=True)
</code></pre>
<p>A gated recurrent unit (GRU) cell</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a557e5b089bda248c2e25791d88d4b2a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a557e5b089bda248c2e25791d88d4b2a.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" alt=""></a> is the sigmoid function.</p>
<p>Parameters:</p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Inputs: input, hidden
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(batch, input_size)</code>: tensor containing input features</li>
<li><strong>hidden</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided.</li>
</ul>
<pre><code class="language-py">Outputs: h’
</code></pre>
<ul>
<li><strong>h’</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next hidden state for each element in the batch</li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight_ih</strong> – the learnable input-hidden weights, of shape <code>(3*hidden_size x input_size)</code></li>
<li><strong>weight_hh</strong> – the learnable hidden-hidden weights, of shape <code>(3*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih</strong> – the learnable input-hidden bias, of shape <code>(3*hidden_size)</code></li>
<li><strong>bias_hh</strong> – the learnable hidden-hidden bias, of shape <code>(3*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" alt=""></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.GRUCell(10, 20)
&gt;&gt;&gt; input = torch.randn(6, 3, 10)
&gt;&gt;&gt; hx = torch.randn(3, 20)
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
 hx = rnn(input[i], hx)
 output.append(hx)

</code></pre>
<h2 id="linear-layers">Linear layers</h2>
<h3 id="linear">Linear</h3>
<pre><code class="language-py">class torch.nn.Linear(in_features, out_features, bias=True)
</code></pre>
<p>Applies a linear transformation to the incoming data: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8c4834b7cb4b9c7a795bf354412e8dd3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8c4834b7cb4b9c7a795bf354412e8dd3.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>in_features</strong> – size of each input sample</li>
<li><strong>out_features</strong> – size of each output sample</li>
<li><strong>bias</strong> – If set to False, the layer will not learn an additive bias. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/37251f14c8c7345b66309c1ce6181e4d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/37251f14c8c7345b66309c1ce6181e4d.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> means any number of additional dimensions</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/052531b4914630967eb9a6ed4f143697.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/052531b4914630967eb9a6ed4f143697.jpg" alt=""></a> where all but the last dimension are the same shape as the input.</li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight</strong> – the learnable weights of the module of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7bdd499093e2167451c56eb5c4480786.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7bdd499093e2167451c56eb5c4480786.jpg" alt=""></a>. The values are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d1dd979275f32a1bcc00f4e3885e68c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d1dd979275f32a1bcc00f4e3885e68c.jpg" alt=""></a></li>
<li><strong>bias</strong> – the learnable bias of the module of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/27eac2d9aa3b57eabe07fcce145717d2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/27eac2d9aa3b57eabe07fcce145717d2.jpg" alt=""></a>. If <code>bias</code> is <code>True</code>, the values are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d1dd979275f32a1bcc00f4e3885e68c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d1dd979275f32a1bcc00f4e3885e68c.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Linear(20, 30)
&gt;&gt;&gt; input = torch.randn(128, 20)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; print(output.size())
torch.Size([128, 30])

</code></pre>
<h3 id="bilinear">Bilinear</h3>
<pre><code class="language-py">class torch.nn.Bilinear(in1_features, in2_features, out_features, bias=True)
</code></pre>
<p>Applies a bilinear transformation to the incoming data: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0d89d1240ed669c322d042acea66b2c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0d89d1240ed669c322d042acea66b2c.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>in1_features</strong> – size of each first input sample</li>
<li><strong>in2_features</strong> – size of each second input sample</li>
<li><strong>out_features</strong> – size of each output sample</li>
<li><strong>bias</strong> – If set to False, the layer will not learn an additive bias. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9cf39fb88b1a94018532514fcb3e125c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9cf39fb88b1a94018532514fcb3e125c.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5b3219dff177846f3a5aebdb36ae5d30.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5b3219dff177846f3a5aebdb36ae5d30.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> means any number of additional dimensions. All but the last dimension of the inputs should be the same.</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/052531b4914630967eb9a6ed4f143697.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/052531b4914630967eb9a6ed4f143697.jpg" alt=""></a> where all but the last dimension are the same shape as the input.</li>
</ul>
<p>| Variables: |</p>
<ul>
<li><strong>weight</strong> – the learnable weights of the module of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3f2a47921a3568c8f0f8c45847fd2ad3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3f2a47921a3568c8f0f8c45847fd2ad3.jpg" alt=""></a>. The values are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76606e23079bb41cbaeb5fa9ddc71c86.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76606e23079bb41cbaeb5fa9ddc71c86.jpg" alt=""></a></li>
<li><strong>bias</strong> – the learnable bias of the module of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/27eac2d9aa3b57eabe07fcce145717d2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/27eac2d9aa3b57eabe07fcce145717d2.jpg" alt=""></a> If <code>bias</code> is <code>True</code>, the values are initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76606e23079bb41cbaeb5fa9ddc71c86.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76606e23079bb41cbaeb5fa9ddc71c86.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Bilinear(20, 30, 40)
&gt;&gt;&gt; input1 = torch.randn(128, 20)
&gt;&gt;&gt; input2 = torch.randn(128, 30)
&gt;&gt;&gt; output = m(input1, input2)
&gt;&gt;&gt; print(output.size())
torch.Size([128, 40])

</code></pre>
<h2 id="dropout-layers">Dropout layers</h2>
<h3 id="dropout">Dropout</h3>
<pre><code class="language-py">class torch.nn.Dropout(p=0.5, inplace=False)
</code></pre>
<p>During training, randomly zeroes some of the elements of the input tensor with probability <code>p</code> using samples from a Bernoulli distribution. Each channel will be zeroed out independently on every forward call.</p>
<p>This has proven to be an effective technique for regularization and preventing the co-adaptation of neurons as described in the paper <a href="https://arxiv.org/abs/1207.0580">Improving neural networks by preventing co-adaptation of feature detectors</a> .</p>
<p>Furthermore, the outputs are scaled by a factor of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/37052da8591fea742432c58ac3a4dc59.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/37052da8591fea742432c58ac3a4dc59.jpg" alt=""></a> during training. This means that during evaluation the module simply computes an identity function.</p>
<p>Parameters:</p>
<ul>
<li><strong>p</strong> – probability of an element to be zeroed. Default: 0.5</li>
<li><strong>inplace</strong> – If set to <code>True</code>, will do this operation in-place. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <code>Any</code>. Input can be of any shape</li>
<li>Output: <code>Same</code>. Output is of the same shape as input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Dropout(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="dropout2d">Dropout2d</h3>
<pre><code class="language-py">class torch.nn.Dropout2d(p=0.5, inplace=False)
</code></pre>
<p>Randomly zero out entire channels (a channel is a 2D feature map, e.g., the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" alt=""></a>-th channel of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a>-th sample in the batched input is a 2D tensor <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5bc8fbe2fea3359e55846184c5eb123a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5bc8fbe2fea3359e55846184c5eb123a.jpg" alt=""></a>) of the input tensor). Each channel will be zeroed out independently on every forward call. with probability <code>p</code> using samples from a Bernoulli distribution.</p>
<p>Usually the input comes from <code>nn.Conv2d</code> modules.</p>
<p>As described in the paper <a href="http://arxiv.org/abs/1411.4280">Efficient Object Localization Using Convolutional Networks</a> , if adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then i.i.d. dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease.</p>
<p>In this case, <code>nn.Dropout2d()</code> will help promote independence between feature maps and should be used instead.</p>
<p>Parameters:</p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – probability of an element to be zero-ed.</li>
<li><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If set to <code>True</code>, will do this operation in-place</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/23f8772594b27bd387be708fe9c085e1.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Dropout2d(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16, 32, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="dropout3d">Dropout3d</h3>
<pre><code class="language-py">class torch.nn.Dropout3d(p=0.5, inplace=False)
</code></pre>
<p>Randomly zero out entire channels (a channel is a 3D feature map, e.g., the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" alt=""></a>-th channel of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a>-th sample in the batched input is a 3D tensor <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5bc8fbe2fea3359e55846184c5eb123a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5bc8fbe2fea3359e55846184c5eb123a.jpg" alt=""></a>) of the input tensor). Each channel will be zeroed out independently on every forward call. with probability <code>p</code> using samples from a Bernoulli distribution.</p>
<p>Usually the input comes from <code>nn.Conv3d</code> modules.</p>
<p>As described in the paper <a href="http://arxiv.org/abs/1411.4280">Efficient Object Localization Using Convolutional Networks</a> , if adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then i.i.d. dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease.</p>
<p>In this case, <code>nn.Dropout3d()</code> will help promote independence between feature maps and should be used instead.</p>
<p>Parameters:</p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – probability of an element to be zeroed.</li>
<li><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If set to <code>True</code>, will do this operation in-place</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5a45f7b445db562b21cfcb525637aab.jpg" alt=""></a> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Dropout3d(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16, 4, 32, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="alphadropout">AlphaDropout</h3>
<pre><code class="language-py">class torch.nn.AlphaDropout(p=0.5, inplace=False)
</code></pre>
<p>Applies Alpha Dropout over the input.</p>
<p>Alpha Dropout is a type of Dropout that maintains the self-normalizing property. For an input with zero mean and unit standard deviation, the output of Alpha Dropout maintains the original mean and standard deviation of the input. Alpha Dropout goes hand-in-hand with SELU activation function, which ensures that the outputs have zero mean and unit standard deviation.</p>
<p>During training, it randomly masks some of the elements of the input tensor with probability <em>p</em> using samples from a bernoulli distribution. The elements to masked are randomized on every forward call, and scaled and shifted to maintain zero mean and unit standard deviation.</p>
<p>During evaluation the module simply computes an identity function.</p>
<p>More details can be found in the paper <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a> .</p>
<p>Parameters:</p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – probability of an element to be dropped. Default: 0.5</li>
<li><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If set to <code>True</code>, will do this operation in-place</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <code>Any</code>. Input can be of any shape</li>
<li>Output: <code>Same</code>. Output is of the same shape as input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.AlphaDropout(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="sparse-layers">Sparse layers</h2>
<h3 id="embedding">Embedding</h3>
<pre><code class="language-py">class torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None)
</code></pre>
<p>A simple lookup table that stores embeddings of a fixed dictionary and size.</p>
<p>This module is often used to store word embeddings and retrieve them using indices. The input to the module is a list of indices, and the output is the corresponding word embeddings.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_embeddings</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – size of the dictionary of embeddings</li>
<li><strong>embedding_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of each embedding vector</li>
<li><strong>padding_idx</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – If given, pads the output with the embedding vector at <code>padding_idx</code> (initialized to zeros) whenever it encounters the index.</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – If given, each embedding vector with norm larger than <code>max_norm</code> is renormalized to have norm <code>max_norm</code>.</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – The p of the p-norm to compute for the <code>max_norm</code> option. Default <code>2</code>.</li>
<li><strong>scale_grad_by_freq</strong> (<em>boolean</em>_,_ <em>optional</em>) – If given, this will scale gradients by the inverse of frequency of the words in the mini-batch. Default <code>False</code>.</li>
<li><strong>sparse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If <code>True</code>, gradient w.r.t. <code>weight</code> matrix will be a sparse tensor. See Notes for more details regarding sparse gradients.</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the learnable weights of the module of shape (num_embeddings, embedding_dim) initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dd84ddbf2f8040d87fb315eeeba51f6d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dd84ddbf2f8040d87fb315eeeba51f6d.jpg" alt=""></a></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Shape:</p>
<blockquote>
<ul>
<li>Input: LongTensor of arbitrary shape containing the indices to extract</li>
<li>Output: <code>(*, embedding_dim)</code>, where <code>*</code> is the input shape</li>
</ul>
</blockquote>
<p>Note</p>
<p>Keep in mind that only a limited number of optimizers support sparse gradients: currently it’s <code>optim.SGD</code> (<code>CUDA</code> and <code>CPU</code>), <code>optim.SparseAdam</code> (<code>CUDA</code> and <code>CPU</code>) and <code>optim.Adagrad</code> (<code>CPU</code>)</p>
<p>Note</p>
<p>With <code>padding_idx</code> set, the embedding vector at <code>padding_idx</code> is initialized to all zeros. However, note that this vector can be modified afterwards, e.g., using a customized initialization method, and thus changing the vector used to pad the output. The gradient for this vector from <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> is always zero.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # an Embedding module containing 10 tensors of size 3
&gt;&gt;&gt; embedding = nn.Embedding(10, 3)
&gt;&gt;&gt; # a batch of 2 samples of 4 indices each
&gt;&gt;&gt; input = torch.LongTensor([[1,2,4,5],[4,3,2,9]])
&gt;&gt;&gt; embedding(input)
tensor([[[-0.0251, -1.6902,  0.7172],
 [-0.6431,  0.0748,  0.6969],
 [ 1.4970,  1.3448, -0.9685],
 [-0.3677, -2.7265, -0.1685]],

 [[ 1.4970,  1.3448, -0.9685],
 [ 0.4362, -0.4004,  0.9400],
 [-0.6431,  0.0748,  0.6969],
 [ 0.9124, -2.3616,  1.1151]]])

&gt;&gt;&gt; # example with padding_idx
&gt;&gt;&gt; embedding = nn.Embedding(10, 3, padding_idx=0)
&gt;&gt;&gt; input = torch.LongTensor([[0,2,0,5]])
&gt;&gt;&gt; embedding(input)
tensor([[[ 0.0000,  0.0000,  0.0000],
 [ 0.1535, -2.0309,  0.9315],
 [ 0.0000,  0.0000,  0.0000],
 [-0.1655,  0.9897,  0.0635]]])

</code></pre>
<pre><code class="language-py">classmethod from_pretrained(embeddings, freeze=True, sparse=False)
</code></pre>
<p>Creates Embedding instance from given 2-dimensional FloatTensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>embeddings</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – FloatTensor containing weights for the Embedding. First dimension is being passed to Embedding as ‘num_embeddings’, second as ‘embedding_dim’.</li>
<li><strong>freeze</strong> (<em>boolean</em>_,_ <em>optional</em>) – If <code>True</code>, the tensor does not get updated in the learning process. Equivalent to <code>embedding.weight.requires_grad = False</code>. Default: <code>True</code></li>
<li><strong>sparse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, gradient w.r.t. weight matrix will be a sparse tensor. See Notes for more details regarding sparse gradients.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # FloatTensor containing pretrained weights
&gt;&gt;&gt; weight = torch.FloatTensor([[1, 2.3, 3], [4, 5.1, 6.3]])
&gt;&gt;&gt; embedding = nn.Embedding.from_pretrained(weight)
&gt;&gt;&gt; # Get embeddings for index 1
&gt;&gt;&gt; input = torch.LongTensor([1])
&gt;&gt;&gt; embedding(input)
tensor([[ 4.0000,  5.1000,  6.3000]])

</code></pre>
<h3 id="embeddingbag">EmbeddingBag</h3>
<pre><code class="language-py">class torch.nn.EmbeddingBag(num_embeddings, embedding_dim, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, mode='mean', sparse=False)
</code></pre>
<p>Computes sums or means of ‘bags’ of embeddings, without instantiating the intermediate embeddings.</p>
<p>For bags of constant length, this class</p>
<blockquote>
<ul>
<li>with <code>mode="sum"</code> is equivalent to <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> followed by <code>torch.sum(dim=1)</code>,</li>
<li>with <code>mode="mean"</code> is equivalent to <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> followed by <code>torch.mean(dim=1)</code>,</li>
<li>with <code>mode="max"</code> is equivalent to <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> followed by <code>torch.max(dim=1)</code>.</li>
</ul>
</blockquote>
<p>However, <a href="#torch.nn.EmbeddingBag" title="torch.nn.EmbeddingBag"><code>EmbeddingBag</code></a> is much more time and memory efficient than using a chain of these operations.</p>
<p>Parameters:</p>
<ul>
<li><strong>num_embeddings</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – size of the dictionary of embeddings</li>
<li><strong>embedding_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of each embedding vector</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – If given, each embedding vector with norm larger than <code>max_norm</code> is renormalized to have norm <code>max_norm</code>.</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – The p of the p-norm to compute for the <code>max_norm</code> option. Default <code>2</code>.</li>
<li><strong>scale_grad_by_freq</strong> (<em>boolean</em>_,_ <em>optional</em>) – if given, this will scale gradients by the inverse of frequency of the words in the mini-batch. Default <code>False</code>. Note: this option is not supported when <code>mode="max"</code>.</li>
<li><strong>mode</strong> (<em>string</em>_,_ <em>optional</em>) – <code>"sum"</code>, <code>"mean"</code> or <code>"max"</code>. Specifies the way to reduce the bag. Default: <code>"mean"</code></li>
<li><strong>sparse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, gradient w.r.t. <code>weight</code> matrix will be a sparse tensor. See Notes for more details regarding sparse gradients. Note: this option is not supported when <code>mode="max"</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the learnable weights of the module of shape <code>(num_embeddings x embedding_dim)</code> initialized from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dd84ddbf2f8040d87fb315eeeba51f6d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dd84ddbf2f8040d87fb315eeeba51f6d.jpg" alt=""></a>.</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Inputs: <code>input</code> (LongTensor) and <code>offsets</code> (LongTensor, optional)</p>
<blockquote>
<ul>
<li> <p>If <code>input</code> is 2D of shape <code>B x N</code>,</p> <p>it will be treated as <code>B</code> bags (sequences) each of fixed length <code>N</code>, and this will return <code>B</code> values aggregated in a way depending on the <code>mode</code>. <code>offsets</code> is ignored and required to be <code>None</code> in this case.</p> </li>
<li> <p>If <code>input</code> is 1D of shape <code>N</code>,</p> <p>it will be treated as a concatenation of multiple bags (sequences). <code>offsets</code> is required to be a 1D tensor containing the starting index positions of each bag in <code>input</code>. Therefore, for <code>offsets</code> of shape <code>B</code>, <code>input</code> will be viewed as having <code>B</code> bags. Empty bags (i.e., having 0-length) will have returned vectors filled by zeros.</p> </li>
</ul>
</blockquote>
<p>Output shape: <code>B x embedding_dim</code></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # an Embedding module containing 10 tensors of size 3
&gt;&gt;&gt; embedding_sum = nn.EmbeddingBag(10, 3, mode='sum')
&gt;&gt;&gt; # a batch of 2 samples of 4 indices each
&gt;&gt;&gt; input = torch.LongTensor([1,2,4,5,4,3,2,9])
&gt;&gt;&gt; offsets = torch.LongTensor([0,4])
&gt;&gt;&gt; embedding_sum(input, offsets)
tensor([[-0.8861, -5.4350, -0.0523],
 [ 1.1306, -2.5798, -1.0044]])

</code></pre>
<h2 id="distance-functions">Distance functions</h2>
<h3 id="cosinesimilarity">CosineSimilarity</h3>
<pre><code class="language-py">class torch.nn.CosineSimilarity(dim=1, eps=1e-08)
</code></pre>
<p>Returns cosine similarity between <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/abdadb44ea35aecb39004dd7f55d9543.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/abdadb44ea35aecb39004dd7f55d9543.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/88fdc6eeb68ef4aacf7cd6bd43fa176e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/88fdc6eeb68ef4aacf7cd6bd43fa176e.jpg" alt=""></a>, computed along dim.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/93f92bee7ec6c9e48618f7c929ab51e3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/93f92bee7ec6c9e48618f7c929ab51e3.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Dimension where cosine similarity is computed. Default: 1</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Small value to avoid division by zero. Default: 1e-8</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input1: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2101d997ef86641ad9f92513b080e8a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2101d997ef86641ad9f92513b080e8a.jpg" alt=""></a> where D is at position <code>dim</code></li>
<li>Input2: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2101d997ef86641ad9f92513b080e8a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c2101d997ef86641ad9f92513b080e8a.jpg" alt=""></a>, same shape as the Input1</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/999c5fb65c1a9ba017a0d60c030400c5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/999c5fb65c1a9ba017a0d60c030400c5.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input1 = torch.randn(100, 128)
&gt;&gt;&gt; input2 = torch.randn(100, 128)
&gt;&gt;&gt; cos = nn.CosineSimilarity(dim=1, eps=1e-6)
&gt;&gt;&gt; output = cos(input1, input2)

</code></pre>
<h3 id="pairwisedistance">PairwiseDistance</h3>
<pre><code class="language-py">class torch.nn.PairwiseDistance(p=2.0, eps=1e-06, keepdim=False)
</code></pre>
<p>Computes the batchwise pairwise distance between vectors <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2f0f406e2d42300da1a9891d89381576.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2f0f406e2d42300da1a9891d89381576.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/60787776d6fd54b3adfd3762b910bd3f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/60787776d6fd54b3adfd3762b910bd3f.jpg" alt=""></a> using the p-norm:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4206b08d53423c6d6f77c51751d33cae.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4206b08d53423c6d6f77c51751d33cae.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>p</strong> (<em>real</em>) – the norm degree. Default: 2</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Small value to avoid division by zero. Default: 1e-6</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Determines whether or not to keep the batch dimension. Default: False</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input1: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" alt=""></a> where <code>D = vector dimension</code></li>
<li>Input2: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" alt=""></a>, same shape as the Input1</li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" alt=""></a>. If <code>keepdim</code> is <code>False</code>, then <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f1b7cdb5b976f1adde1e8b2850a1c127.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f1b7cdb5b976f1adde1e8b2850a1c127.jpg" alt=""></a>.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; pdist = nn.PairwiseDistance(p=2)
&gt;&gt;&gt; input1 = torch.randn(100, 128)
&gt;&gt;&gt; input2 = torch.randn(100, 128)
&gt;&gt;&gt; output = pdist(input1, input2)

</code></pre>
<h2 id="loss-functions">Loss functions</h2>
<h3 id="l1loss">L1Loss</h3>
<pre><code class="language-py">class torch.nn.L1Loss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the mean absolute error (MAE) between each element in the input <code>x</code> and target <code>y</code>.</p>
<p>The loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/415564bfa6c89ba182a02fe2a3d0ca49.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/415564bfa6c89ba182a02fe2a3d0ca49.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the batch size. If reduce is <code>True</code>, then:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dd1952e377a9b618cc6538b18165a417.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/dd1952e377a9b618cc6538b18165a417.jpg" alt=""></a></p>
<p><code>x</code> and <code>y</code> are tensors of arbitrary shapes with a total of <code>n</code> elements each.</p>
<p>The sum operation still operates over all the elements, and divides by <code>n</code>.</p>
<p>The division by <code>n</code> can be avoided if one sets the constructor argument <code>size_average=False</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
<li>Output: scalar. If reduce is <code>False</code>, then <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.L1Loss()
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; target = torch.randn(3, 5)
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="mseloss">MSELoss</h3>
<pre><code class="language-py">class torch.nn.MSELoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the mean squared error (squared L2 norm) between each element in the input <code>x</code> and target <code>y</code>.</p>
<p>The loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e67b64ef5017709a433d1214a681717e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e67b64ef5017709a433d1214a681717e.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the batch size. If reduce is <code>True</code>, then:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f3a00c026a75843dd3a04c64f9cecb47.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f3a00c026a75843dd3a04c64f9cecb47.jpg" alt=""></a></p>
<p>The sum operation still operates over all the elements, and divides by <code>n</code>.</p>
<p>The division by <code>n</code> can be avoided if one sets <code>size_average</code> to <code>False</code>.</p>
<p>To get a batch of losses, a loss per batch element, set <code>reduce</code> to <code>False</code>. These losses are not averaged and are not affected by <code>size_average</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.MSELoss()
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; target = torch.randn(3, 5)
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="crossentropyloss">CrossEntropyLoss</h3>
<pre><code class="language-py">class torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')
</code></pre>
<p>This criterion combines <code>nn.LogSoftmax()</code> and <code>nn.NLLLoss()</code> in one single class.</p>
<p>It is useful when training a classification problem with <code>C</code> classes. If provided, the optional argument <code>weight</code> should be a 1D <code>Tensor</code> assigning weight to each of the classes. This is particularly useful when you have an unbalanced training set.</p>
<p>The <code>input</code> is expected to contain scores for each class.</p>
<p><code>input</code> has to be a Tensor of size either <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cca0c8da541b81bec031e4e52161d2c7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cca0c8da541b81bec031e4e52161d2c7.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> for the <code>K</code>-dimensional case (described later).</p>
<p>This criterion expects a class index (0 to <code>C-1</code>) as the <code>target</code> for each value of a 1D tensor of size <code>minibatch</code></p>
<p>The loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29028e6a28821a298d2a456d6bb175f9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29028e6a28821a298d2a456d6bb175f9.jpg" alt=""></a></p>
<p>or in the case of the <code>weight</code> argument being specified:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bc344720164c2bc94ebd3f405b898216.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bc344720164c2bc94ebd3f405b898216.jpg" alt=""></a></p>
<p>The losses are averaged across observations for each minibatch.</p>
<p>Can also be used for higher dimension inputs, such as 2D images, by providing an input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a5db490cd70a38a0bb9f3de58c51589f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a5db490cd70a38a0bb9f3de58c51589f.jpg" alt=""></a> is the number of dimensions, and a target of appropriate shape (see below).</p>
<p>Parameters:</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, has to be a Tensor of size <code>C</code></li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>ignore_index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Specifies a target value that is ignored and does not contribute to the input gradient. When <code>size_average</code> is <code>True</code>, the loss is averaged over non-ignored targets.</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <pre><code class="language-py">Input: \((N, C)\) where C = number of classes, or
</code></pre> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ddeb501040934760370435d1c223e6b6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ddeb501040934760370435d1c223e6b6.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> in the case of <code>K</code>-dimensional loss.</p> </li>
<li> <pre><code class="language-py">Target: \((N)\) where each value is \(0 \leq \text{targets}[i] \leq C-1\), or
</code></pre> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> in the case of K-dimensional loss.</p> </li>
<li> <pre><code class="language-py">Output: scalar. If reduce is False, then the same size
</code></pre> <p>as the target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" alt=""></a>, or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> in the case of K-dimensional loss.</p> </li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.CrossEntropyLoss()
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; target = torch.empty(3, dtype=torch.long).random_(5)
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="ctcloss">CTCLoss</h3>
<pre><code class="language-py">class torch.nn.CTCLoss(blank=0, reduction='mean')
</code></pre>
<p>The Connectionist Temporal Classification loss.</p>
<p>Parameters:</p>
<ul>
<li><strong>blank</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – blank label. Default <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" alt=""></a>.</li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the output losses will be divided by the target lengths and then the mean over the batch is taken. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<pre><code class="language-py">log_probs: Tensor of size \((T, N, C)\) where C = number of characters in alphabet including blank,
</code></pre>
<p><cite>T = input length</cite>, and <cite>N = batch size</cite>. The logarithmized probabilities of the outputs (e.g. obtained with <a href="#torch.nn.functional.log_softmax" title="torch.nn.functional.log_softmax"><code>torch.nn.functional.log_softmax()</code></a>).</p>
<pre><code class="language-py">targets: Tensor of size \((N, S)\) or (sum(target_lengths)).
</code></pre>
<p>Targets (cannot be blank). In the second form, the targets are assumed to be concatenated.</p>
<pre><code class="language-py">input_lengths: Tuple or tensor of size \((N)\).
</code></pre>
<p>Lengths of the inputs (must each be <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0063f9a7d145aadc1082a0c4c8712a62.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0063f9a7d145aadc1082a0c4c8712a62.jpg" alt=""></a>)</p>
<pre><code class="language-py">target_lengths: Tuple or tensor of size  \((N)\).
</code></pre>
<p>Lengths of the targets</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; ctc_loss = nn.CTCLoss()
&gt;&gt;&gt; log_probs = torch.randn(50, 16, 20).log_softmax(2).detach().requires_grad_()
&gt;&gt;&gt; targets = torch.randint(1, 20, (16, 30), dtype=torch.long)
&gt;&gt;&gt; input_lengths = torch.full((16,), 50, dtype=torch.long)
&gt;&gt;&gt; target_lengths = torch.randint(10,30,(16,), dtype=torch.long)
&gt;&gt;&gt; loss = ctc_loss(log_probs, targets, input_lengths, target_lengths)
&gt;&gt;&gt; loss.backward()

</code></pre>
<pre><code class="language-py">Reference:
</code></pre>
<p>A. Graves et al.: Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks: <a href="https://www.cs.toronto.edu/~graves/icml_2006.pdf">https://www.cs.toronto.edu/~graves/icml_2006.pdf</a></p>
<p>Note</p>
<p>In order to use CuDNN, the following must be satisfied: <code>targets</code> must be in concatenated format, all <code>input_lengths</code> must be <code>T</code>. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e465f6009cd227a31d00f005c2cb1c5b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e465f6009cd227a31d00f005c2cb1c5b.jpg" alt=""></a>, <code>target_lengths</code> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3a2535723ad2261fbfc71d099a993883.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3a2535723ad2261fbfc71d099a993883.jpg" alt=""></a>, the integer arguments must be of dtype <code>torch.int32</code>.</p>
<p>The regular implementation uses the (more common in PyTorch) <code>torch.long</code> dtype.</p>
<p>Note</p>
<p>In some circumstances when using the CUDA backend with CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting <code>torch.backends.cudnn.deterministic = True</code>. Please see the notes on <a href="notes/randomness.html">Reproducibility</a> for background.</p>
<h3 id="nllloss">NLLLoss</h3>
<pre><code class="language-py">class torch.nn.NLLLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')
</code></pre>
<p>The negative log likelihood loss. It is useful to train a classification problem with <code>C</code> classes.</p>
<p>If provided, the optional argument <code>weight</code> should be a 1D Tensor assigning weight to each of the classes. This is particularly useful when you have an unbalanced training set.</p>
<p>The input given through a forward call is expected to contain log-probabilities of each class. <code>input</code> has to be a Tensor of size either <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cca0c8da541b81bec031e4e52161d2c7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cca0c8da541b81bec031e4e52161d2c7.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> for the <code>K</code>-dimensional case (described later).</p>
<p>Obtaining log-probabilities in a neural network is easily achieved by adding a <code>LogSoftmax</code> layer in the last layer of your network. You may use <code>CrossEntropyLoss</code> instead, if you prefer not to add an extra layer.</p>
<p>The target that this loss expects is a class index <code>(0 to C-1, where C = number of classes)</code></p>
<p>If <code>reduce</code> is <code>False</code>, the loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/edf1079de0e5df9633d0de83b68250f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/edf1079de0e5df9633d0de83b68250f2.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the batch size. If <code>reduce</code> is <code>True</code> (default), then</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6eeb4eee2867f6565cb78f3d2e8503f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6eeb4eee2867f6565cb78f3d2e8503f2.jpg" alt=""></a></p>
<p>Can also be used for higher dimension inputs, such as 2D images, by providing an input of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f30f7531b252dc52c6bb945ebb508cc4.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a5db490cd70a38a0bb9f3de58c51589f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a5db490cd70a38a0bb9f3de58c51589f.jpg" alt=""></a> is the number of dimensions, and a target of appropriate shape (see below). In the case of images, it computes NLL loss per-pixel.</p>
<p>Parameters:</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, it has to be a Tensor of size <code>C</code>. Otherwise, it is treated as if having all ones.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>ignore_index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Specifies a target value that is ignored and does not contribute to the input gradient. When <code>size_average</code> is <code>True</code>, the loss is averaged over non-ignored targets.</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <pre><code class="language-py">Input: \((N, C)\) where C = number of classes, or
</code></pre> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ddeb501040934760370435d1c223e6b6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ddeb501040934760370435d1c223e6b6.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> in the case of <code>K</code>-dimensional loss.</p> </li>
<li> <pre><code class="language-py">Target: \((N)\) where each value is \(0 \leq \text{targets}[i] \leq C-1\), or
</code></pre> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> in the case of K-dimensional loss.</p> </li>
<li> <pre><code class="language-py">Output: scalar. If reduce is False, then the same size
</code></pre> <p>as the target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" alt=""></a>, or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5981db74a9cd434c7580e6ba530e21b6.jpg" alt=""></a> with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" alt=""></a> in the case of K-dimensional loss.</p> </li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; loss = nn.NLLLoss()
&gt;&gt;&gt; # input is of size N x C = 3 x 5
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; # each element in target has to have 0 &lt;= value &lt; C
&gt;&gt;&gt; target = torch.tensor([1, 0, 4])
&gt;&gt;&gt; output = loss(m(input), target)
&gt;&gt;&gt; output.backward()
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; # 2D loss example (used, for example, with image inputs)
&gt;&gt;&gt; N, C = 5, 4
&gt;&gt;&gt; loss = nn.NLLLoss()
&gt;&gt;&gt; # input is of size N x C x height x width
&gt;&gt;&gt; data = torch.randn(N, 16, 10, 10)
&gt;&gt;&gt; conv = nn.Conv2d(16, C, (3, 3))
&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; # each element in target has to have 0 &lt;= value &lt; C
&gt;&gt;&gt; target = torch.empty(N, 8, 8, dtype=torch.long).random_(0, C)
&gt;&gt;&gt; output = loss(m(conv(data)), target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="poissonnllloss">PoissonNLLLoss</h3>
<pre><code class="language-py">class torch.nn.PoissonNLLLoss(log_input=True, full=False, size_average=None, eps=1e-08, reduce=None, reduction='mean')
</code></pre>
<p>Negative log likelihood loss with Poisson distribution of target.</p>
<p>The loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f50aaec015c8f6f2ef26d16a60023ea1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f50aaec015c8f6f2ef26d16a60023ea1.jpg" alt=""></a></p>
<p>The last term can be omitted or approximated with Stirling formula. The approximation is used for target values more than 1. For targets less or equal to 1 zeros are added to the loss.</p>
<p>Parameters:</p>
<ul>
<li> <p><strong>log_input</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code> the loss is computed as <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/18729f59c6d4705e1945b3d7b3e09e32.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/18729f59c6d4705e1945b3d7b3e09e32.jpg" alt=""></a>, if <code>False</code> the loss is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/036591dc90f1dafaa138920518e2b05b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/036591dc90f1dafaa138920518e2b05b.jpg" alt=""></a>.</p> </li>
<li> <p><strong>full</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) –</p> <p>whether to compute full loss, i. e. to add the Stirling approximation term</p> <p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b063f11c809ea98839d91fc34d0b4bf0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b063f11c809ea98839d91fc34d0b4bf0.jpg" alt=""></a></p> </li>
<li> <p><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></p> </li>
<li> <p><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Small value to avoid evaluation of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f6dcd4f69520c309a6d71002bd330cb8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f6dcd4f69520c309a6d71002bd330cb8.jpg" alt=""></a> when <code>log_input == False</code>. Default: 1e-8</p> </li>
<li> <p><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></p> </li>
<li> <p><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</p> </li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.PoissonNLLLoss()
&gt;&gt;&gt; log_input = torch.randn(5, 2, requires_grad=True)
&gt;&gt;&gt; target = torch.randn(5, 2)
&gt;&gt;&gt; output = loss(log_input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="kldivloss">KLDivLoss</h3>
<pre><code class="language-py">class torch.nn.KLDivLoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/Kullback-Leibler_divergence">Kullback-Leibler divergence</a> Loss</p>
<p>KL divergence is a useful distance measure for continuous distributions and is often useful when performing direct regression over the space of (discretely sampled) continuous output distributions.</p>
<p>As with <a href="#torch.nn.NLLLoss" title="torch.nn.NLLLoss"><code>NLLLoss</code></a>, the <code>input</code> given is expected to contain <em>log-probabilities</em>. However, unlike <a href="#torch.nn.NLLLoss" title="torch.nn.NLLLoss"><code>NLLLoss</code></a>, <code>input</code> is not restricted to a 2D Tensor. The targets are given as <em>probabilities</em> (i.e. without taking the logarithm).</p>
<p>This criterion expects a <code>target</code> <code>Tensor</code> of the same size as the <code>input</code> <code>Tensor</code>.</p>
<p>The unreduced (i.e. with <code>reduce</code> set to <code>False</code>) loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eba993f61a08816ebd5f577851d521f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eba993f61a08816ebd5f577851d521f2.jpg" alt=""></a></p>
<p>where the index <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> spans all dimensions of <code>input</code> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db4a9fef02111450bf98261889de550c.jpg" alt=""></a> has the same shape as <code>input</code>. If <code>reduce</code> is <code>True</code> (the default), then:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d88944e162eff94bddc1b9a94bcaa3a6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d88944e162eff94bddc1b9a94bcaa3a6.jpg" alt=""></a></p>
<p>In default reduction mode ‘mean’, the losses are averaged for each minibatch over observations <strong>as well as</strong> over dimensions. ‘batchmean’ mode gives the correct KL divergence where losses are averaged over batch dimension only. ‘mean’ mode’s behavior will be changed to the same as ‘batchmean’ in the next major release.</p>
<p>Parameters:</p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘batchmean’ | ‘sum’ | ‘mean’. ‘none’: no reduction will be applied. ‘batchmean’: the sum of the output will be divided by batchsize. ‘sum’: the output will be summed. ‘mean’: the output will be divided by the number of elements in the output. Default: ‘mean’</li>
</ul>
<p>:param .. note:: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated,: and in the meantime, specifying either of those two args will override <code>reduction</code>. :param .. note:: <code>reduction=’mean’</code> doesn’t return the true kl divergence value, please use: <code>reduction=’batchmean’</code> which aligns with KL math definition.</p>
<blockquote>
<p>In the next major release, ‘mean’ will be changed to be the same as ‘batchmean’.</p>
</blockquote>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li> <p>input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</p> </li>
<li> <p>target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</p> </li>
<li> <pre><code class="language-py">output: scalar by default. If reduce is False, then \((N, *)\),
</code></pre> <p>the same shape as the input</p> </li>
</ul>
<h3 id="bceloss">BCELoss</h3>
<pre><code class="language-py">class torch.nn.BCELoss(weight=None, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the Binary Cross Entropy between the target and the output:</p>
<p>The loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f233882012c0c24fcad1869a163b5b7c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f233882012c0c24fcad1869a163b5b7c.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the batch size. If reduce is <code>True</code>, then</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d88944e162eff94bddc1b9a94bcaa3a6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d88944e162eff94bddc1b9a94bcaa3a6.jpg" alt=""></a></p>
<p>This is used for measuring the error of a reconstruction in for example an auto-encoder. Note that the targets <code>y</code> should be numbers between 0 and 1.</p>
<p>Parameters:</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to the loss of each batch element. If given, has to be a Tensor of size “nbatch”.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N, *)</code>, same shape as input.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Sigmoid()
&gt;&gt;&gt; loss = nn.BCELoss()
&gt;&gt;&gt; input = torch.randn(3, requires_grad=True)
&gt;&gt;&gt; target = torch.empty(3).random_(2)
&gt;&gt;&gt; output = loss(m(input), target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="bcewithlogitsloss">BCEWithLogitsLoss</h3>
<pre><code class="language-py">class torch.nn.BCEWithLogitsLoss(weight=None, size_average=None, reduce=None, reduction='mean', pos_weight=None)
</code></pre>
<p>This loss combines a <code>Sigmoid</code> layer and the <code>BCELoss</code> in one single class. This version is more numerically stable than using a plain <code>Sigmoid</code> followed by a <code>BCELoss</code> as, by combining the operations into one layer, we take advantage of the log-sum-exp trick for numerical stability.</p>
<p>The loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0c49aad6f81ec7936e313096f7a53f97.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0c49aad6f81ec7936e313096f7a53f97.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the batch size. If reduce is <code>True</code>, then</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0a16102d9320f70f18d7c8b152000489.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0a16102d9320f70f18d7c8b152000489.jpg" alt=""></a></p>
<p>This is used for measuring the error of a reconstruction in for example an auto-encoder. Note that the targets <code>t[i]</code> should be numbers between 0 and 1.</p>
<p>It’s possible to trade off recall and precision by adding weights to positive examples. In this case the loss can be described as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5ca42e0ee1490d1dea4d5f38cc120d7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d5ca42e0ee1490d1dea4d5f38cc120d7.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76dc369e067e5fa42a4b32b6afd5e570.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76dc369e067e5fa42a4b32b6afd5e570.jpg" alt=""></a> is the positive weight of class <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a>. <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65abc7465f8ac5056f8562962f0ae02e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/65abc7465f8ac5056f8562962f0ae02e.jpg" alt=""></a> increases the recall, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/989afd86a6407cf24295ae8d52ff0080.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/989afd86a6407cf24295ae8d52ff0080.jpg" alt=""></a> increases the precision.</p>
<p>For example, if a dataset contains 100 positive and 300 negative examples of a single class, then <code>pos_weight</code> for the class should be equal to <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6a003751ded2d5e5198d93ee7db1ba5d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6a003751ded2d5e5198d93ee7db1ba5d.jpg" alt=""></a>. The loss would act as if the dataset contains <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fb2ad75ea1ac3ba3ae507a3c8a34db12.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fb2ad75ea1ac3ba3ae507a3c8a34db12.jpg" alt=""></a> positive examples.</p>
<p>Parameters:</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to the loss of each batch element. If given, has to be a Tensor of size “nbatch”.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
<li><strong>pos_weight</strong> – a weight of positive examples. Must be a vector with length equal to the number of classes.</li>
</ul>
<h3 id="marginrankingloss">MarginRankingLoss</h3>
<pre><code class="language-py">class torch.nn.MarginRankingLoss(margin=0.0, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the loss given inputs <code>x1</code>, <code>x2</code>, two 1D mini-batch <code>Tensor</code>s, and a label 1D mini-batch tensor <code>y</code> with values (<code>1</code> or <code>-1</code>).</p>
<p>If <code>y == 1</code> then it assumed the first input should be ranked higher (have a larger value) than the second input, and vice-versa for <code>y == -1</code>.</p>
<p>The loss function for each sample in the mini-batch is:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1664f71bed4b6591f02c8bbb10f2d389.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1664f71bed4b6591f02c8bbb10f2d389.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>0</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" alt=""></a> where <code>N</code> is the batch size and <code>D</code> is the size of a sample.</li>
<li>Target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a3e2b832e04fe8d66596083b23da518.jpg" alt=""></a></li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<h3 id="hingeembeddingloss">HingeEmbeddingLoss</h3>
<pre><code class="language-py">class torch.nn.HingeEmbeddingLoss(margin=1.0, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Measures the loss given an input tensor <code>x</code> and a labels tensor <code>y</code> containing values (<code>1</code> or <code>-1</code>). This is usually used for measuring whether two inputs are similar or dissimilar, e.g. using the L1 pairwise distance as <code>x</code>, and is typically used for learning nonlinear embeddings or semi-supervised learning.</p>
<p>The loss function for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a>-th sample in the mini-batch is</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1e176ed632f1cbc86eb8db4bf6034f24.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1e176ed632f1cbc86eb8db4bf6034f24.jpg" alt=""></a></p>
<p>and the total loss functions is</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0a16102d9320f70f18d7c8b152000489.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0a16102d9320f70f18d7c8b152000489.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/97b4908568a8d2f8549d90e683a8efa2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/97b4908568a8d2f8549d90e683a8efa2.jpg" alt=""></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>1</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: Tensor of arbitrary shape. The sum operation operates over all the elements.</li>
<li>Target: Same shape as input.</li>
<li>Output: scalar. If reduce is <code>False</code>, then same shape as the input</li>
</ul>
<h3 id="multilabelmarginloss">MultiLabelMarginLoss</h3>
<pre><code class="language-py">class torch.nn.MultiLabelMarginLoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a multi-class multi-classification hinge loss (margin-based loss) between input <code>x</code> (a 2D mini-batch <code>Tensor</code>) and output <code>y</code> (which is a 2D <code>Tensor</code> of target class indices). For each sample in the mini-batch:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f4d7e37a53b15d27b3a25c9dc586cd00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f4d7e37a53b15d27b3a25c9dc586cd00.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b75aa938b45ed55c0aa471218a7224ce.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b75aa938b45ed55c0aa471218a7224ce.jpg" alt=""></a> to <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c915dd214c2340e40ac8e79013465783.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c915dd214c2340e40ac8e79013465783.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4da95e4f78bfe10987f5549ced63a7e6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4da95e4f78bfe10987f5549ced63a7e6.jpg" alt=""></a> to <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec0f8a278c4b73ccb95d3a4c1d129697.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec0f8a278c4b73ccb95d3a4c1d129697.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8058aac8e03495c71f75b04169d5baca.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8058aac8e03495c71f75b04169d5baca.jpg" alt=""></a>, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/27b5f368a27d1e15b3656796a28a4411.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/27b5f368a27d1e15b3656796a28a4411.jpg" alt=""></a> for all <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" alt=""></a>.</p>
<p><code>y</code> and <code>x</code> must have the same size.</p>
<p>The criterion only considers a contiguous block of non-negative targets that starts at the front.</p>
<p>This allows for different samples to have variable amounts of target classes</p>
<p>Parameters:</p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/861a7d7a604a97f5620afad259a4c26d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/861a7d7a604a97f5620afad259a4c26d.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a> where <code>N</code> is the batch size and <code>C</code> is the number of classes.</li>
<li>Target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/861a7d7a604a97f5620afad259a4c26d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/861a7d7a604a97f5620afad259a4c26d.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a>, same shape as the input.</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<h3 id="smoothl1loss">SmoothL1Loss</h3>
<pre><code class="language-py">class torch.nn.SmoothL1Loss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that uses a squared term if the absolute element-wise error falls below 1 and an L1 term otherwise. It is less sensitive to outliers than the <code>MSELoss</code> and in some cases prevents exploding gradients (e.g. see “Fast R-CNN” paper by Ross Girshick). Also known as the Huber loss:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cd503c18d22f0e18a5109f3f13d028b2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cd503c18d22f0e18a5109f3f13d028b2.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bbfcb7c1428a33547e15f8853dbe6e4f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bbfcb7c1428a33547e15f8853dbe6e4f.jpg" alt=""></a> is given by:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/621fa336f1f8b6169430fa6b42a00b6d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/621fa336f1f8b6169430fa6b42a00b6d.jpg" alt=""></a></p>
<p><code>x</code> and <code>y</code> arbitrary shapes with a total of <code>n</code> elements each the sum operation still operates over all the elements, and divides by <code>n</code>.</p>
<p>The division by <code>n</code> can be avoided if one sets <code>size_average</code> to <code>False</code></p>
<p>Parameters:</p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
<li>Output: scalar. If reduce is <code>False</code>, then <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb7a3f5bc15cc379e78f768e821eb094.jpg" alt=""></a>, same shape as the input</li>
</ul>
<h3 id="softmarginloss">SoftMarginLoss</h3>
<pre><code class="language-py">class torch.nn.SoftMarginLoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a two-class classification logistic loss between input tensor <code>x</code> and target tensor <code>y</code> (containing 1 or -1).</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/811f3185227a964c048126484987ef1c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/811f3185227a964c048126484987ef1c.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: Tensor of arbitrary shape.</li>
<li>Target: Same shape as input.</li>
<li>Output: scalar. If reduce is <code>False</code>, then same shape as the input</li>
</ul>
<h3 id="multilabelsoftmarginloss">MultiLabelSoftMarginLoss</h3>
<pre><code class="language-py">class torch.nn.MultiLabelSoftMarginLoss(weight=None, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a multi-label one-versus-all loss based on max-entropy, between input <code>x</code> and target <code>y</code> of size <code>(N, C)</code>. For each sample in the minibatch:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/342414ff43adf5d0fa0b62fcde9538a2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/342414ff43adf5d0fa0b62fcde9538a2.jpg" alt=""></a></p>
<p>where <code>i == 0</code> to <code>x.nElement()-1</code>, <code>y[i] in {0,1}</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, it has to be a Tensor of size <code>C</code>. Otherwise, it is treated as if having all ones.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a> where <code>N</code> is the batch size and <code>C</code> is the number of classes.</li>
<li>Target: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a>, same shape as the input.</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<h3 id="cosineembeddingloss">CosineEmbeddingLoss</h3>
<pre><code class="language-py">class torch.nn.CosineEmbeddingLoss(margin=0.0, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the loss given input tensors <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/abdadb44ea35aecb39004dd7f55d9543.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/abdadb44ea35aecb39004dd7f55d9543.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/88fdc6eeb68ef4aacf7cd6bd43fa176e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/88fdc6eeb68ef4aacf7cd6bd43fa176e.jpg" alt=""></a> and a <code>Tensor</code> label <code>y</code> with values 1 or -1. This is used for measuring whether two inputs are similar or dissimilar, using the cosine distance, and is typically used for learning nonlinear embeddings or semi-supervised learning.</p>
<p>The loss function for each sample is:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f894a052d4408e0269216f8b803d074a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f894a052d4408e0269216f8b803d074a.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Should be a number from <code>-1</code> to <code>1</code>, <code>0</code> to <code>0.5</code> is suggested. If <code>margin</code> is missing, the default value is <code>0</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<h3 id="multimarginloss">MultiMarginLoss</h3>
<pre><code class="language-py">class torch.nn.MultiMarginLoss(p=1, margin=1.0, weight=None, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a multi-class classification hinge loss (margin-based loss) between input <code>x</code> (a 2D mini-batch <code>Tensor</code>) and output <code>y</code> (which is a 1D tensor of target class indices, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fffe5e09046ebb236f89daa5091946f6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fffe5e09046ebb236f89daa5091946f6.jpg" alt=""></a>):</p>
<p>For each mini-batch sample, the loss in terms of the 1D input <code>x</code> and scalar output <code>y</code> is:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0f825c52299de2e574d5903469e1af9c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0f825c52299de2e574d5903469e1af9c.jpg" alt=""></a></p>
<p>where <code>i == 0</code> to <code>x.size(0)</code> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/99e4beebf24a180393aa15ec3740cf3a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/99e4beebf24a180393aa15ec3740cf3a.jpg" alt=""></a>.</p>
<p>Optionally, you can give non-equal weighting on the classes by passing a 1D <code>weight</code> tensor into the constructor.</p>
<p>The loss function then becomes:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/03b7ccf64bc071a7c2abbeab89f12d08.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/03b7ccf64bc071a7c2abbeab89f12d08.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>1</code>. <code>1</code> and <code>2</code> are the only supported values</li>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>1</code>.</li>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, it has to be a Tensor of size <code>C</code>. Otherwise, it is treated as if having all ones.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<h3 id="tripletmarginloss">TripletMarginLoss</h3>
<pre><code class="language-py">class torch.nn.TripletMarginLoss(margin=1.0, p=2.0, eps=1e-06, swap=False, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the triplet loss given an input tensors x1, x2, x3 and a margin with a value greater than 0. This is used for measuring a relative similarity between samples. A triplet is composed by <code>a</code>, <code>p</code> and <code>n</code>: anchor, positive examples and negative example respectively. The shapes of all input tensors should be <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" alt=""></a>.</p>
<p>The distance swap is described in detail in the paper <a href="http://www.iis.ee.ic.ac.uk/%7Evbalnt/shallow_descr/TFeat_paper.pdf">Learning shallow convolutional feature descriptors with triplet losses</a> by V. Balntas, E. Riba et al.</p>
<p>The loss function for each sample in the mini-batch is:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a2c4faa5dd95a547388c1b7f69bbc4db.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a2c4faa5dd95a547388c1b7f69bbc4db.jpg" alt=""></a></p>
<p>where</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bac339e9cf6ad679fa9ce3ce33c431ab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bac339e9cf6ad679fa9ce3ce33c431ab.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Default: <code>1</code>.</li>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – The norm degree for pairwise distance. Default: <code>2</code>.</li>
<li><strong>swap</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – The distance swap is described in detail in the paper <code>Learning shallow convolutional feature descriptors with triplet losses</code> by V. Balntas, E. Riba et al. Default: <code>False</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string</em>_,_ <em>optional</em>) – Specifies the reduction to apply to the output: ‘none’ | ‘mean’ | ‘sum’. ‘none’: no reduction will be applied, ‘mean’: the sum of the output will be divided by the number of elements in the output, ‘sum’: the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: ‘mean’</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3dc464d2e10c731f17264e33e497c1a8.jpg" alt=""></a> where <code>D</code> is the vector dimension.</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<pre><code class="language-py">&gt;&gt;&gt; triplet_loss = nn.TripletMarginLoss(margin=1.0, p=2)
&gt;&gt;&gt; input1 = torch.randn(100, 128, requires_grad=True)
&gt;&gt;&gt; input2 = torch.randn(100, 128, requires_grad=True)
&gt;&gt;&gt; input3 = torch.randn(100, 128, requires_grad=True)
&gt;&gt;&gt; output = triplet_loss(input1, input2, input3)
&gt;&gt;&gt; output.backward()

</code></pre>
<h2 id="vision-layers">Vision layers</h2>
<h3 id="pixelshuffle">PixelShuffle</h3>
<pre><code class="language-py">class torch.nn.PixelShuffle(upscale_factor)
</code></pre>
<p>Rearranges elements in a tensor of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1bc8a113de558f2e7d966e72ae39cb95.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1bc8a113de558f2e7d966e72ae39cb95.jpg" alt=""></a> to a tensor of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d4e6de257f72abc5a96af64211b7f909.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d4e6de257f72abc5a96af64211b7f909.jpg" alt=""></a>.</p>
<p>This is useful for implementing efficient sub-pixel convolution with a stride of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/71c5422a7f21b7096aa6d904d5a4f78d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/71c5422a7f21b7096aa6d904d5a4f78d.jpg" alt=""></a>.</p>
<p>Look at the paper: <a href="https://arxiv.org/abs/1609.05158">Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network</a> by Shi et. al (2016) for more details.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>upscale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – factor to increase spatial resolution by</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d6770cccc0ae9886c3b91d55efa20b28.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d6770cccc0ae9886c3b91d55efa20b28.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a162cf8e9185f67b3f5b084d1031dc7e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a162cf8e9185f67b3f5b084d1031dc7e.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; pixel_shuffle = nn.PixelShuffle(3)
&gt;&gt;&gt; input = torch.randn(1, 9, 4, 4)
&gt;&gt;&gt; output = pixel_shuffle(input)
&gt;&gt;&gt; print(output.size())
torch.Size([1, 1, 12, 12])

</code></pre>
<h3 id="upsample">Upsample</h3>
<pre><code class="language-py">class torch.nn.Upsample(size=None, scale_factor=None, mode='nearest', align_corners=None)
</code></pre>
<p>Upsamples a given multi-channel 1D (temporal), 2D (spatial) or 3D (volumetric) data.</p>
<p>The input data is assumed to be of the form <code>minibatch x channels x [optional depth] x [optional height] x width</code>. Hence, for spatial inputs, we expect a 4D Tensor and for volumetric inputs, we expect a 5D Tensor.</p>
<p>The algorithms available for upsampling are nearest neighbor and linear, bilinear and trilinear for 3D, 4D and 5D input Tensor, respectively.</p>
<p>One can either give a <code>scale_factor</code> or the target output <code>size</code> to calculate the output size. (You cannot give both, as it is ambiguous)</p>
<p>Parameters:</p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – a tuple of ints <code>([optional D_out], [optional H_out], W_out)</code> output sizes</li>
<li><strong>scale_factor</strong> (<em>int / tuple of python:ints</em>_,_ <em>optional</em>) – the multiplier for the image height / width / depth</li>
<li><strong>mode</strong> (<em>string</em>_,_ <em>optional</em>) – the upsampling algorithm: one of <code>nearest</code>, <code>linear</code>, <code>bilinear</code> and <code>trilinear</code>. Default: <code>nearest</code></li>
<li><strong>align_corners</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if True, the corner pixels of the input and output tensors are aligned, and thus preserving the values at those pixels. This only has effect when <code>mode</code> is <code>linear</code>, <code>bilinear</code>, or <code>trilinear</code>. Default: False</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/964aa6df63e83f4468aa090441f01972.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c187d190013d0785320e3412fe8cd669.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a> or <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" alt=""></a>, where</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/da11a1265058248a851d6d0331110214.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/da11a1265058248a851d6d0331110214.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/828543b18440713aad6ad023732327ec.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/828543b18440713aad6ad023732327ec.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5a7c5c22409d4ab3c83641508bf72cb6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5a7c5c22409d4ab3c83641508bf72cb6.jpg" alt=""></a></p>
<p>Warning</p>
<p>With <code>align_corners = True</code>, the linearly interpolating modes (<code>linear</code>, <code>bilinear</code>, and <code>trilinear</code>) don’t proportionally align the output and input pixels, and thus the output values can depend on the input size. This was the default behavior for these modes up to version 0.3.1. Since then, the default behavior is <code>align_corners = False</code>. See below for concrete examples on how this affects the outputs.</p>
<p>Note</p>
<p>If you want downsampling/general resizing, you should use <code>interpolate()</code>.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.arange(1, 5).view(1, 1, 2, 2).float()
&gt;&gt;&gt; input
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='nearest')
&gt;&gt;&gt; m(input)
tensor([[[[ 1.,  1.,  2.,  2.],
 [ 1.,  1.,  2.,  2.],
 [ 3.,  3.,  4.,  4.],
 [ 3.,  3.,  4.,  4.]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear')  # align_corners=False
&gt;&gt;&gt; m(input)
tensor([[[[ 1.0000,  1.2500,  1.7500,  2.0000],
 [ 1.5000,  1.7500,  2.2500,  2.5000],
 [ 2.5000,  2.7500,  3.2500,  3.5000],
 [ 3.0000,  3.2500,  3.7500,  4.0000]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
&gt;&gt;&gt; m(input)
tensor([[[[ 1.0000,  1.3333,  1.6667,  2.0000],
 [ 1.6667,  2.0000,  2.3333,  2.6667],
 [ 2.3333,  2.6667,  3.0000,  3.3333],
 [ 3.0000,  3.3333,  3.6667,  4.0000]]]])

&gt;&gt;&gt; # Try scaling the same data in a larger tensor
&gt;&gt;&gt;
&gt;&gt;&gt; input_3x3 = torch.zeros(3, 3).view(1, 1, 3, 3)
&gt;&gt;&gt; input_3x3[:, :, :2, :2].copy_(input)
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])
&gt;&gt;&gt; input_3x3
tensor([[[[ 1.,  2.,  0.],
 [ 3.,  4.,  0.],
 [ 0.,  0.,  0.]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear')  # align_corners=False
&gt;&gt;&gt; # Notice that values in top left corner are the same with the small input (except at boundary)
&gt;&gt;&gt; m(input_3x3)
tensor([[[[ 1.0000,  1.2500,  1.7500,  1.5000,  0.5000,  0.0000],
 [ 1.5000,  1.7500,  2.2500,  1.8750,  0.6250,  0.0000],
 [ 2.5000,  2.7500,  3.2500,  2.6250,  0.8750,  0.0000],
 [ 2.2500,  2.4375,  2.8125,  2.2500,  0.7500,  0.0000],
 [ 0.7500,  0.8125,  0.9375,  0.7500,  0.2500,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
&gt;&gt;&gt; # Notice that values in top left corner are now changed
&gt;&gt;&gt; m(input_3x3)
tensor([[[[ 1.0000,  1.4000,  1.8000,  1.6000,  0.8000,  0.0000],
 [ 1.8000,  2.2000,  2.6000,  2.2400,  1.1200,  0.0000],
 [ 2.6000,  3.0000,  3.4000,  2.8800,  1.4400,  0.0000],
 [ 2.4000,  2.7200,  3.0400,  2.5600,  1.2800,  0.0000],
 [ 1.2000,  1.3600,  1.5200,  1.2800,  0.6400,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]]])

</code></pre>
<h3 id="upsamplingnearest2d">UpsamplingNearest2d</h3>
<pre><code class="language-py">class torch.nn.UpsamplingNearest2d(size=None, scale_factor=None)
</code></pre>
<p>Applies a 2D nearest neighbor upsampling to an input signal composed of several input channels.</p>
<p>To specify the scale, it takes either the <code>size</code> or the <code>scale_factor</code> as it’s constructor argument.</p>
<p>When <code>size</code> is given, it is the output size of the image <code>(h, w)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – a tuple of ints <code>(H_out, W_out)</code> output sizes</li>
<li><strong>scale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the multiplier for the image height or width</li>
</ul>
<p>Warning</p>
<p>This class is deprecated in favor of <code>interpolate()</code>.</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a> where</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/682de298a3561bebd964280ba0d59633.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/682de298a3561bebd964280ba0d59633.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a53007c25abe7f8f65f1a2e958fa146.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a53007c25abe7f8f65f1a2e958fa146.jpg" alt=""></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.arange(1, 5).view(1, 1, 2, 2)
&gt;&gt;&gt; input
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])

&gt;&gt;&gt; m = nn.UpsamplingNearest2d(scale_factor=2)
&gt;&gt;&gt; m(input)
tensor([[[[ 1.,  1.,  2.,  2.],
 [ 1.,  1.,  2.,  2.],
 [ 3.,  3.,  4.,  4.],
 [ 3.,  3.,  4.,  4.]]]])

</code></pre>
<h3 id="upsamplingbilinear2d">UpsamplingBilinear2d</h3>
<pre><code class="language-py">class torch.nn.UpsamplingBilinear2d(size=None, scale_factor=None)
</code></pre>
<p>Applies a 2D bilinear upsampling to an input signal composed of several input channels.</p>
<p>To specify the scale, it takes either the <code>size</code> or the <code>scale_factor</code> as it’s constructor argument.</p>
<p>When <code>size</code> is given, it is the output size of the image <code>(h, w)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – a tuple of ints <code>(H_out, W_out)</code> output sizes</li>
<li><strong>scale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the multiplier for the image height or width</li>
</ul>
<p>Warning</p>
<p>This class is deprecated in favor of <code>interpolate()</code>. It is equivalent to <code>nn.functional.interpolate(..., mode='bilinear', align_corners=True)</code>.</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff71b16eb10237262566c6907acaaf1f.jpg" alt=""></a></li>
<li>Output: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a0ef05f779873fc4dcbf020b1ea14754.jpg" alt=""></a> where</li>
</ul>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/682de298a3561bebd964280ba0d59633.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/682de298a3561bebd964280ba0d59633.jpg" alt=""></a></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a53007c25abe7f8f65f1a2e958fa146.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2a53007c25abe7f8f65f1a2e958fa146.jpg" alt=""></a></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.arange(1, 5).view(1, 1, 2, 2)
&gt;&gt;&gt; input
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])

&gt;&gt;&gt; m = nn.UpsamplingBilinear2d(scale_factor=2)
&gt;&gt;&gt; m(input)
tensor([[[[ 1.0000,  1.3333,  1.6667,  2.0000],
 [ 1.6667,  2.0000,  2.3333,  2.6667],
 [ 2.3333,  2.6667,  3.0000,  3.3333],
 [ 3.0000,  3.3333,  3.6667,  4.0000]]]])

</code></pre>
<h2 id="dataparallel-layers-multi-gpu-distributed">DataParallel layers (multi-GPU, distributed)</h2>
<h3 id="dataparallel">DataParallel</h3>
<pre><code class="language-py">class torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0)
</code></pre>
<p>Implements data parallelism at the module level.</p>
<p>This container parallelizes the application of the given <code>module</code> by splitting the input across the specified devices by chunking in the batch dimension (other objects will be copied once per device). In the forward pass, the module is replicated on each device, and each replica handles a portion of the input. During the backwards pass, gradients from each replica are summed into the original module.</p>
<p>The batch size should be larger than the number of GPUs used.</p>
<p>See also: <a href="notes/cuda.html#cuda-nn-dataparallel-instead">Use nn.DataParallel instead of multiprocessing</a></p>
<p>Arbitrary positional and keyword inputs are allowed to be passed into DataParallel EXCEPT Tensors. All tensors will be scattered on dim specified (default 0). Primitive types will be broadcasted, but all other types will be a shallow copy and can be corrupted if written to in the model’s forward pass.</p>
<p>The parallelized <code>module</code> must have its parameters and buffers on <code>device_ids[0]</code> before running this <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a> module.</p>
<p>Warning</p>
<p>In each forward, <code>module</code> is <strong>replicated</strong> on each device, so any updates to the runing module in <code>forward</code> will be lost. For example, if <code>module</code> has a counter attribute that is incremented in each <code>forward</code>, it will always stay at the initial value becasue the update is done on the replicas which are destroyed after <code>forward</code>. However, <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a> guarantees that the replica on <code>device[0]</code> will have its parameters and buffers sharing storage with the base parallelized <code>module</code>. So <strong>in-place</strong> updates to the parameters or buffers on <code>device[0]</code> will be recorded. E.g., <a href="#torch.nn.BatchNorm2d" title="torch.nn.BatchNorm2d"><code>BatchNorm2d</code></a> and <a href="#torch.nn.utils.spectral_norm" title="torch.nn.utils.spectral_norm"><code>spectral_norm()</code></a> rely on this behavior to update the buffers.</p>
<p>Warning</p>
<p>Forward and backward hooks defined on <code>module</code> and its submodules will be invoked <code>len(device_ids)</code> times, each with inputs located on a particular device. Particularly, the hooks are only guaranteed to be executed in correct order with respect to operations on corresponding devices. For example, it is not guaranteed that hooks set via <a href="#torch.nn.Module.register_forward_pre_hook" title="torch.nn.Module.register_forward_pre_hook"><code>register_forward_pre_hook()</code></a> be executed before <code>all</code> <code>len(device_ids)</code> <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> calls, but that each such hook be executed before the corresponding <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> call of that device.</p>
<p>Warning</p>
<p>When <code>module</code> returns a scalar (i.e., 0-dimensional tensor) in <code>forward()</code>, this wrapper will return a vector of length equal to number of devices used in data parallelism, containing the result from each device.</p>
<p>Note</p>
<p>There is a subtlety in using the <code>pack sequence -&amp;gt; recurrent network -&amp;gt; unpack sequence</code> pattern in a <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> wrapped in <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a>. See <a href="notes/faq.html#pack-rnn-unpack-with-data-parallelism">My recurrent network doesn’t work with data parallelism</a> section in FAQ for details.</p>
<p>Parameters:</p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – module to be parallelized</li>
<li><strong>device_ids</strong> (<em>list of python:int</em> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – CUDA devices (default: all devices)</li>
<li><strong>output_device</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – device location of output (default: device_ids[0])</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – the module to be parallelized</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; net = torch.nn.DataParallel(model, device_ids=[0, 1, 2])
&gt;&gt;&gt; output = net(input_var)

</code></pre>
<h3 id="distributeddataparallel">DistributedDataParallel</h3>
<pre><code class="language-py">class torch.nn.parallel.DistributedDataParallel(module, device_ids=None, output_device=None, dim=0, broadcast_buffers=True, process_group=None, bucket_cap_mb=25, check_reduction=False)
</code></pre>
<p>Implements distributed data parallelism that is based on torch.distributed package at the module level.</p>
<p>This container parallelizes the application of the given module by splitting the input across the specified devices by chunking in the batch dimension. The module is replicated on each machine and each device, and each such replica handles a portion of the input. During the backwards pass, gradients from each node are averaged.</p>
<p>The batch size should be larger than the number of GPUs used locally. It should also be an integer multiple of the number of GPUs so that each chunk is the same size (so that each GPU processes the same number of samples).</p>
<p>See also: <a href="distributed.html#distributed-basics">Basics</a> and <a href="notes/cuda.html#cuda-nn-dataparallel-instead">Use nn.DataParallel instead of multiprocessing</a>. The same constraints on input as in <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> apply.</p>
<p>Creation of this class requires that <code>torch.distributed</code> to be already initialized, by calling <a href="distributed.html#torch.distributed.init_process_group" title="torch.distributed.init_process_group"><code>torch.distributed.init_process_group()</code></a></p>
<p><code>DistributedDataParallel</code> can be used in the following two ways:</p>
<ol>
<li>Single-Process Multi-GPU</li>
</ol>
<p>In this case, a single process will be spawned on each host/node and each process will operate on all the GPUs of the node where it’s running. To use <code>DistributedDataParallel</code> in this way, you can simply construct the model as the following:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(backend="nccl")
&gt;&gt;&gt; model = DistributedDataParallel(model) # device_ids will include all GPU devices be default

</code></pre>
<ol>
<li>Multi-Process Single-GPU</li>
</ol>
<p>This is the highly recommended way to use <code>DistributedDataParallel</code>, with multiple processes, each of which operates on a single GPU. This is currently the fastest approach to do data parallel training using PyTorch and applies to both single-node(multi-GPU) and multi-node data parallel training. It is proven to be significantly faster than <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> for single-node multi-GPU data parallel training.</p>
<p>Here is how to use it: on each host with N GPUs, you should spawn up N processes, while ensuring that each process invidually works on a single GPU from 0 to N-1. Therefore, it is your job to ensure that your training script operates on a single given GPU by calling:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.cuda.set_device(i)

</code></pre>
<p>where i is from 0 to N-1. In each process, you should refer the following to construct this module:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(backend='nccl', world_size=4, init_method='...')
&gt;&gt;&gt; model = DistributedDataParallel(model, device_ids=[i], output_device=i)

</code></pre>
<p>In order to spawn up multiple processes per node, you can use either <code>torch.distributed.launch</code> or <code>torch.multiprocessing.spawn</code></p>
<p>Note</p>
<p><code>nccl</code> backend is currently the fastest and highly recommended backend to be used with Multi-Process Single-GPU distributed training and this applies to both single-node and multi-node distributed training</p>
<p>Warning</p>
<p>This module works only with the <code>gloo</code> and <code>nccl</code> backends.</p>
<p>Warning</p>
<p>Constructor, forward method, and differentiation of the output (or a function of the output of this module) is a distributed synchronization point. Take that into account in case different processes might be executing different code.</p>
<p>Warning</p>
<p>This module assumes all parameters are registered in the model by the time it is created. No parameters should be added nor removed later. Same applies to buffers.</p>
<p>Warning</p>
<p>This module assumes all parameters are registered in the model of each distributed processes are in the same order. The module itself will conduct gradient all-reduction following the reverse order of the registered parameters of the model. In other wise, it is users’ responsibility to ensure that each distributed process has the exact same model and thus the exact parameter registeration order.</p>
<p>Warning</p>
<p>This module assumes all buffers and gradients are dense.</p>
<p>Warning</p>
<p>This module doesn’t work with <a href="autograd.html#torch.autograd.grad" title="torch.autograd.grad"><code>torch.autograd.grad()</code></a> (i.e. it will only work if gradients are to be accumulated in <code>.grad</code> attributes of parameters).</p>
<p>Warning</p>
<p>If you plan on using this module with a <code>nccl</code> backend or a <code>gloo</code> backend (that uses Infiniband), together with a DataLoader that uses multiple workers, please change the multiprocessing start method to <code>forkserver</code> (Python 3 only) or <code>spawn</code>. Unfortunately Gloo (that uses Infiniband) and NCCL2 are not fork safe, and you will likely experience deadlocks if you don’t change this setting.</p>
<p>Warning</p>
<p>Forward and backward hooks defined on <code>module</code> and its submodules won’t be invoked anymore, unless the hooks are initialized in the <code>forward()</code> method.</p>
<p>Warning</p>
<p>You should never try to change your model’s parameters after wrapping up your model with DistributedDataParallel. In other words, when wrapping up your model with DistributedDataParallel, the constructor of DistributedDataParallel will register the additional gradient reduction functions on all the parameters of the model itself at the time of construction. If you change the model’s parameters after the DistributedDataParallel construction, this is not supported and unexpected behaviors can happen, since some parameters’ gradient reduction functions might not get called.</p>
<p>Note</p>
<p>Parameters are never broadcast between processes. The module performs an all-reduce step on gradients and assumes that they will be modified by the optimizer in all processes in the same way. Buffers (e.g. BatchNorm stats) are broadcast from the module in process of rank 0, to all other replicas in the system in every iteration.</p>
<p>Parameters:</p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – module to be parallelized</li>
<li><strong>device_ids</strong> (<em>list of python:int</em> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – CUDA devices (default: all devices)</li>
<li><strong>output_device</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – device location of output (default: device_ids[0])</li>
<li><strong>broadcast_buffers</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – flag that enables syncing (broadcasting) buffers of the module at beginning of the forward function. (default: True)</li>
<li><strong>process_group</strong> – the process group to be used for distributed data all-reduction. If None, the default process group, which is created by <code>torch.distributed.init_process_group</code>, will be used. (default: None)</li>
<li><strong>bucket_cap_mb</strong> – DistributedDataParallel will bucket parameters into multiple buckets so that gradient reduction of each bucket can potentially overlap with backward computation. bucket_cap_mb controls the bucket size in MegaBytes (MB) (default: 25)</li>
<li><strong>check_reduction</strong> – when setting to True, it enables DistributedDataParallel to automatically check if the previous iteration’s backward reductions were successfully issued at the beginning of every iteration’s forward function. You normally don’t need this option enabled unless you are observing weird behaviors such as different ranks are getting different gradients, which should not happen if DistributedDataParallel is corrected used. (default: False)</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – the module to be parallelized</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Example::
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(backend='nccl', world_size=4, init_method='...')
&gt;&gt;&gt; net = torch.nn.DistributedDataParallel(model, pg)

</code></pre>
<h3 id="distributeddataparallelcpu">DistributedDataParallelCPU</h3>
<pre><code class="language-py">class torch.nn.parallel.DistributedDataParallelCPU(module)
</code></pre>
<p>Implements distributed data parallelism for CPU at the module level.</p>
<p>This module supports the <code>mpi</code> and <code>gloo</code> backends.</p>
<p>This container parallelizes the application of the given module by splitting the input across the specified devices by chunking in the batch dimension. The module is replicated on each machine, and each such replica handles a portion of the input. During the backwards pass, gradients from each node are averaged.</p>
<p>This module could be used in conjunction with the DistributedSampler, (see :class <code>torch.utils.data.distributed.DistributedSampler</code>) which will load a subset of the original datset for each node with the same batch size. So strong scaling should be configured like this:</p>
<p>n = 1, batch size = 12</p>
<p>n = 2, batch size = 64</p>
<p>n = 4, batch size = 32</p>
<p>n = 8, batch size = 16</p>
<p>Creation of this class requires the distributed package to be already initialized in the process group mode (see <a href="distributed.html#torch.distributed.init_process_group" title="torch.distributed.init_process_group"><code>torch.distributed.init_process_group()</code></a>).</p>
<p>Warning</p>
<p>Constructor, forward method, and differentiation of the output (or a function of the output of this module) is a distributed synchronization point. Take that into account in case different node might be executing different code.</p>
<p>Warning</p>
<p>This module assumes all parameters are registered in the model by the time it is created. No parameters should be added nor removed later.</p>
<p>Warning</p>
<p>This module assumes all gradients are dense.</p>
<p>Warning</p>
<p>This module doesn’t work with <a href="autograd.html#torch.autograd.grad" title="torch.autograd.grad"><code>torch.autograd.grad()</code></a> (i.e. it will only work if gradients are to be accumulated in <code>.grad</code> attributes of parameters).</p>
<p>Warning</p>
<p>Forward and backward hooks defined on <code>module</code> and its submodules won’t be invoked anymore, unless the hooks are initialized in the <code>forward()</code> method.</p>
<p>Note</p>
<p>Parameters are broadcast between nodes in the <strong>init</strong>() function. The module performs an all-reduce step on gradients and assumes that they will be modified by the optimizer in all nodes in the same way.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>module</strong> – module to be parallelized</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(world_size=4, init_method='...')
&gt;&gt;&gt; net = torch.nn.DistributedDataParallelCPU(model)

</code></pre>
<h2 id="utilities">Utilities</h2>
<h3 id="clip-grad-norm-">clip_grad_norm_</h3>
<pre><code class="language-py">torch.nn.utils.clip_grad_norm_(parameters, max_norm, norm_type=2)
</code></pre>
<p>Clips gradient norm of an iterable of parameters.</p>
<p>The norm is computed over all gradients together, as if they were concatenated into a single vector. Gradients are modified in-place.</p>
<p>Parameters:</p>
<ul>
<li><strong>parameters</strong> (<em>Iterable</em>_[<em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a></em>] or_ <a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – an iterable of Tensors or a single Tensor that will have gradients normalized</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – max norm of the gradients</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – type of the used p-norm. Can be <code>'inf'</code> for infinity norm.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>Total norm of the parameters (viewed as a single vector).</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="clip-grad-value-">clip_grad_value_</h3>
<pre><code class="language-py">torch.nn.utils.clip_grad_value_(parameters, clip_value)
</code></pre>
<p>Clips gradient of an iterable of parameters at specified value.</p>
<p>Gradients are modified in-place.</p>
<p>Parameters:</p>
<ul>
<li><strong>parameters</strong> (<em>Iterable</em>_[<em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a></em>] or_ <a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – an iterable of Tensors or a single Tensor that will have gradients normalized</li>
<li><strong>clip_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – maximum allowed value of the gradients The gradients are clipped in the range [-clip_value, clip_value]</li>
</ul>
<h3 id="parameters-to-vector">parameters_to_vector</h3>
<pre><code class="language-py">torch.nn.utils.parameters_to_vector(parameters)
</code></pre>
<p>Convert parameters to one vector</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>Iterable</em>_[<em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a></em>]_) – an iterator of Tensors that are the parameters of a model.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>The parameters represented by a single vector</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<h3 id="vector-to-parameters">vector_to_parameters</h3>
<pre><code class="language-py">torch.nn.utils.vector_to_parameters(vec, parameters)
</code></pre>
<p>Convert one vector to the parameters</p>
<p>Parameters:</p>
<ul>
<li><strong>vec</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – a single vector represents the parameters of a model.</li>
<li><strong>parameters</strong> (<em>Iterable</em>_[<em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a></em>]_) – an iterator of Tensors that are the parameters of a model.</li>
</ul>
<h3 id="weight-norm">weight_norm</h3>
<pre><code class="language-py">torch.nn.utils.weight_norm(module, name='weight', dim=0)
</code></pre>
<p>Applies weight normalization to a parameter in the given module.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/06160be4a838f9d6d20cabc64f32670e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/06160be4a838f9d6d20cabc64f32670e.jpg" alt=""></a></p>
<p>Weight normalization is a reparameterization that decouples the magnitude of a weight tensor from its direction. This replaces the parameter specified by <code>name</code> (e.g. “weight”) with two parameters: one specifying the magnitude (e.g. “weight_g”) and one specifying the direction (e.g. “weight_v”). Weight normalization is implemented via a hook that recomputes the weight tensor from the magnitude and direction before every <code>forward()</code> call.</p>
<p>By default, with <code>dim=0</code>, the norm is computed independently per output channel/plane. To compute a norm over the entire weight tensor, use <code>dim=None</code>.</p>
<p>See <a href="https://arxiv.org/abs/1602.07868">https://arxiv.org/abs/1602.07868</a></p>
<p>Parameters:</p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – dimension over which to compute the norm</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>The original module with the weight norm hook</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40), name='weight')
Linear (20 -&gt; 40)
&gt;&gt;&gt; m.weight_g.size()
torch.Size([40, 1])
&gt;&gt;&gt; m.weight_v.size()
torch.Size([40, 20])

</code></pre>
<h3 id="remove-weight-norm">remove_weight_norm</h3>
<pre><code class="language-py">torch.nn.utils.remove_weight_norm(module, name='weight')
</code></pre>
<p>Removes the weight normalization reparameterization from a module.</p>
<p>Parameters:</p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
</ul>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40))
&gt;&gt;&gt; remove_weight_norm(m)

</code></pre>
<h3 id="spectral-norm">spectral_norm</h3>
<pre><code class="language-py">torch.nn.utils.spectral_norm(module, name='weight', n_power_iterations=1, eps=1e-12, dim=None)
</code></pre>
<p>Applies spectral normalization to a parameter in the given module.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1ca46cc2506aac38bf00645f64b1a3e3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1ca46cc2506aac38bf00645f64b1a3e3.jpg" alt=""></a></p>
<p>Spectral normalization stabilizes the training of discriminators (critics) in Generaive Adversarial Networks (GANs) by rescaling the weight tensor with spectral norm <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" alt=""></a> of the weight matrix calculated using power iteration method. If the dimension of the weight tensor is greater than 2, it is reshaped to 2D in power iteration method to get spectral norm. This is implemented via a hook that calculates spectral norm and rescales weight before every <code>forward()</code> call.</p>
<p>See <a href="https://arxiv.org/abs/1802.05957">Spectral Normalization for Generative Adversarial Networks</a> .</p>
<p>Parameters:</p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
<li><strong>n_power_iterations</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – number of power iterations to calculate spectal norm</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – epsilon for numerical stability in calculating norms</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – dimension corresponding to number of outputs, the default is 0, except for modules that are instances of ConvTranspose1/2/3d, when it is 1</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>The original module with the spectal norm hook</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = spectral_norm(nn.Linear(20, 40))
Linear (20 -&gt; 40)
&gt;&gt;&gt; m.weight_u.size()
torch.Size([20])

</code></pre>
<h3 id="remove-spectral-norm">remove_spectral_norm</h3>
<pre><code class="language-py">torch.nn.utils.remove_spectral_norm(module, name='weight')
</code></pre>
<p>Removes the spectral normalization reparameterization from a module.</p>
<p>Parameters:</p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
</ul>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; m = spectral_norm(nn.Linear(40, 10))
&gt;&gt;&gt; remove_spectral_norm(m)

</code></pre>
<h3 id="packedsequence">PackedSequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.PackedSequence(data, batch_sizes=None)
</code></pre>
<p>Holds the data and list of <code>batch_sizes</code> of a packed sequence.</p>
<p>All RNN modules accept packed sequences as inputs.</p>
<p>Note</p>
<p>Instances of this class should never be created manually. They are meant to be instantiated by functions like <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a>.</p>
<p>Batch sizes represent the number elements at each sequence step in the batch, not the varying sequence lengths passed to <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a>. For instance, given data <code>abc</code> and <code>x</code> the <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> would contain data <code>axbc</code> with <code>batch_sizes=[2,1,1]</code>.</p>
<p>| Variables: |</p>
<ul>
<li><strong>data</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Tensor containing packed sequence</li>
<li><strong>batch_sizes</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Tensor of integers holding information about the batch size at each sequence step</li>
</ul>
<h3 id="pack-padded-sequence">pack_padded_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pack_padded_sequence(input, lengths, batch_first=False)
</code></pre>
<p>Packs a Tensor containing padded sequences of variable length.</p>
<p>Input can be of size <code>T x B x *</code> where <code>T</code> is the length of the longest sequence (equal to <code>lengths[0]</code>), <code>B</code> is the batch size, and <code>*</code> is any number of dimensions (including 0). If <code>batch_first</code> is True <code>B x T x *</code> inputs are expected.</p>
<p>The sequences should be sorted by length in a decreasing order, i.e. <code>input[:,0]</code> should be the longest sequence, and <code>input[:,B-1]</code> the shortest one.</p>
<p>Note</p>
<p>This function accepts any input that has at least two dimensions. You can apply it to pack the labels, and use the output of the RNN with them to compute the loss directly. A Tensor can be retrieved from a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> object by accessing its <code>.data</code> attribute.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – padded batch of variable length sequences.</li>
<li><strong>lengths</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – list of sequences lengths of each batch element.</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, the input is expected in <code>B x T x *</code> format.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> object</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="pad-packed-sequence">pad_packed_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pad_packed_sequence(sequence, batch_first=False, padding_value=0.0, total_length=None)
</code></pre>
<p>Pads a packed batch of variable length sequences.</p>
<p>It is an inverse operation to <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a>.</p>
<p>The returned Tensor’s data will be of size <code>T x B x *</code>, where <code>T</code> is the length of the longest sequence and <code>B</code> is the batch size. If <code>batch_first</code> is True, the data will be transposed into <code>B x T x *</code> format.</p>
<p>Batch elements will be ordered decreasingly by their length.</p>
<p>Note</p>
<p><code>total_length</code> is useful to implement the <code>pack sequence -&amp;gt; recurrent network -&amp;gt; unpack sequence</code> pattern in a <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> wrapped in <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a>. See <a href="notes/faq.html#pack-rnn-unpack-with-data-parallelism">this FAQ section</a> for details.</p>
<p>Parameters:</p>
<ul>
<li><strong>sequence</strong> (<em>PackedSequence</em>) – batch to pad</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, the output will be in <code>B x T x *</code> format.</li>
<li><strong>padding_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – values for padded elements.</li>
<li><strong>total_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – if not <code>None</code>, the output will be padded to have length <code>total_length</code>. This method will throw <a href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code>ValueError</code></a> if <code>total_length</code> is less than the max sequence length in <code>sequence</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>Tuple of Tensor containing the padded sequence, and a Tensor containing the list of lengths of each sequence in the batch.</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="pad-sequence">pad_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pad_sequence(sequences, batch_first=False, padding_value=0)
</code></pre>
<p>Pad a list of variable length Tensors with zero</p>
<p><code>pad_sequence</code> stacks a list of Tensors along a new dimension, and pads them to equal length. For example, if the input is list of sequences with size <code>L x *</code> and if batch_first is False, and <code>T x B x *</code> otherwise.</p>
<p><code>B</code> is batch size. It is equal to the number of elements in <code>sequences</code>. <code>T</code> is length of the longest sequence. <code>L</code> is length of the sequence. <code>*</code> is any number of trailing dimensions, including none.</p>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; from torch.nn.utils.rnn import pad_sequence
&gt;&gt;&gt; a = torch.ones(25, 300)
&gt;&gt;&gt; b = torch.ones(22, 300)
&gt;&gt;&gt; c = torch.ones(15, 300)
&gt;&gt;&gt; pad_sequence([a, b, c]).size()
torch.Size([25, 3, 300])

</code></pre>
<p>Note</p>
<p>This function returns a Tensor of size <code>T x B x *</code> or <code>B x T x *</code> where <code>T</code> is the length of the longest sequence. This function assumes trailing dimensions and type of all the Tensors in sequences are same.</p>
<p>Parameters:</p>
<ul>
<li><strong>sequences</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a><em>[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>]</em>) – list of variable length sequences.</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – output will be in <code>B x T x *</code> if True, or in <code>T x B x *</code> otherwise</li>
<li><strong>padding_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – value for padded elements. Default: 0.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>Tensor of size <code>T x B x *</code> if <code>batch_first</code> is <code>False</code>. Tensor of size <code>B x T x *</code> otherwise</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="pack-sequence">pack_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pack_sequence(sequences)
</code></pre>
<p>Packs a list of variable length Tensors</p>
<p><code>sequences</code> should be a list of Tensors of size <code>L x *</code>, where <code>L</code> is the length of a sequence and <code>*</code> is any number of trailing dimensions, including zero. They should be sorted in the order of decreasing length.</p>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; from torch.nn.utils.rnn import pack_sequence
&gt;&gt;&gt; a = torch.tensor([1,2,3])
&gt;&gt;&gt; b = torch.tensor([4,5])
&gt;&gt;&gt; c = torch.tensor([6])
&gt;&gt;&gt; pack_sequence([a, b, c])
PackedSequence(data=tensor([ 1,  4,  6,  2,  5,  3]), batch_sizes=tensor([ 3,  2,  1]))

</code></pre>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>sequences</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a><em>[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>]</em>) – A list of sequences of decreasing length.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> object</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/97/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/97/index.html">Twisted与异步编程入门</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/60.html">likebeta</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 158个">158</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/74/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/74/index.html">Python进阶</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/46.html">东滨社</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">73页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2664个">2664</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/130/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/130/index.html">进击的Python</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/68.html">HuberTRoy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 169个">169</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/111/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/kubernetes_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/111/index.html">和我一步步部署 kubernetes 集群</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="kubernetes">kubernetes</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">17页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/186/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/186/index.html">leetcode题解，记录自己的leetcode解题之路</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8204个">8204</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/146/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/146/index.html">http2讲解</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/78.html">bagder</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1463个">1463</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../../" title="返回首页"><img class="" src="../../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../../book/169/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_getting_started.html" title="起步" data-book-page-rel-url="docs/1.0/tut_getting_started.html" data-book-page-id="11555">起步</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/deep_learning_60min_blitz.html" title="PyTorch 深度学习: 60 分钟极速入门" data-book-page-rel-url="docs/1.0/deep_learning_60min_blitz.html" data-book-page-id="11556">PyTorch 深度学习: 60 分钟极速入门</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_tensor_tutorial.html" title="什么是 PyTorch？" data-book-page-rel-url="docs/1.0/blitz_tensor_tutorial.html" data-book-page-id="11557">什么是 PyTorch？</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_autograd_tutorial.html" title="Autograd：自动求导" data-book-page-rel-url="docs/1.0/blitz_autograd_tutorial.html" data-book-page-id="11558">Autograd：自动求导</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_neural_networks_tutorial.html" title="神经网络" data-book-page-rel-url="docs/1.0/blitz_neural_networks_tutorial.html" data-book-page-id="11559">神经网络</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_cifar10_tutorial.html" title="训练分类器" data-book-page-rel-url="docs/1.0/blitz_cifar10_tutorial.html" data-book-page-id="11560">训练分类器</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_data_parallel_tutorial.html" title="可选：数据并行处理" data-book-page-rel-url="docs/1.0/blitz_data_parallel_tutorial.html" data-book-page-id="11561">可选：数据并行处理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/data_loading_tutorial.html" title="数据加载和处理教程" data-book-page-rel-url="docs/1.0/data_loading_tutorial.html" data-book-page-id="11562">数据加载和处理教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/pytorch_with_examples.html" title="用例子学习 PyTorch" data-book-page-rel-url="docs/1.0/pytorch_with_examples.html" data-book-page-id="11563">用例子学习 PyTorch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/transfer_learning_tutorial.html" title="迁移学习教程" data-book-page-rel-url="docs/1.0/transfer_learning_tutorial.html" data-book-page-id="11564">迁移学习教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/deploy_seq2seq_hybrid_frontend_tutorial.html" title="混合前端的 seq2seq 模型部署" data-book-page-rel-url="docs/1.0/deploy_seq2seq_hybrid_frontend_tutorial.html" data-book-page-id="11565">混合前端的 seq2seq 模型部署</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/saving_loading_models.html" title="Saving and Loading Models" data-book-page-rel-url="docs/1.0/saving_loading_models.html" data-book-page-id="11566">Saving and Loading Models</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn_tutorial.html" title="What is `torch.nn` _really_?" data-book-page-rel-url="docs/1.0/nn_tutorial.html" data-book-page-id="11567">What is `torch.nn` _really_?</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_image.html" title="图像" data-book-page-rel-url="docs/1.0/tut_image.html" data-book-page-id="11568">图像</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/finetuning_torchvision_models_tutorial.html" title="Torchvision 模型微调" data-book-page-rel-url="docs/1.0/finetuning_torchvision_models_tutorial.html" data-book-page-id="11569">Torchvision 模型微调</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/spatial_transformer_tutorial.html" title="空间变换器网络教程" data-book-page-rel-url="docs/1.0/spatial_transformer_tutorial.html" data-book-page-id="11570">空间变换器网络教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/neural_style_tutorial.html" title="使用 PyTorch 进行图像风格转换" data-book-page-rel-url="docs/1.0/neural_style_tutorial.html" data-book-page-id="11571">使用 PyTorch 进行图像风格转换</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/fgsm_tutorial.html" title="对抗性示例生成" data-book-page-rel-url="docs/1.0/fgsm_tutorial.html" data-book-page-id="11572">对抗性示例生成</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/super_resolution_with_caffe2.html" title="使用 ONNX 将模型从 PyTorch 传输到 Caffe2 和移动端" data-book-page-rel-url="docs/1.0/super_resolution_with_caffe2.html" data-book-page-id="11573">使用 ONNX 将模型从 PyTorch 传输到 Caffe2 和移动端</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_text.html" title="文本" data-book-page-rel-url="docs/1.0/tut_text.html" data-book-page-id="11574">文本</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/chatbot_tutorial.html" title="聊天机器人教程" data-book-page-rel-url="docs/1.0/chatbot_tutorial.html" data-book-page-id="11575">聊天机器人教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/char_rnn_generation_tutorial.html" title="使用字符级别特征的 RNN 网络生成姓氏" data-book-page-rel-url="docs/1.0/char_rnn_generation_tutorial.html" data-book-page-id="11576">使用字符级别特征的 RNN 网络生成姓氏</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/char_rnn_classification_tutorial.html" title="使用字符级别特征的 RNN 网络进行姓氏分类" data-book-page-rel-url="docs/1.0/char_rnn_classification_tutorial.html" data-book-page-id="11577">使用字符级别特征的 RNN 网络进行姓氏分类</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/deep_learning_nlp_tutorial.html" title="Deep Learning for NLP with Pytorch" data-book-page-rel-url="docs/1.0/deep_learning_nlp_tutorial.html" data-book-page-id="11578">Deep Learning for NLP with Pytorch</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_pytorch_tutorial.html" title="PyTorch 介绍" data-book-page-rel-url="docs/1.0/nlp_pytorch_tutorial.html" data-book-page-id="11579">PyTorch 介绍</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_deep_learning_tutorial.html" title="使用 PyTorch 进行深度学习" data-book-page-rel-url="docs/1.0/nlp_deep_learning_tutorial.html" data-book-page-id="11580">使用 PyTorch 进行深度学习</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_word_embeddings_tutorial.html" title="Word Embeddings: Encoding Lexical Semantics" data-book-page-rel-url="docs/1.0/nlp_word_embeddings_tutorial.html" data-book-page-id="11581">Word Embeddings: Encoding Lexical Semantics</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_sequence_models_tutorial.html" title="序列模型和 LSTM 网络" data-book-page-rel-url="docs/1.0/nlp_sequence_models_tutorial.html" data-book-page-id="11582">序列模型和 LSTM 网络</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_advanced_tutorial.html" title="Advanced: Making Dynamic Decisions and the Bi-LSTM CRF" data-book-page-rel-url="docs/1.0/nlp_advanced_tutorial.html" data-book-page-id="11583">Advanced: Making Dynamic Decisions and the Bi-LSTM CRF</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/seq2seq_translation_tutorial.html" title="基于注意力机制的 seq2seq 神经网络翻译" data-book-page-rel-url="docs/1.0/seq2seq_translation_tutorial.html" data-book-page-id="11584">基于注意力机制的 seq2seq 神经网络翻译</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_generative.html" title="生成" data-book-page-rel-url="docs/1.0/tut_generative.html" data-book-page-id="11585">生成</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/dcgan_faces_tutorial.html" title="DCGAN Tutorial" data-book-page-rel-url="docs/1.0/dcgan_faces_tutorial.html" data-book-page-id="11586">DCGAN Tutorial</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_reinforcement_learning.html" title="强化学习" data-book-page-rel-url="docs/1.0/tut_reinforcement_learning.html" data-book-page-id="11587">强化学习</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/reinforcement_q_learning.html" title="Reinforcement Learning (DQN) Tutorial" data-book-page-rel-url="docs/1.0/reinforcement_q_learning.html" data-book-page-id="11588">Reinforcement Learning (DQN) Tutorial</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_extending_pytorch.html" title="扩展 PyTorch" data-book-page-rel-url="docs/1.0/tut_extending_pytorch.html" data-book-page-id="11589">扩展 PyTorch</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/numpy_extensions_tutorial.html" title="用 numpy 和 scipy 创建扩展" data-book-page-rel-url="docs/1.0/numpy_extensions_tutorial.html" data-book-page-id="11590">用 numpy 和 scipy 创建扩展</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cpp_extension.html" title="Custom C++   and CUDA Extensions" data-book-page-rel-url="docs/1.0/cpp_extension.html" data-book-page-id="11591">Custom C++ and CUDA Extensions</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torch_script_custom_ops.html" title="Extending TorchScript with Custom C++   Operators" data-book-page-rel-url="docs/1.0/torch_script_custom_ops.html" data-book-page-id="11592">Extending TorchScript with Custom C++ Operators</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_production_usage.html" title="生产性使用" data-book-page-rel-url="docs/1.0/tut_production_usage.html" data-book-page-id="11593">生产性使用</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/dist_tuto.html" title="Writing Distributed Applications with PyTorch" data-book-page-rel-url="docs/1.0/dist_tuto.html" data-book-page-id="11594">Writing Distributed Applications with PyTorch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/aws_distributed_training_tutorial.html" title="使用 Amazon AWS 进行分布式训练" data-book-page-rel-url="docs/1.0/aws_distributed_training_tutorial.html" data-book-page-id="11595">使用 Amazon AWS 进行分布式训练</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/ONNXLive.html" title="ONNX 现场演示教程" data-book-page-rel-url="docs/1.0/ONNXLive.html" data-book-page-id="11596">ONNX 现场演示教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cpp_export.html" title="在 C++ 中加载 PYTORCH 模型" data-book-page-rel-url="docs/1.0/cpp_export.html" data-book-page-id="11597">在 C++ 中加载 PYTORCH 模型</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_other_language.html" title="其它语言中的 PyTorch" data-book-page-rel-url="docs/1.0/tut_other_language.html" data-book-page-id="11598">其它语言中的 PyTorch</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cpp_frontend.html" title="使用 PyTorch C++ 前端" data-book-page-rel-url="docs/1.0/cpp_frontend.html" data-book-page-id="11599">使用 PyTorch C++ 前端</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_notes.html" title="注解" data-book-page-rel-url="docs/1.0/docs_notes.html" data-book-page-id="11600">注解</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_autograd.html" title="自动求导机制" data-book-page-rel-url="docs/1.0/notes_autograd.html" data-book-page-id="11601">自动求导机制</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_broadcasting.html" title="广播语义" data-book-page-rel-url="docs/1.0/notes_broadcasting.html" data-book-page-id="11602">广播语义</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_cuda.html" title="CUDA 语义" data-book-page-rel-url="docs/1.0/notes_cuda.html" data-book-page-id="11603">CUDA 语义</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_extending.html" title="Extending PyTorch" data-book-page-rel-url="docs/1.0/notes_extending.html" data-book-page-id="11604">Extending PyTorch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_faq.html" title="Frequently Asked Questions" data-book-page-rel-url="docs/1.0/notes_faq.html" data-book-page-id="11605">Frequently Asked Questions</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_multiprocessing.html" title="Multiprocessing best practices" data-book-page-rel-url="docs/1.0/notes_multiprocessing.html" data-book-page-id="11606">Multiprocessing best practices</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_randomness.html" title="Reproducibility" data-book-page-rel-url="docs/1.0/notes_randomness.html" data-book-page-id="11607">Reproducibility</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_serialization.html" title="Serialization semantics" data-book-page-rel-url="docs/1.0/notes_serialization.html" data-book-page-id="11608">Serialization semantics</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_windows.html" title="Windows FAQ" data-book-page-rel-url="docs/1.0/notes_windows.html" data-book-page-id="11609">Windows FAQ</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_package_ref.html" title="包参考" data-book-page-rel-url="docs/1.0/docs_package_ref.html" data-book-page-id="11610">包参考</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torch.html" title="torch" data-book-page-rel-url="docs/1.0/torch.html" data-book-page-id="11611">torch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tensors.html" title="torch.Tensor" data-book-page-rel-url="docs/1.0/tensors.html" data-book-page-id="11612">torch.Tensor</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tensor_attributes.html" title="Tensor Attributes" data-book-page-rel-url="docs/1.0/tensor_attributes.html" data-book-page-id="11613">Tensor Attributes</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/type_info.html" title="数据类型信息" data-book-page-rel-url="docs/1.0/type_info.html" data-book-page-id="11614">数据类型信息</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/sparse.html" title="torch.sparse" data-book-page-rel-url="docs/1.0/sparse.html" data-book-page-id="11615">torch.sparse</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cuda.html" title="torch.cuda" data-book-page-rel-url="docs/1.0/cuda.html" data-book-page-id="11616">torch.cuda</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/storage.html" title="torch.Storage" data-book-page-rel-url="docs/1.0/storage.html" data-book-page-id="11617">torch.Storage</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn.html" title="torch.nn" data-book-page-rel-url="docs/1.0/nn.html" data-book-page-id="11618">torch.nn</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn_functional.html" title="torch.nn.functional" data-book-page-rel-url="docs/1.0/nn_functional.html" data-book-page-id="11619">torch.nn.functional</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn_init.html" title="torch.nn.init" data-book-page-rel-url="docs/1.0/nn_init.html" data-book-page-id="11620">torch.nn.init</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/optim.html" title="torch.optim" data-book-page-rel-url="docs/1.0/optim.html" data-book-page-id="11621">torch.optim</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/autograd.html" title="Automatic differentiation package - torch.autograd" data-book-page-rel-url="docs/1.0/autograd.html" data-book-page-id="11622">Automatic differentiation package - torch.autograd</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/distributed.html" title="Distributed communication package - torch.distributed" data-book-page-rel-url="docs/1.0/distributed.html" data-book-page-id="11623">Distributed communication package - torch.distributed</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/distributions.html" title="Probability distributions - torch.distributions" data-book-page-rel-url="docs/1.0/distributions.html" data-book-page-id="11624">Probability distributions - torch.distributions</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/jit.html" title="Torch Script" data-book-page-rel-url="docs/1.0/jit.html" data-book-page-id="11625">Torch Script</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/multiprocessing.html" title="多进程包 - torch.multiprocessing" data-book-page-rel-url="docs/1.0/multiprocessing.html" data-book-page-id="11626">多进程包 - torch.multiprocessing</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/bottleneck.html" title="torch.utils.bottleneck" data-book-page-rel-url="docs/1.0/bottleneck.html" data-book-page-id="11627">torch.utils.bottleneck</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/checkpoint.html" title="torch.utils.checkpoint" data-book-page-rel-url="docs/1.0/checkpoint.html" data-book-page-id="11628">torch.utils.checkpoint</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_cpp_extension.html" title="torch.utils.cpp_extension" data-book-page-rel-url="docs/1.0/docs_cpp_extension.html" data-book-page-id="11629">torch.utils.cpp_extension</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/data.html" title="torch.utils.data" data-book-page-rel-url="docs/1.0/data.html" data-book-page-id="11630">torch.utils.data</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/dlpack.html" title="torch.utils.dlpack" data-book-page-rel-url="docs/1.0/dlpack.html" data-book-page-id="11631">torch.utils.dlpack</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/hub.html" title="torch.hub" data-book-page-rel-url="docs/1.0/hub.html" data-book-page-id="11632">torch.hub</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/model_zoo.html" title="torch.utils.model_zoo" data-book-page-rel-url="docs/1.0/model_zoo.html" data-book-page-id="11633">torch.utils.model_zoo</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/onnx.html" title="torch.onnx" data-book-page-rel-url="docs/1.0/onnx.html" data-book-page-id="11634">torch.onnx</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/distributed_deprecated.html" title="Distributed communication package (deprecated) - torch.distributed.deprecated" data-book-page-rel-url="docs/1.0/distributed_deprecated.html" data-book-page-id="11635">Distributed communication package (deprecated) - torch.distributed.deprecated</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_torchvision_ref.html" title="torchvision 参考" data-book-page-rel-url="docs/1.0/docs_torchvision_ref.html" data-book-page-id="11636">torchvision 参考</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_datasets.html" title="torchvision.datasets" data-book-page-rel-url="docs/1.0/torchvision_datasets.html" data-book-page-id="11637">torchvision.datasets</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_models.html" title="torchvision.models" data-book-page-rel-url="docs/1.0/torchvision_models.html" data-book-page-id="11638">torchvision.models</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_transforms.html" title="torchvision.transforms" data-book-page-rel-url="docs/1.0/torchvision_transforms.html" data-book-page-id="11639">torchvision.transforms</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_utils.html" title="torchvision.utils" data-book-page-rel-url="docs/1.0/torchvision_utils.html" data-book-page-id="11640">torchvision.utils</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =169;var bookPageId =11618;var bookPageRelUrl ='docs/1.0/nn.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>