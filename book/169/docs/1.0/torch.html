
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>torch-PyTorch 1.0 中文文档 & 教程</title>
<meta content='torch,PyTorch 1.0 中文文档 & 教程' name='keywords'>
<meta content='torch,PyTorch 1.0 中文文档 & 教程' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../../book/169/docs/1.0/docs_package_ref.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">包参考</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../../book/169/docs/1.0/tensors.html">
<span class="">torch.Tensor</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../../book/169/index.html">PyTorch 1.0 中文文档 & 教程</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/pytorch-doc-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="torch">torch</h1>
<p>The torch package contains data structures for multi-dimensional tensors and mathematical operations over these are defined. Additionally, it provides many utilities for efficient serializing of Tensors and arbitrary types, and other useful utilities.</p>
<p>It has a CUDA counterpart, that enables you to run your tensor computations on an NVIDIA GPU with compute capability &gt;= 3.0.</p>
<h2 id="tensors">Tensors</h2>
<pre><code class="language-py">torch.is_tensor(obj)
</code></pre>
<p>Returns True if <code>obj</code> is a PyTorch tensor.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>obj</strong> (<em>Object</em>) – Object to test</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">torch.is_storage(obj)
</code></pre>
<p>Returns True if <code>obj</code> is a PyTorch storage object.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>obj</strong> (<em>Object</em>) – Object to test</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">torch.set_default_dtype(d)
</code></pre>
<p>Sets the default floating point dtype to <code>d</code>. This type will be used as default floating point type for type inference in <a href="#torch.tensor" title="torch.tensor"><code>torch.tensor()</code></a>.</p>
<p>The default floating point dtype is initially <code>torch.float32</code>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>d</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>) – the floating point dtype to make the default</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.tensor([1.2, 3]).dtype           # initial default for floating point is torch.float32
torch.float32
&gt;&gt;&gt; torch.set_default_dtype(torch.float64)
&gt;&gt;&gt; torch.tensor([1.2, 3]).dtype           # a new floating point tensor
torch.float64

</code></pre>
<pre><code class="language-py">torch.get_default_dtype() → torch.dtype
</code></pre>
<p>Get the current default floating point <a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>.</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.get_default_dtype()  # initial default for floating point is torch.float32
torch.float32
&gt;&gt;&gt; torch.set_default_dtype(torch.float64)
&gt;&gt;&gt; torch.get_default_dtype()  # default is now changed to torch.float64
torch.float64
&gt;&gt;&gt; torch.set_default_tensor_type(torch.FloatTensor)  # setting tensor type also affects this
&gt;&gt;&gt; torch.get_default_dtype()  # changed to torch.float32, the dtype for torch.FloatTensor
torch.float32

</code></pre>
<pre><code class="language-py">torch.set_default_tensor_type(t)
</code></pre>
<p>Sets the default <code>torch.Tensor</code> type to floating point tensor type <a href="#torch.t" title="torch.t"><code>t</code></a>. This type will also be used as default floating point type for type inference in <a href="#torch.tensor" title="torch.tensor"><code>torch.tensor()</code></a>.</p>
<p>The default floating point tensor type is initially <code>torch.FloatTensor</code>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>t</strong> (<a href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><em>type</em></a> <em>or</em> <em>string</em>) – the floating point tensor type or its name</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.tensor([1.2, 3]).dtype    # initial default for floating point is torch.float32
torch.float32
&gt;&gt;&gt; torch.set_default_tensor_type(torch.DoubleTensor)
&gt;&gt;&gt; torch.tensor([1.2, 3]).dtype    # a new floating point tensor
torch.float64

</code></pre>
<pre><code class="language-py">torch.numel(input) → int
</code></pre>
<p>Returns the total number of elements in the <code>input</code> tensor.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 2, 3, 4, 5)
&gt;&gt;&gt; torch.numel(a)
120
&gt;&gt;&gt; a = torch.zeros(4,4)
&gt;&gt;&gt; torch.numel(a)
16

</code></pre>
<pre><code class="language-py">torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None)
</code></pre>
<p>Set options for printing. Items shamelessly taken from NumPy</p>
<p>Parameters:</p>
<ul>
<li><strong>precision</strong> – Number of digits of precision for floating point output (default = 4).</li>
<li><strong>threshold</strong> – Total number of array elements which trigger summarization rather than full <code>repr</code> (default = 1000).</li>
<li><strong>edgeitems</strong> – Number of array items in summary at beginning and end of each dimension (default = 3).</li>
<li><strong>linewidth</strong> – The number of characters per line for the purpose of inserting line breaks (default = 80). Thresholded matrices will ignore this parameter.</li>
<li><strong>profile</strong> – Sane defaults for pretty printing. Can override with any of the above options. (any one of <code>default</code>, <code>short</code>, <code>full</code>)</li>
</ul>
<pre><code class="language-py">torch.set_flush_denormal(mode) → bool
</code></pre>
<p>Disables denormal floating numbers on CPU.</p>
<p>Returns <code>True</code> if your system supports flushing denormal numbers and it successfully configures flush denormal mode. <a href="#torch.set_flush_denormal" title="torch.set_flush_denormal"><code>set_flush_denormal()</code></a> is only supported on x86 architectures supporting SSE3.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>mode</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Controls whether to enable flush denormal mode or not</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.set_flush_denormal(True)
True
&gt;&gt;&gt; torch.tensor([1e-323], dtype=torch.float64)
tensor([ 0.], dtype=torch.float64)
&gt;&gt;&gt; torch.set_flush_denormal(False)
True
&gt;&gt;&gt; torch.tensor([1e-323], dtype=torch.float64)
tensor(9.88131e-324 *
 [ 1.0000], dtype=torch.float64)

</code></pre>
<h3 id="creation-ops">Creation Ops</h3>
<p>Note</p>
<p>Random sampling creation ops are listed under <a href="#random-sampling">Random sampling</a> and include: <a href="#torch.rand" title="torch.rand"><code>torch.rand()</code></a> <a href="#torch.rand_like" title="torch.rand_like"><code>torch.rand_like()</code></a> <a href="#torch.randn" title="torch.randn"><code>torch.randn()</code></a> <a href="#torch.randn_like" title="torch.randn_like"><code>torch.randn_like()</code></a> <a href="#torch.randint" title="torch.randint"><code>torch.randint()</code></a> <a href="#torch.randint_like" title="torch.randint_like"><code>torch.randint_like()</code></a> <a href="#torch.randperm" title="torch.randperm"><code>torch.randperm()</code></a> You may also use <a href="#torch.empty" title="torch.empty"><code>torch.empty()</code></a> with the <a href="#inplace-random-sampling">In-place random sampling</a> methods to create <a href="tensors.html#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> s with values sampled from a broader range of distributions.</p>
<pre><code class="language-py">torch.tensor(data, dtype=None, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Constructs a tensor with <code>data</code>.</p>
<p>Warning</p>
<p><a href="#torch.tensor" title="torch.tensor"><code>torch.tensor()</code></a> always copies <code>data</code>. If you have a Tensor <code>data</code> and want to avoid a copy, use <a href="tensors.html#torch.Tensor.requires_grad_" title="torch.Tensor.requires_grad_"><code>torch.Tensor.requires_grad_()</code></a> or <a href="autograd.html#torch.Tensor.detach" title="torch.Tensor.detach"><code>torch.Tensor.detach()</code></a>. If you have a NumPy <code>ndarray</code> and want to avoid a copy, use <a href="#torch.from_numpy" title="torch.from_numpy"><code>torch.from_numpy()</code></a>.</p>
<p>Warning</p>
<p>When data is a tensor <code>x</code>, <a href="#torch.tensor" title="torch.tensor"><code>torch.tensor()</code></a> reads out ‘the data’ from whatever it is passed, and constructs a leaf variable. Therefore <code>torch.tensor(x)</code> is equivalent to <code>x.clone().detach()</code> and <code>torch.tensor(x, requires_grad=True)</code> is equivalent to <code>x.clone().detach().requires_grad_(True)</code>. The equivalents using <code>clone()</code> and <code>detach()</code> are recommended.</p>
<p>Parameters:</p>
<ul>
<li><strong>data</strong> (<em>array_like</em>) – Initial data for the tensor. Can be a list, tuple, NumPy <code>ndarray</code>, scalar, and other types.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, infers data type from <code>data</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])
tensor([[ 0.1000,  1.2000],
 [ 2.2000,  3.1000],
 [ 4.9000,  5.2000]])

&gt;&gt;&gt; torch.tensor([0, 1])  # Type inference on data
tensor([ 0,  1])

&gt;&gt;&gt; torch.tensor([[0.11111, 0.222222, 0.3333333]],
 dtype=torch.float64,
 device=torch.device('cuda:0'))  # creates a torch.cuda.DoubleTensor
tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device='cuda:0')

&gt;&gt;&gt; torch.tensor(3.14159)  # Create a scalar (zero-dimensional tensor)
tensor(3.1416)

&gt;&gt;&gt; torch.tensor([])  # Create an empty tensor (of size (0,))
tensor([])

</code></pre>
<pre><code class="language-py">torch.sparse_coo_tensor(indices, values, size=None, dtype=None, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Constructs a sparse tensors in COO(rdinate) format with non-zero elements at the given <code>indices</code> with the given <code>values</code>. A sparse tensor can be <code>uncoalesced</code>, in that case, there are duplicate coordinates in the indices, and the value at that index is the sum of all duplicate value entries: <a href="https://pytorch.org/docs/stable/sparse.html">torch.sparse</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>indices</strong> (<em>array_like</em>) – Initial data for the tensor. Can be a list, tuple, NumPy <code>ndarray</code>, scalar, and other types. Will be cast to a <code>torch.LongTensor</code> internally. The indices are the coordinates of the non-zero values in the matrix, and thus should be two-dimensional where the first dimension is the number of tensor dimensions and the second dimension is the number of non-zero values.</li>
<li><strong>values</strong> (<em>array_like</em>) – Initial values for the tensor. Can be a list, tuple, NumPy <code>ndarray</code>, scalar, and other types.</li>
<li><strong>size</strong> (list, tuple, or <code>torch.Size</code>, optional) – Size of the sparse tensor. If not provided the size will be inferred as the minimum size big enough to hold all non-zero elements.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if None, infers data type from <code>values</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if None, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; i = torch.tensor([[0, 1, 1],
 [2, 0, 2]])
&gt;&gt;&gt; v = torch.tensor([3, 4, 5], dtype=torch.float32)
&gt;&gt;&gt; torch.sparse_coo_tensor(i, v, [2, 4])
tensor(indices=tensor([[0, 1, 1],
 [2, 0, 2]]),
 values=tensor([3., 4., 5.]),
 size=(2, 4), nnz=3, layout=torch.sparse_coo)

&gt;&gt;&gt; torch.sparse_coo_tensor(i, v)  # Shape inference
tensor(indices=tensor([[0, 1, 1],
 [2, 0, 2]]),
 values=tensor([3., 4., 5.]),
 size=(2, 3), nnz=3, layout=torch.sparse_coo)

&gt;&gt;&gt; torch.sparse_coo_tensor(i, v, [2, 4],
 dtype=torch.float64,
 device=torch.device('cuda:0'))
tensor(indices=tensor([[0, 1, 1],
 [2, 0, 2]]),
 values=tensor([3., 4., 5.]),
 device='cuda:0', size=(2, 4), nnz=3, dtype=torch.float64,
 layout=torch.sparse_coo)

# Create an empty sparse tensor with the following invariants:
#   1\. sparse_dim + dense_dim = len(SparseTensor.shape)
#   2\. SparseTensor._indices().shape = (sparse_dim, nnz)
#   3\. SparseTensor._values().shape = (nnz, SparseTensor.shape[sparse_dim:])
#
# For instance, to create an empty sparse tensor with nnz = 0, dense_dim = 0 and
# sparse_dim = 1 (hence indices is a 2D tensor of shape = (1, 0))
&gt;&gt;&gt; S = torch.sparse_coo_tensor(torch.empty([1, 0]), [], [1])
tensor(indices=tensor([], size=(1, 0)),
 values=tensor([], size=(0,)),
 size=(1,), nnz=0, layout=torch.sparse_coo)

# and to create an empty sparse tensor with nnz = 0, dense_dim = 1 and
# sparse_dim = 1
&gt;&gt;&gt; S = torch.sparse_coo_tensor(torch.empty([1, 0]), torch.empty([0, 2]), [1, 2])
tensor(indices=tensor([], size=(1, 0)),
 values=tensor([], size=(0, 2)),
 size=(1, 2), nnz=0, layout=torch.sparse_coo)

</code></pre>
<pre><code class="language-py">torch.as_tensor(data, dtype=None, device=None) → Tensor
</code></pre>
<p>Convert the data into a <code>torch.Tensor</code>. If the data is already a <code>Tensor</code> with the same <code>dtype</code> and <code>device</code>, no copy will be performed, otherwise a new <code>Tensor</code> will be returned with computational graph retained if data <code>Tensor</code> has <code>requires_grad=True</code>. Similarly, if the data is an <code>ndarray</code> of the corresponding <code>dtype</code> and the <code>device</code> is the cpu, no copy will be performed.</p>
<p>Parameters:</p>
<ul>
<li><strong>data</strong> (<em>array_like</em>) – Initial data for the tensor. Can be a list, tuple, NumPy <code>ndarray</code>, scalar, and other types.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, infers data type from <code>data</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = numpy.array([1, 2, 3])
&gt;&gt;&gt; t = torch.as_tensor(a)
&gt;&gt;&gt; t
tensor([ 1,  2,  3])
&gt;&gt;&gt; t[0] = -1
&gt;&gt;&gt; a
array([-1,  2,  3])

&gt;&gt;&gt; a = numpy.array([1, 2, 3])
&gt;&gt;&gt; t = torch.as_tensor(a, device=torch.device('cuda'))
&gt;&gt;&gt; t
tensor([ 1,  2,  3])
&gt;&gt;&gt; t[0] = -1
&gt;&gt;&gt; a
array([1,  2,  3])

</code></pre>
<pre><code class="language-py">torch.from_numpy(ndarray) → Tensor
</code></pre>
<p>Creates a <a href="tensors.html#torch.Tensor" title="torch.Tensor"><code>Tensor</code></a> from a <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><code>numpy.ndarray</code></a>.</p>
<p>The returned tensor and <code>ndarray</code> share the same memory. Modifications to the tensor will be reflected in the <code>ndarray</code> and vice versa. The returned tensor is not resizable.</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = numpy.array([1, 2, 3])
&gt;&gt;&gt; t = torch.from_numpy(a)
&gt;&gt;&gt; t
tensor([ 1,  2,  3])
&gt;&gt;&gt; t[0] = -1
&gt;&gt;&gt; a
array([-1,  2,  3])

</code></pre>
<pre><code class="language-py">torch.zeros(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with the scalar value <code>0</code>, with the shape defined by the variable argument <code>sizes</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>sizes</strong> (<em>int...</em>) – a sequence of integers defining the shape of the output tensor. Can be a variable number of arguments or a collection like a list or tuple.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.zeros(2, 3)
tensor([[ 0.,  0.,  0.],
 [ 0.,  0.,  0.]])

&gt;&gt;&gt; torch.zeros(5)
tensor([ 0.,  0.,  0.,  0.,  0.])

</code></pre>
<pre><code class="language-py">torch.zeros_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with the scalar value <code>0</code>, with the same size as <code>input</code>. <code>torch.zeros_like(input)</code> is equivalent to <code>torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)</code>.</p>
<p>Warning</p>
<p>As of 0.4, this function does not support an <code>out</code> keyword. As an alternative, the old <code>torch.zeros_like(input, out=output)</code> is equivalent to <code>torch.zeros(input.size(), out=output)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the size of <code>input</code> will determine size of the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned Tensor. Default: if <code>None</code>, defaults to the dtype of <code>input</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned tensor. Default: if <code>None</code>, defaults to the layout of <code>input</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, defaults to the device of <code>input</code>.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.empty(2, 3)
&gt;&gt;&gt; torch.zeros_like(input)
tensor([[ 0.,  0.,  0.],
 [ 0.,  0.,  0.]])

</code></pre>
<pre><code class="language-py">torch.ones(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with the scalar value <code>1</code>, with the shape defined by the variable argument <code>sizes</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>sizes</strong> (<em>int...</em>) – a sequence of integers defining the shape of the output tensor. Can be a variable number of arguments or a collection like a list or tuple.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.ones(2, 3)
tensor([[ 1.,  1.,  1.],
 [ 1.,  1.,  1.]])

&gt;&gt;&gt; torch.ones(5)
tensor([ 1.,  1.,  1.,  1.,  1.])

</code></pre>
<pre><code class="language-py">torch.ones_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with the scalar value <code>1</code>, with the same size as <code>input</code>. <code>torch.ones_like(input)</code> is equivalent to <code>torch.ones(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)</code>.</p>
<p>Warning</p>
<p>As of 0.4, this function does not support an <code>out</code> keyword. As an alternative, the old <code>torch.ones_like(input, out=output)</code> is equivalent to <code>torch.ones(input.size(), out=output)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the size of <code>input</code> will determine size of the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned Tensor. Default: if <code>None</code>, defaults to the dtype of <code>input</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned tensor. Default: if <code>None</code>, defaults to the layout of <code>input</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, defaults to the device of <code>input</code>.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.empty(2, 3)
&gt;&gt;&gt; torch.ones_like(input)
tensor([[ 1.,  1.,  1.],
 [ 1.,  1.,  1.]])

</code></pre>
<pre><code class="language-py">torch.arange(start=0, end, step=1, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a 1-D tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/93f0e014493a12cb3334b1c1f00517f4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/93f0e014493a12cb3334b1c1f00517f4.jpg" alt=""></a> with values from the interval <code>[start, end)</code> taken with common difference <code>step</code> beginning from <code>start</code>.</p>
<p>Note that non-integer <code>step</code> is subject to floating point rounding errors when comparing against <code>end</code>; to avoid inconsistency, we advise adding a small epsilon to <code>end</code> in such cases.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e6fd079c910af8a8a6486e341b02282.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e6fd079c910af8a8a6486e341b02282.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>start</strong> (<em>Number</em>) – the starting value for the set of points. Default: <code>0</code>.</li>
<li><strong>end</strong> (<em>Number</em>) – the ending value for the set of points</li>
<li><strong>step</strong> (<em>Number</em>) – the gap between each pair of adjacent points. Default: <code>1</code>.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). If <code>dtype</code> is not given, infer the data type from the other input arguments. If any of <code>start</code>, <code>end</code>, or <code>stop</code> are floating-point, the <code>dtype</code> is inferred to be the default dtype, see <a href="#torch.get_default_dtype" title="torch.get_default_dtype"><code>get_default_dtype()</code></a>. Otherwise, the <code>dtype</code> is inferred to be <code>torch.int64</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.arange(5)
tensor([ 0,  1,  2,  3,  4])
&gt;&gt;&gt; torch.arange(1, 4)
tensor([ 1,  2,  3])
&gt;&gt;&gt; torch.arange(1, 2.5, 0.5)
tensor([ 1.0000,  1.5000,  2.0000])

</code></pre>
<pre><code class="language-py">torch.range(start=0, end, step=1, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a 1-D tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8df7b0b7ce71be5149c4526856d43f13.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8df7b0b7ce71be5149c4526856d43f13.jpg" alt=""></a> with values from <code>start</code> to <code>end</code> with step <code>step</code>. Step is the gap between two values in the tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/df6d39cd8a83332eb174ec540be74326.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/df6d39cd8a83332eb174ec540be74326.jpg" alt=""></a></p>
<p>Warning</p>
<p>This function is deprecated in favor of <a href="#torch.arange" title="torch.arange"><code>torch.arange()</code></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>start</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the starting value for the set of points. Default: <code>0</code>.</li>
<li><strong>end</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the ending value for the set of points</li>
<li><strong>step</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the gap between each pair of adjacent points. Default: <code>1</code>.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.range(1, 4)
tensor([ 1.,  2.,  3.,  4.])
&gt;&gt;&gt; torch.range(1, 4, 0.5)
tensor([ 1.0000,  1.5000,  2.0000,  2.5000,  3.0000,  3.5000,  4.0000])

</code></pre>
<pre><code class="language-py">torch.linspace(start, end, steps=100, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a one-dimensional tensor of <code>steps</code> equally spaced points between <code>start</code> and <code>end</code>.</p>
<p>The output tensor is 1-D of size <code>steps</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>start</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the starting value for the set of points</li>
<li><strong>end</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the ending value for the set of points</li>
<li><strong>steps</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of points to sample between <code>start</code> and <code>end</code>. Default: <code>100</code>.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.linspace(3, 10, steps=5)
tensor([  3.0000,   4.7500,   6.5000,   8.2500,  10.0000])
&gt;&gt;&gt; torch.linspace(-10, 10, steps=5)
tensor([-10.,  -5.,   0.,   5.,  10.])
&gt;&gt;&gt; torch.linspace(start=-10, end=10, steps=5)
tensor([-10.,  -5.,   0.,   5.,  10.])

</code></pre>
<pre><code class="language-py">torch.logspace(start, end, steps=100, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a one-dimensional tensor of <code>steps</code> points logarithmically spaced between <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8472cb905d226233b6c5b6ca382cf74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8472cb905d226233b6c5b6ca382cf74.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5385eb329ab67a640482b03b99be6155.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5385eb329ab67a640482b03b99be6155.jpg" alt=""></a>.</p>
<p>The output tensor is 1-D of size <code>steps</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>start</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the starting value for the set of points</li>
<li><strong>end</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the ending value for the set of points</li>
<li><strong>steps</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of points to sample between <code>start</code> and <code>end</code>. Default: <code>100</code>.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.logspace(start=-10, end=10, steps=5)
tensor([ 1.0000e-10,  1.0000e-05,  1.0000e+00,  1.0000e+05,  1.0000e+10])
&gt;&gt;&gt; torch.logspace(start=0.1, end=1.0, steps=5)
tensor([  1.2589,   2.1135,   3.5481,   5.9566,  10.0000])

</code></pre>
<pre><code class="language-py">torch.eye(n, m=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.</p>
<p>Parameters:</p>
<ul>
<li><strong>n</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of rows</li>
<li><strong>m</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the number of columns with default being <code>n</code></li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A 2-D tensor with ones on the diagonal and zeros elsewhere</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.eye(3)
tensor([[ 1.,  0.,  0.],
 [ 0.,  1.,  0.],
 [ 0.,  0.,  1.]])

</code></pre>
<pre><code class="language-py">torch.empty(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with uninitialized data. The shape of the tensor is defined by the variable argument <code>sizes</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>sizes</strong> (<em>int...</em>) – a sequence of integers defining the shape of the output tensor. Can be a variable number of arguments or a collection like a list or tuple.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.empty(2, 3)
tensor(1.00000e-08 *
 [[ 6.3984,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000]])

</code></pre>
<pre><code class="language-py">torch.empty_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns an uninitialized tensor with the same size as <code>input</code>. <code>torch.empty_like(input)</code> is equivalent to <code>torch.empty(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the size of <code>input</code> will determine size of the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned Tensor. Default: if <code>None</code>, defaults to the dtype of <code>input</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned tensor. Default: if <code>None</code>, defaults to the layout of <code>input</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, defaults to the device of <code>input</code>.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.empty((2,3), dtype=torch.int64)
tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],
 [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])

</code></pre>
<pre><code class="language-py">torch.full(size, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor of size <code>size</code> filled with <code>fill_value</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>size</strong> (<em>int...</em>) – a list, tuple, or <code>torch.Size</code> of integers defining the shape of the output tensor.</li>
<li><strong>fill_value</strong> – the number to fill the output tensor with.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.full((2, 3), 3.141592)
tensor([[ 3.1416,  3.1416,  3.1416],
 [ 3.1416,  3.1416,  3.1416]])

</code></pre>
<pre><code class="language-py">torch.full_like(input, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor with the same size as <code>input</code> filled with <code>fill_value</code>. <code>torch.full_like(input, fill_value)</code> is equivalent to <code>torch.full_like(input.size(), fill_value, dtype=input.dtype, layout=input.layout, device=input.device)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the size of <code>input</code> will determine size of the output tensor</li>
<li><strong>fill_value</strong> – the number to fill the output tensor with.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned Tensor. Default: if <code>None</code>, defaults to the dtype of <code>input</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned tensor. Default: if <code>None</code>, defaults to the layout of <code>input</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, defaults to the device of <code>input</code>.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<h3 id="indexing-slicing-joining-mutating-ops">Indexing, Slicing, Joining, Mutating Ops</h3>
<pre><code class="language-py">torch.cat(tensors, dim=0, out=None) → Tensor
</code></pre>
<p>Concatenates the given sequence of <code>seq</code> tensors in the given dimension. All tensors must either have the same shape (except in the concatenating dimension) or be empty.</p>
<p><a href="#torch.cat" title="torch.cat"><code>torch.cat()</code></a> can be seen as an inverse operation for <a href="#torch.split" title="torch.split"><code>torch.split()</code></a> and <a href="#torch.chunk" title="torch.chunk"><code>torch.chunk()</code></a>.</p>
<p><a href="#torch.cat" title="torch.cat"><code>torch.cat()</code></a> can be best understood via examples.</p>
<p>Parameters:</p>
<ul>
<li><strong>tensors</strong> (<em>sequence of Tensors</em>) – any python sequence of tensors of the same type. Non-empty tensors provided must have the same shape, except in the cat dimension.</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the dimension over which the tensors are concatenated</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(2, 3)
&gt;&gt;&gt; x
tensor([[ 0.6580, -1.0969, -0.4614],
 [-0.1034, -0.5790,  0.1497]])
&gt;&gt;&gt; torch.cat((x, x, x), 0)
tensor([[ 0.6580, -1.0969, -0.4614],
 [-0.1034, -0.5790,  0.1497],
 [ 0.6580, -1.0969, -0.4614],
 [-0.1034, -0.5790,  0.1497],
 [ 0.6580, -1.0969, -0.4614],
 [-0.1034, -0.5790,  0.1497]])
&gt;&gt;&gt; torch.cat((x, x, x), 1)
tensor([[ 0.6580, -1.0969, -0.4614,  0.6580, -1.0969, -0.4614,  0.6580,
 -1.0969, -0.4614],
 [-0.1034, -0.5790,  0.1497, -0.1034, -0.5790,  0.1497, -0.1034,
 -0.5790,  0.1497]])

</code></pre>
<pre><code class="language-py">torch.chunk(tensor, chunks, dim=0) → List of Tensors
</code></pre>
<p>Splits a tensor into a specific number of chunks.</p>
<p>Last chunk will be smaller if the tensor size along the given dimension <code>dim</code> is not divisible by <code>chunks</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to split</li>
<li><strong>chunks</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of chunks to return</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – dimension along which to split the tensor</li>
</ul>
<pre><code class="language-py">torch.gather(input, dim, index, out=None) → Tensor
</code></pre>
<p>Gathers values along an axis specified by <code>dim</code>.</p>
<p>For a 3-D tensor the output is specified by:</p>
<pre><code class="language-py">out[i][j][k] = input[index[i][j][k]][j][k]  # if dim == 0
out[i][j][k] = input[i][index[i][j][k]][k]  # if dim == 1
out[i][j][k] = input[i][j][index[i][j][k]]  # if dim == 2

</code></pre>
<p>If <code>input</code> is an n-dimensional tensor with size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cc51a9d31af24562d403cf82e9e26cb9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cc51a9d31af24562d403cf82e9e26cb9.jpg" alt=""></a> and <code>dim = i</code>, then <code>index</code> must be an <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a>-dimensional tensor with size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ad1437dec91c9b5a9e20d1e044527a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ad1437dec91c9b5a9e20d1e044527a.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e03000f13271a1cd4b262e91f1e8f846.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e03000f13271a1cd4b262e91f1e8f846.jpg" alt=""></a> and <code>out</code> will have the same size as <code>index</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the source tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the axis along which to index</li>
<li><strong>index</strong> (<em>LongTensor</em>) – the indices of elements to gather</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the destination tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; t = torch.tensor([[1,2],[3,4]])
&gt;&gt;&gt; torch.gather(t, 1, torch.tensor([[0,0],[1,0]]))
tensor([[ 1,  1],
 [ 4,  3]])

</code></pre>
<pre><code class="language-py">torch.index_select(input, dim, index, out=None) → Tensor
</code></pre>
<p>Returns a new tensor which indexes the <code>input</code> tensor along dimension <code>dim</code> using the entries in <code>index</code> which is a <code>LongTensor</code>.</p>
<p>The returned tensor has the same number of dimensions as the original tensor (<code>input</code>). The <code>dim</code>th dimension has the same size as the length of <code>index</code>; other dimensions have the same size as in the original tensor.</p>
<p>Note</p>
<p>The returned tensor does <strong>not</strong> use the same storage as the original tensor. If <code>out</code> has a different shape than expected, we silently change it to the correct shape, reallocating the underlying storage if necessary.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension in which we index</li>
<li><strong>index</strong> (<em>LongTensor</em>) – the 1-D tensor containing the indices to index</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(3, 4)
&gt;&gt;&gt; x
tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],
 [-0.4664,  0.2647, -0.1228, -1.1068],
 [-1.1734, -0.6571,  0.7230, -0.6004]])
&gt;&gt;&gt; indices = torch.tensor([0, 2])
&gt;&gt;&gt; torch.index_select(x, 0, indices)
tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],
 [-1.1734, -0.6571,  0.7230, -0.6004]])
&gt;&gt;&gt; torch.index_select(x, 1, indices)
tensor([[ 0.1427, -0.5414],
 [-0.4664, -0.1228],
 [-1.1734,  0.7230]])

</code></pre>
<pre><code class="language-py">torch.masked_select(input, mask, out=None) → Tensor
</code></pre>
<p>Returns a new 1-D tensor which indexes the <code>input</code> tensor according to the binary mask <code>mask</code> which is a <code>ByteTensor</code>.</p>
<p>The shapes of the <code>mask</code> tensor and the <code>input</code> tensor don’t need to match, but they must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Note</p>
<p>The returned tensor does <strong>not</strong> use the same storage as the original tensor</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input data</li>
<li><strong>mask</strong> (<a href="tensors.html#torch.ByteTensor" title="torch.ByteTensor"><em>ByteTensor</em></a>) – the tensor containing the binary mask to index with</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(3, 4)
&gt;&gt;&gt; x
tensor([[ 0.3552, -2.3825, -0.8297,  0.3477],
 [-1.2035,  1.2252,  0.5002,  0.6248],
 [ 0.1307, -2.0608,  0.1244,  2.0139]])
&gt;&gt;&gt; mask = x.ge(0.5)
&gt;&gt;&gt; mask
tensor([[ 0,  0,  0,  0],
 [ 0,  1,  1,  1],
 [ 0,  0,  0,  1]], dtype=torch.uint8)
&gt;&gt;&gt; torch.masked_select(x, mask)
tensor([ 1.2252,  0.5002,  0.6248,  2.0139])

</code></pre>
<pre><code class="language-py">torch.narrow(input, dimension, start, length) → Tensor
</code></pre>
<p>Returns a new tensor that is a narrowed version of <code>input</code> tensor. The dimension <code>dim</code> is input from <code>start</code> to <code>start + length</code>. The returned tensor and <code>input</code> tensor share the same underlying storage.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to narrow</li>
<li><strong>dimension</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension along which to narrow</li>
<li><strong>start</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the starting dimension</li>
<li><strong>length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the distance to the ending dimension</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; torch.narrow(x, 0, 0, 2)
tensor([[ 1,  2,  3],
 [ 4,  5,  6]])
&gt;&gt;&gt; torch.narrow(x, 1, 1, 2)
tensor([[ 2,  3],
 [ 5,  6],
 [ 8,  9]])

</code></pre>
<pre><code class="language-py">torch.nonzero(input, out=None) → LongTensor
</code></pre>
<p>Returns a tensor containing the indices of all non-zero elements of <code>input</code>. Each row in the result contains the indices of a non-zero element in <code>input</code>.</p>
<p>If <code>input</code> has <code>n</code> dimensions, then the resulting indices tensor <code>out</code> is of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a6282f8c351e427a676fb9abf237e01f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a6282f8c351e427a676fb9abf237e01f.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d132b400654f0a1c0bf2cf921b391c8a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d132b400654f0a1c0bf2cf921b391c8a.jpg" alt=""></a> is the total number of non-zero elements in the <code>input</code> tensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<em>LongTensor</em>_,_ <em>optional</em>) – the output tensor containing indices</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.nonzero(torch.tensor([1, 1, 1, 0, 1]))
tensor([[ 0],
 [ 1],
 [ 2],
 [ 4]])
&gt;&gt;&gt; torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],
 [0.0, 0.4, 0.0, 0.0],
 [0.0, 0.0, 1.2, 0.0],
 [0.0, 0.0, 0.0,-0.4]]))
tensor([[ 0,  0],
 [ 1,  1],
 [ 2,  2],
 [ 3,  3]])

</code></pre>
<pre><code class="language-py">torch.reshape(input, shape) → Tensor
</code></pre>
<p>Returns a tensor with the same data and number of elements as <code>input</code>, but with the specified shape. When possible, the returned tensor will be a view of <code>input</code>. Otherwise, it will be a copy. Contiguous inputs and inputs with compatible strides can be reshaped without copying, but you should not depend on the copying vs. viewing behavior.</p>
<p>See <a href="tensors.html#torch.Tensor.view" title="torch.Tensor.view"><code>torch.Tensor.view()</code></a> on when it is possible to return a view.</p>
<p>A single dimension may be -1, in which case it’s inferred from the remaining dimensions and the number of elements in <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to be reshaped</li>
<li><strong>shape</strong> (<em>tuple of python:ints</em>) – the new shape</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.arange(4.)
&gt;&gt;&gt; torch.reshape(a, (2, 2))
tensor([[ 0.,  1.],
 [ 2.,  3.]])
&gt;&gt;&gt; b = torch.tensor([[0, 1], [2, 3]])
&gt;&gt;&gt; torch.reshape(b, (-1,))
tensor([ 0,  1,  2,  3])

</code></pre>
<pre><code class="language-py">torch.split(tensor, split_size_or_sections, dim=0)
</code></pre>
<p>Splits the tensor into chunks.</p>
<p>If <code>split_size_or_sections</code> is an integer type, then <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a> will be split into equally sized chunks (if possible). Last chunk will be smaller if the tensor size along the given dimension <code>dim</code> is not divisible by <code>split_size</code>.</p>
<p>If <code>split_size_or_sections</code> is a list, then <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a> will be split into <code>len(split_size_or_sections)</code> chunks with sizes in <code>dim</code> according to <code>split_size_or_sections</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – tensor to split.</li>
<li><strong>split_size_or_sections</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>) or</em> <em>(</em><a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a><em>(</em><a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>)</em>) – size of a single chunk or list of sizes for each chunk</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – dimension along which to split the tensor.</li>
</ul>
<pre><code class="language-py">torch.squeeze(input, dim=None, out=None) → Tensor
</code></pre>
<p>Returns a tensor with all the dimensions of <code>input</code> of size <code>1</code> removed.</p>
<p>For example, if <code>input</code> is of shape: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e798b9a45934bd0742372a7daf0d72a4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e798b9a45934bd0742372a7daf0d72a4.jpg" alt=""></a> then the <code>out</code> tensor will be of shape: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ebcff51adfcadbe79dc480e6924d59b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ebcff51adfcadbe79dc480e6924d59b.jpg" alt=""></a>.</p>
<p>When <code>dim</code> is given, a squeeze operation is done only in the given dimension. If <code>input</code> is of shape: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/86382e0be02bdfa9046461356e835f6a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/86382e0be02bdfa9046461356e835f6a.jpg" alt=""></a>, <code>squeeze(input, 0)</code> leaves the tensor unchanged, but <code>squeeze(input, 1)</code> will squeeze the tensor to the shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8f06e0620721d3fc0d796a659d8ecf03.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8f06e0620721d3fc0d796a659d8ecf03.jpg" alt=""></a>.</p>
<p>Note</p>
<p>The returned tensor shares the storage with the input tensor, so changing the contents of one will change the contents of the other.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – if given, the input will be squeezed only in this dimension</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.zeros(2, 1, 2, 1, 2)
&gt;&gt;&gt; x.size()
torch.Size([2, 1, 2, 1, 2])
&gt;&gt;&gt; y = torch.squeeze(x)
&gt;&gt;&gt; y.size()
torch.Size([2, 2, 2])
&gt;&gt;&gt; y = torch.squeeze(x, 0)
&gt;&gt;&gt; y.size()
torch.Size([2, 1, 2, 1, 2])
&gt;&gt;&gt; y = torch.squeeze(x, 1)
&gt;&gt;&gt; y.size()
torch.Size([2, 2, 1, 2])

</code></pre>
<pre><code class="language-py">torch.stack(seq, dim=0, out=None) → Tensor
</code></pre>
<p>Concatenates sequence of tensors along a new dimension.</p>
<p>All tensors need to be of the same size.</p>
<p>Parameters:</p>
<ul>
<li><strong>seq</strong> (<em>sequence of Tensors</em>) – sequence of tensors to concatenate</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – dimension to insert. Has to be between 0 and the number of dimensions of concatenated tensors (inclusive)</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<pre><code class="language-py">torch.t(input) → Tensor
</code></pre>
<p>Expects <code>input</code> to be a matrix (2-D tensor) and transposes dimensions 0 and 1.</p>
<p>Can be seen as a short-hand function for <code>transpose(input, 0, 1)</code>.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(2, 3)
&gt;&gt;&gt; x
tensor([[ 0.4875,  0.9158, -0.5872],
 [ 0.3938, -0.6929,  0.6932]])
&gt;&gt;&gt; torch.t(x)
tensor([[ 0.4875,  0.3938],
 [ 0.9158, -0.6929],
 [-0.5872,  0.6932]])

</code></pre>
<pre><code class="language-py">torch.take(input, indices) → Tensor
</code></pre>
<p>Returns a new tensor with the elements of <code>input</code> at the given indices. The input tensor is treated as if it were viewed as a 1-D tensor. The result takes the same shape as the indices.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>indices</strong> (<em>LongTensor</em>) – the indices into tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; src = torch.tensor([[4, 3, 5],
 [6, 7, 8]])
&gt;&gt;&gt; torch.take(src, torch.tensor([0, 2, 5]))
tensor([ 4,  5,  8])

</code></pre>
<pre><code class="language-py">torch.transpose(input, dim0, dim1) → Tensor
</code></pre>
<p>Returns a tensor that is a transposed version of <code>input</code>. The given dimensions <code>dim0</code> and <code>dim1</code> are swapped.</p>
<p>The resulting <code>out</code> tensor shares it’s underlying storage with the <code>input</code> tensor, so changing the content of one would change the content of the other.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim0</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the first dimension to be transposed</li>
<li><strong>dim1</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the second dimension to be transposed</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(2, 3)
&gt;&gt;&gt; x
tensor([[ 1.0028, -0.9893,  0.5809],
 [-0.1669,  0.7299,  0.4942]])
&gt;&gt;&gt; torch.transpose(x, 0, 1)
tensor([[ 1.0028, -0.1669],
 [-0.9893,  0.7299],
 [ 0.5809,  0.4942]])

</code></pre>
<pre><code class="language-py">torch.unbind(tensor, dim=0) → seq
</code></pre>
<p>Removes a tensor dimension.</p>
<p>Returns a tuple of all slices along a given dimension, already without it.</p>
<p>Parameters:</p>
<ul>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to unbind</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – dimension to remove</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.unbind(torch.tensor([[1, 2, 3],
&gt;&gt;&gt;                            [4, 5, 6],
&gt;&gt;&gt;                            [7, 8, 9]]))
(tensor([1, 2, 3]), tensor([4, 5, 6]), tensor([7, 8, 9]))

</code></pre>
<pre><code class="language-py">torch.unsqueeze(input, dim, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with a dimension of size one inserted at the specified position.</p>
<p>The returned tensor shares the same underlying data with this tensor.</p>
<p>A <code>dim</code> value within the range <code>[-input.dim() - 1, input.dim() + 1)</code> can be used. Negative <code>dim</code> will correspond to <a href="#torch.unsqueeze" title="torch.unsqueeze"><code>unsqueeze()</code></a> applied at <code>dim</code> = <code>dim + input.dim() + 1</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the index at which to insert the singleton dimension</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.tensor([1, 2, 3, 4])
&gt;&gt;&gt; torch.unsqueeze(x, 0)
tensor([[ 1,  2,  3,  4]])
&gt;&gt;&gt; torch.unsqueeze(x, 1)
tensor([[ 1],
 [ 2],
 [ 3],
 [ 4]])

</code></pre>
<pre><code class="language-py">torch.where(condition, x, y) → Tensor
</code></pre>
<p>Return a tensor of elements selected from either <code>x</code> or <code>y</code>, depending on <code>condition</code>.</p>
<p>The operation is defined as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/731cf2092e0addecd6cde7e99f46763f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/731cf2092e0addecd6cde7e99f46763f.jpg" alt=""></a></p>
<p>Note</p>
<p>The tensors <code>condition</code>, <code>x</code>, <code>y</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>condition</strong> (<a href="tensors.html#torch.ByteTensor" title="torch.ByteTensor"><em>ByteTensor</em></a>) – When True (nonzero), yield x, otherwise yield y</li>
<li><strong>x</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – values selected at indices where <code>condition</code> is <code>True</code></li>
<li><strong>y</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – values selected at indices where <code>condition</code> is <code>False</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tensor of shape equal to the broadcasted shape of <code>condition</code>, <code>x</code>, <code>y</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(3, 2)
&gt;&gt;&gt; y = torch.ones(3, 2)
&gt;&gt;&gt; x
tensor([[-0.4620,  0.3139],
 [ 0.3898, -0.7197],
 [ 0.0478, -0.1657]])
&gt;&gt;&gt; torch.where(x &gt; 0, x, y)
tensor([[ 1.0000,  0.3139],
 [ 0.3898,  1.0000],
 [ 0.0478,  1.0000]])

</code></pre>
<h2 id="random-sampling">Random sampling</h2>
<pre><code class="language-py">torch.manual_seed(seed)
</code></pre>
<p>Sets the seed for generating random numbers. Returns a <code>torch._C.Generator</code> object.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>seed</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The desired seed.</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">torch.initial_seed()
</code></pre>
<p>Returns the initial seed for generating random numbers as a Python <code>long</code>.</p>
<pre><code class="language-py">torch.get_rng_state()
</code></pre>
<p>Returns the random number generator state as a <code>torch.ByteTensor</code>.</p>
<pre><code class="language-py">torch.set_rng_state(new_state)
</code></pre>
<p>Sets the random number generator state.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>new_state</strong> (<a href="tensors.html#torch.ByteTensor" title="torch.ByteTensor"><em>torch.ByteTensor</em></a>) – The desired state</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">torch.default_generator = &lt;torch._C.Generator object&gt;
</code></pre>
<pre><code class="language-py">torch.bernoulli(input, *, generator=None, out=None) → Tensor
</code></pre>
<p>Draws binary random numbers (0 or 1) from a Bernoulli distribution.</p>
<p>The <code>input</code> tensor should be a tensor containing probabilities to be used for drawing the binary random number. Hence, all values in <code>input</code> have to be in the range: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1ac351f229015d1047c7d979a9233916.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1ac351f229015d1047c7d979a9233916.jpg" alt=""></a>.</p>
<p>The <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/511f5a204e4e69e0f1c374e9a5738214.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/511f5a204e4e69e0f1c374e9a5738214.jpg" alt=""></a> element of the output tensor will draw a value <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" alt=""></a> according to the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/511f5a204e4e69e0f1c374e9a5738214.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/511f5a204e4e69e0f1c374e9a5738214.jpg" alt=""></a> probability value given in <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b3f6cd5a237f587278432aa96dd0fd96.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b3f6cd5a237f587278432aa96dd0fd96.jpg" alt=""></a></p>
<p>The returned <code>out</code> tensor only has values 0 or 1 and is of the same shape as <code>input</code>.</p>
<p><code>out</code> can have integral <code>dtype</code>, but :attr<code>input</code> must have floating point <code>dtype</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor of probability values for the Bernoulli distribution</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.empty(3, 3).uniform_(0, 1)  # generate a uniform random matrix with range [0, 1]
&gt;&gt;&gt; a
tensor([[ 0.1737,  0.0950,  0.3609],
 [ 0.7148,  0.0289,  0.2676],
 [ 0.9456,  0.8937,  0.7202]])
&gt;&gt;&gt; torch.bernoulli(a)
tensor([[ 1.,  0.,  0.],
 [ 0.,  0.,  0.],
 [ 1.,  1.,  1.]])

&gt;&gt;&gt; a = torch.ones(3, 3) # probability of drawing "1" is 1
&gt;&gt;&gt; torch.bernoulli(a)
tensor([[ 1.,  1.,  1.],
 [ 1.,  1.,  1.],
 [ 1.,  1.,  1.]])
&gt;&gt;&gt; a = torch.zeros(3, 3) # probability of drawing "1" is 0
&gt;&gt;&gt; torch.bernoulli(a)
tensor([[ 0.,  0.,  0.],
 [ 0.,  0.,  0.],
 [ 0.,  0.,  0.]])

</code></pre>
<pre><code class="language-py">torch.multinomial(input, num_samples, replacement=False, out=None) → LongTensor
</code></pre>
<p>Returns a tensor where each row contains <code>num_samples</code> indices sampled from the multinomial probability distribution located in the corresponding row of tensor <code>input</code>.</p>
<p>Note</p>
<p>The rows of <code>input</code> do not need to sum to one (in which case we use the values as weights), but must be non-negative, finite and have a non-zero sum.</p>
<p>Indices are ordered from left to right according to when each was sampled (first samples are placed in first column).</p>
<p>If <code>input</code> is a vector, <code>out</code> is a vector of size <code>num_samples</code>.</p>
<p>If <code>input</code> is a matrix with <code>m</code> rows, <code>out</code> is an matrix of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c52c825df9f5a9934f74be6777337b15.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c52c825df9f5a9934f74be6777337b15.jpg" alt=""></a>.</p>
<p>If replacement is <code>True</code>, samples are drawn with replacement.</p>
<p>If not, they are drawn without replacement, which means that when a sample index is drawn for a row, it cannot be drawn again for that row.</p>
<p>This implies the constraint that <code>num_samples</code> must be lower than <code>input</code> length (or number of columns of <code>input</code> if it is a matrix).</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor containing probabilities</li>
<li><strong>num_samples</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of samples to draw</li>
<li><strong>replacement</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether to draw with replacement or not</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; weights = torch.tensor([0, 10, 3, 0], dtype=torch.float) # create a tensor of weights
&gt;&gt;&gt; torch.multinomial(weights, 4)
tensor([ 1,  2,  0,  0])
&gt;&gt;&gt; torch.multinomial(weights, 4, replacement=True)
tensor([ 2,  1,  1,  1])

</code></pre>
<pre><code class="language-py">torch.normal()
</code></pre>
<pre><code class="language-py">torch.normal(mean, std, out=None) → Tensor
</code></pre>
<p>Returns a tensor of random numbers drawn from separate normal distributions whose mean and standard deviation are given.</p>
<p>The <a href="#torch.mean" title="torch.mean"><code>mean</code></a> is a tensor with the mean of each output element’s normal distribution</p>
<p>The <a href="#torch.std" title="torch.std"><code>std</code></a> is a tensor with the standard deviation of each output element’s normal distribution</p>
<p>The shapes of <a href="#torch.mean" title="torch.mean"><code>mean</code></a> and <a href="#torch.std" title="torch.std"><code>std</code></a> don’t need to match, but the total number of elements in each tensor need to be the same.</p>
<p>Note</p>
<p>When the shapes do not match, the shape of <a href="#torch.mean" title="torch.mean"><code>mean</code></a> is used as the shape for the returned output tensor</p>
<p>Parameters:</p>
<ul>
<li><strong>mean</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor of per-element means</li>
<li><strong>std</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor of per-element standard deviations</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.normal(mean=torch.arange(1., 11.), std=torch.arange(1, 0, -0.1))
tensor([  1.0425,   3.5672,   2.7969,   4.2925,   4.7229,   6.2134,
 8.0505,   8.1408,   9.0563,  10.0566])

</code></pre>
<pre><code class="language-py">torch.normal(mean=0.0, std, out=None) → Tensor
</code></pre>
<p>Similar to the function above, but the means are shared among all drawn elements.</p>
<p>Parameters:</p>
<ul>
<li><strong>mean</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – the mean for all distributions</li>
<li><strong>std</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor of per-element standard deviations</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.normal(mean=0.5, std=torch.arange(1., 6.))
tensor([-1.2793, -1.0732, -2.0687,  5.1177, -1.2303])

</code></pre>
<pre><code class="language-py">torch.normal(mean, std=1.0, out=None) → Tensor
</code></pre>
<p>Similar to the function above, but the standard-deviations are shared among all drawn elements.</p>
<p>Parameters:</p>
<ul>
<li><strong>mean</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor of per-element means</li>
<li><strong>std</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – the standard deviation for all distributions</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.normal(mean=torch.arange(1., 6.))
tensor([ 1.1552,  2.6148,  2.6535,  5.8318,  4.2361])

</code></pre>
<pre><code class="language-py">torch.rand(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with random numbers from a uniform distribution on the interval <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a686b817a52173e9e124e756a19344be.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a686b817a52173e9e124e756a19344be.jpg" alt=""></a></p>
<p>The shape of the tensor is defined by the variable argument <code>sizes</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>sizes</strong> (<em>int...</em>) – a sequence of integers defining the shape of the output tensor. Can be a variable number of arguments or a collection like a list or tuple.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.rand(4)
tensor([ 0.5204,  0.2503,  0.3525,  0.5673])
&gt;&gt;&gt; torch.rand(2, 3)
tensor([[ 0.8237,  0.5781,  0.6879],
 [ 0.3816,  0.7249,  0.0998]])

</code></pre>
<pre><code class="language-py">torch.rand_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor with the same size as <code>input</code> that is filled with random numbers from a uniform distribution on the interval <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a686b817a52173e9e124e756a19344be.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a686b817a52173e9e124e756a19344be.jpg" alt=""></a>. <code>torch.rand_like(input)</code> is equivalent to <code>torch.rand(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the size of <code>input</code> will determine size of the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned Tensor. Default: if <code>None</code>, defaults to the dtype of <code>input</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned tensor. Default: if <code>None</code>, defaults to the layout of <code>input</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, defaults to the device of <code>input</code>.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<pre><code class="language-py">torch.randint(low=0, high, size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with random integers generated uniformly between <code>low</code> (inclusive) and <code>high</code> (exclusive).</p>
<p>The shape of the tensor is defined by the variable argument <code>size</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>low</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Lowest integer to be drawn from the distribution. Default: 0.</li>
<li><strong>high</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – One above the highest integer to be drawn from the distribution.</li>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – a tuple defining the shape of the output tensor.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.randint(3, 5, (3,))
tensor([4, 3, 4])

&gt;&gt;&gt; torch.randint(10, (2, 2))
tensor([[0, 2],
 [5, 5]])

&gt;&gt;&gt; torch.randint(3, 10, (2, 2))
tensor([[4, 5],
 [6, 7]])

</code></pre>
<pre><code class="language-py">torch.randint_like(input, low=0, high, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor with the same shape as Tensor <code>input</code> filled with random integers generated uniformly between <code>low</code> (inclusive) and <code>high</code> (exclusive).</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the size of <code>input</code> will determine size of the output tensor</li>
<li><strong>low</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Lowest integer to be drawn from the distribution. Default: 0.</li>
<li><strong>high</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – One above the highest integer to be drawn from the distribution.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned Tensor. Default: if <code>None</code>, defaults to the dtype of <code>input</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned tensor. Default: if <code>None</code>, defaults to the layout of <code>input</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, defaults to the device of <code>input</code>.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<pre><code class="language-py">torch.randn(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor filled with random numbers from a normal distribution with mean <code>0</code> and variance <code>1</code> (also called the standard normal distribution).</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/71f756d003530899b04dfd92986cea2f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/71f756d003530899b04dfd92986cea2f.jpg" alt=""></a></p>
<p>The shape of the tensor is defined by the variable argument <code>sizes</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>sizes</strong> (<em>int...</em>) – a sequence of integers defining the shape of the output tensor. Can be a variable number of arguments or a collection like a list or tuple.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.randn(4)
tensor([-2.1436,  0.9966,  2.3426, -0.6366])
&gt;&gt;&gt; torch.randn(2, 3)
tensor([[ 1.5954,  2.8929, -1.0923],
 [ 1.1719, -0.4709, -0.1996]])

</code></pre>
<pre><code class="language-py">torch.randn_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Returns a tensor with the same size as <code>input</code> that is filled with random numbers from a normal distribution with mean 0 and variance 1. <code>torch.randn_like(input)</code> is equivalent to <code>torch.randn(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the size of <code>input</code> will determine size of the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned Tensor. Default: if <code>None</code>, defaults to the dtype of <code>input</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned tensor. Default: if <code>None</code>, defaults to the layout of <code>input</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, defaults to the device of <code>input</code>.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<pre><code class="language-py">torch.randperm(n, out=None, dtype=torch.int64, layout=torch.strided, device=None, requires_grad=False) → LongTensor
</code></pre>
<p>Returns a random permutation of integers from <code>0</code> to <code>n - 1</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>n</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the upper bound (exclusive)</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: <code>torch.int64</code>.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.randperm(4)
tensor([2, 1, 0, 3])

</code></pre>
<h3 id="in-place-random-sampling">In-place random sampling</h3>
<p>There are a few more in-place random sampling functions defined on Tensors as well. Click through to refer to their documentation:</p>
<ul>
<li><a href="tensors.html#torch.Tensor.bernoulli_" title="torch.Tensor.bernoulli_"><code>torch.Tensor.bernoulli_()</code></a> - in-place version of <a href="#torch.bernoulli" title="torch.bernoulli"><code>torch.bernoulli()</code></a></li>
<li><a href="tensors.html#torch.Tensor.cauchy_" title="torch.Tensor.cauchy_"><code>torch.Tensor.cauchy_()</code></a> - numbers drawn from the Cauchy distribution</li>
<li><a href="tensors.html#torch.Tensor.exponential_" title="torch.Tensor.exponential_"><code>torch.Tensor.exponential_()</code></a> - numbers drawn from the exponential distribution</li>
<li><a href="tensors.html#torch.Tensor.geometric_" title="torch.Tensor.geometric_"><code>torch.Tensor.geometric_()</code></a> - elements drawn from the geometric distribution</li>
<li><a href="tensors.html#torch.Tensor.log_normal_" title="torch.Tensor.log_normal_"><code>torch.Tensor.log_normal_()</code></a> - samples from the log-normal distribution</li>
<li><a href="tensors.html#torch.Tensor.normal_" title="torch.Tensor.normal_"><code>torch.Tensor.normal_()</code></a> - in-place version of <a href="#torch.normal" title="torch.normal"><code>torch.normal()</code></a></li>
<li><a href="tensors.html#torch.Tensor.random_" title="torch.Tensor.random_"><code>torch.Tensor.random_()</code></a> - numbers sampled from the discrete uniform distribution</li>
<li><a href="tensors.html#torch.Tensor.uniform_" title="torch.Tensor.uniform_"><code>torch.Tensor.uniform_()</code></a> - numbers sampled from the continuous uniform distribution</li>
</ul>
<h2 id="serialization">Serialization</h2>
<pre><code class="language-py">torch.save(obj, f, pickle_module=&lt;module 'pickle' from '/scratch/rzou/pt/release-env/lib/python3.7/pickle.py'&gt;, pickle_protocol=2)
</code></pre>
<p>Saves an object to a disk file.</p>
<p>See also: <a href="notes/serialization.html#recommend-saving-models">Recommended approach for saving a model</a></p>
<p>Parameters:</p>
<ul>
<li><strong>obj</strong> – saved object</li>
<li><strong>f</strong> – a file-like object (has to implement write and flush) or a string containing a file name</li>
<li><strong>pickle_module</strong> – module used for pickling metadata and objects</li>
<li><strong>pickle_protocol</strong> – can be specified to override the default protocol</li>
</ul>
<p>Warning</p>
<p>If you are using Python 2, torch.save does NOT support StringIO.StringIO as a valid file-like object. This is because the write method should return the number of bytes written; StringIO.write() does not do this.</p>
<p>Please use something like io.BytesIO instead.</p>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; # Save to file
&gt;&gt;&gt; x = torch.tensor([0, 1, 2, 3, 4])
&gt;&gt;&gt; torch.save(x, 'tensor.pt')
&gt;&gt;&gt; # Save to io.BytesIO buffer
&gt;&gt;&gt; buffer = io.BytesIO()
&gt;&gt;&gt; torch.save(x, buffer)

</code></pre>
<pre><code class="language-py">torch.load(f, map_location=None, pickle_module=&lt;module 'pickle' from '/scratch/rzou/pt/release-env/lib/python3.7/pickle.py'&gt;)
</code></pre>
<p>Loads an object saved with <a href="#torch.save" title="torch.save"><code>torch.save()</code></a> from a file.</p>
<p><a href="#torch.load" title="torch.load"><code>torch.load()</code></a> uses Python’s unpickling facilities but treats storages, which underlie tensors, specially. They are first deserialized on the CPU and are then moved to the device they were saved from. If this fails (e.g. because the run time system doesn’t have certain devices), an exception is raised. However, storages can be dynamically remapped to an alternative set of devices using the <code>map_location</code> argument.</p>
<p>If <code>map_location</code> is a callable, it will be called once for each serialized storage with two arguments: storage and location. The storage argument will be the initial deserialization of the storage, residing on the CPU. Each serialized storage has a location tag associated with it which identifies the device it was saved from, and this tag is the second argument passed to map_location. The builtin location tags are <code>‘cpu’</code> for CPU tensors and <code>‘cuda:device_id’</code> (e.g. <code>‘cuda:2’</code>) for CUDA tensors. <code>map_location</code> should return either None or a storage. If <code>map_location</code> returns a storage, it will be used as the final deserialized object, already moved to the right device. Otherwise, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b69f1ef0735e18ff4ee132790112ce0d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b69f1ef0735e18ff4ee132790112ce0d.jpg" alt=""></a> will fall back to the default behavior, as if <code>map_location</code> wasn’t specified.</p>
<p>If <code>map_location</code> is a string, it should be a device tag, where all tensors should be loaded.</p>
<p>Otherwise, if <code>map_location</code> is a dict, it will be used to remap location tags appearing in the file (keys), to ones that specify where to put the storages (values).</p>
<p>User extensions can register their own location tags and tagging and deserialization methods using <code>register_package</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>f</strong> – a file-like object (has to implement read, readline, tell, and seek), or a string containing a file name</li>
<li><strong>map_location</strong> – a function, torch.device, string or a dict specifying how to remap storage locations</li>
<li><strong>pickle_module</strong> – module used for unpickling metadata and objects (has to match the pickle_module used to serialize file)</li>
</ul>
<p>Note</p>
<p>When you call <a href="#torch.load" title="torch.load"><code>torch.load()</code></a> on a file which contains GPU tensors, those tensors will be loaded to GPU by default. You can call <code>torch.load(.., map_location=’cpu’)</code> and then <code>load_state_dict()</code> to avoid GPU RAM surge when loading a model checkpoint.</p>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.load('tensors.pt')
# Load all tensors onto the CPU
&gt;&gt;&gt; torch.load('tensors.pt', map_location=torch.device('cpu'))
# Load all tensors onto the CPU, using a function
&gt;&gt;&gt; torch.load('tensors.pt', map_location=lambda storage, loc: storage)
# Load all tensors onto GPU 1
&gt;&gt;&gt; torch.load('tensors.pt', map_location=lambda storage, loc: storage.cuda(1))
# Map tensors from GPU 1 to GPU 0
&gt;&gt;&gt; torch.load('tensors.pt', map_location={'cuda:1':'cuda:0'})
# Load tensor from io.BytesIO object
&gt;&gt;&gt; with open('tensor.pt') as f:
 buffer = io.BytesIO(f.read())
&gt;&gt;&gt; torch.load(buffer)

</code></pre>
<h2 id="parallelism">Parallelism</h2>
<pre><code class="language-py">torch.get_num_threads() → int
</code></pre>
<p>Gets the number of OpenMP threads used for parallelizing CPU operations</p>
<pre><code class="language-py">torch.set_num_threads(int)
</code></pre>
<p>Sets the number of OpenMP threads used for parallelizing CPU operations</p>
<h2 id="locally-disabling-gradient-computation">Locally disabling gradient computation</h2>
<p>The context managers <code>torch.no_grad()</code>, <code>torch.enable_grad()</code>, and <code>torch.set_grad_enabled()</code> are helpful for locally disabling and enabling gradient computation. See <a href="autograd.html#locally-disable-grad">Locally disabling gradient computation</a> for more details on their usage.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.zeros(1, requires_grad=True)
&gt;&gt;&gt; with torch.no_grad():
...     y = x * 2
&gt;&gt;&gt; y.requires_grad
False

&gt;&gt;&gt; is_train = False
&gt;&gt;&gt; with torch.set_grad_enabled(is_train):
...     y = x * 2
&gt;&gt;&gt; y.requires_grad
False

&gt;&gt;&gt; torch.set_grad_enabled(True)  # this can also be used as a function
&gt;&gt;&gt; y = x * 2
&gt;&gt;&gt; y.requires_grad
True

&gt;&gt;&gt; torch.set_grad_enabled(False)
&gt;&gt;&gt; y = x * 2
&gt;&gt;&gt; y.requires_grad
False

</code></pre>
<h2 id="math-operations">Math operations</h2>
<h3 id="pointwise-ops">Pointwise Ops</h3>
<pre><code class="language-py">torch.abs(input, out=None) → Tensor
</code></pre>
<p>Computes the element-wise absolute value of the given <code>input</code> tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1a4bcc75ec995f7b04a37cccd88b214b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1a4bcc75ec995f7b04a37cccd88b214b.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.abs(torch.tensor([-1, -2, 3]))
tensor([ 1,  2,  3])

</code></pre>
<pre><code class="language-py">torch.acos(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the arccosine of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3533abc4adcb633e8fb0bfc683c437bb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3533abc4adcb633e8fb0bfc683c437bb.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.3348, -0.5889,  0.2005, -0.1584])
&gt;&gt;&gt; torch.acos(a)
tensor([ 1.2294,  2.2004,  1.3690,  1.7298])

</code></pre>
<pre><code class="language-py">torch.add()
</code></pre>
<pre><code class="language-py">torch.add(input, value, out=None)
</code></pre>
<p>Adds the scalar <code>value</code> to each element of the input <code>input</code> and returns a new resulting tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76a7103f78e0443c4ad36bbf203db638.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/76a7103f78e0443c4ad36bbf203db638.jpg" alt=""></a></p>
<p>If <code>input</code> is of type FloatTensor or DoubleTensor, <code>value</code> must be a real number, otherwise it should be an integer.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>value</strong> (<em>Number</em>) – the number to be added to each element of <code>input</code></li>
</ul>
<table>
<thead>
<tr>
<th>Keyword Arguments:</th>
</tr>
</thead>
<tbody>
<tr>
<td>&nbsp;</td>
<td><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.0202,  1.0985,  1.3506, -0.6056])
&gt;&gt;&gt; torch.add(a, 20)
tensor([ 20.0202,  21.0985,  21.3506,  19.3944])

</code></pre>
<pre><code class="language-py">torch.add(input, value=1, other, out=None)
</code></pre>
<p>Each element of the tensor <code>other</code> is multiplied by the scalar <code>value</code> and added to each element of the tensor <code>input</code>. The resulting tensor is returned.</p>
<p>The shapes of <code>input</code> and <code>other</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bc929133d25d93686f6106f171de0de3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bc929133d25d93686f6106f171de0de3.jpg" alt=""></a></p>
<p>If <code>other</code> is of type FloatTensor or DoubleTensor, <code>value</code> must be a real number, otherwise it should be an integer.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first input tensor</li>
<li><strong>value</strong> (<em>Number</em>) – the scalar multiplier for <code>other</code></li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second input tensor</li>
</ul>
<table>
<thead>
<tr>
<th>Keyword Arguments:</th>
</tr>
</thead>
<tbody>
<tr>
<td>&nbsp;</td>
<td><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.9732, -0.3497,  0.6245,  0.4022])
&gt;&gt;&gt; b = torch.randn(4, 1)
&gt;&gt;&gt; b
tensor([[ 0.3743],
 [-1.7724],
 [-0.5811],
 [-0.8017]])
&gt;&gt;&gt; torch.add(a, 10, b)
tensor([[  2.7695,   3.3930,   4.3672,   4.1450],
 [-18.6971, -18.0736, -17.0994, -17.3216],
 [ -6.7845,  -6.1610,  -5.1868,  -5.4090],
 [ -8.9902,  -8.3667,  -7.3925,  -7.6147]])

</code></pre>
<pre><code class="language-py">torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None) → Tensor
</code></pre>
<p>Performs the element-wise division of <code>tensor1</code> by <code>tensor2</code>, multiply the result by the scalar <code>value</code> and add it to <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e6bfafde43b0e449b24255b208acc8e0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e6bfafde43b0e449b24255b208acc8e0.jpg" alt=""></a></p>
<p>The shapes of <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a>, <code>tensor1</code>, and <code>tensor2</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>For inputs of type <code>FloatTensor</code> or <code>DoubleTensor</code>, <code>value</code> must be a real number, otherwise an integer.</p>
<p>Parameters:</p>
<ul>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to be added</li>
<li><strong>value</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1b168c1663790fbd38202af8bfea37bc.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1b168c1663790fbd38202af8bfea37bc.jpg" alt=""></a></li>
<li><strong>tensor1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the numerator tensor</li>
<li><strong>tensor2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the denominator tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; t = torch.randn(1, 3)
&gt;&gt;&gt; t1 = torch.randn(3, 1)
&gt;&gt;&gt; t2 = torch.randn(1, 3)
&gt;&gt;&gt; torch.addcdiv(t, 0.1, t1, t2)
tensor([[-0.2312, -3.6496,  0.1312],
 [-1.0428,  3.4292, -0.1030],
 [-0.5369, -0.9829,  0.0430]])

</code></pre>
<pre><code class="language-py">torch.addcmul(tensor, value=1, tensor1, tensor2, out=None) → Tensor
</code></pre>
<p>Performs the element-wise multiplication of <code>tensor1</code> by <code>tensor2</code>, multiply the result by the scalar <code>value</code> and add it to <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ab575ca50c2fce8e335280dff71f26b0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ab575ca50c2fce8e335280dff71f26b0.jpg" alt=""></a></p>
<p>The shapes of <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a>, <code>tensor1</code>, and <code>tensor2</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>For inputs of type <code>FloatTensor</code> or <code>DoubleTensor</code>, <code>value</code> must be a real number, otherwise an integer.</p>
<p>Parameters:</p>
<ul>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to be added</li>
<li><strong>value</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b345d1a46cebf2308e450926de3195ef.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b345d1a46cebf2308e450926de3195ef.jpg" alt=""></a></li>
<li><strong>tensor1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to be multiplied</li>
<li><strong>tensor2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; t = torch.randn(1, 3)
&gt;&gt;&gt; t1 = torch.randn(3, 1)
&gt;&gt;&gt; t2 = torch.randn(1, 3)
&gt;&gt;&gt; torch.addcmul(t, 0.1, t1, t2)
tensor([[-0.8635, -0.6391,  1.6174],
 [-0.7617, -0.5879,  1.7388],
 [-0.8353, -0.6249,  1.6511]])

</code></pre>
<pre><code class="language-py">torch.asin(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the arcsine of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb9c70310a0ed5b865beb34bc1e28a99.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eb9c70310a0ed5b865beb34bc1e28a99.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.5962,  1.4985, -0.4396,  1.4525])
&gt;&gt;&gt; torch.asin(a)
tensor([-0.6387,     nan, -0.4552,     nan])

</code></pre>
<pre><code class="language-py">torch.atan(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the arctangent of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cd3367165f341b3ab7dd3ee6dcfbb92c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cd3367165f341b3ab7dd3ee6dcfbb92c.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.2341,  0.2539, -0.6256, -0.6448])
&gt;&gt;&gt; torch.atan(a)
tensor([ 0.2299,  0.2487, -0.5591, -0.5727])

</code></pre>
<pre><code class="language-py">torch.atan2(input1, input2, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the arctangent of the elements of <code>input1</code> and <code>input2</code>.</p>
<p>The shapes of <code>input1</code> and <code>input2</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first input tensor</li>
<li><strong>input2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.9041,  0.0196, -0.3108, -2.4423])
&gt;&gt;&gt; torch.atan2(a, torch.randn(4))
tensor([ 0.9833,  0.0811, -1.9743, -1.4151])

</code></pre>
<pre><code class="language-py">torch.ceil(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the ceil of the elements of <code>input</code>, the smallest integer greater than or equal to each element.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efa1e00e060e0787c8b7ea48fe74745d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efa1e00e060e0787c8b7ea48fe74745d.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.6341, -1.4208, -1.0900,  0.5826])
&gt;&gt;&gt; torch.ceil(a)
tensor([-0., -1., -1.,  1.])

</code></pre>
<pre><code class="language-py">torch.clamp(input, min, max, out=None) → Tensor
</code></pre>
<p>Clamp all elements in <code>input</code> into the range <code>[</code> <a href="#torch.min" title="torch.min"><code>min</code></a>, <a href="#torch.max" title="torch.max"><code>max</code></a> <code>]</code> and return a resulting tensor:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a116639ce05e419a65971fdffeaa2d81.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a116639ce05e419a65971fdffeaa2d81.jpg" alt=""></a></p>
<p>If <code>input</code> is of type <code>FloatTensor</code> or <code>DoubleTensor</code>, args <a href="#torch.min" title="torch.min"><code>min</code></a> and <a href="#torch.max" title="torch.max"><code>max</code></a> must be real numbers, otherwise they should be integers.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>min</strong> (<em>Number</em>) – lower-bound of the range to be clamped to</li>
<li><strong>max</strong> (<em>Number</em>) – upper-bound of the range to be clamped to</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-1.7120,  0.1734, -0.0478, -0.0922])
&gt;&gt;&gt; torch.clamp(a, min=-0.5, max=0.5)
tensor([-0.5000,  0.1734, -0.0478, -0.0922])

</code></pre>
<pre><code class="language-py">torch.clamp(input, *, min, out=None) → Tensor
</code></pre>
<p>Clamps all elements in <code>input</code> to be larger or equal <a href="#torch.min" title="torch.min"><code>min</code></a>.</p>
<p>If <code>input</code> is of type <code>FloatTensor</code> or <code>DoubleTensor</code>, <code>value</code> should be a real number, otherwise it should be an integer.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>value</strong> (<em>Number</em>) – minimal value of each element in the output</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.0299, -2.3184,  2.1593, -0.8883])
&gt;&gt;&gt; torch.clamp(a, min=0.5)
tensor([ 0.5000,  0.5000,  2.1593,  0.5000])

</code></pre>
<pre><code class="language-py">torch.clamp(input, *, max, out=None) → Tensor
</code></pre>
<p>Clamps all elements in <code>input</code> to be smaller or equal <a href="#torch.max" title="torch.max"><code>max</code></a>.</p>
<p>If <code>input</code> is of type <code>FloatTensor</code> or <code>DoubleTensor</code>, <code>value</code> should be a real number, otherwise it should be an integer.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>value</strong> (<em>Number</em>) – maximal value of each element in the output</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.7753, -0.4702, -0.4599,  1.1899])
&gt;&gt;&gt; torch.clamp(a, max=0.5)
tensor([ 0.5000, -0.4702, -0.4599,  0.5000])

</code></pre>
<pre><code class="language-py">torch.cos(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the cosine of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ba6a1422eca60e84b7e3e9c551761d18.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ba6a1422eca60e84b7e3e9c551761d18.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 1.4309,  1.2706, -0.8562,  0.9796])
&gt;&gt;&gt; torch.cos(a)
tensor([ 0.1395,  0.2957,  0.6553,  0.5574])

</code></pre>
<pre><code class="language-py">torch.cosh(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the hyperbolic cosine of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/676476d8f75c5c5d3a52347cb5576435.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/676476d8f75c5c5d3a52347cb5576435.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.1632,  1.1835, -0.6979, -0.7325])
&gt;&gt;&gt; torch.cosh(a)
tensor([ 1.0133,  1.7860,  1.2536,  1.2805])

</code></pre>
<pre><code class="language-py">torch.div()
</code></pre>
<pre><code class="language-py">torch.div(input, value, out=None) → Tensor
</code></pre>
<p>Divides each element of the input <code>input</code> with the scalar <code>value</code> and returns a new resulting tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/92ada503afc46afd1ea338c293ed0b48.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/92ada503afc46afd1ea338c293ed0b48.jpg" alt=""></a></p>
<p>If <code>input</code> is of type <code>FloatTensor</code> or <code>DoubleTensor</code>, <code>value</code> should be a real number, otherwise it should be an integer</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>value</strong> (<em>Number</em>) – the number to be divided to each element of <code>input</code></li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(5)
&gt;&gt;&gt; a
tensor([ 0.3810,  1.2774, -0.2972, -0.3719,  0.4637])
&gt;&gt;&gt; torch.div(a, 0.5)
tensor([ 0.7620,  2.5548, -0.5944, -0.7439,  0.9275])

</code></pre>
<pre><code class="language-py">torch.div(input, other, out=None) → Tensor
</code></pre>
<p>Each element of the tensor <code>input</code> is divided by each element of the tensor <code>other</code>. The resulting tensor is returned. The shapes of <code>input</code> and <code>other</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/19b90d4ca4770702635c981d243185b9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/19b90d4ca4770702635c981d243185b9.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the numerator tensor</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the denominator tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[-0.3711, -1.9353, -0.4605, -0.2917],
 [ 0.1815, -1.0111,  0.9805, -1.5923],
 [ 0.1062,  1.4581,  0.7759, -1.2344],
 [-0.1830, -0.0313,  1.1908, -1.4757]])
&gt;&gt;&gt; b = torch.randn(4)
&gt;&gt;&gt; b
tensor([ 0.8032,  0.2930, -0.8113, -0.2308])
&gt;&gt;&gt; torch.div(a, b)
tensor([[-0.4620, -6.6051,  0.5676,  1.2637],
 [ 0.2260, -3.4507, -1.2086,  6.8988],
 [ 0.1322,  4.9764, -0.9564,  5.3480],
 [-0.2278, -0.1068, -1.4678,  6.3936]])

</code></pre>
<pre><code class="language-py">torch.digamma(input, out=None) → Tensor
</code></pre>
<p>Computes the logarithmic derivative of the gamma function on <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/369a7b2257c669fcc4fcd12afa5cfde7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/369a7b2257c669fcc4fcd12afa5cfde7.jpg" alt=""></a></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compute the digamma function on</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.tensor([1, 0.5])
&gt;&gt;&gt; torch.digamma(a)
tensor([-0.5772, -1.9635])

</code></pre>
<pre><code class="language-py">torch.erf(tensor, out=None) → Tensor
</code></pre>
<p>Computes the error function of each element. The error function is defined as follows:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/486fba0c8b6d762f89942dff1e3067f8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/486fba0c8b6d762f89942dff1e3067f8.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.erf(torch.tensor([0, -1., 10.]))
tensor([ 0.0000, -0.8427,  1.0000])

</code></pre>
<pre><code class="language-py">torch.erfc(input, out=None) → Tensor
</code></pre>
<p>Computes the complementary error function of each element of <code>input</code>. The complementary error function is defined as follows:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6100237da75310da52ebc2247d9918f1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6100237da75310da52ebc2247d9918f1.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.erfc(torch.tensor([0, -1., 10.]))
tensor([ 1.0000, 1.8427,  0.0000])

</code></pre>
<pre><code class="language-py">torch.erfinv(input, out=None) → Tensor
</code></pre>
<p>Computes the inverse error function of each element of <code>input</code>. The inverse error function is defined in the range <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2454c5f08b77e60915c698acbc0eec91.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2454c5f08b77e60915c698acbc0eec91.jpg" alt=""></a> as:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff1b16ddc6ea5e8c13cd48cf7e4e26c4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff1b16ddc6ea5e8c13cd48cf7e4e26c4.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.erfinv(torch.tensor([0, 0.5, -1.]))
tensor([ 0.0000,  0.4769,    -inf])

</code></pre>
<pre><code class="language-py">torch.exp(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the exponential of the elements of the input tensor <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c1c7df2e920de2c586fe0c1040d8e7cd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c1c7df2e920de2c586fe0c1040d8e7cd.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.exp(torch.tensor([0, math.log(2.)]))
tensor([ 1.,  2.])

</code></pre>
<pre><code class="language-py">torch.expm1(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the exponential of the elements minus 1 of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3f5d893e1a9355354b0f64666f45b4ff.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3f5d893e1a9355354b0f64666f45b4ff.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.expm1(torch.tensor([0, math.log(2.)]))
tensor([ 0.,  1.])

</code></pre>
<pre><code class="language-py">torch.floor(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the floor of the elements of <code>input</code>, the largest integer less than or equal to each element.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/17860fe2f89c3d742fd5a35e3616d8b4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/17860fe2f89c3d742fd5a35e3616d8b4.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.8166,  1.5308, -0.2530, -0.2091])
&gt;&gt;&gt; torch.floor(a)
tensor([-1.,  1., -1., -1.])

</code></pre>
<pre><code class="language-py">torch.fmod(input, divisor, out=None) → Tensor
</code></pre>
<p>Computes the element-wise remainder of division.</p>
<p>The dividend and divisor may contain both for integer and floating point numbers. The remainder has the same sign as the dividend <code>input</code>.</p>
<p>When <code>divisor</code> is a tensor, the shapes of <code>input</code> and <code>divisor</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the dividend</li>
<li><strong>divisor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the divisor, which may be either a number or a tensor of the same shape as the dividend</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.fmod(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)
tensor([-1., -0., -1.,  1.,  0.,  1.])
&gt;&gt;&gt; torch.fmod(torch.tensor([1., 2, 3, 4, 5]), 1.5)
tensor([ 1.0000,  0.5000,  0.0000,  1.0000,  0.5000])

</code></pre>
<pre><code class="language-py">torch.frac(input, out=None) → Tensor
</code></pre>
<p>Computes the fractional portion of each element in <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0e649c6142e2ff9cde94388354dc3638.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0e649c6142e2ff9cde94388354dc3638.jpg" alt=""></a></p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.frac(torch.tensor([1, 2.5, -3.2]))
tensor([ 0.0000,  0.5000, -0.2000])

</code></pre>
<pre><code class="language-py">torch.lerp(start, end, weight, out=None)
</code></pre>
<p>Does a linear interpolation of two tensors <code>start</code> and <code>end</code> based on a scalar <code>weight</code> and returns the resulting <code>out</code> tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/52c0d270ea337a2b6d51bf86fb6f2d45.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/52c0d270ea337a2b6d51bf86fb6f2d45.jpg" alt=""></a></p>
<p>The shapes of <code>start</code> and <code>end</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>start</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor with the starting points</li>
<li><strong>end</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor with the ending points</li>
<li><strong>weight</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the weight for the interpolation formula</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; start = torch.arange(1., 5.)
&gt;&gt;&gt; end = torch.empty(4).fill_(10)
&gt;&gt;&gt; start
tensor([ 1.,  2.,  3.,  4.])
&gt;&gt;&gt; end
tensor([ 10.,  10.,  10.,  10.])
&gt;&gt;&gt; torch.lerp(start, end, 0.5)
tensor([ 5.5000,  6.0000,  6.5000,  7.0000])

</code></pre>
<pre><code class="language-py">torch.log(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the natural logarithm of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63dc128af37016ef7e59d39837eccc3d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/63dc128af37016ef7e59d39837eccc3d.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(5)
&gt;&gt;&gt; a
tensor([-0.7168, -0.5471, -0.8933, -1.4428, -0.1190])
&gt;&gt;&gt; torch.log(a)
tensor([ nan,  nan,  nan,  nan,  nan])

</code></pre>
<pre><code class="language-py">torch.log10(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the logarithm to the base 10 of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8020f6f65d1d242403c13ad15b32ad43.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8020f6f65d1d242403c13ad15b32ad43.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.rand(5)
&gt;&gt;&gt; a
tensor([ 0.5224,  0.9354,  0.7257,  0.1301,  0.2251])

&gt;&gt;&gt; torch.log10(a)
tensor([-0.2820, -0.0290, -0.1392, -0.8857, -0.6476])

</code></pre>
<pre><code class="language-py">torch.log1p(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the natural logarithm of (1 + <code>input</code>).</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/553908dc43850f56bb79cbef6e776136.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/553908dc43850f56bb79cbef6e776136.jpg" alt=""></a></p>
<p>Note</p>
<p>This function is more accurate than <a href="#torch.log" title="torch.log"><code>torch.log()</code></a> for small values of <code>input</code></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(5)
&gt;&gt;&gt; a
tensor([-1.0090, -0.9923,  1.0249, -0.5372,  0.2492])
&gt;&gt;&gt; torch.log1p(a)
tensor([    nan, -4.8653,  0.7055, -0.7705,  0.2225])

</code></pre>
<pre><code class="language-py">torch.log2(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the logarithm to the base 2 of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a6be5b946e4f6d5d157679d60642a747.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a6be5b946e4f6d5d157679d60642a747.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.rand(5)
&gt;&gt;&gt; a
tensor([ 0.8419,  0.8003,  0.9971,  0.5287,  0.0490])

&gt;&gt;&gt; torch.log2(a)
tensor([-0.2483, -0.3213, -0.0042, -0.9196, -4.3504])

</code></pre>
<pre><code class="language-py">torch.mul()
</code></pre>
<pre><code class="language-py">torch.mul(input, value, out=None)
</code></pre>
<p>Multiplies each element of the input <code>input</code> with the scalar <code>value</code> and returns a new resulting tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7dd1caf9162104803cc11bfb0de7a8fa.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7dd1caf9162104803cc11bfb0de7a8fa.jpg" alt=""></a></p>
<p>If <code>input</code> is of type <code>FloatTensor</code> or <code>DoubleTensor</code>, <code>value</code> should be a real number, otherwise it should be an integer</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>value</strong> (<em>Number</em>) – the number to be multiplied to each element of <code>input</code></li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3)
&gt;&gt;&gt; a
tensor([ 0.2015, -0.4255,  2.6087])
&gt;&gt;&gt; torch.mul(a, 100)
tensor([  20.1494,  -42.5491,  260.8663])

</code></pre>
<pre><code class="language-py">torch.mul(input, other, out=None)
</code></pre>
<p>Each element of the tensor <code>input</code> is multiplied by each element of the Tensor <code>other</code>. The resulting tensor is returned.</p>
<p>The shapes of <code>input</code> and <code>other</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/13296a8d428f985a8702d83e100d4153.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/13296a8d428f985a8702d83e100d4153.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first multiplicand tensor</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second multiplicand tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 1)
&gt;&gt;&gt; a
tensor([[ 1.1207],
 [-0.3137],
 [ 0.0700],
 [ 0.8378]])
&gt;&gt;&gt; b = torch.randn(1, 4)
&gt;&gt;&gt; b
tensor([[ 0.5146,  0.1216, -0.5244,  2.2382]])
&gt;&gt;&gt; torch.mul(a, b)
tensor([[ 0.5767,  0.1363, -0.5877,  2.5083],
 [-0.1614, -0.0382,  0.1645, -0.7021],
 [ 0.0360,  0.0085, -0.0367,  0.1567],
 [ 0.4312,  0.1019, -0.4394,  1.8753]])

</code></pre>
<pre><code class="language-py">torch.mvlgamma(input, p) → Tensor
</code></pre>
<p>Computes the multivariate log-gamma function with dimension <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648811253cdbfe19389964c25be56518.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/648811253cdbfe19389964c25be56518.jpg" alt=""></a> element-wise, given by</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d1cecf35ffe071cbcf420549cd030664.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d1cecf35ffe071cbcf420549cd030664.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8890ddee156302958d8906a2799dc16b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8890ddee156302958d8906a2799dc16b.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/94c1ba406fbf0f76780513dfd005e6f5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/94c1ba406fbf0f76780513dfd005e6f5.jpg" alt=""></a> is the Gamma function.</p>
<p>If any of the elements are less than or equal to <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/80e27a556a24dac8f2985689098c1a82.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/80e27a556a24dac8f2985689098c1a82.jpg" alt=""></a>, then an error is thrown.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compute the multivariate log-gamma function</li>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of dimensions</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.empty(2, 3).uniform_(1, 2)
&gt;&gt;&gt; a
tensor([[1.6835, 1.8474, 1.1929],
 [1.0475, 1.7162, 1.4180]])
&gt;&gt;&gt; torch.mvlgamma(a, 2)
tensor([[0.3928, 0.4007, 0.7586],
 [1.0311, 0.3901, 0.5049]])

</code></pre>
<pre><code class="language-py">torch.neg(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the negative of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5ea71e988dcc7de6c27b28ca79f4e893.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5ea71e988dcc7de6c27b28ca79f4e893.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(5)
&gt;&gt;&gt; a
tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])
&gt;&gt;&gt; torch.neg(a)
tensor([-0.0090,  0.2262,  0.0682,  0.2866, -0.3940])

</code></pre>
<pre><code class="language-py">torch.pow()
</code></pre>
<pre><code class="language-py">torch.pow(input, exponent, out=None) → Tensor
</code></pre>
<p>Takes the power of each element in <code>input</code> with <code>exponent</code> and returns a tensor with the result.</p>
<p><code>exponent</code> can be either a single <code>float</code> number or a <code>Tensor</code> with the same number of elements as <code>input</code>.</p>
<p>When <code>exponent</code> is a scalar value, the operation applied is:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a04a68f6eedb206fc30bd425f792afdb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a04a68f6eedb206fc30bd425f792afdb.jpg" alt=""></a></p>
<p>When <code>exponent</code> is a tensor, the operation applied is:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5499cae563d1d075246e3a18b191e870.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5499cae563d1d075246e3a18b191e870.jpg" alt=""></a></p>
<p>When <code>exponent</code> is a tensor, the shapes of <code>input</code> and <code>exponent</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>exponent</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a> <em>or</em> <em>tensor</em>) – the exponent value</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.4331,  1.2475,  0.6834, -0.2791])
&gt;&gt;&gt; torch.pow(a, 2)
tensor([ 0.1875,  1.5561,  0.4670,  0.0779])
&gt;&gt;&gt; exp = torch.arange(1., 5.)

&gt;&gt;&gt; a = torch.arange(1., 5.)
&gt;&gt;&gt; a
tensor([ 1.,  2.,  3.,  4.])
&gt;&gt;&gt; exp
tensor([ 1.,  2.,  3.,  4.])
&gt;&gt;&gt; torch.pow(a, exp)
tensor([   1.,    4.,   27.,  256.])

</code></pre>
<pre><code class="language-py">torch.pow(base, input, out=None) → Tensor
</code></pre>
<p><code>base</code> is a scalar <code>float</code> value, and <code>input</code> is a tensor. The returned tensor <code>out</code> is of the same shape as <code>input</code></p>
<p>The operation applied is:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0c98533a385eed5ae6f333583d9d239e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0c98533a385eed5ae6f333583d9d239e.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>base</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the scalar base value for the power operation</li>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the exponent tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; exp = torch.arange(1., 5.)
&gt;&gt;&gt; base = 2
&gt;&gt;&gt; torch.pow(base, exp)
tensor([  2.,   4.,   8.,  16.])

</code></pre>
<pre><code class="language-py">torch.reciprocal(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the reciprocal of the elements of <code>input</code></p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a4cb9bbdd43eddd6583c288380fe9704.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a4cb9bbdd43eddd6583c288380fe9704.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.4595, -2.1219, -1.4314,  0.7298])
&gt;&gt;&gt; torch.reciprocal(a)
tensor([-2.1763, -0.4713, -0.6986,  1.3702])

</code></pre>
<pre><code class="language-py">torch.remainder(input, divisor, out=None) → Tensor
</code></pre>
<p>Computes the element-wise remainder of division.</p>
<p>The divisor and dividend may contain both for integer and floating point numbers. The remainder has the same sign as the divisor.</p>
<p>When <code>divisor</code> is a tensor, the shapes of <code>input</code> and <code>divisor</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the dividend</li>
<li><strong>divisor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the divisor that may be either a number or a Tensor of the same shape as the dividend</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.remainder(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)
tensor([ 1.,  0.,  1.,  1.,  0.,  1.])
&gt;&gt;&gt; torch.remainder(torch.tensor([1., 2, 3, 4, 5]), 1.5)
tensor([ 1.0000,  0.5000,  0.0000,  1.0000,  0.5000])

</code></pre>
<p>See also</p>
<p><a href="#torch.fmod" title="torch.fmod"><code>torch.fmod()</code></a>, which computes the element-wise remainder of division equivalently to the C library function <code>fmod()</code>.</p>
<pre><code class="language-py">torch.round(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with each of the elements of <code>input</code> rounded to the closest integer.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.9920,  0.6077,  0.9734, -1.0362])
&gt;&gt;&gt; torch.round(a)
tensor([ 1.,  1.,  1., -1.])

</code></pre>
<pre><code class="language-py">torch.rsqrt(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the reciprocal of the square-root of each of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ba016159f6eee3d6e907b3f1f4690148.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ba016159f6eee3d6e907b3f1f4690148.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.0370,  0.2970,  1.5420, -0.9105])
&gt;&gt;&gt; torch.rsqrt(a)
tensor([    nan,  1.8351,  0.8053,     nan])

</code></pre>
<pre><code class="language-py">torch.sigmoid(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the sigmoid of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/35490743ae06a50e628101c524fa3557.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/35490743ae06a50e628101c524fa3557.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.9213,  1.0887, -0.8858, -1.7683])
&gt;&gt;&gt; torch.sigmoid(a)
tensor([ 0.7153,  0.7481,  0.2920,  0.1458])

</code></pre>
<pre><code class="language-py">torch.sign(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the sign of the elements of <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.tensor([0.7, -1.2, 0., 2.3])
&gt;&gt;&gt; a
tensor([ 0.7000, -1.2000,  0.0000,  2.3000])
&gt;&gt;&gt; torch.sign(a)
tensor([ 1., -1.,  0.,  1.])

</code></pre>
<pre><code class="language-py">torch.sin(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the sine of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4bb3f3689a942de005b6ed433517a99a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4bb3f3689a942de005b6ed433517a99a.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-0.5461,  0.1347, -2.7266, -0.2746])
&gt;&gt;&gt; torch.sin(a)
tensor([-0.5194,  0.1343, -0.4032, -0.2711])

</code></pre>
<pre><code class="language-py">torch.sinh(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the hyperbolic sine of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ef01436f55bc1cd4c0407857bb6b41d0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ef01436f55bc1cd4c0407857bb6b41d0.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.5380, -0.8632, -0.1265,  0.9399])
&gt;&gt;&gt; torch.sinh(a)
tensor([ 0.5644, -0.9744, -0.1268,  1.0845])

</code></pre>
<pre><code class="language-py">torch.sqrt(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the square-root of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5407c7228f589f6c48f1bdd755f1e4c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5407c7228f589f6c48f1bdd755f1e4c8.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-2.0755,  1.0226,  0.0831,  0.4806])
&gt;&gt;&gt; torch.sqrt(a)
tensor([    nan,  1.0112,  0.2883,  0.6933])

</code></pre>
<pre><code class="language-py">torch.tan(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the tangent of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0cab489cdb9e93ea59ac064d58876397.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/0cab489cdb9e93ea59ac064d58876397.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([-1.2027, -1.7687,  0.4412, -1.3856])
&gt;&gt;&gt; torch.tan(a)
tensor([-2.5930,  4.9859,  0.4722, -5.3366])

</code></pre>
<pre><code class="language-py">torch.tanh(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the hyperbolic tangent of the elements of <code>input</code>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f29380f07881b913efa1bcc641e2ae.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f29380f07881b913efa1bcc641e2ae.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.8986, -0.7279,  1.1745,  0.2611])
&gt;&gt;&gt; torch.tanh(a)
tensor([ 0.7156, -0.6218,  0.8257,  0.2553])

</code></pre>
<pre><code class="language-py">torch.trunc(input, out=None) → Tensor
</code></pre>
<p>Returns a new tensor with the truncated integer values of the elements of <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 3.4742,  0.5466, -0.8008, -0.9079])
&gt;&gt;&gt; torch.trunc(a)
tensor([ 3.,  0., -0., -0.])

</code></pre>
<h3 id="reduction-ops">Reduction Ops</h3>
<pre><code class="language-py">torch.argmax(input, dim=None, keepdim=False)
</code></pre>
<p>Returns the indices of the maximum values of a tensor across a dimension.</p>
<p>This is the second value returned by <a href="#torch.max" title="torch.max"><code>torch.max()</code></a>. See its documentation for the exact semantics of this method.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce. If <code>None</code>, the argmax of the flattened input is returned.</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensors have <code>dim</code> retained or not. Ignored if <code>dim=None</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],
 [-0.7401, -0.8805, -0.3402, -1.1936],
 [ 0.4907, -1.3948, -1.0691, -0.3132],
 [-1.6092,  0.5419, -0.2993,  0.3195]])

&gt;&gt;&gt; torch.argmax(a, dim=1)
tensor([ 0,  2,  0,  1])

</code></pre>
<pre><code class="language-py">torch.argmin(input, dim=None, keepdim=False)
</code></pre>
<p>Returns the indices of the minimum values of a tensor across a dimension.</p>
<p>This is the second value returned by <a href="#torch.min" title="torch.min"><code>torch.min()</code></a>. See its documentation for the exact semantics of this method.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce. If <code>None</code>, the argmin of the flattened input is returned.</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensors have <code>dim</code> retained or not. Ignored if <code>dim=None</code>.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[ 0.1139,  0.2254, -0.1381,  0.3687],
 [ 1.0100, -1.1975, -0.0102, -0.4732],
 [-0.9240,  0.1207, -0.7506, -1.0213],
 [ 1.7809, -1.2960,  0.9384,  0.1438]])

&gt;&gt;&gt; torch.argmin(a, dim=1)
tensor([ 2,  1,  3,  1])

</code></pre>
<pre><code class="language-py">torch.cumprod(input, dim, dtype=None) → Tensor
</code></pre>
<p>Returns the cumulative product of elements of <code>input</code> in the dimension <code>dim</code>.</p>
<p>For example, if <code>input</code> is a vector of size N, the result will also be a vector of size N, with elements.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e9045e46c1b7fca7acb598cf474f16e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9e9045e46c1b7fca7acb598cf474f16e.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to do the operation over</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. If specified, the input tensor is casted to <code>dtype</code> before the operation is performed. This is useful for preventing data type overflows. Default: None.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(10)
&gt;&gt;&gt; a
tensor([ 0.6001,  0.2069, -0.1919,  0.9792,  0.6727,  1.0062,  0.4126,
 -0.2129, -0.4206,  0.1968])
&gt;&gt;&gt; torch.cumprod(a, dim=0)
tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0158, -0.0065,
 0.0014, -0.0006, -0.0001])

&gt;&gt;&gt; a[5] = 0.0
&gt;&gt;&gt; torch.cumprod(a, dim=0)
tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0000, -0.0000,
 0.0000, -0.0000, -0.0000])

</code></pre>
<pre><code class="language-py">torch.cumsum(input, dim, out=None, dtype=None) → Tensor
</code></pre>
<p>Returns the cumulative sum of elements of <code>input</code> in the dimension <code>dim</code>.</p>
<p>For example, if <code>input</code> is a vector of size N, the result will also be a vector of size N, with elements.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/70f741993caea1156636d61e6f21e463.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/70f741993caea1156636d61e6f21e463.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to do the operation over</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. If specified, the input tensor is casted to <code>dtype</code> before the operation is performed. This is useful for preventing data type overflows. Default: None.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(10)
&gt;&gt;&gt; a
tensor([-0.8286, -0.4890,  0.5155,  0.8443,  0.1865, -0.1752, -2.0595,
 0.1850, -1.1571, -0.4243])
&gt;&gt;&gt; torch.cumsum(a, dim=0)
tensor([-0.8286, -1.3175, -0.8020,  0.0423,  0.2289,  0.0537, -2.0058,
 -1.8209, -2.9780, -3.4022])

</code></pre>
<pre><code class="language-py">torch.dist(input, other, p=2) → Tensor
</code></pre>
<p>Returns the p-norm of (<code>input</code> - <code>other</code>)</p>
<p>The shapes of <code>input</code> and <code>other</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the Right-hand-side input tensor</li>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – the norm to be computed</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(4)
&gt;&gt;&gt; x
tensor([-1.5393, -0.8675,  0.5916,  1.6321])
&gt;&gt;&gt; y = torch.randn(4)
&gt;&gt;&gt; y
tensor([ 0.0967, -1.0511,  0.6295,  0.8360])
&gt;&gt;&gt; torch.dist(x, y, 3.5)
tensor(1.6727)
&gt;&gt;&gt; torch.dist(x, y, 3)
tensor(1.6973)
&gt;&gt;&gt; torch.dist(x, y, 0)
tensor(inf)
&gt;&gt;&gt; torch.dist(x, y, 1)
tensor(2.6537)

</code></pre>
<pre><code class="language-py">torch.logsumexp(input, dim, keepdim=False, out=None)
</code></pre>
<p>Returns the log of summed exponentials of each row of the <code>input</code> tensor in the given dimension <code>dim</code>. The computation is numerically stabilized.</p>
<p>For summation index <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d8fdd0e28cfb03738fc5227885ee035a.jpg" alt=""></a> given by <code>dim</code> and other indices <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a>, the result is</p>
<blockquote>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5acb5b22a7a5c1cfbfda7f648a00c656.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5acb5b22a7a5c1cfbfda7f648a00c656.jpg" alt=""></a></p>
</blockquote>
<p>If <code>keepdim</code> is <code>True</code>, the output tensor is of the same size as <code>input</code> except in the dimension <code>dim</code> where it is of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensor having 1 fewer dimension than <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <em>tuple of python:ints</em>) – the dimension or dimensions to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensor has <code>dim</code> retained or not</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<pre><code class="language-py">Example::
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; torch.logsumexp(a, 1)
tensor([ 0.8442,  1.4322,  0.8711])

</code></pre>
<pre><code class="language-py">torch.mean()
</code></pre>
<pre><code class="language-py">torch.mean(input) → Tensor
</code></pre>
<p>Returns the mean value of all elements in the <code>input</code> tensor.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[ 0.2294, -0.5481,  1.3288]])
&gt;&gt;&gt; torch.mean(a)
tensor(0.3367)

</code></pre>
<pre><code class="language-py">torch.mean(input, dim, keepdim=False, out=None) → Tensor
</code></pre>
<p>Returns the mean value of each row of the <code>input</code> tensor in the given dimension <code>dim</code>. If <code>dim</code> is a list of dimensions, reduce over all of them.</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensor is of the same size as <code>input</code> except in the dimension(s) <code>dim</code> where it is of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensor having 1 (or <code>len(dim)</code>) fewer dimension(s).</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether the output tensor has <code>dim</code> retained or not</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[-0.3841,  0.6320,  0.4254, -0.7384],
 [-0.9644,  1.0131, -0.6549, -1.4279],
 [-0.2951, -1.3350, -0.7694,  0.5600],
 [ 1.0842, -0.9580,  0.3623,  0.2343]])
&gt;&gt;&gt; torch.mean(a, 1)
tensor([-0.0163, -0.5085, -0.4599,  0.1807])
&gt;&gt;&gt; torch.mean(a, 1, True)
tensor([[-0.0163],
 [-0.5085],
 [-0.4599],
 [ 0.1807]])

</code></pre>
<pre><code class="language-py">torch.median()
</code></pre>
<pre><code class="language-py">torch.median(input) → Tensor
</code></pre>
<p>Returns the median value of all elements in the <code>input</code> tensor.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[ 1.5219, -1.5212,  0.2202]])
&gt;&gt;&gt; torch.median(a)
tensor(0.2202)

</code></pre>
<pre><code class="language-py">torch.median(input, dim=-1, keepdim=False, values=None, indices=None) -&gt; (Tensor, LongTensor)
</code></pre>
<p>Returns the median value of each row of the <code>input</code> tensor in the given dimension <code>dim</code>. Also returns the index location of the median value as a <code>LongTensor</code>.</p>
<p>By default, <code>dim</code> is the last dimension of the <code>input</code> tensor.</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensors are of the same size as <code>input</code> except in the dimension <code>dim</code> where they are of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the outputs tensor having 1 fewer dimension than <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensors have <code>dim</code> retained or not</li>
<li><strong>values</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>indices</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output index tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 5)
&gt;&gt;&gt; a
tensor([[ 0.2505, -0.3982, -0.9948,  0.3518, -1.3131],
 [ 0.3180, -0.6993,  1.0436,  0.0438,  0.2270],
 [-0.2751,  0.7303,  0.2192,  0.3321,  0.2488],
 [ 1.0778, -1.9510,  0.7048,  0.4742, -0.7125]])
&gt;&gt;&gt; torch.median(a, 1)
(tensor([-0.3982,  0.2270,  0.2488,  0.4742]), tensor([ 1,  4,  4,  3]))

</code></pre>
<pre><code class="language-py">torch.mode(input, dim=-1, keepdim=False, values=None, indices=None) -&gt; (Tensor, LongTensor)
</code></pre>
<p>Returns the mode value of each row of the <code>input</code> tensor in the given dimension <code>dim</code>. Also returns the index location of the mode value as a <code>LongTensor</code>.</p>
<p>By default, <code>dim</code> is the last dimension of the <code>input</code> tensor.</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensors are of the same size as <code>input</code> except in the dimension <code>dim</code> where they are of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensors having 1 fewer dimension than <code>input</code>.</p>
<p>Note</p>
<p>This function is not defined for <code>torch.cuda.Tensor</code> yet.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensors have <code>dim</code> retained or not</li>
<li><strong>values</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
<li><strong>indices</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output index tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 5)
&gt;&gt;&gt; a
tensor([[-1.2808, -1.0966, -1.5946, -0.1148,  0.3631],
 [ 1.1395,  1.1452, -0.6383,  0.3667,  0.4545],
 [-0.4061, -0.3074,  0.4579, -1.3514,  1.2729],
 [-1.0130,  0.3546, -1.4689, -0.1254,  0.0473]])
&gt;&gt;&gt; torch.mode(a, 1)
(tensor([-1.5946, -0.6383, -1.3514, -1.4689]), tensor([ 2,  2,  3,  2]))

</code></pre>
<pre><code class="language-py">torch.norm(input, p='fro', dim=None, keepdim=False, out=None)
</code></pre>
<p>Returns the matrix norm or vector norm of a given tensor.</p>
<p>Parameters:</p>
<ul>
<li> <p><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</p> </li>
<li> <p><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>inf</em>_,_ <em>-inf</em>_,_ <em>'fro'__,</em> <em>'nuc'__,</em> <em>optional</em>) –</p> <p>the order of norm. Default: <code>'fro'</code> The following norms can be calculated:</p> <p>| ord | matrix norm | vector norm | | --- | --- | --- | | None | Frobenius norm | 2-norm | | ’fro’ | Frobenius norm | – | | ‘nuc’ | nuclear norm | – | | Other | as vec norm when dim is None | sum(abs(x)<strong>ord)</strong>(1./ord) |</p> </li>
<li> <p><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>2-tuple of python:ints</em>_,_ <em>2-list of python:ints</em>_,_ <em>optional</em>) – If it is an int, vector norm will be calculated, if it is 2-tuple of ints, matrix norm will be calculated. If the value is None, matrix norm will be calculated when the input tensor only has two dimensions, vector norm will be calculated when the input tensor only has one dimension. If the input tensor has more than two dimensions, the vector norm will be applied to last dimension.</p> </li>
<li> <p><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether the output tensors have <code>dim</code> retained or not. Ignored if <code>dim</code> = <code>None</code> and <code>out</code> = <code>None</code>. Default: <code>False</code></p> </li>
<li> <p><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor. Ignored if <code>dim</code> = <code>None</code> and <code>out</code> = <code>None</code>.</p> </li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; import torch
&gt;&gt;&gt; a = torch.arange(9, dtype= torch.float) - 4
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; torch.norm(a)
tensor(7.7460)
&gt;&gt;&gt; torch.norm(b)
tensor(7.7460)
&gt;&gt;&gt; torch.norm(a, float('inf'))
tensor(4.)
&gt;&gt;&gt; torch.norm(b, float('inf'))
tensor([4., 3., 4.])
&gt;&gt;&gt; c = torch.tensor([[ 1, 2, 3],[-1, 1, 4]] , dtype= torch.float)
&gt;&gt;&gt; torch.norm(c, dim=0)
tensor([1.4142, 2.2361, 5.0000])
&gt;&gt;&gt; torch.norm(c, dim=1)
tensor([3.7417, 4.2426])
&gt;&gt;&gt; torch.norm(c, p=1, dim=1)
tensor([6., 6.])
&gt;&gt;&gt; d = torch.arange(8, dtype= torch.float).reshape(2,2,2)
&gt;&gt;&gt; torch.norm(d, dim=(1,2))
tensor([ 3.7417, 11.2250])
&gt;&gt;&gt; torch.norm(d[0, :, :]), torch.norm(d[1, :, :])
(tensor(3.7417), tensor(11.2250))

</code></pre>
<pre><code class="language-py">torch.prod()
</code></pre>
<pre><code class="language-py">torch.prod(input, dtype=None) → Tensor
</code></pre>
<p>Returns the product of all elements in the <code>input</code> tensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. If specified, the input tensor is casted to <code>dtype</code> before the operation is performed. This is useful for preventing data type overflows. Default: None.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[-0.8020,  0.5428, -1.5854]])
&gt;&gt;&gt; torch.prod(a)
tensor(0.6902)

</code></pre>
<pre><code class="language-py">torch.prod(input, dim, keepdim=False, dtype=None) → Tensor
</code></pre>
<p>Returns the product of each row of the <code>input</code> tensor in the given dimension <code>dim</code>.</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensor is of the same size as <code>input</code> except in the dimension <code>dim</code> where it is of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensor having 1 fewer dimension than <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensor has <code>dim</code> retained or not</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. If specified, the input tensor is casted to <code>dtype</code> before the operation is performed. This is useful for preventing data type overflows. Default: None.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 2)
&gt;&gt;&gt; a
tensor([[ 0.5261, -0.3837],
 [ 1.1857, -0.2498],
 [-1.1646,  0.0705],
 [ 1.1131, -1.0629]])
&gt;&gt;&gt; torch.prod(a, 1)
tensor([-0.2018, -0.2962, -0.0821, -1.1831])

</code></pre>
<pre><code class="language-py">torch.std()
</code></pre>
<pre><code class="language-py">torch.std(input, unbiased=True) → Tensor
</code></pre>
<p>Returns the standard-deviation of all elements in the <code>input</code> tensor.</p>
<p>If <code>unbiased</code> is <code>False</code>, then the standard-deviation will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>unbiased</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether to use the unbiased estimation or not</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[-0.8166, -1.3802, -0.3560]])
&gt;&gt;&gt; torch.std(a)
tensor(0.5130)

</code></pre>
<pre><code class="language-py">torch.std(input, dim, keepdim=False, unbiased=True, out=None) → Tensor
</code></pre>
<p>Returns the standard-deviation of each row of the <code>input</code> tensor in the given dimension <code>dim</code>.</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensor is of the same size as <code>input</code> except in the dimension <code>dim</code> where it is of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensor having 1 fewer dimension than <code>input</code>.</p>
<p>If <code>unbiased</code> is <code>False</code>, then the standard-deviation will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensor has <code>dim</code> retained or not</li>
<li><strong>unbiased</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether to use the unbiased estimation or not</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[ 0.2035,  1.2959,  1.8101, -0.4644],
 [ 1.5027, -0.3270,  0.5905,  0.6538],
 [-1.5745,  1.3330, -0.5596, -0.6548],
 [ 0.1264, -0.5080,  1.6420,  0.1992]])
&gt;&gt;&gt; torch.std(a, dim=1)
tensor([ 1.0311,  0.7477,  1.2204,  0.9087])

</code></pre>
<pre><code class="language-py">torch.sum()
</code></pre>
<pre><code class="language-py">torch.sum(input, dtype=None) → Tensor
</code></pre>
<p>Returns the sum of all elements in the <code>input</code> tensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. If specified, the input tensor is casted to <code>dtype</code> before the operation is performed. This is useful for preventing data type overflows. Default: None.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[ 0.1133, -0.9567,  0.2958]])
&gt;&gt;&gt; torch.sum(a)
tensor(-0.5475)

</code></pre>
<pre><code class="language-py">torch.sum(input, dim, keepdim=False, dtype=None) → Tensor
</code></pre>
<p>Returns the sum of each row of the <code>input</code> tensor in the given dimension <code>dim</code>. If <code>dim</code> is a list of dimensions, reduce over all of them.</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensor is of the same size as <code>input</code> except in the dimension(s) <code>dim</code> where it is of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensor having 1 (or <code>len(dim)</code>) fewer dimension(s).</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <em>tuple of python:ints</em>) – the dimension or dimensions to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensor has <code>dim</code> retained or not</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. If specified, the input tensor is casted to <code>dtype</code> before the operation is performed. This is useful for preventing data type overflows. Default: None.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[ 0.0569, -0.2475,  0.0737, -0.3429],
 [-0.2993,  0.9138,  0.9337, -1.6864],
 [ 0.1132,  0.7892, -0.1003,  0.5688],
 [ 0.3637, -0.9906, -0.4752, -1.5197]])
&gt;&gt;&gt; torch.sum(a, 1)
tensor([-0.4598, -0.1381,  1.3708, -2.6217])
&gt;&gt;&gt; b = torch.arange(4 * 5 * 6).view(4, 5, 6)
&gt;&gt;&gt; torch.sum(b, (2, 1))
tensor([  435.,  1335.,  2235.,  3135.])

</code></pre>
<pre><code class="language-py">torch.unique(input, sorted=False, return_inverse=False, dim=None)
</code></pre>
<p>Returns the unique scalar elements of the input tensor as a 1-D tensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>sorted</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Whether to sort the unique elements in ascending order before returning as output.</li>
<li><strong>return_inverse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Whether to also return the indices for where elements in the original input ended up in the returned unique list.</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to apply unique. If <code>None</code>, the unique of the flattened input is returned. default: <code>None</code></li>
</ul>
<p>| Returns: | A tensor or a tuple of tensors containing</p>
<p>&gt; * <strong>output</strong> (<em>Tensor</em>): the output list of unique scalar elements. &gt; * <strong>inverse_indices</strong> (<em>Tensor</em>): (optional) if <code>return_inverse</code> is True, there will be a 2nd returned tensor (same shape as input) representing the indices for where elements in the original input map to in the output; otherwise, this function will only return a single tensor.</p>
<table>
<thead>
<tr>
<th>Return type:</th>
<th>(<a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>, <a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a> (optional))</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; output = torch.unique(torch.tensor([1, 3, 2, 3], dtype=torch.long))
&gt;&gt;&gt; output
tensor([ 2,  3,  1])

&gt;&gt;&gt; output, inverse_indices = torch.unique(
 torch.tensor([1, 3, 2, 3], dtype=torch.long), sorted=True, return_inverse=True)
&gt;&gt;&gt; output
tensor([ 1,  2,  3])
&gt;&gt;&gt; inverse_indices
tensor([ 0,  2,  1,  2])

&gt;&gt;&gt; output, inverse_indices = torch.unique(
 torch.tensor([[1, 3], [2, 3]], dtype=torch.long), sorted=True, return_inverse=True)
&gt;&gt;&gt; output
tensor([ 1,  2,  3])
&gt;&gt;&gt; inverse_indices
tensor([[ 0,  2],
 [ 1,  2]])

</code></pre>
<pre><code class="language-py">torch.var()
</code></pre>
<pre><code class="language-py">torch.var(input, unbiased=True) → Tensor
</code></pre>
<p>Returns the variance of all elements in the <code>input</code> tensor.</p>
<p>If <code>unbiased</code> is <code>False</code>, then the variance will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>unbiased</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether to use the unbiased estimation or not</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[-0.3425, -1.2636, -0.4864]])
&gt;&gt;&gt; torch.var(a)
tensor(0.2455)

</code></pre>
<pre><code class="language-py">torch.var(input, dim, keepdim=False, unbiased=True, out=None) → Tensor
</code></pre>
<p>Returns the variance of each row of the <code>input</code> tensor in the given dimension <code>dim</code>.</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensors are of the same size as <code>input</code> except in the dimension <code>dim</code> where they are of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the outputs tensor having 1 fewer dimension than <code>input</code>.</p>
<p>If <code>unbiased</code> is <code>False</code>, then the variance will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensor has <code>dim</code> retained or not</li>
<li><strong>unbiased</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether to use the unbiased estimation or not</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[-0.3567,  1.7385, -1.3042,  0.7423],
 [ 1.3436, -0.1015, -0.9834, -0.8438],
 [ 0.6056,  0.1089, -0.3112, -1.4085],
 [-0.7700,  0.6074, -0.1469,  0.7777]])
&gt;&gt;&gt; torch.var(a, 1)
tensor([ 1.7444,  1.1363,  0.7356,  0.5112])

</code></pre>
<h3 id="comparison-ops">Comparison Ops</h3>
<pre><code class="language-py">torch.allclose(self, other, rtol=1e-05, atol=1e-08, equal_nan=False) → bool
</code></pre>
<p>This function checks if all <code>self</code> and <code>other</code> satisfy the condition:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5dd778c75ab74a08d08025aa32f15e20.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5dd778c75ab74a08d08025aa32f15e20.jpg" alt=""></a></p>
<p>elementwise, for all elements of <code>self</code> and <code>other</code>. The behaviour of this function is analogous to <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html">numpy.allclose</a></p>
<p>Parameters:</p>
<ul>
<li><strong>self</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – first tensor to compare</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – second tensor to compare</li>
<li><strong>atol</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – absolute tolerance. Default: 1e-08</li>
<li><strong>rtol</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – relative tolerance. Default: 1e-05</li>
<li><strong>equal_nan</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, then two <code>NaN</code> s will be compared as equal. Default: <code>False</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.allclose(torch.tensor([10000., 1e-07]), torch.tensor([10000.1, 1e-08]))
False
&gt;&gt;&gt; torch.allclose(torch.tensor([10000., 1e-08]), torch.tensor([10000.1, 1e-09]))
True
&gt;&gt;&gt; torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]))
False
&gt;&gt;&gt; torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]), equal_nan=True)
True

</code></pre>
<pre><code class="language-py">torch.argsort(input, dim=None, descending=False)
</code></pre>
<p>Returns the indices that sort a tensor along a given dimension in ascending order by value.</p>
<p>This is the second value returned by <a href="#torch.sort" title="torch.sort"><code>torch.sort()</code></a>. See its documentation for the exact semantics of this method.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the dimension to sort along</li>
<li><strong>descending</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls the sorting order (ascending or descending)</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],
 [ 0.1598,  0.0788, -0.0745, -1.2700],
 [ 1.2208,  1.0722, -0.7064,  1.2564],
 [ 0.0669, -0.2318, -0.8229, -0.9280]])

&gt;&gt;&gt; torch.argsort(a, dim=1)
tensor([[2, 0, 3, 1],
 [3, 2, 1, 0],
 [2, 1, 0, 3],
 [3, 2, 1, 0]])

</code></pre>
<pre><code class="language-py">torch.eq(input, other, out=None) → Tensor
</code></pre>
<p>Computes element-wise equality</p>
<p>The second argument can be a number or a tensor whose shape is <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with the first argument.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compare</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the tensor or value to compare</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor. Must be a <code>ByteTensor</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A <code>torch.ByteTensor</code> containing a 1 at each location where comparison is true</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.eq(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
tensor([[ 1,  0],
 [ 0,  1]], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.equal(tensor1, tensor2) → bool
</code></pre>
<p><code>True</code> if two tensors have the same size and elements, <code>False</code> otherwise.</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.equal(torch.tensor([1, 2]), torch.tensor([1, 2]))
True

</code></pre>
<pre><code class="language-py">torch.ge(input, other, out=None) → Tensor
</code></pre>
<p>Computes <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7cedf1d52401b16530bccf12f96edd5a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7cedf1d52401b16530bccf12f96edd5a.jpg" alt=""></a> element-wise.</p>
<p>The second argument can be a number or a tensor whose shape is <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with the first argument.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compare</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the tensor or value to compare</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor that must be a <code>ByteTensor</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A <code>torch.ByteTensor</code> containing a 1 at each location where comparison is true</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.ge(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
tensor([[ 1,  1],
 [ 0,  1]], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.gt(input, other, out=None) → Tensor
</code></pre>
<p>Computes <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d325c4b6e2e06380eb65ceae1e84d76.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9d325c4b6e2e06380eb65ceae1e84d76.jpg" alt=""></a> element-wise.</p>
<p>The second argument can be a number or a tensor whose shape is <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with the first argument.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compare</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the tensor or value to compare</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor that must be a <code>ByteTensor</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A <code>torch.ByteTensor</code> containing a 1 at each location where comparison is true</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.gt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
tensor([[ 0,  1],
 [ 0,  0]], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.isfinite(tensor)
</code></pre>
<p>Returns a new tensor with boolean elements representing if each element is <code>Finite</code> or not.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – A tensor to check</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>A <code>torch.ByteTensor</code> containing a 1 at each location of finite elements and 0 otherwise</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.isfinite(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))
tensor([ 1,  0,  1,  0,  0], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.isinf(tensor)
</code></pre>
<p>Returns a new tensor with boolean elements representing if each element is <code>+/-INF</code> or not.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – A tensor to check</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>A <code>torch.ByteTensor</code> containing a 1 at each location of <code>+/-INF</code> elements and 0 otherwise</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.isinf(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))
tensor([ 0,  1,  0,  1,  0], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.isnan(tensor)
</code></pre>
<p>Returns a new tensor with boolean elements representing if each element is <code>NaN</code> or not.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – A tensor to check</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>A <code>torch.ByteTensor</code> containing a 1 at each location of <code>NaN</code> elements.</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.isnan(torch.tensor([1, float('nan'), 2]))
tensor([ 0,  1,  0], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.kthvalue(input, k, dim=None, keepdim=False, out=None) -&gt; (Tensor, LongTensor)
</code></pre>
<p>Returns the <code>k</code> th smallest element of the given <code>input</code> tensor along a given dimension.</p>
<p>If <code>dim</code> is not given, the last dimension of the <code>input</code> is chosen.</p>
<p>A tuple of <code>(values, indices)</code> is returned, where the <code>indices</code> is the indices of the kth-smallest element in the original <code>input</code> tensor in dimension <code>dim</code>.</p>
<p>If <code>keepdim</code> is <code>True</code>, both the <code>values</code> and <code>indices</code> tensors are the same size as <code>input</code>, except in the dimension <code>dim</code> where they are of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in both the <code>values</code> and <code>indices</code> tensors having 1 fewer dimension than the <code>input</code> tensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>k</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – k for the k-th smallest element</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the dimension to find the kth value along</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensors have <code>dim</code> retained or not</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the output tuple of (Tensor, LongTensor) can be optionally given to be used as output buffers</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.arange(1., 6.)
&gt;&gt;&gt; x
tensor([ 1.,  2.,  3.,  4.,  5.])
&gt;&gt;&gt; torch.kthvalue(x, 4)
(tensor(4.), tensor(3))

&gt;&gt;&gt; x=torch.arange(1.,7.).resize_(2,3)
&gt;&gt;&gt; x
tensor([[ 1.,  2.,  3.],
 [ 4.,  5.,  6.]])
&gt;&gt;&gt; torch.kthvalue(x,2,0,True)
(tensor([[ 4.,  5.,  6.]]), tensor([[ 1,  1,  1]]))

</code></pre>
<pre><code class="language-py">torch.le(input, other, out=None) → Tensor
</code></pre>
<p>Computes <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7cce834f96c0e53d76c3ec5ed63cf099.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7cce834f96c0e53d76c3ec5ed63cf099.jpg" alt=""></a> element-wise.</p>
<p>The second argument can be a number or a tensor whose shape is <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with the first argument.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compare</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the tensor or value to compare</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor that must be a <code>ByteTensor</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A <code>torch.ByteTensor</code> containing a 1 at each location where comparison is true</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.le(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
tensor([[ 1,  0],
 [ 1,  1]], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.lt(input, other, out=None) → Tensor
</code></pre>
<p>Computes <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/26b8f23e09743e63a71bcf53c650f1a8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/26b8f23e09743e63a71bcf53c650f1a8.jpg" alt=""></a> element-wise.</p>
<p>The second argument can be a number or a tensor whose shape is <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with the first argument.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compare</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the tensor or value to compare</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor that must be a <code>ByteTensor</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A <code>torch.ByteTensor</code> containing a 1 at each location where comparison is true</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.lt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
tensor([[ 0,  0],
 [ 1,  0]], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.max()
</code></pre>
<pre><code class="language-py">torch.max(input) → Tensor
</code></pre>
<p>Returns the maximum value of all elements in the <code>input</code> tensor.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[ 0.6763,  0.7445, -2.2369]])
&gt;&gt;&gt; torch.max(a)
tensor(0.7445)

</code></pre>
<pre><code class="language-py">torch.max(input, dim, keepdim=False, out=None) -&gt; (Tensor, LongTensor)
</code></pre>
<p>Returns the maximum value of each row of the <code>input</code> tensor in the given dimension <code>dim</code>. The second return value is the index location of each maximum value found (argmax).</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensors are of the same size as <code>input</code> except in the dimension <code>dim</code> where they are of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensors having 1 fewer dimension than <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensors have <code>dim</code> retained or not</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the result tuple of two output tensors (max, max_indices)</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
 [ 1.1949, -1.1127, -2.2379, -0.6702],
 [ 1.5717, -0.9207,  0.1297, -1.8768],
 [-0.6172,  1.0036, -0.6060, -0.2432]])
&gt;&gt;&gt; torch.max(a, 1)
(tensor([ 0.8475,  1.1949,  1.5717,  1.0036]), tensor([ 3,  0,  0,  1]))

</code></pre>
<pre><code class="language-py">torch.max(input, other, out=None) → Tensor
</code></pre>
<p>Each element of the tensor <code>input</code> is compared with the corresponding element of the tensor <code>other</code> and an element-wise maximum is taken.</p>
<p>The shapes of <code>input</code> and <code>other</code> don’t need to match, but they must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/adfdd713f1ca11c4b41b733a5f452f47.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/adfdd713f1ca11c4b41b733a5f452f47.jpg" alt=""></a></p>
<p>Note</p>
<p>When the shapes do not match, the shape of the returned output tensor follows the <a href="notes/broadcasting.html#broadcasting-semantics">broadcasting rules</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.2942, -0.7416,  0.2653, -0.1584])
&gt;&gt;&gt; b = torch.randn(4)
&gt;&gt;&gt; b
tensor([ 0.8722, -1.7421, -0.4141, -0.5055])
&gt;&gt;&gt; torch.max(a, b)
tensor([ 0.8722, -0.7416,  0.2653, -0.1584])

</code></pre>
<pre><code class="language-py">torch.min()
</code></pre>
<pre><code class="language-py">torch.min(input) → Tensor
</code></pre>
<p>Returns the minimum value of all elements in the <code>input</code> tensor.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(1, 3)
&gt;&gt;&gt; a
tensor([[ 0.6750,  1.0857,  1.7197]])
&gt;&gt;&gt; torch.min(a)
tensor(0.6750)

</code></pre>
<pre><code class="language-py">torch.min(input, dim, keepdim=False, out=None) -&gt; (Tensor, LongTensor)
</code></pre>
<p>Returns the minimum value of each row of the <code>input</code> tensor in the given dimension <code>dim</code>. The second return value is the index location of each minimum value found (argmin).</p>
<p>If <code>keepdim</code> is <code>True</code>, the output tensors are of the same size as <code>input</code> except in the dimension <code>dim</code> where they are of size 1. Otherwise, <code>dim</code> is squeezed (see <a href="#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a>), resulting in the output tensors having 1 fewer dimension than <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to reduce</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – whether the output tensors have <code>dim</code> retained or not</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the tuple of two output tensors (min, min_indices)</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[-0.6248,  1.1334, -1.1899, -0.2803],
 [-1.4644, -0.2635, -0.3651,  0.6134],
 [ 0.2457,  0.0384,  1.0128,  0.7015],
 [-0.1153,  2.9849,  2.1458,  0.5788]])
&gt;&gt;&gt; torch.min(a, 1)
(tensor([-1.1899, -1.4644,  0.0384, -0.1153]), tensor([ 2,  0,  1,  0]))

</code></pre>
<pre><code class="language-py">torch.min(input, other, out=None) → Tensor
</code></pre>
<p>Each element of the tensor <code>input</code> is compared with the corresponding element of the tensor <code>other</code> and an element-wise minimum is taken. The resulting tensor is returned.</p>
<p>The shapes of <code>input</code> and <code>other</code> don’t need to match, but they must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/173d7b4bb5cacbc18349fb16cd6130ab.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/173d7b4bb5cacbc18349fb16cd6130ab.jpg" alt=""></a></p>
<p>Note</p>
<p>When the shapes do not match, the shape of the returned output tensor follows the <a href="notes/broadcasting.html#broadcasting-semantics">broadcasting rules</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second input tensor</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4)
&gt;&gt;&gt; a
tensor([ 0.8137, -1.1740, -0.6460,  0.6308])
&gt;&gt;&gt; b = torch.randn(4)
&gt;&gt;&gt; b
tensor([-0.1369,  0.1555,  0.4019, -0.1929])
&gt;&gt;&gt; torch.min(a, b)
tensor([-0.1369, -1.1740, -0.6460, -0.1929])

</code></pre>
<pre><code class="language-py">torch.ne(input, other, out=None) → Tensor
</code></pre>
<p>Computes <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b7e900c499f533c33aac63d7b487c24.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b7e900c499f533c33aac63d7b487c24.jpg" alt=""></a> element-wise.</p>
<p>The second argument can be a number or a tensor whose shape is <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with the first argument.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to compare</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the tensor or value to compare</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor that must be a <code>ByteTensor</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A <code>torch.ByteTensor</code> containing a 1 at each location where comparison is true.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.ne(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
tensor([[ 0,  1],
 [ 1,  0]], dtype=torch.uint8)

</code></pre>
<pre><code class="language-py">torch.sort(input, dim=None, descending=False, out=None) -&gt; (Tensor, LongTensor)
</code></pre>
<p>Sorts the elements of the <code>input</code> tensor along a given dimension in ascending order by value.</p>
<p>If <code>dim</code> is not given, the last dimension of the <code>input</code> is chosen.</p>
<p>If <code>descending</code> is <code>True</code> then the elements are sorted in descending order by value.</p>
<p>A tuple of (sorted_tensor, sorted_indices) is returned, where the sorted_indices are the indices of the elements in the original <code>input</code> tensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the dimension to sort along</li>
<li><strong>descending</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls the sorting order (ascending or descending)</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the output tuple of (<code>Tensor</code>, <code>LongTensor</code>) that can be optionally given to be used as output buffers</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(3, 4)
&gt;&gt;&gt; sorted, indices = torch.sort(x)
&gt;&gt;&gt; sorted
tensor([[-0.2162,  0.0608,  0.6719,  2.3332],
 [-0.5793,  0.0061,  0.6058,  0.9497],
 [-0.5071,  0.3343,  0.9553,  1.0960]])
&gt;&gt;&gt; indices
tensor([[ 1,  0,  2,  3],
 [ 3,  1,  0,  2],
 [ 0,  3,  1,  2]])

&gt;&gt;&gt; sorted, indices = torch.sort(x, 0)
&gt;&gt;&gt; sorted
tensor([[-0.5071, -0.2162,  0.6719, -0.5793],
 [ 0.0608,  0.0061,  0.9497,  0.3343],
 [ 0.6058,  0.9553,  1.0960,  2.3332]])
&gt;&gt;&gt; indices
tensor([[ 2,  0,  0,  1],
 [ 0,  1,  1,  2],
 [ 1,  2,  2,  0]])

</code></pre>
<pre><code class="language-py">torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor)
</code></pre>
<p>Returns the <code>k</code> largest elements of the given <code>input</code> tensor along a given dimension.</p>
<p>If <code>dim</code> is not given, the last dimension of the <code>input</code> is chosen.</p>
<p>If <code>largest</code> is <code>False</code> then the <code>k</code> smallest elements are returned.</p>
<p>A tuple of <code>(values, indices)</code> is returned, where the <code>indices</code> are the indices of the elements in the original <code>input</code> tensor.</p>
<p>The boolean option <code>sorted</code> if <code>True</code>, will make sure that the returned <code>k</code> elements are themselves sorted</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>k</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the k in “top-k”</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the dimension to sort along</li>
<li><strong>largest</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return largest or smallest elements</li>
<li><strong>sorted</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return the elements in sorted order</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the output tuple of (Tensor, LongTensor) that can be optionally given to be used as output buffers</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.arange(1., 6.)
&gt;&gt;&gt; x
tensor([ 1.,  2.,  3.,  4.,  5.])
&gt;&gt;&gt; torch.topk(x, 3)
(tensor([ 5.,  4.,  3.]), tensor([ 4,  3,  2]))

</code></pre>
<h3 id="spectral-ops">Spectral Ops</h3>
<pre><code class="language-py">torch.fft(input, signal_ndim, normalized=False) → Tensor
</code></pre>
<p>Complex-to-complex Discrete Fourier Transform</p>
<p>This method computes the complex-to-complex discrete Fourier transform. Ignoring the batch dimensions, it computes the following expression:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5562db7e8cbd1caa591b84aef7d65178.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5562db7e8cbd1caa591b84aef7d65178.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a> = <code>signal_ndim</code> is number of dimensions for the signal, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" alt=""></a> is the size of signal dimension <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a>.</p>
<p>This method supports 1D, 2D and 3D complex-to-complex transforms, indicated by <code>signal_ndim</code>. <code>input</code> must be a tensor with last dimension of size 2, representing the real and imaginary components of complex numbers, and should have at least <code>signal_ndim + 1</code> dimensions with optionally arbitrary number of leading batch dimensions. If <code>normalized</code> is set to <code>True</code>, this normalizes the result by dividing it with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eee43fa49e4959712077ced4d4c25da3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eee43fa49e4959712077ced4d4c25da3.jpg" alt=""></a> so that the operator is unitary.</p>
<p>Returns the real and the imaginary parts together as one tensor of the same shape of <code>input</code>.</p>
<p>The inverse of this function is <a href="#torch.ifft" title="torch.ifft"><code>ifft()</code></a>.</p>
<p>Note</p>
<p>For CUDA tensors, an LRU cache is used for cuFFT plans to speed up repeatedly running FFT methods on tensors of same geometry with same same configuration.</p>
<p>Changing <code>torch.backends.cuda.cufft_plan_cache.max_size</code> (default is 4096 on CUDA 10 and newer, and 1023 on older CUDA versions) controls the capacity of this cache. Some cuFFT plans may allocate GPU memory. You can use <code>torch.backends.cuda.cufft_plan_cache.size</code> to query the number of plans currently in cache, and <code>torch.backends.cuda.cufft_plan_cache.clear()</code> to clear the cache.</p>
<p>Warning</p>
<p>For CPU tensors, this method is currently only available with MKL. Use <code>torch.backends.mkl.is_available()</code> to check if MKL is installed.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor of at least <code>signal_ndim</code> <code>+ 1</code> dimensions</li>
<li><strong>signal_ndim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of dimensions in each signal. <code>signal_ndim</code> can only be 1, 2 or 3</li>
<li><strong>normalized</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return normalized results. Default: <code>False</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tensor containing the complex-to-complex Fourier transform result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; # unbatched 2D FFT
&gt;&gt;&gt; x = torch.randn(4, 3, 2)
&gt;&gt;&gt; torch.fft(x, 2)
tensor([[[-0.0876,  1.7835],
 [-2.0399, -2.9754],
 [ 4.4773, -5.0119]],

 [[-1.5716,  2.7631],
 [-3.8846,  5.2652],
 [ 0.2046, -0.7088]],

 [[ 1.9938, -0.5901],
 [ 6.5637,  6.4556],
 [ 2.9865,  4.9318]],

 [[ 7.0193,  1.1742],
 [-1.3717, -2.1084],
 [ 2.0289,  2.9357]]])
&gt;&gt;&gt; # batched 1D FFT
&gt;&gt;&gt; torch.fft(x, 1)
tensor([[[ 1.8385,  1.2827],
 [-0.1831,  1.6593],
 [ 2.4243,  0.5367]],

 [[-0.9176, -1.5543],
 [-3.9943, -2.9860],
 [ 1.2838, -2.9420]],

 [[-0.8854, -0.6860],
 [ 2.4450,  0.0808],
 [ 1.3076, -0.5768]],

 [[-0.1231,  2.7411],
 [-0.3075, -1.7295],
 [-0.5384, -2.0299]]])
&gt;&gt;&gt; # arbitrary number of batch dimensions, 2D FFT
&gt;&gt;&gt; x = torch.randn(3, 3, 5, 5, 2)
&gt;&gt;&gt; y = torch.fft(x, 2)
&gt;&gt;&gt; y.shape
torch.Size([3, 3, 5, 5, 2])

</code></pre>
<pre><code class="language-py">torch.ifft(input, signal_ndim, normalized=False) → Tensor
</code></pre>
<p>Complex-to-complex Inverse Discrete Fourier Transform</p>
<p>This method computes the complex-to-complex inverse discrete Fourier transform. Ignoring the batch dimensions, it computes the following expression:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/014337971856a1c52bd1bc756aa262b6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/014337971856a1c52bd1bc756aa262b6.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a> = <code>signal_ndim</code> is number of dimensions for the signal, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" alt=""></a> is the size of signal dimension <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a>.</p>
<p>The argument specifications are almost identical with <a href="#torch.fft" title="torch.fft"><code>fft()</code></a>. However, if <code>normalized</code> is set to <code>True</code>, this instead returns the results multiplied by <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/363cf16ec847125aff9d3c88189beea7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/363cf16ec847125aff9d3c88189beea7.jpg" alt=""></a>, to become a unitary operator. Therefore, to invert a <a href="#torch.fft" title="torch.fft"><code>fft()</code></a>, the <code>normalized</code> argument should be set identically for <a href="#torch.fft" title="torch.fft"><code>fft()</code></a>.</p>
<p>Returns the real and the imaginary parts together as one tensor of the same shape of <code>input</code>.</p>
<p>The inverse of this function is <a href="#torch.fft" title="torch.fft"><code>fft()</code></a>.</p>
<p>Note</p>
<p>For CUDA tensors, an LRU cache is used for cuFFT plans to speed up repeatedly running FFT methods on tensors of same geometry with same same configuration.</p>
<p>Changing <code>torch.backends.cuda.cufft_plan_cache.max_size</code> (default is 4096 on CUDA 10 and newer, and 1023 on older CUDA versions) controls the capacity of this cache. Some cuFFT plans may allocate GPU memory. You can use <code>torch.backends.cuda.cufft_plan_cache.size</code> to query the number of plans currently in cache, and <code>torch.backends.cuda.cufft_plan_cache.clear()</code> to clear the cache.</p>
<p>Warning</p>
<p>For CPU tensors, this method is currently only available with MKL. Use <code>torch.backends.mkl.is_available()</code> to check if MKL is installed.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor of at least <code>signal_ndim</code> <code>+ 1</code> dimensions</li>
<li><strong>signal_ndim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of dimensions in each signal. <code>signal_ndim</code> can only be 1, 2 or 3</li>
<li><strong>normalized</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return normalized results. Default: <code>False</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tensor containing the complex-to-complex inverse Fourier transform result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(3, 3, 2)
&gt;&gt;&gt; x
tensor([[[ 1.2766,  1.3680],
 [-0.8337,  2.0251],
 [ 0.9465, -1.4390]],

 [[-0.1890,  1.6010],
 [ 1.1034, -1.9230],
 [-0.9482,  1.0775]],

 [[-0.7708, -0.8176],
 [-0.1843, -0.2287],
 [-1.9034, -0.2196]]])
&gt;&gt;&gt; y = torch.fft(x, 2)
&gt;&gt;&gt; torch.ifft(y, 2)  # recover x
tensor([[[ 1.2766,  1.3680],
 [-0.8337,  2.0251],
 [ 0.9465, -1.4390]],

 [[-0.1890,  1.6010],
 [ 1.1034, -1.9230],
 [-0.9482,  1.0775]],

 [[-0.7708, -0.8176],
 [-0.1843, -0.2287],
 [-1.9034, -0.2196]]])

</code></pre>
<pre><code class="language-py">torch.rfft(input, signal_ndim, normalized=False, onesided=True) → Tensor
</code></pre>
<p>Real-to-complex Discrete Fourier Transform</p>
<p>This method computes the real-to-complex discrete Fourier transform. It is mathematically equivalent with <a href="#torch.fft" title="torch.fft"><code>fft()</code></a> with differences only in formats of the input and output.</p>
<p>This method supports 1D, 2D and 3D real-to-complex transforms, indicated by <code>signal_ndim</code>. <code>input</code> must be a tensor with at least <code>signal_ndim</code> dimensions with optionally arbitrary number of leading batch dimensions. If <code>normalized</code> is set to <code>True</code>, this normalizes the result by dividing it with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eee43fa49e4959712077ced4d4c25da3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eee43fa49e4959712077ced4d4c25da3.jpg" alt=""></a> so that the operator is unitary, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" alt=""></a> is the size of signal dimension <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a>.</p>
<p>The real-to-complex Fourier transform results follow conjugate symmetry:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5ea82a4989c8b43517e53dc795d5516.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f5ea82a4989c8b43517e53dc795d5516.jpg" alt=""></a></p>
<p>where the index arithmetic is computed modulus the size of the corresponding dimension, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b57c343978b88489065e0d2443349ae0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b57c343978b88489065e0d2443349ae0.jpg" alt=""></a> is the conjugate operator, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a> = <code>signal_ndim</code>. <code>onesided</code> flag controls whether to avoid redundancy in the output results. If set to <code>True</code> (default), the output will not be full complex result of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d0cb8b79768b92645994f059e281aaca.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d0cb8b79768b92645994f059e281aaca.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> is the shape of <code>input</code>, but instead the last dimension will be halfed as of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/baa9baa3b9c79a896640a3f7c20deb1c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/baa9baa3b9c79a896640a3f7c20deb1c.jpg" alt=""></a>.</p>
<p>The inverse of this function is <a href="#torch.irfft" title="torch.irfft"><code>irfft()</code></a>.</p>
<p>Note</p>
<p>For CUDA tensors, an LRU cache is used for cuFFT plans to speed up repeatedly running FFT methods on tensors of same geometry with same same configuration.</p>
<p>Changing <code>torch.backends.cuda.cufft_plan_cache.max_size</code> (default is 4096 on CUDA 10 and newer, and 1023 on older CUDA versions) controls the capacity of this cache. Some cuFFT plans may allocate GPU memory. You can use <code>torch.backends.cuda.cufft_plan_cache.size</code> to query the number of plans currently in cache, and <code>torch.backends.cuda.cufft_plan_cache.clear()</code> to clear the cache.</p>
<p>Warning</p>
<p>For CPU tensors, this method is currently only available with MKL. Use <code>torch.backends.mkl.is_available()</code> to check if MKL is installed.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor of at least <code>signal_ndim</code> dimensions</li>
<li><strong>signal_ndim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of dimensions in each signal. <code>signal_ndim</code> can only be 1, 2 or 3</li>
<li><strong>normalized</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return normalized results. Default: <code>False</code></li>
<li><strong>onesided</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return half of results to avoid redundancy. Default: <code>True</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tensor containing the real-to-complex Fourier transform result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(5, 5)
&gt;&gt;&gt; torch.rfft(x, 2).shape
torch.Size([5, 3, 2])
&gt;&gt;&gt; torch.rfft(x, 2, onesided=False).shape
torch.Size([5, 5, 2])

</code></pre>
<pre><code class="language-py">torch.irfft(input, signal_ndim, normalized=False, onesided=True, signal_sizes=None) → Tensor
</code></pre>
<p>Complex-to-real Inverse Discrete Fourier Transform</p>
<p>This method computes the complex-to-real inverse discrete Fourier transform. It is mathematically equivalent with <a href="#torch.ifft" title="torch.ifft"><code>ifft()</code></a> with differences only in formats of the input and output.</p>
<p>The argument specifications are almost identical with <a href="#torch.ifft" title="torch.ifft"><code>ifft()</code></a>. Similar to <a href="#torch.ifft" title="torch.ifft"><code>ifft()</code></a>, if <code>normalized</code> is set to <code>True</code>, this normalizes the result by multiplying it with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eee43fa49e4959712077ced4d4c25da3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eee43fa49e4959712077ced4d4c25da3.jpg" alt=""></a> so that the operator is unitary, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4236d8cccece7d17f3a004865adbf94d.jpg" alt=""></a> is the size of signal dimension <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/31df9c730e19ca29b59dce64b99d98c1.jpg" alt=""></a>.</p>
<p>Due to the conjugate symmetry, <code>input</code> do not need to contain the full complex frequency values. Roughly half of the values will be sufficient, as is the case when <code>input</code> is given by <a href="#torch.rfft" title="torch.rfft"><code>rfft()</code></a> with <code>rfft(signal, onesided=True)</code>. In such case, set the <code>onesided</code> argument of this method to <code>True</code>. Moreover, the original signal shape information can sometimes be lost, optionally set <code>signal_sizes</code> to be the size of the original signal (without the batch dimensions if in batched mode) to recover it with correct shape.</p>
<p>Therefore, to invert an <a href="#torch.rfft" title="torch.rfft"><code>rfft()</code></a>, the <code>normalized</code> and <code>onesided</code> arguments should be set identically for <a href="#torch.irfft" title="torch.irfft"><code>irfft()</code></a>, and preferrably a <code>signal_sizes</code> is given to avoid size mismatch. See the example below for a case of size mismatch.</p>
<p>See <a href="#torch.rfft" title="torch.rfft"><code>rfft()</code></a> for details on conjugate symmetry.</p>
<p>The inverse of this function is <a href="#torch.rfft" title="torch.rfft"><code>rfft()</code></a>.</p>
<p>Warning</p>
<p>Generally speaking, the input of this function should contain values following conjugate symmetry. Note that even if <code>onesided</code> is <code>True</code>, often symmetry on some part is still needed. When this requirement is not satisfied, the behavior of <a href="#torch.irfft" title="torch.irfft"><code>irfft()</code></a> is undefined. Since <a href="autograd.html#torch.autograd.gradcheck" title="torch.autograd.gradcheck"><code>torch.autograd.gradcheck()</code></a> estimates numerical Jacobian with point perturbations, <a href="#torch.irfft" title="torch.irfft"><code>irfft()</code></a> will almost certainly fail the check.</p>
<p>Note</p>
<p>For CUDA tensors, an LRU cache is used for cuFFT plans to speed up repeatedly running FFT methods on tensors of same geometry with same same configuration.</p>
<p>Changing <code>torch.backends.cuda.cufft_plan_cache.max_size</code> (default is 4096 on CUDA 10 and newer, and 1023 on older CUDA versions) controls the capacity of this cache. Some cuFFT plans may allocate GPU memory. You can use <code>torch.backends.cuda.cufft_plan_cache.size</code> to query the number of plans currently in cache, and <code>torch.backends.cuda.cufft_plan_cache.clear()</code> to clear the cache.</p>
<p>Warning</p>
<p>For CPU tensors, this method is currently only available with MKL. Use <code>torch.backends.mkl.is_available()</code> to check if MKL is installed.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor of at least <code>signal_ndim</code> <code>+ 1</code> dimensions</li>
<li><strong>signal_ndim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of dimensions in each signal. <code>signal_ndim</code> can only be 1, 2 or 3</li>
<li><strong>normalized</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return normalized results. Default: <code>False</code></li>
<li><strong>onesided</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether <code>input</code> was halfed to avoid redundancy, e.g., by <a href="#torch.rfft" title="torch.rfft"><code>rfft()</code></a>. Default: <code>True</code></li>
<li><strong>signal_sizes</strong> (list or <code>torch.Size</code>, optional) – the size of the original signal (without batch dimension). Default: <code>None</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tensor containing the complex-to-real inverse Fourier transform result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(4, 4)
&gt;&gt;&gt; torch.rfft(x, 2, onesided=True).shape
torch.Size([4, 3, 2])
&gt;&gt;&gt;
&gt;&gt;&gt; # notice that with onesided=True, output size does not determine the original signal size
&gt;&gt;&gt; x = torch.randn(4, 5)

&gt;&gt;&gt; torch.rfft(x, 2, onesided=True).shape
torch.Size([4, 3, 2])
&gt;&gt;&gt;
&gt;&gt;&gt; # now we use the original shape to recover x
&gt;&gt;&gt; x
tensor([[-0.8992,  0.6117, -1.6091, -0.4155, -0.8346],
 [-2.1596, -0.0853,  0.7232,  0.1941, -0.0789],
 [-2.0329,  1.1031,  0.6869, -0.5042,  0.9895],
 [-0.1884,  0.2858, -1.5831,  0.9917, -0.8356]])
&gt;&gt;&gt; y = torch.rfft(x, 2, onesided=True)
&gt;&gt;&gt; torch.irfft(y, 2, onesided=True, signal_sizes=x.shape)  # recover x
tensor([[-0.8992,  0.6117, -1.6091, -0.4155, -0.8346],
 [-2.1596, -0.0853,  0.7232,  0.1941, -0.0789],
 [-2.0329,  1.1031,  0.6869, -0.5042,  0.9895],
 [-0.1884,  0.2858, -1.5831,  0.9917, -0.8356]])

</code></pre>
<pre><code class="language-py">torch.stft(input, n_fft, hop_length=None, win_length=None, window=None, center=True, pad_mode='reflect', normalized=False, onesided=True)
</code></pre>
<p>Short-time Fourier transform (STFT).</p>
<p>Ignoring the optional batch dimension, this method computes the following expression:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b0732a4ca07b0a4bbb1c8e42755dd635.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b0732a4ca07b0a4bbb1c8e42755dd635.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" alt=""></a> is the index of the sliding window, and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fbd51655b696eb58cdc3e2a85d8138d3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fbd51655b696eb58cdc3e2a85d8138d3.jpg" alt=""></a> is the frequency that <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/309b97f749e9d19a615ef66fdc686f9f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/309b97f749e9d19a615ef66fdc686f9f.jpg" alt=""></a>. When <code>onesided</code> is the default value <code>True</code>,</p>
<ul>
<li><code>input</code> must be either a 1-D time sequence or a 2-D batch of time sequences.</li>
<li>If <code>hop_length</code> is <code>None</code> (default), it is treated as equal to <code>floor(n_fft / 4)</code>.</li>
<li>If <code>win_length</code> is <code>None</code> (default), it is treated as equal to <code>n_fft</code>.</li>
<li><code>window</code> can be a 1-D tensor of size <code>win_length</code>, e.g., from <a href="#torch.hann_window" title="torch.hann_window"><code>torch.hann_window()</code></a>. If <code>window</code> is <code>None</code> (default), it is treated as if having <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" alt=""></a> everywhere in the window. If <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6331c460bba556da5e58d69a99aa834e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6331c460bba556da5e58d69a99aa834e.jpg" alt=""></a>, <code>window</code> will be padded on both sides to length <code>n_fft</code> before being applied.</li>
<li>If <code>center</code> is <code>True</code> (default), <code>input</code> will be padded on both sides so that the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/654b00d1036ba7f7d93e02f57fc00a75.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/654b00d1036ba7f7d93e02f57fc00a75.jpg" alt=""></a>-th frame is centered at time <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fca268610b657c34819b28d98ed12232.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fca268610b657c34819b28d98ed12232.jpg" alt=""></a>. Otherwise, the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/654b00d1036ba7f7d93e02f57fc00a75.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/654b00d1036ba7f7d93e02f57fc00a75.jpg" alt=""></a>-th frame begins at time <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fca268610b657c34819b28d98ed12232.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fca268610b657c34819b28d98ed12232.jpg" alt=""></a>.</li>
<li><code>pad_mode</code> determines the padding method used on <code>input</code> when <code>center</code> is <code>True</code>. See <a href="nn.html#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a> for all available options. Default is <code>"reflect"</code>.</li>
<li>If <code>onesided</code> is <code>True</code> (default), only values for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fbd51655b696eb58cdc3e2a85d8138d3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fbd51655b696eb58cdc3e2a85d8138d3.jpg" alt=""></a> in <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/960f7132c51380d407edbfffa1d01db2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/960f7132c51380d407edbfffa1d01db2.jpg" alt=""></a> are returned because the real-to-complex Fourier transform satisfies the conjugate symmetry, i.e., <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5fce0cf9e58e0a0a71eb6931ade5e784.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5fce0cf9e58e0a0a71eb6931ade5e784.jpg" alt=""></a>.</li>
<li>If <code>normalized</code> is <code>True</code> (default is <code>False</code>), the function returns the normalized STFT results, i.e., multiplied by <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/207c21435d21c4bdec529a2f3b922bff.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/207c21435d21c4bdec529a2f3b922bff.jpg" alt=""></a>.</li>
</ul>
<p>Returns the real and the imaginary parts together as one tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a272f1ebb738ea28a82ccb05e4284b0d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a272f1ebb738ea28a82ccb05e4284b0d.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> is the optional batch size of <code>input</code>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the number of frequencies where STFT is applied, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5a047a5ca04e45726dba21b8302977da.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5a047a5ca04e45726dba21b8302977da.jpg" alt=""></a> is the total number of frames used, and each pair in the last dimension represents a complex number as the real part and the imaginary part.</p>
<p>Warning</p>
<p>This function changed signature at version 0.4.1. Calling with the previous signature may cause error or return incorrect result.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>n_fft</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – size of Fourier transform</li>
<li><strong>hop_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the distance between neighboring sliding window frames. Default: <code>None</code> (treated as equal to <code>floor(n_fft / 4)</code>)</li>
<li><strong>win_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the size of window frame and STFT filter. Default: <code>None</code> (treated as equal to <code>n_fft</code>)</li>
<li><strong>window</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the optional window function. Default: <code>None</code> (treated as window of all <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" alt=""></a> s)</li>
<li><strong>center</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether to pad <code>input</code> on both sides so that the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/654b00d1036ba7f7d93e02f57fc00a75.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/654b00d1036ba7f7d93e02f57fc00a75.jpg" alt=""></a>-th frame is centered at time <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fca268610b657c34819b28d98ed12232.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fca268610b657c34819b28d98ed12232.jpg" alt=""></a>. Default: <code>True</code></li>
<li><strong>pad_mode</strong> (<em>string</em>_,_ <em>optional</em>) – controls the padding method used when <code>center</code> is <code>True</code>. Default: <code>"reflect"</code></li>
<li><strong>normalized</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return the normalized STFT results Default: <code>False</code></li>
<li><strong>onesided</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether to return half of results to avoid redundancy Default: <code>True</code></li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tensor containing the STFT result with shape described above</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">torch.bartlett_window(window_length, periodic=True, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Bartlett window function.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/25485c0c544da57274d0f702ecfbec35.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/25485c0c544da57274d0f702ecfbec35.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the full window size.</p>
<p>The input <code>window_length</code> is a positive integer controlling the returned window size. <code>periodic</code> flag determines whether the returned window trims off the last duplicate value from the symmetric window and is ready to be used as a periodic window with functions like <a href="#torch.stft" title="torch.stft"><code>torch.stft()</code></a>. Therefore, if <code>periodic</code> is true, the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> in above formula is in fact <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" alt=""></a>. Also, we always have <code>torch.bartlett_window(L, periodic=True)</code> equal to <code>torch.bartlett_window(L + 1, periodic=False)[:-1])</code>.</p>
<p>Note</p>
<p>If <code>window_length</code> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" alt=""></a>, the returned window contains a single value 1.</p>
<p>Parameters:</p>
<ul>
<li><strong>window_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of returned window</li>
<li><strong>periodic</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If True, returns a window to be used as periodic function. If False, return a symmetric window.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). Only floating point types are supported.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned window tensor. Only <code>torch.strided</code> (dense layout) is supported.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A 1-D tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" alt=""></a> containing the window</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">torch.blackman_window(window_length, periodic=True, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Blackman window function.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5677fb096f4cdf5ffeb86c4d3646067a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5677fb096f4cdf5ffeb86c4d3646067a.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the full window size.</p>
<p>The input <code>window_length</code> is a positive integer controlling the returned window size. <code>periodic</code> flag determines whether the returned window trims off the last duplicate value from the symmetric window and is ready to be used as a periodic window with functions like <a href="#torch.stft" title="torch.stft"><code>torch.stft()</code></a>. Therefore, if <code>periodic</code> is true, the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> in above formula is in fact <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" alt=""></a>. Also, we always have <code>torch.blackman_window(L, periodic=True)</code> equal to <code>torch.blackman_window(L + 1, periodic=False)[:-1])</code>.</p>
<p>Note</p>
<p>If <code>window_length</code> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" alt=""></a>, the returned window contains a single value 1.</p>
<p>Parameters:</p>
<ul>
<li><strong>window_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of returned window</li>
<li><strong>periodic</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If True, returns a window to be used as periodic function. If False, return a symmetric window.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). Only floating point types are supported.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned window tensor. Only <code>torch.strided</code> (dense layout) is supported.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A 1-D tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" alt=""></a> containing the window</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">torch.hamming_window(window_length, periodic=True, alpha=0.54, beta=0.46, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Hamming window function.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6ef50ea7103d4d74ef7919bfc2edf193.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6ef50ea7103d4d74ef7919bfc2edf193.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the full window size.</p>
<p>The input <code>window_length</code> is a positive integer controlling the returned window size. <code>periodic</code> flag determines whether the returned window trims off the last duplicate value from the symmetric window and is ready to be used as a periodic window with functions like <a href="#torch.stft" title="torch.stft"><code>torch.stft()</code></a>. Therefore, if <code>periodic</code> is true, the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> in above formula is in fact <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" alt=""></a>. Also, we always have <code>torch.hamming_window(L, periodic=True)</code> equal to <code>torch.hamming_window(L + 1, periodic=False)[:-1])</code>.</p>
<p>Note</p>
<p>If <code>window_length</code> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" alt=""></a>, the returned window contains a single value 1.</p>
<p>Note</p>
<p>This is a generalized version of <a href="#torch.hann_window" title="torch.hann_window"><code>torch.hann_window()</code></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>window_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of returned window</li>
<li><strong>periodic</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If True, returns a window to be used as periodic function. If False, return a symmetric window.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). Only floating point types are supported.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned window tensor. Only <code>torch.strided</code> (dense layout) is supported.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A 1-D tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" alt=""></a> containing the window</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">torch.hann_window(window_length, periodic=True, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
</code></pre>
<p>Hann window function.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3574793e8ae7241ce6a84e44a219b914.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3574793e8ae7241ce6a84e44a219b914.jpg" alt=""></a></p>
<p>where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is the full window size.</p>
<p>The input <code>window_length</code> is a positive integer controlling the returned window size. <code>periodic</code> flag determines whether the returned window trims off the last duplicate value from the symmetric window and is ready to be used as a periodic window with functions like <a href="#torch.stft" title="torch.stft"><code>torch.stft()</code></a>. Therefore, if <code>periodic</code> is true, the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> in above formula is in fact <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8ec5251e790c02993c5bb875e109ed2c.jpg" alt=""></a>. Also, we always have <code>torch.hann_window(L, periodic=True)</code> equal to <code>torch.hann_window(L + 1, periodic=False)[:-1])</code>.</p>
<p>Note</p>
<p>If <code>window_length</code> <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b32b16dc37b80bf97e00ad0589be346b.jpg" alt=""></a>, the returned window contains a single value 1.</p>
<p>Parameters:</p>
<ul>
<li><strong>window_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of returned window</li>
<li><strong>periodic</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If True, returns a window to be used as periodic function. If False, return a symmetric window.</li>
<li><strong>dtype</strong> (<a href="tensor_attributes.html#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). Only floating point types are supported.</li>
<li><strong>layout</strong> (<a href="tensor_attributes.html#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a>, optional) – the desired layout of returned window tensor. Only <code>torch.strided</code> (dense layout) is supported.</li>
<li><strong>device</strong> (<a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a href="#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A 1-D tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d7e55488941e3a1a5ac791b70ccda5f.jpg" alt=""></a> containing the window</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<h3 id="other-operations">Other Operations</h3>
<pre><code class="language-py">torch.bincount(self, weights=None, minlength=0) → Tensor
</code></pre>
<p>Count the frequency of each value in an array of non-negative ints.</p>
<p>The number of bins (size 1) is one larger than the largest value in <code>input</code> unless <code>input</code> is empty, in which case the result is a tensor of size 0. If <code>minlength</code> is specified, the number of bins is at least <code>minlength</code> and if <code>input</code> is empty, then the result is tensor of size <code>minlength</code> filled with zeros. If <code>n</code> is the value at position <code>i</code>, <code>out[n] += weights[i]</code> if <code>weights</code> is specified else <code>out[n] += 1</code>.</p>
<p>Note</p>
<p>When using the CUDA backend, this operation may induce nondeterministic behaviour that is not easily switched off. Please see the notes on <a href="notes/randomness.html">Reproducibility</a> for background.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 1-d int tensor</li>
<li><strong>weights</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – optional, weight for each value in the input tensor. Should be of same size as input tensor.</li>
<li><strong>minlength</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – optional, minimum number of bins. Should be non-negative.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>a tensor of shape <code>Size([max(input) + 1])</code> if <code>input</code> is non-empty, else <code>Size(0)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td>output (<a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>)</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.randint(0, 8, (5,), dtype=torch.int64)
&gt;&gt;&gt; weights = torch.linspace(0, 1, steps=5)
&gt;&gt;&gt; input, weights
(tensor([4, 3, 6, 3, 4]),
 tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])

&gt;&gt;&gt; torch.bincount(input)
tensor([0, 0, 0, 2, 2, 0, 1])

&gt;&gt;&gt; input.bincount(weights)
tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])

</code></pre>
<pre><code class="language-py">torch.broadcast_tensors(*tensors) → List of Tensors
</code></pre>
<p>Broadcasts the given tensors according to _broadcasting-semantics.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th>*<strong>tensors</strong> – any number of tensors of the same type</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.arange(3).view(1, 3)
&gt;&gt;&gt; y = torch.arange(2).view(2, 1)
&gt;&gt;&gt; a, b = torch.broadcast_tensors(x, y)
&gt;&gt;&gt; a.size()
torch.Size([2, 3])
&gt;&gt;&gt; a
tensor([[0, 1, 2],
 [0, 1, 2]])

</code></pre>
<pre><code class="language-py">torch.cross(input, other, dim=-1, out=None) → Tensor
</code></pre>
<p>Returns the cross product of vectors in dimension <code>dim</code> of <code>input</code> and <code>other</code>.</p>
<p><code>input</code> and <code>other</code> must have the same size, and the size of their <code>dim</code> dimension should be 3.</p>
<p>If <code>dim</code> is not given, it defaults to the first dimension found with the size 3.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>other</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second input tensor</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the dimension to take the cross-product in.</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(4, 3)
&gt;&gt;&gt; a
tensor([[-0.3956,  1.1455,  1.6895],
 [-0.5849,  1.3672,  0.3599],
 [-1.1626,  0.7180, -0.0521],
 [-0.1339,  0.9902, -2.0225]])
&gt;&gt;&gt; b = torch.randn(4, 3)
&gt;&gt;&gt; b
tensor([[-0.0257, -1.4725, -1.2251],
 [-1.1479, -0.7005, -1.9757],
 [-1.3904,  0.3726, -1.1836],
 [-0.9688, -0.7153,  0.2159]])
&gt;&gt;&gt; torch.cross(a, b, dim=1)
tensor([[ 1.0844, -0.5281,  0.6120],
 [-2.4490, -1.5687,  1.9792],
 [-0.8304, -1.3037,  0.5650],
 [-1.2329,  1.9883,  1.0551]])
&gt;&gt;&gt; torch.cross(a, b)
tensor([[ 1.0844, -0.5281,  0.6120],
 [-2.4490, -1.5687,  1.9792],
 [-0.8304, -1.3037,  0.5650],
 [-1.2329,  1.9883,  1.0551]])

</code></pre>
<pre><code class="language-py">torch.diag(input, diagonal=0, out=None) → Tensor
</code></pre>
<ul>
<li>If <code>input</code> is a vector (1-D tensor), then returns a 2-D square tensor with the elements of <code>input</code> as the diagonal.</li>
<li>If <code>input</code> is a matrix (2-D tensor), then returns a 1-D tensor with the diagonal elements of <code>input</code>.</li>
</ul>
<p>The argument <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> controls which diagonal to consider:</p>
<ul>
<li>If <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> = 0, it is the main diagonal.</li>
<li>If <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> &gt; 0, it is above the main diagonal.</li>
<li>If <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> &lt; 0, it is below the main diagonal.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>diagonal</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the diagonal to consider</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>See also</p>
<p><a href="#torch.diagonal" title="torch.diagonal"><code>torch.diagonal()</code></a> always returns the diagonal of its input.</p>
<p><a href="#torch.diagflat" title="torch.diagflat"><code>torch.diagflat()</code></a> always constructs a tensor with diagonal elements specified by the input.</p>
<p>Examples:</p>
<p>Get the square matrix where the input vector is the diagonal:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3)
&gt;&gt;&gt; a
tensor([ 0.5950,-0.0872, 2.3298])
&gt;&gt;&gt; torch.diag(a)
tensor([[ 0.5950, 0.0000, 0.0000],
 [ 0.0000,-0.0872, 0.0000],
 [ 0.0000, 0.0000, 2.3298]])
&gt;&gt;&gt; torch.diag(a, 1)
tensor([[ 0.0000, 0.5950, 0.0000, 0.0000],
 [ 0.0000, 0.0000,-0.0872, 0.0000],
 [ 0.0000, 0.0000, 0.0000, 2.3298],
 [ 0.0000, 0.0000, 0.0000, 0.0000]])

</code></pre>
<p>Get the k-th diagonal of a given matrix:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a
tensor([[-0.4264, 0.0255,-0.1064],
 [ 0.8795,-0.2429, 0.1374],
 [ 0.1029,-0.6482,-1.6300]])
&gt;&gt;&gt; torch.diag(a, 0)
tensor([-0.4264,-0.2429,-1.6300])
&gt;&gt;&gt; torch.diag(a, 1)
tensor([ 0.0255, 0.1374])

</code></pre>
<pre><code class="language-py">torch.diag_embed(input, offset=0, dim1=-2, dim2=-1) → Tensor
</code></pre>
<p>Creates a tensor whose diagonals of certain 2D planes (specified by <code>dim1</code> and <code>dim2</code>) are filled by <code>input</code>. To facilitate creating batched diagonal matrices, the 2D planes formed by the last two dimensions of the returned tensor are chosen by default.</p>
<p>The argument <code>offset</code> controls which diagonal to consider:</p>
<ul>
<li>If <code>offset</code> = 0, it is the main diagonal.</li>
<li>If <code>offset</code> &gt; 0, it is above the main diagonal.</li>
<li>If <code>offset</code> &lt; 0, it is below the main diagonal.</li>
</ul>
<p>The size of the new matrix will be calculated to make the specified diagonal of the size of the last input dimension. Note that for <code>offset</code> other than <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28256dd5af833c877d63bfabfaa7b301.jpg" alt=""></a>, the order of <code>dim1</code> and <code>dim2</code> matters. Exchanging them is equivalent to changing the sign of <code>offset</code>.</p>
<p>Applying <a href="#torch.diagonal" title="torch.diagonal"><code>torch.diagonal()</code></a> to the output of this function with the same arguments yields a matrix identical to input. However, <a href="#torch.diagonal" title="torch.diagonal"><code>torch.diagonal()</code></a> has different default dimensions, so those need to be explicitly specified.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor. Must be at least 1-dimensional.</li>
<li><strong>offset</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – which diagonal to consider. Default: 0 (main diagonal).</li>
<li><strong>dim1</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – first dimension with respect to which to take diagonal. Default: -2.</li>
<li><strong>dim2</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – second dimension with respect to which to take diagonal. Default: -1.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(2, 3)
&gt;&gt;&gt; torch.diag_embed(a)
tensor([[[ 1.5410,  0.0000,  0.0000],
 [ 0.0000, -0.2934,  0.0000],
 [ 0.0000,  0.0000, -2.1788]],

 [[ 0.5684,  0.0000,  0.0000],
 [ 0.0000, -1.0845,  0.0000],
 [ 0.0000,  0.0000, -1.3986]]])

&gt;&gt;&gt; torch.diag_embed(a, offset=1, dim1=0, dim2=2)
tensor([[[ 0.0000,  1.5410,  0.0000,  0.0000],
 [ 0.0000,  0.5684,  0.0000,  0.0000]],

 [[ 0.0000,  0.0000, -0.2934,  0.0000],
 [ 0.0000,  0.0000, -1.0845,  0.0000]],

 [[ 0.0000,  0.0000,  0.0000, -2.1788],
 [ 0.0000,  0.0000,  0.0000, -1.3986]],

 [[ 0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000]]])

</code></pre>
<pre><code class="language-py">torch.diagflat(input, diagonal=0) → Tensor
</code></pre>
<ul>
<li>If <code>input</code> is a vector (1-D tensor), then returns a 2-D square tensor with the elements of <code>input</code> as the diagonal.</li>
<li>If <code>input</code> is a tensor with more than one dimension, then returns a 2-D tensor with diagonal elements equal to a flattened <code>input</code>.</li>
</ul>
<p>The argument <code>offset</code> controls which diagonal to consider:</p>
<ul>
<li>If <code>offset</code> = 0, it is the main diagonal.</li>
<li>If <code>offset</code> &gt; 0, it is above the main diagonal.</li>
<li>If <code>offset</code> &lt; 0, it is below the main diagonal.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>offset</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the diagonal to consider. Default: 0 (main diagonal).</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3)
&gt;&gt;&gt; a
tensor([-0.2956, -0.9068,  0.1695])
&gt;&gt;&gt; torch.diagflat(a)
tensor([[-0.2956,  0.0000,  0.0000],
 [ 0.0000, -0.9068,  0.0000],
 [ 0.0000,  0.0000,  0.1695]])
&gt;&gt;&gt; torch.diagflat(a, 1)
tensor([[ 0.0000, -0.2956,  0.0000,  0.0000],
 [ 0.0000,  0.0000, -0.9068,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.1695],
 [ 0.0000,  0.0000,  0.0000,  0.0000]])

&gt;&gt;&gt; a = torch.randn(2, 2)
&gt;&gt;&gt; a
tensor([[ 0.2094, -0.3018],
 [-0.1516,  1.9342]])
&gt;&gt;&gt; torch.diagflat(a)
tensor([[ 0.2094,  0.0000,  0.0000,  0.0000],
 [ 0.0000, -0.3018,  0.0000,  0.0000],
 [ 0.0000,  0.0000, -0.1516,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  1.9342]])

</code></pre>
<pre><code class="language-py">torch.diagonal(input, offset=0, dim1=0, dim2=1) → Tensor
</code></pre>
<p>Returns a partial view of <code>input</code> with the its diagonal elements with respect to <code>dim1</code> and <code>dim2</code> appended as a dimension at the end of the shape.</p>
<p>The argument <code>offset</code> controls which diagonal to consider:</p>
<ul>
<li>If <code>offset</code> = 0, it is the main diagonal.</li>
<li>If <code>offset</code> &gt; 0, it is above the main diagonal.</li>
<li>If <code>offset</code> &lt; 0, it is below the main diagonal.</li>
</ul>
<p>Applying <a href="#torch.diag_embed" title="torch.diag_embed"><code>torch.diag_embed()</code></a> to the output of this function with the same arguments yields a diagonal matrix with the diagonal entries of the input. However, <a href="#torch.diag_embed" title="torch.diag_embed"><code>torch.diag_embed()</code></a> has different default dimensions, so those need to be explicitly specified.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor. Must be at least 2-dimensional.</li>
<li><strong>offset</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – which diagonal to consider. Default: 0 (main diagonal).</li>
<li><strong>dim1</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – first dimension with respect to which to take diagonal. Default: 0.</li>
<li><strong>dim2</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – second dimension with respect to which to take diagonal. Default: 1.</li>
</ul>
<p>Note</p>
<p>To take a batch diagonal, pass in dim1=-2, dim2=-1.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a
tensor([[-1.0854,  1.1431, -0.1752],
 [ 0.8536, -0.0905,  0.0360],
 [ 0.6927, -0.3735, -0.4945]])

&gt;&gt;&gt; torch.diagonal(a, 0)
tensor([-1.0854, -0.0905, -0.4945])

&gt;&gt;&gt; torch.diagonal(a, 1)
tensor([ 1.1431,  0.0360])

&gt;&gt;&gt; x = torch.randn(2, 5, 4, 2)
&gt;&gt;&gt; torch.diagonal(x, offset=-1, dim1=1, dim2=2)
tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],
 [-1.1065,  1.0401, -0.2235, -0.7938]],

 [[-1.7325, -0.3081,  0.6166,  0.2335],
 [ 1.0500,  0.7336, -0.3836, -1.1015]]])

</code></pre>
<pre><code class="language-py">torch.einsum(equation, *operands) → Tensor
</code></pre>
<p>This function provides a way of computing multilinear expressions (i.e. sums of products) using the Einstein summation convention.</p>
<p>Parameters:</p>
<ul>
<li><strong>equation</strong> (<em>string</em>) – The equation is given in terms of lower case letters (indices) to be associated with each dimension of the operands and result. The left hand side lists the operands dimensions, separated by commas. There should be one index letter per tensor dimension. The right hand side follows after <code>-&amp;gt;</code> and gives the indices for the output. If the <code>-&amp;gt;</code> and right hand side are omitted, it implicitly defined as the alphabetically sorted list of all indices appearing exactly once in the left hand side. The indices not apprearing in the output are summed over after multiplying the operands entries. If an index appears several times for the same operand, a diagonal is taken. Ellipses <code>…</code> represent a fixed number of dimensions. If the right hand side is inferred, the ellipsis dimensions are at the beginning of the output.</li>
<li><strong>operands</strong> (<em>list of Tensors</em>) – The operands to compute the Einstein sum of. Note that the operands are passed as a list, not as individual arguments.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.randn(5)
&gt;&gt;&gt; y = torch.randn(4)
&gt;&gt;&gt; torch.einsum('i,j-&gt;ij', x, y)  # outer product
tensor([[-0.0570, -0.0286, -0.0231,  0.0197],
 [ 1.2616,  0.6335,  0.5113, -0.4351],
 [ 1.4452,  0.7257,  0.5857, -0.4984],
 [-0.4647, -0.2333, -0.1883,  0.1603],
 [-1.1130, -0.5588, -0.4510,  0.3838]])

&gt;&gt;&gt; A = torch.randn(3,5,4)
&gt;&gt;&gt; l = torch.randn(2,5)
&gt;&gt;&gt; r = torch.randn(2,4)
&gt;&gt;&gt; torch.einsum('bn,anm,bm-&gt;ba', l, A, r) # compare torch.nn.functional.bilinear
tensor([[-0.3430, -5.2405,  0.4494],
 [ 0.3311,  5.5201, -3.0356]])

&gt;&gt;&gt; As = torch.randn(3,2,5)
&gt;&gt;&gt; Bs = torch.randn(3,5,4)
&gt;&gt;&gt; torch.einsum('bij,bjk-&gt;bik', As, Bs) # batch matrix multiplication
tensor([[[-1.0564, -1.5904,  3.2023,  3.1271],
 [-1.6706, -0.8097, -0.8025, -2.1183]],

 [[ 4.2239,  0.3107, -0.5756, -0.2354],
 [-1.4558, -0.3460,  1.5087, -0.8530]],

 [[ 2.8153,  1.8787, -4.3839, -1.2112],
 [ 0.3728, -2.1131,  0.0921,  0.8305]]])

&gt;&gt;&gt; A = torch.randn(3, 3)
&gt;&gt;&gt; torch.einsum('ii-&gt;i', A) # diagonal
tensor([-0.7825,  0.8291, -0.1936])

&gt;&gt;&gt; A = torch.randn(4, 3, 3)
&gt;&gt;&gt; torch.einsum('...ii-&gt;...i', A) # batch diagonal
tensor([[-1.0864,  0.7292,  0.0569],
 [-0.9725, -1.0270,  0.6493],
 [ 0.5832, -1.1716, -1.5084],
 [ 0.4041, -1.1690,  0.8570]])

&gt;&gt;&gt; A = torch.randn(2, 3, 4, 5)
&gt;&gt;&gt; torch.einsum('...ij-&gt;...ji', A).shape # batch permute
torch.Size([2, 3, 5, 4])

</code></pre>
<pre><code class="language-py">torch.flatten(input, start_dim=0, end_dim=-1) → Tensor
</code></pre>
<p>Flattens a contiguous range of dims in a tensor.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>start_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the first dim to flatten</li>
<li><strong>end_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the last dim to flatten</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; t = torch.tensor([[[1, 2],
 [3, 4]],
 [[5, 6],
 [7, 8]]])
&gt;&gt;&gt; torch.flatten(t)
tensor([1, 2, 3, 4, 5, 6, 7, 8])
&gt;&gt;&gt; torch.flatten(t, start_dim=1)
tensor([[1, 2, 3, 4],
 [5, 6, 7, 8]])

</code></pre>
<pre><code class="language-py">torch.flip(input, dims) → Tensor
</code></pre>
<p>Reverse the order of a n-D tensor along given axis in dims.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>dims</strong> (<em>a list</em> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – axis to flip on</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.arange(8).view(2, 2, 2)
&gt;&gt;&gt; x
tensor([[[ 0,  1],
 [ 2,  3]],

 [[ 4,  5],
 [ 6,  7]]])
&gt;&gt;&gt; torch.flip(x, [0, 1])
tensor([[[ 6,  7],
 [ 4,  5]],

 [[ 2,  3],
 [ 0,  1]]])

</code></pre>
<pre><code class="language-py">torch.histc(input, bins=100, min=0, max=0, out=None) → Tensor
</code></pre>
<p>Computes the histogram of a tensor.</p>
<p>The elements are sorted into equal width bins between <a href="#torch.min" title="torch.min"><code>min</code></a> and <a href="#torch.max" title="torch.max"><code>max</code></a>. If <a href="#torch.min" title="torch.min"><code>min</code></a> and <a href="#torch.max" title="torch.max"><code>max</code></a> are both zero, the minimum and maximum values of the data are used.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>bins</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of histogram bins</li>
<li><strong>min</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – lower end of the range (inclusive)</li>
<li><strong>max</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – upper end of the range (inclusive)</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>Histogram represented as a tensor</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.histc(torch.tensor([1., 2, 1]), bins=4, min=0, max=3)
tensor([ 0.,  2.,  1.,  0.])

</code></pre>
<pre><code class="language-py">torch.meshgrid(*tensors, **kwargs)
</code></pre>
<p>Take <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> tensors, each of which can be either scalar or 1-dimensional vector, and create <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> N-dimensional grids, where the :math:[<code>](#id2)i</code>th grid is defined by expanding the :math:[<code>](#id4)i</code>th input over dimensions defined by other inputs.</p>
<blockquote>
<pre><code class="language-py">Args:
</code></pre>
<p>tensors (list of Tensor): list of scalars or 1 dimensional tensors. Scalars will be treated as tensors of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e800eead21f1007b4005a268169586f7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e800eead21f1007b4005a268169586f7.jpg" alt=""></a> automatically</p>
<pre><code class="language-py">Returns:
</code></pre>
<p>seq (sequence of Tensors): If the input has <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a1c2f8d5b1226e67bdb44b12a6ddf18b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a1c2f8d5b1226e67bdb44b12a6ddf18b.jpg" alt=""></a> tensors of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5871a78f7096a5c43c0b08b090b8c4f1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5871a78f7096a5c43c0b08b090b8c4f1.jpg" alt=""></a>, then the output would also has <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a1c2f8d5b1226e67bdb44b12a6ddf18b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a1c2f8d5b1226e67bdb44b12a6ddf18b.jpg" alt=""></a> tensors, where all tensors are of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/771af95b2d780e68358b78d5124091fa.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/771af95b2d780e68358b78d5124091fa.jpg" alt=""></a>.</p>
<p>Example:</p>
<pre><code class="language-py">&amp;gt;&amp;gt;&amp;gt; x = torch.tensor([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; y = torch.tensor([4, 5, 6])
&amp;gt;&amp;gt;&amp;gt; grid_x, grid_y = torch.meshgrid(x, y)
&amp;gt;&amp;gt;&amp;gt; grid_x
tensor([[1, 1, 1],
 [2, 2, 2],
 [3, 3, 3]])
&amp;gt;&amp;gt;&amp;gt; grid_y
tensor([[4, 5, 6],
 [4, 5, 6],
 [4, 5, 6]])

</code></pre>
</blockquote>
<pre><code class="language-py">torch.renorm(input, p, dim, maxnorm, out=None) → Tensor
</code></pre>
<p>Returns a tensor where each sub-tensor of <code>input</code> along dimension <code>dim</code> is normalized such that the <code>p</code>-norm of the sub-tensor is lower than the value <code>maxnorm</code></p>
<p>Note</p>
<p>If the norm of a row is lower than <code>maxnorm</code>, the row is unchanged</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the power for the norm computation</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the dimension to slice over to get the sub-tensors</li>
<li><strong>maxnorm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the maximum norm to keep each sub-tensor under</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.ones(3, 3)
&gt;&gt;&gt; x[1].fill_(2)
tensor([ 2.,  2.,  2.])
&gt;&gt;&gt; x[2].fill_(3)
tensor([ 3.,  3.,  3.])
&gt;&gt;&gt; x
tensor([[ 1.,  1.,  1.],
 [ 2.,  2.,  2.],
 [ 3.,  3.,  3.]])
&gt;&gt;&gt; torch.renorm(x, 1, 0, 5)
tensor([[ 1.0000,  1.0000,  1.0000],
 [ 1.6667,  1.6667,  1.6667],
 [ 1.6667,  1.6667,  1.6667]])

</code></pre>
<pre><code class="language-py">torch.tensordot(a, b, dims=2)
</code></pre>
<p>Returns a contraction of a and b over multiple dimensions.</p>
<p><a href="#torch.tensordot" title="torch.tensordot"><code>tensordot</code></a> implements a generalizes the matrix product.</p>
<p>Parameters:</p>
<ul>
<li><strong>a</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Left tensor to contract</li>
<li><strong>b</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Right tensor to contract</li>
<li><strong>dims</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <em>tuple of two lists of python:integers</em>) – number of dimensions to contract or explicit lists of dimensions for <code>a</code> and <code>b</code> respectively</li>
</ul>
<p>When called with an integer argument <code>dims</code> = <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a>, and the number of dimensions of <code>a</code> and <code>b</code> is <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a>, respectively, it computes</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/99b9f5b0cd445ecb19920e143987f33e.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/99b9f5b0cd445ecb19920e143987f33e.jpg" alt=""></a></p>
<p>When called with <code>dims</code> of the list form, the given dimensions will be contracted in place of the last <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a> of <code>a</code> and the first <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9566974d45a96737f7e0ecf302d877b8.jpg" alt=""></a> of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6872867a863714d15d9a0d64c20734ce.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6872867a863714d15d9a0d64c20734ce.jpg" alt=""></a>. The sizes in these dimensions must match, but <a href="#torch.tensordot" title="torch.tensordot"><code>tensordot</code></a> will deal with broadcasted dimensions.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.arange(60.).reshape(3, 4, 5)
&gt;&gt;&gt; b = torch.arange(24.).reshape(4, 3, 2)
&gt;&gt;&gt; torch.tensordot(a, b, dims=([1, 0], [0, 1]))
tensor([[4400., 4730.],
 [4532., 4874.],
 [4664., 5018.],
 [4796., 5162.],
 [4928., 5306.]])

&gt;&gt;&gt; a = torch.randn(3, 4, 5, device='cuda')
&gt;&gt;&gt; b = torch.randn(4, 5, 6, device='cuda')
&gt;&gt;&gt; c = torch.tensordot(a, b, dims=2).cpu()
tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],
 [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],
 [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])

</code></pre>
<pre><code class="language-py">torch.trace(input) → Tensor
</code></pre>
<p>Returns the sum of the elements of the diagonal of the input 2-D matrix.</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.arange(1., 10.).view(3, 3)
&gt;&gt;&gt; x
tensor([[ 1.,  2.,  3.],
 [ 4.,  5.,  6.],
 [ 7.,  8.,  9.]])
&gt;&gt;&gt; torch.trace(x)
tensor(15.)

</code></pre>
<pre><code class="language-py">torch.tril(input, diagonal=0, out=None) → Tensor
</code></pre>
<p>Returns the lower triangular part of the matrix (2-D tensor) <code>input</code>, the other elements of the result tensor <code>out</code> are set to 0.</p>
<p>The lower triangular part of the matrix is defined as the elements on and below the diagonal.</p>
<p>The argument <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> controls which diagonal to consider. If <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> = 0, all elements on and below the main diagonal are retained. A positive value includes just as many diagonals above the main diagonal, and similarly a negative value excludes just as many diagonals below the main diagonal. The main diagonal are the set of indices <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6291ea635817db74920cd048cc3cb8d4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6291ea635817db74920cd048cc3cb8d4.jpg" alt=""></a> for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1bfb3770a124b38b3aba63186b7c8f46.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1bfb3770a124b38b3aba63186b7c8f46.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5ccb16cb4e75340b0c2b2d022fd778a7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5ccb16cb4e75340b0c2b2d022fd778a7.jpg" alt=""></a> are the dimensions of the matrix.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>diagonal</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the diagonal to consider</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a
tensor([[-1.0813, -0.8619,  0.7105],
 [ 0.0935,  0.1380,  2.2112],
 [-0.3409, -0.9828,  0.0289]])
&gt;&gt;&gt; torch.tril(a)
tensor([[-1.0813,  0.0000,  0.0000],
 [ 0.0935,  0.1380,  0.0000],
 [-0.3409, -0.9828,  0.0289]])

&gt;&gt;&gt; b = torch.randn(4, 6)
&gt;&gt;&gt; b
tensor([[ 1.2219,  0.5653, -0.2521, -0.2345,  1.2544,  0.3461],
 [ 0.4785, -0.4477,  0.6049,  0.6368,  0.8775,  0.7145],
 [ 1.1502,  3.2716, -1.1243, -0.5413,  0.3615,  0.6864],
 [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0978]])
&gt;&gt;&gt; torch.tril(b, diagonal=1)
tensor([[ 1.2219,  0.5653,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.4785, -0.4477,  0.6049,  0.0000,  0.0000,  0.0000],
 [ 1.1502,  3.2716, -1.1243, -0.5413,  0.0000,  0.0000],
 [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0000]])
&gt;&gt;&gt; torch.tril(b, diagonal=-1)
tensor([[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.4785,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 1.1502,  3.2716,  0.0000,  0.0000,  0.0000,  0.0000],
 [-0.0614, -0.7344, -1.3164,  0.0000,  0.0000,  0.0000]])

</code></pre>
<pre><code class="language-py">torch.triu(input, diagonal=0, out=None) → Tensor
</code></pre>
<p>Returns the upper triangular part of the matrix (2-D tensor) <code>input</code>, the other elements of the result tensor <code>out</code> are set to 0.</p>
<p>The upper triangular part of the matrix is defined as the elements on and above the diagonal.</p>
<p>The argument <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> controls which diagonal to consider. If <a href="#torch.diagonal" title="torch.diagonal"><code>diagonal</code></a> = 0, all elements on and below the main diagonal are retained. A positive value excludes just as many diagonals above the main diagonal, and similarly a negative value includes just as many diagonals below the main diagonal. The main diagonal are the set of indices <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6291ea635817db74920cd048cc3cb8d4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6291ea635817db74920cd048cc3cb8d4.jpg" alt=""></a> for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1bfb3770a124b38b3aba63186b7c8f46.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1bfb3770a124b38b3aba63186b7c8f46.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5ccb16cb4e75340b0c2b2d022fd778a7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5ccb16cb4e75340b0c2b2d022fd778a7.jpg" alt=""></a> are the dimensions of the matrix.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>diagonal</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the diagonal to consider</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a
tensor([[ 0.2309,  0.5207,  2.0049],
 [ 0.2072, -1.0680,  0.6602],
 [ 0.3480, -0.5211, -0.4573]])
&gt;&gt;&gt; torch.triu(a)
tensor([[ 0.2309,  0.5207,  2.0049],
 [ 0.0000, -1.0680,  0.6602],
 [ 0.0000,  0.0000, -0.4573]])
&gt;&gt;&gt; torch.triu(a, diagonal=1)
tensor([[ 0.0000,  0.5207,  2.0049],
 [ 0.0000,  0.0000,  0.6602],
 [ 0.0000,  0.0000,  0.0000]])
&gt;&gt;&gt; torch.triu(a, diagonal=-1)
tensor([[ 0.2309,  0.5207,  2.0049],
 [ 0.2072, -1.0680,  0.6602],
 [ 0.0000, -0.5211, -0.4573]])

&gt;&gt;&gt; b = torch.randn(4, 6)
&gt;&gt;&gt; b
tensor([[ 0.5876, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],
 [-0.2447,  0.9556, -1.2919,  1.3378, -0.1768, -1.0857],
 [ 0.4333,  0.3146,  0.6576, -1.0432,  0.9348, -0.4410],
 [-0.9888,  1.0679, -1.3337, -1.6556,  0.4798,  0.2830]])
&gt;&gt;&gt; torch.tril(b, diagonal=1)
tensor([[ 0.5876, -0.0794,  0.0000,  0.0000,  0.0000,  0.0000],
 [-0.2447,  0.9556, -1.2919,  0.0000,  0.0000,  0.0000],
 [ 0.4333,  0.3146,  0.6576, -1.0432,  0.0000,  0.0000],
 [-0.9888,  1.0679, -1.3337, -1.6556,  0.4798,  0.0000]])
&gt;&gt;&gt; torch.tril(b, diagonal=-1)
tensor([[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [-0.2447,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.4333,  0.3146,  0.0000,  0.0000,  0.0000,  0.0000],
 [-0.9888,  1.0679, -1.3337,  0.0000,  0.0000,  0.0000]])

</code></pre>
<h3 id="blas-and-lapack-operations">BLAS and LAPACK Operations</h3>
<pre><code class="language-py">torch.addbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor
</code></pre>
<p>Performs a batch matrix-matrix product of matrices stored in <code>batch1</code> and <code>batch2</code>, with a reduced add step (all matrix multiplications get accumulated along the first dimension). <code>mat</code> is added to the final result.</p>
<p><code>batch1</code> and <code>batch2</code> must be 3-D tensors each containing the same number of matrices.</p>
<p>If <code>batch1</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eccd104fbbbbb116c7e98ca54b2214a0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eccd104fbbbbb116c7e98ca54b2214a0.jpg" alt=""></a> tensor, <code>batch2</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8b603730e091b70ad24e5a089cdd30f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8b603730e091b70ad24e5a089cdd30f.jpg" alt=""></a> tensor, <code>mat</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" alt=""></a> tensor and <code>out</code> will be a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" alt=""></a> tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e9a3c5b413385d813461f90cc06b1454.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/e9a3c5b413385d813461f90cc06b1454.jpg" alt=""></a></p>
<p>For inputs of type <code>FloatTensor</code> or <code>DoubleTensor</code>, arguments <code>beta</code> and <code>alpha</code> must be real numbers, otherwise they should be integers.</p>
<p>Parameters:</p>
<ul>
<li><strong>beta</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <code>mat</code> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a>)</li>
<li><strong>mat</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – matrix to be added</li>
<li><strong>alpha</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <code>batch1 @ batch2</code> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" alt=""></a>)</li>
<li><strong>batch1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first batch of matrices to be multiplied</li>
<li><strong>batch2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second batch of matrices to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; M = torch.randn(3, 5)
&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)
&gt;&gt;&gt; torch.addbmm(M, batch1, batch2)
tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],
 [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],
 [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])

</code></pre>
<pre><code class="language-py">torch.addmm(beta=1, mat, alpha=1, mat1, mat2, out=None) → Tensor
</code></pre>
<p>Performs a matrix multiplication of the matrices <code>mat1</code> and <code>mat2</code>. The matrix <code>mat</code> is added to the final result.</p>
<p>If <code>mat1</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a> tensor, <code>mat2</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec84c2d649caa2a7d4dc59b6b23b0278.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec84c2d649caa2a7d4dc59b6b23b0278.jpg" alt=""></a> tensor, then <code>mat</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" alt=""></a> tensor and <code>out</code> will be a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" alt=""></a> tensor.</p>
<p><code>alpha</code> and <code>beta</code> are scaling factors on matrix-vector product between <code>mat1</code> and :attr<code>mat2</code> and the added matrix <code>mat</code> respectively.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d4b0912f137549bc9b2dc4ee38a0a40.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8d4b0912f137549bc9b2dc4ee38a0a40.jpg" alt=""></a></p>
<p>For inputs of type <code>FloatTensor</code> or <code>DoubleTensor</code>, arguments <code>beta</code> and <code>alpha</code> must be real numbers, otherwise they should be integers.</p>
<p>Parameters:</p>
<ul>
<li><strong>beta</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <code>mat</code> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a>)</li>
<li><strong>mat</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – matrix to be added</li>
<li><strong>alpha</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c4fda0ec33ee23096c7bac6105f7a619.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c4fda0ec33ee23096c7bac6105f7a619.jpg" alt=""></a> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" alt=""></a>)</li>
<li><strong>mat1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first matrix to be multiplied</li>
<li><strong>mat2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second matrix to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; M = torch.randn(2, 3)
&gt;&gt;&gt; mat1 = torch.randn(2, 3)
&gt;&gt;&gt; mat2 = torch.randn(3, 3)
&gt;&gt;&gt; torch.addmm(M, mat1, mat2)
tensor([[-4.8716,  1.4671, -1.3746],
 [ 0.7573, -3.9555, -2.8681]])

</code></pre>
<pre><code class="language-py">torch.addmv(beta=1, tensor, alpha=1, mat, vec, out=None) → Tensor
</code></pre>
<p>Performs a matrix-vector product of the matrix <code>mat</code> and the vector <code>vec</code>. The vector <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a> is added to the final result.</p>
<p>If <code>mat</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a> tensor, <code>vec</code> is a 1-D tensor of size <code>m</code>, then <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with a 1-D tensor of size <code>n</code> and <code>out</code> will be 1-D tensor of size <code>n</code>.</p>
<p><code>alpha</code> and <code>beta</code> are scaling factors on matrix-vector product between <code>mat</code> and <code>vec</code> and the added tensor <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a> respectively.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4188eb7768951ccca87969272bcfa3a7.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/4188eb7768951ccca87969272bcfa3a7.jpg" alt=""></a></p>
<p>For inputs of type <code>FloatTensor</code> or <code>DoubleTensor</code>, arguments <code>beta</code> and <code>alpha</code> must be real numbers, otherwise they should be integers</p>
<p>Parameters:</p>
<ul>
<li><strong>beta</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <a href="#torch.tensor" title="torch.tensor"><code>tensor</code></a> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a>)</li>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – vector to be added</li>
<li><strong>alpha</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a901c2282b0dbdcf23379ddd5a3c274b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a901c2282b0dbdcf23379ddd5a3c274b.jpg" alt=""></a> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" alt=""></a>)</li>
<li><strong>mat</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – matrix to be multiplied</li>
<li><strong>vec</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – vector to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; M = torch.randn(2)
&gt;&gt;&gt; mat = torch.randn(2, 3)
&gt;&gt;&gt; vec = torch.randn(3)
&gt;&gt;&gt; torch.addmv(M, mat, vec)
tensor([-0.3768, -5.5565])

</code></pre>
<pre><code class="language-py">torch.addr(beta=1, mat, alpha=1, vec1, vec2, out=None) → Tensor
</code></pre>
<p>Performs the outer-product of vectors <code>vec1</code> and <code>vec2</code> and adds it to the matrix <code>mat</code>.</p>
<p>Optional values <code>beta</code> and <code>alpha</code> are scaling factors on the outer product between <code>vec1</code> and <code>vec2</code> and the added matrix <code>mat</code> respectively.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/171f2173f3a92cea6433a9dd012888ad.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/171f2173f3a92cea6433a9dd012888ad.jpg" alt=""></a></p>
<p>If <code>vec1</code> is a vector of size <code>n</code> and <code>vec2</code> is a vector of size <code>m</code>, then <code>mat</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with a matrix of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a> and <code>out</code> will be a matrix of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a>.</p>
<p>For inputs of type <code>FloatTensor</code> or <code>DoubleTensor</code>, arguments <code>beta</code> and <code>alpha</code> must be real numbers, otherwise they should be integers</p>
<p>Parameters:</p>
<ul>
<li><strong>beta</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <code>mat</code> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a>)</li>
<li><strong>mat</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – matrix to be added</li>
<li><strong>alpha</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3f2eb83c372296996af0ac869a078ebd.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3f2eb83c372296996af0ac869a078ebd.jpg" alt=""></a> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" alt=""></a>)</li>
<li><strong>vec1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first vector of the outer product</li>
<li><strong>vec2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second vector of the outer product</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; vec1 = torch.arange(1., 4.)
&gt;&gt;&gt; vec2 = torch.arange(1., 3.)
&gt;&gt;&gt; M = torch.zeros(3, 2)
&gt;&gt;&gt; torch.addr(M, vec1, vec2)
tensor([[ 1.,  2.],
 [ 2.,  4.],
 [ 3.,  6.]])

</code></pre>
<pre><code class="language-py">torch.baddbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor
</code></pre>
<p>Performs a batch matrix-matrix product of matrices in <code>batch1</code> and <code>batch2</code>. <code>mat</code> is added to the final result.</p>
<p><code>batch1</code> and <code>batch2</code> must be 3-D tensors each containing the same number of matrices.</p>
<p>If <code>batch1</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eccd104fbbbbb116c7e98ca54b2214a0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eccd104fbbbbb116c7e98ca54b2214a0.jpg" alt=""></a> tensor, <code>batch2</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8b603730e091b70ad24e5a089cdd30f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8b603730e091b70ad24e5a089cdd30f.jpg" alt=""></a> tensor, then <code>mat</code> must be <a href="notes/broadcasting.html#broadcasting-semantics">broadcastable</a> with a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f0e4a370460668f7e257b22d08622d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f0e4a370460668f7e257b22d08622d.jpg" alt=""></a> tensor and <code>out</code> will be a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f0e4a370460668f7e257b22d08622d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f0e4a370460668f7e257b22d08622d.jpg" alt=""></a> tensor. Both <code>alpha</code> and <code>beta</code> mean the same as the scaling factors used in <a href="#torch.addbmm" title="torch.addbmm"><code>torch.addbmm()</code></a>.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/069d82fba319e5aec62a5ad55fd0d01c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/069d82fba319e5aec62a5ad55fd0d01c.jpg" alt=""></a></p>
<p>For inputs of type <code>FloatTensor</code> or <code>DoubleTensor</code>, arguments <code>beta</code> and <code>alpha</code> must be real numbers, otherwise they should be integers.</p>
<p>Parameters:</p>
<ul>
<li><strong>beta</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <code>mat</code> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/50705df736e9a7919e768cf8c4e4f794.jpg" alt=""></a>)</li>
<li><strong>mat</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to be added</li>
<li><strong>alpha</strong> (<em>Number</em>_,_ <em>optional</em>) – multiplier for <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c9ac2542d6edbedec1234ae90d5bf79f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/c9ac2542d6edbedec1234ae90d5bf79f.jpg" alt=""></a> (<a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/82005cc2e0087e2a52c7e43df4a19a00.jpg" alt=""></a>)</li>
<li><strong>batch1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first batch of matrices to be multiplied</li>
<li><strong>batch2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second batch of matrices to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; M = torch.randn(10, 3, 5)
&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)
&gt;&gt;&gt; torch.baddbmm(M, batch1, batch2).size()
torch.Size([10, 3, 5])

</code></pre>
<pre><code class="language-py">torch.bmm(batch1, batch2, out=None) → Tensor
</code></pre>
<p>Performs a batch matrix-matrix product of matrices stored in <code>batch1</code> and <code>batch2</code>.</p>
<p><code>batch1</code> and <code>batch2</code> must be 3-D tensors each containing the same number of matrices.</p>
<p>If <code>batch1</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eccd104fbbbbb116c7e98ca54b2214a0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/eccd104fbbbbb116c7e98ca54b2214a0.jpg" alt=""></a> tensor, <code>batch2</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8b603730e091b70ad24e5a089cdd30f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8b603730e091b70ad24e5a089cdd30f.jpg" alt=""></a> tensor, <code>out</code> will be a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f0e4a370460668f7e257b22d08622d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/29f0e4a370460668f7e257b22d08622d.jpg" alt=""></a> tensor.</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/699b5d44b53e8c67d763dc6fb072e488.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/699b5d44b53e8c67d763dc6fb072e488.jpg" alt=""></a></p>
<p>Note</p>
<p>This function does not <a href="notes/broadcasting.html#broadcasting-semantics">broadcast</a>. For broadcasting matrix products, see <a href="#torch.matmul" title="torch.matmul"><code>torch.matmul()</code></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>batch1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first batch of matrices to be multiplied</li>
<li><strong>batch2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second batch of matrices to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)
&gt;&gt;&gt; res = torch.bmm(batch1, batch2)
&gt;&gt;&gt; res.size()
torch.Size([10, 3, 5])

</code></pre>
<pre><code class="language-py">torch.btrifact(A, info=None, pivot=True)
</code></pre>
<p>Batch LU factorization.</p>
<p>Returns a tuple containing the LU factorization and pivots. Pivoting is done if <code>pivot</code> is set.</p>
<p>The optional argument <code>info</code> stores information if the factorization succeeded for each minibatch example. The <code>info</code> is provided as an <code>IntTensor</code>, its values will be filled from dgetrf and a non-zero value indicates an error occurred. Specifically, the values are from cublas if cuda is being used, otherwise LAPACK.</p>
<p>Warning</p>
<p>The <code>info</code> argument is deprecated in favor of <a href="#torch.btrifact_with_info" title="torch.btrifact_with_info"><code>torch.btrifact_with_info()</code></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to factor</li>
<li><strong>info</strong> (<em>IntTensor</em>_,_ <em>optional</em>) – (deprecated) an <code>IntTensor</code> to store values indicating whether factorization succeeds</li>
<li><strong>pivot</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether pivoting is done</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tuple containing factorization and pivots.</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(2, 3, 3)
&gt;&gt;&gt; A_LU, pivots = torch.btrifact(A)
&gt;&gt;&gt; A_LU
tensor([[[ 1.3506,  2.5558, -0.0816],
 [ 0.1684,  1.1551,  0.1940],
 [ 0.1193,  0.6189, -0.5497]],

 [[ 0.4526,  1.2526, -0.3285],
 [-0.7988,  0.7175, -0.9701],
 [ 0.2634, -0.9255, -0.3459]]])

&gt;&gt;&gt; pivots
tensor([[ 3,  3,  3],
 [ 3,  3,  3]], dtype=torch.int32)

</code></pre>
<pre><code class="language-py">torch.btrifact_with_info(A, pivot=True) -&gt; (Tensor, IntTensor, IntTensor)
</code></pre>
<p>Batch LU factorization with additional error information.</p>
<p>This is a version of <a href="#torch.btrifact" title="torch.btrifact"><code>torch.btrifact()</code></a> that always creates an info <code>IntTensor</code>, and returns it as the third return value.</p>
<p>Parameters:</p>
<ul>
<li><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the tensor to factor</li>
<li><strong>pivot</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls whether pivoting is done</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tuple containing factorization, pivots, and an <code>IntTensor</code> where non-zero values indicate whether factorization for each minibatch sample succeeds.</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(2, 3, 3)
&gt;&gt;&gt; A_LU, pivots, info = A.btrifact_with_info()
&gt;&gt;&gt; if info.nonzero().size(0) == 0:
&gt;&gt;&gt;   print('LU factorization succeeded for all samples!')
LU factorization succeeded for all samples!

</code></pre>
<pre><code class="language-py">torch.btrisolve(b, LU_data, LU_pivots) → Tensor
</code></pre>
<p>Batch LU solve.</p>
<p>Returns the LU solve of the linear system <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79f5b7df86014d0a54c744c91d8b351d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79f5b7df86014d0a54c744c91d8b351d.jpg" alt=""></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>b</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the RHS tensor</li>
<li><strong>LU_data</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the pivoted LU factorization of A from <a href="#torch.btrifact" title="torch.btrifact"><code>btrifact()</code></a>.</li>
<li><strong>LU_pivots</strong> (<em>IntTensor</em>) – the pivots of the LU factorization</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(2, 3, 3)
&gt;&gt;&gt; b = torch.randn(2, 3)
&gt;&gt;&gt; A_LU = torch.btrifact(A)
&gt;&gt;&gt; x = torch.btrisolve(b, *A_LU)
&gt;&gt;&gt; torch.norm(torch.bmm(A, x.unsqueeze(2)) - b.unsqueeze(2))
tensor(1.00000e-07 *
 2.8312)

</code></pre>
<pre><code class="language-py">torch.btriunpack(LU_data, LU_pivots, unpack_data=True, unpack_pivots=True)
</code></pre>
<p>Unpacks the data and pivots from a batched LU factorization (btrifact) of a tensor.</p>
<p>Returns a tuple of tensors as <code>(the pivots, the L tensor, the U tensor)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>LU_data</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the packed LU factorization data</li>
<li><strong>LU_pivots</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the packed LU factorization pivots</li>
<li><strong>unpack_data</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – flag indicating if the data should be unpacked</li>
<li><strong>unpack_pivots</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – flag indicating if the pivots should be unpacked</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(2, 3, 3)
&gt;&gt;&gt; A_LU, pivots = A.btrifact()
&gt;&gt;&gt; P, A_L, A_U = torch.btriunpack(A_LU, pivots)
&gt;&gt;&gt;
&gt;&gt;&gt; # can recover A from factorization
&gt;&gt;&gt; A_ = torch.bmm(P, torch.bmm(A_L, A_U))

</code></pre>
<pre><code class="language-py">torch.chain_matmul(*matrices)
</code></pre>
<p>Returns the matrix product of the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> 2-D tensors. This product is efficiently computed using the matrix chain order algorithm which selects the order in which incurs the lowest cost in terms of arithmetic operations (<a href="CLRS">CLRS</a>(https://mitpress.mit.edu/books/introduction-algorithms-third-edition)). Note that since this is a function to compute the product, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> needs to be greater than or equal to 2; if equal to 2 then a trivial matrix-matrix product is returned. If <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9341d9048ac485106d2b2ee8de14876f.jpg" alt=""></a> is 1, then this is a no-op - the original matrix is returned as is.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>matrices</strong> (<em>Tensors...</em>) – a sequence of 2 or more 2-D tensors whose product is to be determined.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>if the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5c5e7583f110d90e938149340dd42e92.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5c5e7583f110d90e938149340dd42e92.jpg" alt=""></a> tensor was of dimensions <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fd285b0b789ab6ce131b7a0208da2fe0.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/fd285b0b789ab6ce131b7a0208da2fe0.jpg" alt=""></a>, then the product would be of dimensions <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/61c4b45c29064296a380ab945a449672.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/61c4b45c29064296a380ab945a449672.jpg" alt=""></a>.</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 4)
&gt;&gt;&gt; b = torch.randn(4, 5)
&gt;&gt;&gt; c = torch.randn(5, 6)
&gt;&gt;&gt; d = torch.randn(6, 7)
&gt;&gt;&gt; torch.chain_matmul(a, b, c, d)
tensor([[ -2.3375,  -3.9790,  -4.1119,  -6.6577,   9.5609, -11.5095,  -3.2614],
 [ 21.4038,   3.3378,  -8.4982,  -5.2457, -10.2561,  -2.4684,   2.7163],
 [ -0.9647,  -5.8917,  -2.3213,  -5.2284,  12.8615, -12.2816,  -2.5095]])

</code></pre>
<pre><code class="language-py">torch.cholesky(A, upper=False, out=None) → Tensor
</code></pre>
<p>Computes the Cholesky decomposition of a symmetric positive-definite matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> or for batches of symmetric positive-definite matrices.</p>
<p>If <code>upper</code> is <code>True</code>, the returned matrix <code>U</code> is upper-triangular, and the decomposition has the form:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7100a5dce6b64985eeb45416a640b7e6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7100a5dce6b64985eeb45416a640b7e6.jpg" alt=""></a></p>
<p>If <code>upper</code> is <code>False</code>, the returned matrix <code>L</code> is lower-triangular, and the decomposition has the form:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ec14c9e61e88b877808fab3bbdd17ca.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3ec14c9e61e88b877808fab3bbdd17ca.jpg" alt=""></a></p>
<p>If <code>upper</code> is <code>True</code>, and <code>A</code> is a batch of symmetric positive-definite matrices, then the returned tensor will be composed of upper-triangular Cholesky factors of each of the individual matrices. Similarly, when <code>upper</code> is <code>False</code>, the returned tensor will be composed of lower-triangular Cholesky factors of each of the individual matrices.</p>
<p>Parameters:</p>
<ul>
<li><strong>a</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor of size (<a href="#id6">*</a>, n, n) where <code>*</code> is zero or more batch dimensions consisting of symmetric positive-definite matrices.</li>
<li><strong>upper</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – flag that indicates whether to return a upper or lower triangular matrix. Default: <code>False</code></li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output matrix</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a = torch.mm(a, a.t()) # make symmetric positive-definite
&gt;&gt;&gt; l = torch.cholesky(a)
&gt;&gt;&gt; a
tensor([[ 2.4112, -0.7486,  1.4551],
 [-0.7486,  1.3544,  0.1294],
 [ 1.4551,  0.1294,  1.6724]])
&gt;&gt;&gt; l
tensor([[ 1.5528,  0.0000,  0.0000],
 [-0.4821,  1.0592,  0.0000],
 [ 0.9371,  0.5487,  0.7023]])
&gt;&gt;&gt; torch.mm(l, l.t())
tensor([[ 2.4112, -0.7486,  1.4551],
 [-0.7486,  1.3544,  0.1294],
 [ 1.4551,  0.1294,  1.6724]])
&gt;&gt;&gt; a = torch.randn(3, 2, 2)
&gt;&gt;&gt; a = torch.matmul(a, a.transpose(-1, -2)) + 1e-03 # make symmetric positive-definite
&gt;&gt;&gt; l = torch.cholesky(a)
&gt;&gt;&gt; z = torch.matmul(l, l.transpose(-1, -2))
&gt;&gt;&gt; torch.max(torch.abs(z - a)) # Max non-zero
tensor(2.3842e-07)

</code></pre>
<pre><code class="language-py">torch.dot(tensor1, tensor2) → Tensor
</code></pre>
<p>Computes the dot product (inner product) of two tensors.</p>
<p>Note</p>
<p>This function does not <a href="notes/broadcasting.html#broadcasting-semantics">broadcast</a>.</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.dot(torch.tensor([2, 3]), torch.tensor([2, 1]))
tensor(7)

</code></pre>
<pre><code class="language-py">torch.eig(a, eigenvectors=False, out=None) -&gt; (Tensor, Tensor)
</code></pre>
<p>Computes the eigenvalues and eigenvectors of a real square matrix.</p>
<p>Parameters:</p>
<ul>
<li><strong>a</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the square matrix of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" alt=""></a> for which the eigenvalues and eigenvectors will be computed</li>
<li><strong>eigenvectors</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – <code>True</code> to compute both eigenvalues and eigenvectors; otherwise, only eigenvalues will be computed</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the output tensors</li>
</ul>
<p>| Returns: | A tuple containing</p>
<p>&gt; * <strong>e</strong> (<em>Tensor</em>): Shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6bb1e4cc787b2a2a3e362c6385033b7d.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6bb1e4cc787b2a2a3e362c6385033b7d.jpg" alt=""></a>. Each row is an eigenvalue of <code>a</code>, where the first element is the real part and the second element is the imaginary part. The eigenvalues are not necessarily ordered. &gt; * <strong>v</strong> (<em>Tensor</em>): If <code>eigenvectors=False</code>, it’s an empty tensor. Otherwise, this tensor of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" alt=""></a> can be used to compute normalized (unit length) eigenvectors of corresponding eigenvalues <code>e</code> as follows. If the corresponding e[j] is a real number, column v[:, j] is the eigenvector corresponding to eigenvalue e[j]. If the corresponding e[j] and e[j + 1] eigenvalues form a complex conjugate pair, then the true eigenvectors can be computed as <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec9513691a2c7521c03807425da807ed.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec9513691a2c7521c03807425da807ed.jpg" alt=""></a>, <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a532b8aa12f3a5051c8105bf8e226b64.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a532b8aa12f3a5051c8105bf8e226b64.jpg" alt=""></a>.</p>
<table>
<thead>
<tr>
<th>Return type:</th>
<th>(<a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>, <a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">torch.gels(B, A, out=None) → Tensor
</code></pre>
<p>Computes the solution to the least squares and least norm problems for a full rank matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cc3ea6b8d05f85433fd7aa6a20c33408.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/cc3ea6b8d05f85433fd7aa6a20c33408.jpg" alt=""></a> and a matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/813135a6280e2672503128d3d2080d4a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/813135a6280e2672503128d3d2080d4a.jpg" alt=""></a> of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/602cd3c92249bd53b21908f902ff6089.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/602cd3c92249bd53b21908f902ff6089.jpg" alt=""></a>.</p>
<p>If <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/199260d72e51fe506909a150c6f77020.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/199260d72e51fe506909a150c6f77020.jpg" alt=""></a>, <a href="#torch.gels" title="torch.gels"><code>gels()</code></a> solves the least-squares problem:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6d9885b2d1646d00061288d0c063790b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6d9885b2d1646d00061288d0c063790b.jpg" alt=""></a></p>
<p>If <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bc0a7901ab359873a58a64e43f9fc85a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/bc0a7901ab359873a58a64e43f9fc85a.jpg" alt=""></a>, <a href="#torch.gels" title="torch.gels"><code>gels()</code></a> solves the least-norm problem:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/921685e425167b15563b245ca59e3ac3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/921685e425167b15563b245ca59e3ac3.jpg" alt=""></a></p>
<p>Returned tensor <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1284cf6bcb6c2ffc47e2dd24cd1c51b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1284cf6bcb6c2ffc47e2dd24cd1c51b8.jpg" alt=""></a> has shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b10f10ee19a21653d24c909eb3e0877a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b10f10ee19a21653d24c909eb3e0877a.jpg" alt=""></a>. The first <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a> rows of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1284cf6bcb6c2ffc47e2dd24cd1c51b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1284cf6bcb6c2ffc47e2dd24cd1c51b8.jpg" alt=""></a> contains the solution. If <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/199260d72e51fe506909a150c6f77020.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/199260d72e51fe506909a150c6f77020.jpg" alt=""></a>, the residual sum of squares for the solution in each column is given by the sum of squares of elements in the remaining <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/51e590a6a852e7b2d4cd0a3476859fc5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/51e590a6a852e7b2d4cd0a3476859fc5.jpg" alt=""></a> rows of that column.</p>
<p>Parameters:</p>
<ul>
<li><strong>B</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/813135a6280e2672503128d3d2080d4a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/813135a6280e2672503128d3d2080d4a.jpg" alt=""></a></li>
<li><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" alt=""></a> by <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a> matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a></li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the optional destination tensor</li>
</ul>
<p>| Returns: | A tuple containing:</p>
<p>&gt; * <strong>X</strong> (<em>Tensor</em>): the least squares solution &gt; * <strong>qr</strong> (<em>Tensor</em>): the details of the QR factorization</p>
<table>
<thead>
<tr>
<th>Return type:</th>
<th>(<a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>, <a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Note</p>
<p>The returned matrices will always be transposed, irrespective of the strides of the input matrices. That is, they will have stride <code>(1, m)</code> instead of <code>(m, 1)</code>.</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.tensor([[1., 1, 1],
 [2, 3, 4],
 [3, 5, 2],
 [4, 2, 5],
 [5, 4, 3]])
&gt;&gt;&gt; B = torch.tensor([[-10., -3],
 [ 12, 14],
 [ 14, 12],
 [ 16, 16],
 [ 18, 16]])
&gt;&gt;&gt; X, _ = torch.gels(B, A)
&gt;&gt;&gt; X
tensor([[  2.0000,   1.0000],
 [  1.0000,   1.0000],
 [  1.0000,   2.0000],
 [ 10.9635,   4.8501],
 [  8.9332,   5.2418]])

</code></pre>
<pre><code class="language-py">torch.geqrf(input, out=None) -&gt; (Tensor, Tensor)
</code></pre>
<p>This is a low-level function for calling LAPACK directly.</p>
<p>You’ll generally want to use <a href="#torch.qr" title="torch.qr"><code>torch.qr()</code></a> instead.</p>
<p>Computes a QR decomposition of <code>input</code>, but without constructing <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d680db5f32fd278f8d48e5407691154.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d680db5f32fd278f8d48e5407691154.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/502cdd9c79852b33d2a6d18ba5ec3102.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/502cdd9c79852b33d2a6d18ba5ec3102.jpg" alt=""></a> as explicit separate matrices.</p>
<p>Rather, this directly calls the underlying LAPACK function <code>?geqrf</code> which produces a sequence of ‘elementary reflectors’.</p>
<p>See <a href="https://software.intel.com/en-us/node/521004">LAPACK documentation for geqrf</a> for further details.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input matrix</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the output tuple of (Tensor, Tensor)</li>
</ul>
<pre><code class="language-py">torch.ger(vec1, vec2, out=None) → Tensor
</code></pre>
<p>Outer product of <code>vec1</code> and <code>vec2</code>. If <code>vec1</code> is a vector of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a> and <code>vec2</code> is a vector of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" alt=""></a>, then <code>out</code> must be a matrix of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a>.</p>
<p>Note</p>
<p>This function does not <a href="notes/broadcasting.html#broadcasting-semantics">broadcast</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>vec1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 1-D input vector</li>
<li><strong>vec2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 1-D input vector</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – optional output matrix</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; v1 = torch.arange(1., 5.)
&gt;&gt;&gt; v2 = torch.arange(1., 4.)
&gt;&gt;&gt; torch.ger(v1, v2)
tensor([[  1.,   2.,   3.],
 [  2.,   4.,   6.],
 [  3.,   6.,   9.],
 [  4.,   8.,  12.]])

</code></pre>
<pre><code class="language-py">torch.gesv(B, A) -&gt; (Tensor, Tensor)
</code></pre>
<p>This function returns the solution to the system of linear equations represented by <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9c11b6313ae06c752584c5c1b2c03964.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9c11b6313ae06c752584c5c1b2c03964.jpg" alt=""></a> and the LU factorization of A, in order as a tuple <code>X, LU</code>.</p>
<p><code>LU</code> contains <code>L</code> and <code>U</code> factors for LU factorization of <code>A</code>.</p>
<p><code>torch.gesv(B, A)</code> can take in 2D inputs <code>B, A</code> or inputs that are batches of 2D matrices. If the inputs are batches, then returns batched outputs <code>X, LU</code>.</p>
<p>Note</p>
<p>The <code>out</code> keyword only supports 2D matrix inputs, that is, <code>B, A</code> must be 2D matrices.</p>
<p>Note</p>
<p>Irrespective of the original strides, the returned matrices <code>X</code> and <code>LU</code> will be transposed, i.e. with strides like <code>B.contiguous().transpose(-1, -2).strides()</code> and <code>A.contiguous().transpose(-1, -2).strides()</code> respectively.</p>
<p>Parameters:</p>
<ul>
<li><strong>B</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – input matrix of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d9795910f977049c4df2084f47c592ed.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d9795910f977049c4df2084f47c592ed.jpg" alt=""></a> , where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> is zero or more batch dimensions.</li>
<li><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – input square matrix of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/494aaae2a24df44c813ce87b9f21d745.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/494aaae2a24df44c813ce87b9f21d745.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> is zero or more batch dimensions.</li>
<li><strong>out</strong> (<em>(</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>)__,</em> <em>optional</em>) – optional output tuple.</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.tensor([[6.80, -2.11,  5.66,  5.97,  8.23],
 [-6.05, -3.30,  5.36, -4.44,  1.08],
 [-0.45,  2.58, -2.70,  0.27,  9.04],
 [8.32,  2.71,  4.35,  -7.17,  2.14],
 [-9.67, -5.14, -7.26,  6.08, -6.87]]).t()
&gt;&gt;&gt; B = torch.tensor([[4.02,  6.19, -8.22, -7.57, -3.03],
 [-1.56,  4.00, -8.67,  1.75,  2.86],
 [9.81, -4.09, -4.57, -8.61,  8.99]]).t()
&gt;&gt;&gt; X, LU = torch.gesv(B, A)
&gt;&gt;&gt; torch.dist(B, torch.mm(A, X))
tensor(1.00000e-06 *
 7.0977)

&gt;&gt;&gt; # Batched solver example
&gt;&gt;&gt; A = torch.randn(2, 3, 1, 4, 4)
&gt;&gt;&gt; B = torch.randn(2, 3, 1, 4, 6)
&gt;&gt;&gt; X, LU = torch.gesv(B, A)
&gt;&gt;&gt; torch.dist(B, A.matmul(X))
tensor(1.00000e-06 *
 3.6386)

</code></pre>
<pre><code class="language-py">torch.inverse(input, out=None) → Tensor
</code></pre>
<p>Takes the inverse of the square matrix <code>input</code>. <code>input</code> can be batches of 2D square tensors, in which case this function would return a tensor composed of individual inverses.</p>
<p>Note</p>
<p>Irrespective of the original strides, the returned tensors will be transposed, i.e. with strides like <code>input.contiguous().transpose(-2, -1).strides()</code></p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor of size (<a href="#id8">*</a>, n, n) where <code>*</code> is zero or more batch dimensions</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the optional output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; x = torch.rand(4, 4)
&gt;&gt;&gt; y = torch.inverse(x)
&gt;&gt;&gt; z = torch.mm(x, y)
&gt;&gt;&gt; z
tensor([[ 1.0000, -0.0000, -0.0000,  0.0000],
 [ 0.0000,  1.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  1.0000,  0.0000],
 [ 0.0000, -0.0000, -0.0000,  1.0000]])
&gt;&gt;&gt; torch.max(torch.abs(z - torch.eye(4))) # Max non-zero
tensor(1.1921e-07)
&gt;&gt;&gt; # Batched inverse example
&gt;&gt;&gt; x = torch.randn(2, 3, 4, 4)
&gt;&gt;&gt; y = torch.inverse(x)
&gt;&gt;&gt; z = torch.matmul(x, y)
&gt;&gt;&gt; torch.max(torch.abs(z - torch.eye(4).expand_as(x))) # Max non-zero
tensor(1.9073e-06)

</code></pre>
<pre><code class="language-py">torch.det(A) → Tensor
</code></pre>
<p>Calculates determinant of a 2D square tensor.</p>
<p>Note</p>
<p>Backward through <a href="#torch.det" title="torch.det"><code>det()</code></a> internally uses SVD results when <code>A</code> is not invertible. In this case, double backward through <a href="#torch.det" title="torch.det"><code>det()</code></a> will be unstable in when <code>A</code> doesn’t have distinct singular values. See <a href="#torch.svd" title="torch.svd"><code>svd()</code></a> for details.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – The input 2D square tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(3, 3)
&gt;&gt;&gt; torch.det(A)
tensor(3.7641)

</code></pre>
<pre><code class="language-py">torch.logdet(A) → Tensor
</code></pre>
<p>Calculates log determinant of a 2D square tensor.</p>
<p>Note</p>
<p>Result is <code>-inf</code> if <code>A</code> has zero log determinant, and is <code>nan</code> if <code>A</code> has negative determinant.</p>
<p>Note</p>
<p>Backward through <a href="#torch.logdet" title="torch.logdet"><code>logdet()</code></a> internally uses SVD results when <code>A</code> is not invertible. In this case, double backward through <a href="#torch.logdet" title="torch.logdet"><code>logdet()</code></a> will be unstable in when <code>A</code> doesn’t have distinct singular values. See <a href="#torch.svd" title="torch.svd"><code>svd()</code></a> for details.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – The input 2D square tensor</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(3, 3)
&gt;&gt;&gt; torch.det(A)
tensor(0.2611)
&gt;&gt;&gt; torch.logdet(A)
tensor(-1.3430)

</code></pre>
<pre><code class="language-py">torch.slogdet(A) -&gt; (Tensor, Tensor)
</code></pre>
<p>Calculates the sign and log value of a 2D square tensor’s determinant.</p>
<p>Note</p>
<p>If <code>A</code> has zero determinant, this returns <code>(0, -inf)</code>.</p>
<p>Note</p>
<p>Backward through <a href="#torch.slogdet" title="torch.slogdet"><code>slogdet()</code></a> internally uses SVD results when <code>A</code> is not invertible. In this case, double backward through <a href="#torch.slogdet" title="torch.slogdet"><code>slogdet()</code></a> will be unstable in when <code>A</code> doesn’t have distinct singular values. See <a href="#torch.svd" title="torch.svd"><code>svd()</code></a> for details.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – The input 2D square tensor</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>A tuple containing the sign of the determinant, and the log value of the absolute determinant.</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(3, 3)
&gt;&gt;&gt; torch.det(A)
tensor(-4.8215)
&gt;&gt;&gt; torch.logdet(A)
tensor(nan)
&gt;&gt;&gt; torch.slogdet(A)
(tensor(-1.), tensor(1.5731))

</code></pre>
<pre><code class="language-py">torch.matmul(tensor1, tensor2, out=None) → Tensor
</code></pre>
<p>Matrix product of two tensors.</p>
<p>The behavior depends on the dimensionality of the tensors as follows:</p>
<ul>
<li>If both tensors are 1-dimensional, the dot product (scalar) is returned.</li>
<li>If both arguments are 2-dimensional, the matrix-matrix product is returned.</li>
<li>If the first argument is 1-dimensional and the second argument is 2-dimensional, a 1 is prepended to its dimension for the purpose of the matrix multiply. After the matrix multiply, the prepended dimension is removed.</li>
<li>If the first argument is 2-dimensional and the second argument is 1-dimensional, the matrix-vector product is returned.</li>
<li>If both arguments are at least 1-dimensional and at least one argument is N-dimensional (where N &gt; 2), then a batched matrix multiply is returned. If the first argument is 1-dimensional, a 1 is prepended to its dimension for the purpose of the batched matrix multiply and removed after. If the second argument is 1-dimensional, a 1 is appended to its dimension for the purpose of the batched matrix multiple and removed after. The non-matrix (i.e. batch) dimensions are <a href="notes/broadcasting.html#broadcasting-semantics">broadcasted</a> (and thus must be broadcastable). For example, if <code>tensor1</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a4697ce48760baf0633769e49f46b335.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/a4697ce48760baf0633769e49f46b335.jpg" alt=""></a> tensor and <code>tensor2</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ad9fbe324dcc50cc2232a9c1a2675daf.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ad9fbe324dcc50cc2232a9c1a2675daf.jpg" alt=""></a> tensor, <code>out</code> will be an <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6082fde6b0f498f9ed21c0ac7a9709d3.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6082fde6b0f498f9ed21c0ac7a9709d3.jpg" alt=""></a> tensor.</li>
</ul>
<p>Note</p>
<p>The 1-dimensional dot product version of this function does not support an <code>out</code> parameter.</p>
<p>Parameters:</p>
<ul>
<li><strong>tensor1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first tensor to be multiplied</li>
<li><strong>tensor2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second tensor to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; # vector x vector
&gt;&gt;&gt; tensor1 = torch.randn(3)
&gt;&gt;&gt; tensor2 = torch.randn(3)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([])
&gt;&gt;&gt; # matrix x vector
&gt;&gt;&gt; tensor1 = torch.randn(3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(4)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([3])
&gt;&gt;&gt; # batched matrix x broadcasted vector
&gt;&gt;&gt; tensor1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(4)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([10, 3])
&gt;&gt;&gt; # batched matrix x batched matrix
&gt;&gt;&gt; tensor1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(10, 4, 5)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([10, 3, 5])
&gt;&gt;&gt; # batched matrix x broadcasted matrix
&gt;&gt;&gt; tensor1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(4, 5)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([10, 3, 5])

</code></pre>
<pre><code class="language-py">torch.matrix_power(input, n) → Tensor
</code></pre>
<p>Returns the matrix raised to the power <code>n</code> for square matrices. For batch of matrices, each individual matrix is raised to the power <code>n</code>.</p>
<p>If <code>n</code> is negative, then the inverse of the matrix (if invertible) is raised to the power <code>n</code>. For a batch of matrices, the batched inverse (if invertible) is raised to the power <code>n</code>. If <code>n</code> is 0, then an identity matrix is returned.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input tensor</li>
<li><strong>n</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the power to raise the matrix to</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(2, 2, 2)
&gt;&gt;&gt; a
tensor([[[-1.9975, -1.9610],
 [ 0.9592, -2.3364]],

 [[-1.2534, -1.3429],
 [ 0.4153, -1.4664]]])
&gt;&gt;&gt; torch.matrix_power(a, 3)
tensor([[[  3.9392, -23.9916],
 [ 11.7357,  -0.2070]],

 [[  0.2468,  -6.7168],
 [  2.0774,  -0.8187]]])

</code></pre>
<pre><code class="language-py">torch.matrix_rank(input, tol=None, bool symmetric=False) → Tensor
</code></pre>
<p>Returns the numerical rank of a 2-D tensor. The method to compute the matrix rank is done using SVD by default. If <code>symmetric</code> is <code>True</code>, then <code>input</code> is assumed to be symmetric, and the computation of the rank is done by obtaining the eigenvalues.</p>
<p><code>tol</code> is the threshold below which the singular values (or the eigenvalues when <code>symmetric</code> is <code>True</code>) are considered to be 0. If <code>tol</code> is not specified, <code>tol</code> is set to <code>S.max() * max(S.size()) * eps</code> where <code>S</code> is the singular values (or the eigenvalues when <code>symmetric</code> is <code>True</code>), and <code>eps</code> is the epsilon value for the datatype of <code>input</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input 2-D tensor</li>
<li><strong>tol</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – the tolerance value. Default: <code>None</code></li>
<li><strong>symmetric</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – indicates whether <code>input</code> is symmetric. Default: <code>False</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.eye(10)
&gt;&gt;&gt; torch.matrix_rank(a)
tensor(10)
&gt;&gt;&gt; b = torch.eye(10)
&gt;&gt;&gt; b[0, 0] = 0
&gt;&gt;&gt; torch.matrix_rank(b)
tensor(9)

</code></pre>
<pre><code class="language-py">torch.mm(mat1, mat2, out=None) → Tensor
</code></pre>
<p>Performs a matrix multiplication of the matrices <code>mat1</code> and <code>mat2</code>.</p>
<p>If <code>mat1</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a> tensor, <code>mat2</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec84c2d649caa2a7d4dc59b6b23b0278.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ec84c2d649caa2a7d4dc59b6b23b0278.jpg" alt=""></a> tensor, <code>out</code> will be a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/42cdcd96fd628658ac0e3e7070ba08d5.jpg" alt=""></a> tensor.</p>
<p>Note</p>
<p>This function does not <a href="notes/broadcasting.html#broadcasting-semantics">broadcast</a>. For broadcasting matrix products, see <a href="#torch.matmul" title="torch.matmul"><code>torch.matmul()</code></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>mat1</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the first matrix to be multiplied</li>
<li><strong>mat2</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the second matrix to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; mat1 = torch.randn(2, 3)
&gt;&gt;&gt; mat2 = torch.randn(3, 3)
&gt;&gt;&gt; torch.mm(mat1, mat2)
tensor([[ 0.4851,  0.5037, -0.3633],
 [-0.0760, -3.6705,  2.4784]])

</code></pre>
<pre><code class="language-py">torch.mv(mat, vec, out=None) → Tensor
</code></pre>
<p>Performs a matrix-vector product of the matrix <code>mat</code> and the vector <code>vec</code>.</p>
<p>If <code>mat</code> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a> tensor, <code>vec</code> is a 1-D tensor of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" alt=""></a>, <code>out</code> will be 1-D of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/493731e423d5db62086d0b8705dda0c8.jpg" alt=""></a>.</p>
<p>Note</p>
<p>This function does not <a href="notes/broadcasting.html#broadcasting-semantics">broadcast</a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>mat</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – matrix to be multiplied</li>
<li><strong>vec</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – vector to be multiplied</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; mat = torch.randn(2, 3)
&gt;&gt;&gt; vec = torch.randn(3)
&gt;&gt;&gt; torch.mv(mat, vec)
tensor([ 1.0404, -0.6361])

</code></pre>
<pre><code class="language-py">torch.orgqr(a, tau) → Tensor
</code></pre>
<p>Computes the orthogonal matrix <code>Q</code> of a QR factorization, from the <code>(a, tau)</code> tuple returned by <a href="#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a>.</p>
<p>This directly calls the underlying LAPACK function <code>?orgqr</code>. See <a href="https://software.intel.com/en-us/mkl-developer-reference-c-orgqr">LAPACK documentation for orgqr</a> for further details.</p>
<p>Parameters:</p>
<ul>
<li><strong>a</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the <code>a</code> from <a href="#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a>.</li>
<li><strong>tau</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the <code>tau</code> from <a href="#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a>.</li>
</ul>
<pre><code class="language-py">torch.ormqr(a, tau, mat, left=True, transpose=False) -&gt; (Tensor, Tensor)
</code></pre>
<p>Multiplies <code>mat</code> by the orthogonal <code>Q</code> matrix of the QR factorization formed by <a href="#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a> that is represented by <code>(a, tau)</code>.</p>
<p>This directly calls the underlying LAPACK function <code>?ormqr</code>. See <a href="https://software.intel.com/en-us/mkl-developer-reference-c-ormqr">LAPACK documentation for ormqr</a> for further details.</p>
<p>Parameters:</p>
<ul>
<li><strong>a</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the <code>a</code> from <a href="#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a>.</li>
<li><strong>tau</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the <code>tau</code> from <a href="#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a>.</li>
<li><strong>mat</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the matrix to be multiplied.</li>
</ul>
<pre><code class="language-py">torch.pinverse(input, rcond=1e-15) → Tensor
</code></pre>
<p>Calculates the pseudo-inverse (also known as the Moore-Penrose inverse) of a 2D tensor. Please look at <a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse">Moore-Penrose inverse</a> for more details</p>
<p>Note</p>
<p>This method is implemented using the Singular Value Decomposition.</p>
<p>Note</p>
<p>The pseudo-inverse is not necessarily a continuous function in the elements of the matrix <a href="1">1</a>(https://epubs.siam.org/doi/10.1137/0117004). Therefore, derivatives are not always existent, and exist for a constant rank only <a href="2">2</a>(https://www.jstor.org/stable/2156365). However, this method is backprop-able due to the implementation by using SVD results, and could be unstable. Double-backward will also be unstable due to the usage of SVD internally. See <a href="#torch.svd" title="torch.svd"><code>svd()</code></a> for more details.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – The input 2D tensor of dimensions <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ee12b6c487a34051534acf84ddb3f98f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ee12b6c487a34051534acf84ddb3f98f.jpg" alt=""></a></li>
<li><strong>rcond</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – A floating point value to determine the cutoff for small singular values. Default: 1e-15</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>The pseudo-inverse of <code>input</code> of dimensions <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3380c6697127aa874110f3e6faef8bdf.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3380c6697127aa874110f3e6faef8bdf.jpg" alt=""></a></th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.randn(3, 5)
&gt;&gt;&gt; input
tensor([[ 0.5495,  0.0979, -1.4092, -0.1128,  0.4132],
 [-1.1143, -0.3662,  0.3042,  1.6374, -0.9294],
 [-0.3269, -0.5745, -0.0382, -0.5922, -0.6759]])
&gt;&gt;&gt; torch.pinverse(input)
tensor([[ 0.0600, -0.1933, -0.2090],
 [-0.0903, -0.0817, -0.4752],
 [-0.7124, -0.1631, -0.2272],
 [ 0.1356,  0.3933, -0.5023],
 [-0.0308, -0.1725, -0.5216]])

</code></pre>
<pre><code class="language-py">torch.potrf(a, upper=True, out=None)
</code></pre>
<p>Computes the Cholesky decomposition of a symmetric positive-definite matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a>.</p>
<p>For more information, regarding <a href="#torch.potrf" title="torch.potrf"><code>torch.potrf()</code></a>, please check <a href="#torch.cholesky" title="torch.cholesky"><code>torch.cholesky()</code></a>.</p>
<p>Warning</p>
<p>torch.potrf is deprecated in favour of torch.cholesky and will be removed in the next release. Please use torch.cholesky instead and note that the <code>upper</code> argument in torch.cholesky defaults to <code>False</code>.</p>
<pre><code class="language-py">torch.potri(u, upper=True, out=None) → Tensor
</code></pre>
<p>Computes the inverse of a positive semidefinite matrix given its Cholesky factor <code>u</code>: returns matrix <code>inv</code></p>
<p>If <code>upper</code> is <code>True</code> or not provided, <code>u</code> is upper triangular such that the returned tensor is</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8e80431286b91606da8941100c871bc6.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/8e80431286b91606da8941100c871bc6.jpg" alt=""></a></p>
<p>If <code>upper</code> is <code>False</code>, <code>u</code> is lower triangular such that the returned tensor is</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41fe857d2b3b29df4a984ddab7b21847.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/41fe857d2b3b29df4a984ddab7b21847.jpg" alt=""></a></p>
<p>Parameters:</p>
<ul>
<li><strong>u</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input 2-D tensor, a upper or lower triangular Cholesky factor</li>
<li><strong>upper</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether to return a upper (default) or lower triangular matrix</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor for <code>inv</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a = torch.mm(a, a.t()) # make symmetric positive definite
&gt;&gt;&gt; u = torch.cholesky(a)
&gt;&gt;&gt; a
tensor([[  0.9935,  -0.6353,   1.5806],
 [ -0.6353,   0.8769,  -1.7183],
 [  1.5806,  -1.7183,  10.6618]])
&gt;&gt;&gt; torch.potri(u)
tensor([[ 1.9314,  1.2251, -0.0889],
 [ 1.2251,  2.4439,  0.2122],
 [-0.0889,  0.2122,  0.1412]])
&gt;&gt;&gt; a.inverse()
tensor([[ 1.9314,  1.2251, -0.0889],
 [ 1.2251,  2.4439,  0.2122],
 [-0.0889,  0.2122,  0.1412]])

</code></pre>
<pre><code class="language-py">torch.potrs(b, u, upper=True, out=None) → Tensor
</code></pre>
<p>Solves a linear system of equations with a positive semidefinite matrix to be inverted given its Cholesky factor matrix <code>u</code>.</p>
<p>If <code>upper</code> is <code>True</code> or not provided, <code>u</code> is upper triangular and <code>c</code> is returned such that:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/886788a09088ffab8386053266129b3c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/886788a09088ffab8386053266129b3c.jpg" alt=""></a></p>
<p>If <code>upper</code> is <code>False</code>, <code>u</code> is and lower triangular and <code>c</code> is returned such that:</p>
<p><a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/17f8916876d295a6aef6f97efbae20d5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/17f8916876d295a6aef6f97efbae20d5.jpg" alt=""></a></p>
<p><code>torch.potrs(b, u)</code> can take in 2D inputs <code>b, u</code> or inputs that are batches of 2D matrices. If the inputs are batches, then returns batched outputs <code>c</code></p>
<p>Note</p>
<p>The <code>out</code> keyword only supports 2D matrix inputs, that is, <code>b, u</code> must be 2D matrices.</p>
<p>Parameters:</p>
<ul>
<li><strong>b</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – input matrix of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d9795910f977049c4df2084f47c592ed.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/d9795910f977049c4df2084f47c592ed.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> is zero or more batch dimensions</li>
<li><strong>u</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – input matrix of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/494aaae2a24df44c813ce87b9f21d745.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/494aaae2a24df44c813ce87b9f21d745.jpg" alt=""></a>, where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/28ec51e742166ea3400be6e7343bbfa5.jpg" alt=""></a> is zero of more batch dimensions composed of upper or lower triangular Cholesky factor</li>
<li><strong>upper</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether to return a upper (default) or lower triangular matrix</li>
<li><strong>out</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – the output tensor for <code>c</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a = torch.mm(a, a.t()) # make symmetric positive definite
&gt;&gt;&gt; u = torch.cholesky(a)
&gt;&gt;&gt; a
tensor([[ 0.7747, -1.9549,  1.3086],
 [-1.9549,  6.7546, -5.4114],
 [ 1.3086, -5.4114,  4.8733]])
&gt;&gt;&gt; b = torch.randn(3, 2)
&gt;&gt;&gt; b
tensor([[-0.6355,  0.9891],
 [ 0.1974,  1.4706],
 [-0.4115, -0.6225]])
&gt;&gt;&gt; torch.potrs(b,u)
tensor([[ -8.1625,  19.6097],
 [ -5.8398,  14.2387],
 [ -4.3771,  10.4173]])
&gt;&gt;&gt; torch.mm(a.inverse(),b)
tensor([[ -8.1626,  19.6097],
 [ -5.8398,  14.2387],
 [ -4.3771,  10.4173]])

</code></pre>
<pre><code class="language-py">torch.pstrf(a, upper=True, out=None) -&gt; (Tensor, Tensor)
</code></pre>
<p>Computes the pivoted Cholesky decomposition of a positive semidefinite matrix <code>a</code>. returns matrices <code>u</code> and <code>piv</code>.</p>
<p>If <code>upper</code> is <code>True</code> or not provided, <code>u</code> is upper triangular such that <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1fb46274ab877a719bfb6aad1055a2ac.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1fb46274ab877a719bfb6aad1055a2ac.jpg" alt=""></a>, with <code>p</code> the permutation given by <code>piv</code>.</p>
<p>If <code>upper</code> is <code>False</code>, <code>u</code> is lower triangular such that <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/294e0994f5012c83c1e0c122c5a406a2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/294e0994f5012c83c1e0c122c5a406a2.jpg" alt=""></a>.</p>
<p>Parameters:</p>
<ul>
<li><strong>a</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input 2-D tensor</li>
<li><strong>upper</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether to return a upper (default) or lower triangular matrix</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – tuple of <code>u</code> and <code>piv</code> tensors</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.randn(3, 3)
&gt;&gt;&gt; a = torch.mm(a, a.t()) # make symmetric positive definite
&gt;&gt;&gt; a
tensor([[ 3.5405, -0.4577,  0.8342],
 [-0.4577,  1.8244, -0.1996],
 [ 0.8342, -0.1996,  3.7493]])
&gt;&gt;&gt; u,piv = torch.pstrf(a)
&gt;&gt;&gt; u
tensor([[ 1.9363,  0.4308, -0.1031],
 [ 0.0000,  1.8316, -0.2256],
 [ 0.0000,  0.0000,  1.3277]])
&gt;&gt;&gt; piv
tensor([ 2,  0,  1], dtype=torch.int32)
&gt;&gt;&gt; p = torch.eye(3).index_select(0,piv.long()).index_select(0,piv.long()).t() # make pivot permutation
&gt;&gt;&gt; torch.mm(torch.mm(p.t(),torch.mm(u.t(),u)),p) # reconstruct
tensor([[ 3.5405, -0.4577,  0.8342],
 [-0.4577,  1.8244, -0.1996],
 [ 0.8342, -0.1996,  3.7493]])

</code></pre>
<pre><code class="language-py">torch.qr(input, out=None) -&gt; (Tensor, Tensor)
</code></pre>
<p>Computes the QR decomposition of a matrix <code>input</code>, and returns matrices <code>Q</code> and <code>R</code> such that <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5dcc06c3a05a06beb80d3f1ef2e078f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/5dcc06c3a05a06beb80d3f1ef2e078f2.jpg" alt=""></a>, with <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d680db5f32fd278f8d48e5407691154.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d680db5f32fd278f8d48e5407691154.jpg" alt=""></a> being an orthogonal matrix and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/502cdd9c79852b33d2a6d18ba5ec3102.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/502cdd9c79852b33d2a6d18ba5ec3102.jpg" alt=""></a> being an upper triangular matrix.</p>
<p>This returns the thin (reduced) QR factorization.</p>
<p>Note</p>
<p>precision may be lost if the magnitudes of the elements of <code>input</code> are large</p>
<p>Note</p>
<p>While it should always give you a valid decomposition, it may not give you the same one across platforms - it will depend on your LAPACK implementation.</p>
<p>Note</p>
<p>Irrespective of the original strides, the returned matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d680db5f32fd278f8d48e5407691154.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1d680db5f32fd278f8d48e5407691154.jpg" alt=""></a> will be transposed, i.e. with strides <code>(1, m)</code> instead of <code>(m, 1)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input 2-D tensor</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – tuple of <code>Q</code> and <code>R</code> tensors</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.tensor([[12., -51, 4], [6, 167, -68], [-4, 24, -41]])
&gt;&gt;&gt; q, r = torch.qr(a)
&gt;&gt;&gt; q
tensor([[-0.8571,  0.3943,  0.3314],
 [-0.4286, -0.9029, -0.0343],
 [ 0.2857, -0.1714,  0.9429]])
&gt;&gt;&gt; r
tensor([[ -14.0000,  -21.0000,   14.0000],
 [   0.0000, -175.0000,   70.0000],
 [   0.0000,    0.0000,  -35.0000]])
&gt;&gt;&gt; torch.mm(q, r).round()
tensor([[  12.,  -51.,    4.],
 [   6.,  167.,  -68.],
 [  -4.,   24.,  -41.]])
&gt;&gt;&gt; torch.mm(q.t(), q).round()
tensor([[ 1.,  0.,  0.],
 [ 0.,  1., -0.],
 [ 0., -0.,  1.]])

</code></pre>
<pre><code class="language-py">torch.svd(input, some=True, compute_uv=True, out=None) -&gt; (Tensor, Tensor, Tensor)
</code></pre>
<p><code>U, S, V = torch.svd(A)</code> returns the singular value decomposition of a real matrix <code>A</code> of size <code>(n x m)</code> such that <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/af257a01939a1fbe6211d4a4c168f25b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/af257a01939a1fbe6211d4a4c168f25b.jpg" alt=""></a>.</p>
<p><code>U</code> is of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" alt=""></a>.</p>
<p><code>S</code> is a diagonal matrix of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/b2d82f601df5521e215e30962b942ad1.jpg" alt=""></a>, represented as a vector of size <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f72656b2358852a4b20972b707fd8222.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f72656b2358852a4b20972b707fd8222.jpg" alt=""></a> containing the non-negative diagonal entries.</p>
<p><code>V</code> is of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" alt=""></a>.</p>
<p>If <code>some</code> is <code>True</code> (default), the returned <code>U</code> and <code>V</code> matrices will contain only <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3c84c3f757bca109ec4ed7fc0cada53f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/3c84c3f757bca109ec4ed7fc0cada53f.jpg" alt=""></a> orthonormal columns.</p>
<p>If <code>compute_uv</code> is <code>False</code>, the returned <code>U</code> and <code>V</code> matrices will be zero matrices of shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/7819768bc0adceb9951cf2ce9a0525f2.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" alt=""></a> respectively. <code>some</code> will be ignored here.</p>
<p>Note</p>
<p>The implementation of SVD on CPU uses the LAPACK routine <code>?gesdd</code> (a divide-and-conquer algorithm) instead of <code>?gesvd</code> for speed. Analogously, the SVD on GPU uses the MAGMA routine <code>gesdd</code> as well.</p>
<p>Note</p>
<p>Irrespective of the original strides, the returned matrix <code>U</code> will be transposed, i.e. with strides <code>(1, n)</code> instead of <code>(n, 1)</code>.</p>
<p>Note</p>
<p>Extra care needs to be taken when backward through <code>U</code> and <code>V</code> outputs. Such operation is really only stable when <code>input</code> is full rank with all distinct singular values. Otherwise, <code>NaN</code> can appear as the gradients are not properly defined. Also, notice that double backward will usually do an additional backward through <code>U</code> and <code>V</code> even if the original backward is only on <code>S</code>.</p>
<p>Note</p>
<p>When <code>some</code> = <code>False</code>, the gradients on <code>U[:, min(n, m):]</code> and <code>V[:, min(n, m):]</code> will be ignored in backward as those vectors can be arbitrary bases of the subspaces.</p>
<p>Note</p>
<p>When <code>compute_uv</code> = <code>False</code>, backward cannot be performed since <code>U</code> and <code>V</code> from the forward pass is required for the backward operation.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input 2-D tensor</li>
<li><strong>some</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – controls the shape of returned <code>U</code> and <code>V</code></li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the output tuple of tensors</li>
</ul>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.tensor([[8.79,  6.11, -9.15,  9.57, -3.49,  9.84],
 [9.93,  6.91, -7.93,  1.64,  4.02,  0.15],
 [9.83,  5.04,  4.86,  8.83,  9.80, -8.99],
 [5.45, -0.27,  4.85,  0.74, 10.00, -6.02],
 [3.16,  7.98,  3.01,  5.80,  4.27, -5.31]]).t()

&gt;&gt;&gt; u, s, v = torch.svd(a)
&gt;&gt;&gt; u
tensor([[-0.5911,  0.2632,  0.3554,  0.3143,  0.2299],
 [-0.3976,  0.2438, -0.2224, -0.7535, -0.3636],
 [-0.0335, -0.6003, -0.4508,  0.2334, -0.3055],
 [-0.4297,  0.2362, -0.6859,  0.3319,  0.1649],
 [-0.4697, -0.3509,  0.3874,  0.1587, -0.5183],
 [ 0.2934,  0.5763, -0.0209,  0.3791, -0.6526]])
&gt;&gt;&gt; s
tensor([ 27.4687,  22.6432,   8.5584,   5.9857,   2.0149])
&gt;&gt;&gt; v
tensor([[-0.2514,  0.8148, -0.2606,  0.3967, -0.2180],
 [-0.3968,  0.3587,  0.7008, -0.4507,  0.1402],
 [-0.6922, -0.2489, -0.2208,  0.2513,  0.5891],
 [-0.3662, -0.3686,  0.3859,  0.4342, -0.6265],
 [-0.4076, -0.0980, -0.4933, -0.6227, -0.4396]])
&gt;&gt;&gt; torch.dist(a, torch.mm(torch.mm(u, torch.diag(s)), v.t()))
tensor(1.00000e-06 *
 9.3738)

</code></pre>
<pre><code class="language-py">torch.symeig(input, eigenvectors=False, upper=True, out=None) -&gt; (Tensor, Tensor)
</code></pre>
<p>This function returns eigenvalues and eigenvectors of a real symmetric matrix <code>input</code>, represented by a tuple <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/07aa3eb39d8bb2f8d4d17cd4925159b4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/07aa3eb39d8bb2f8d4d17cd4925159b4.jpg" alt=""></a>.</p>
<p><code>input</code> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/21ec2ab32d1af3e766487093bb20cf22.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/21ec2ab32d1af3e766487093bb20cf22.jpg" alt=""></a> are <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" alt=""></a> matrices and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be8982d125e27260b5c793cf0d39d70a.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be8982d125e27260b5c793cf0d39d70a.jpg" alt=""></a> is a <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/20ddd8181c2e0d0fb893637e8572d475.jpg" alt=""></a> dimensional vector.</p>
<p>This function calculates all eigenvalues (and vectors) of <code>input</code> such that <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db9e47c935013aa5b30057ba51ac84b9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/db9e47c935013aa5b30057ba51ac84b9.jpg" alt=""></a>.</p>
<p>The boolean argument <code>eigenvectors</code> defines computation of eigenvectors or eigenvalues only.</p>
<p>If it is <code>False</code>, only eigenvalues are computed. If it is <code>True</code>, both eigenvalues and eigenvectors are computed.</p>
<p>Since the input matrix <code>input</code> is supposed to be symmetric, only the upper triangular portion is used by default.</p>
<p>If <code>upper</code> is <code>False</code>, then lower triangular portion is used.</p>
<p>Note: Irrespective of the original strides, the returned matrix <code>V</code> will be transposed, i.e. with strides <code>(1, m)</code> instead of <code>(m, 1)</code>.</p>
<p>Parameters:</p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input symmetric matrix</li>
<li><strong>eigenvectors</strong> (<em>boolean</em>_,_ <em>optional</em>) – controls whether eigenvectors have to be computed</li>
<li><strong>upper</strong> (<em>boolean</em>_,_ <em>optional</em>) – controls whether to consider upper-triangular or lower-triangular region</li>
<li><strong>out</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – the output tuple of (Tensor, Tensor)</li>
</ul>
<p>| Returns: | A tuple containing</p>
<p>&gt; * <strong>e</strong> (<em>Tensor</em>): Shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2f4b02bcd5b11d436474c4c4cdb91683.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/2f4b02bcd5b11d436474c4c4cdb91683.jpg" alt=""></a>. Each element is an eigenvalue of <code>input</code>, The eigenvalues are in ascending order. &gt; * <strong>V</strong> (<em>Tensor</em>): Shape <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/be5a855e888d33755dcdfa9d94e598d4.jpg" alt=""></a>. If <code>eigenvectors=False</code>, it’s a tensor filled with zeros. Otherwise, this tensor contains the orthonormal eigenvectors of the <code>input</code>.</p>
<table>
<thead>
<tr>
<th>Return type:</th>
<th>(<a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>, <a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; a = torch.tensor([[ 1.96,  0.00,  0.00,  0.00,  0.00],
 [-6.49,  3.80,  0.00,  0.00,  0.00],
 [-0.47, -6.39,  4.17,  0.00,  0.00],
 [-7.20,  1.50, -1.51,  5.70,  0.00],
 [-0.65, -6.34,  2.67,  1.80, -7.10]]).t()
&gt;&gt;&gt; e, v = torch.symeig(a, eigenvectors=True)
&gt;&gt;&gt; e
tensor([-11.0656,  -6.2287,   0.8640,   8.8655,  16.0948])
&gt;&gt;&gt; v
tensor([[-0.2981, -0.6075,  0.4026, -0.3745,  0.4896],
 [-0.5078, -0.2880, -0.4066, -0.3572, -0.6053],
 [-0.0816, -0.3843, -0.6600,  0.5008,  0.3991],
 [-0.0036, -0.4467,  0.4553,  0.6204, -0.4564],
 [-0.8041,  0.4480,  0.1725,  0.3108,  0.1622]])

</code></pre>
<pre><code class="language-py">torch.trtrs(b, A, upper=True, transpose=False, unitriangular=False) -&gt; (Tensor, Tensor)
</code></pre>
<p>Solves a system of equations with a triangular coefficient matrix <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> and multiple right-hand sides <code>b</code>.</p>
<p>In particular, solves <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79ccd3754eebf815ed3195b42f93bacb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79ccd3754eebf815ed3195b42f93bacb.jpg" alt=""></a> and assumes <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> is upper-triangular with the default keyword arguments.</p>
<p>Parameters:</p>
<ul>
<li><strong>A</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the input triangular coefficient matrix</li>
<li><strong>b</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – multiple right-hand sides. Each column of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6872867a863714d15d9a0d64c20734ce.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/6872867a863714d15d9a0d64c20734ce.jpg" alt=""></a> is a right-hand side for the system of equations.</li>
<li><strong>upper</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether to solve the upper-triangular system of equations (default) or the lower-triangular system of equations. Default: True.</li>
<li><strong>transpose</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> should be transposed before being sent into the solver. Default: False.</li>
<li><strong>unitriangular</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – whether <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> is unit triangular. If True, the diagonal elements of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> are assumed to be 1 and not referenced from <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a>. Default: False.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>A tuple <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1044f4a1887b042eb41d12f782c0582f.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1044f4a1887b042eb41d12f782c0582f.jpg" alt=""></a> where <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8961918eb987d8916766b1d77790ecb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/f8961918eb987d8916766b1d77790ecb.jpg" alt=""></a> is a clone of <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/efdb05f076173b39fdd26ef663e7b0d8.jpg" alt=""></a> and <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1284cf6bcb6c2ffc47e2dd24cd1c51b8.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/1284cf6bcb6c2ffc47e2dd24cd1c51b8.jpg" alt=""></a> is the solution to <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79ccd3754eebf815ed3195b42f93bacb.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/79ccd3754eebf815ed3195b42f93bacb.jpg" alt=""></a> (or whatever variant of the system of equations, depending on the keyword arguments.)</th>
</tr>
</thead>
<tbody></tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>A: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff833c4d1f13ca018e121d87f6ef1607.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff833c4d1f13ca018e121d87f6ef1607.jpg" alt=""></a></li>
<li>b: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a></li>
<li>output[0]: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" alt=""></a></li>
<li>output[1]: <a href="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff833c4d1f13ca018e121d87f6ef1607.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/pytorch-doc-zh/docs/1.0/img/ff833c4d1f13ca018e121d87f6ef1607.jpg" alt=""></a></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; A = torch.randn(2, 2).triu()
&gt;&gt;&gt; A
tensor([[ 1.1527, -1.0753],
 [ 0.0000,  0.7986]])
&gt;&gt;&gt; b = torch.randn(2, 3)
&gt;&gt;&gt; b
tensor([[-0.0210,  2.3513, -1.5492],
 [ 1.5429,  0.7403, -1.0243]])
&gt;&gt;&gt; torch.trtrs(b, A)
(tensor([[ 1.7840,  2.9045, -2.5405],
 [ 1.9319,  0.9269, -1.2826]]), tensor([[ 1.1527, -1.0753],
 [ 0.0000,  0.7986]]))

</code></pre>
<h2 id="utilities">Utilities</h2>
<pre><code class="language-py">torch.compiled_with_cxx11_abi()
</code></pre>
<p>Returns whether PyTorch was built with _GLIBCXX_USE_CXX11_ABI=1</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/162/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/162/index.html">Python方向综合面试题</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/92.html">jackfrued</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">115页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 35个">35</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/5/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/5/index.html">超级棒的"派神"书</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/5.html">zhaoolee</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/156/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/156/index.html">pyspider中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/88.html">aaronhua123</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">18页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月12日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/2/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/typescript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/2/index.html">TypeScript使用手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/2.html">zhongsp</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="typescript">typescript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">83页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1879个">1879</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/200/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/200/index.html">软件开发基础知识宝典</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/112.html">frank-lam</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/183/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/183/index.html">一起来学算法吧！</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/100.html">MisterBooo</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 97个">97</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../../" title="返回首页"><img class="" src="../../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../../book/169/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_getting_started.html" title="起步" data-book-page-rel-url="docs/1.0/tut_getting_started.html" data-book-page-id="11555">起步</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/deep_learning_60min_blitz.html" title="PyTorch 深度学习: 60 分钟极速入门" data-book-page-rel-url="docs/1.0/deep_learning_60min_blitz.html" data-book-page-id="11556">PyTorch 深度学习: 60 分钟极速入门</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_tensor_tutorial.html" title="什么是 PyTorch？" data-book-page-rel-url="docs/1.0/blitz_tensor_tutorial.html" data-book-page-id="11557">什么是 PyTorch？</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_autograd_tutorial.html" title="Autograd：自动求导" data-book-page-rel-url="docs/1.0/blitz_autograd_tutorial.html" data-book-page-id="11558">Autograd：自动求导</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_neural_networks_tutorial.html" title="神经网络" data-book-page-rel-url="docs/1.0/blitz_neural_networks_tutorial.html" data-book-page-id="11559">神经网络</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_cifar10_tutorial.html" title="训练分类器" data-book-page-rel-url="docs/1.0/blitz_cifar10_tutorial.html" data-book-page-id="11560">训练分类器</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/blitz_data_parallel_tutorial.html" title="可选：数据并行处理" data-book-page-rel-url="docs/1.0/blitz_data_parallel_tutorial.html" data-book-page-id="11561">可选：数据并行处理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/data_loading_tutorial.html" title="数据加载和处理教程" data-book-page-rel-url="docs/1.0/data_loading_tutorial.html" data-book-page-id="11562">数据加载和处理教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/pytorch_with_examples.html" title="用例子学习 PyTorch" data-book-page-rel-url="docs/1.0/pytorch_with_examples.html" data-book-page-id="11563">用例子学习 PyTorch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/transfer_learning_tutorial.html" title="迁移学习教程" data-book-page-rel-url="docs/1.0/transfer_learning_tutorial.html" data-book-page-id="11564">迁移学习教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/deploy_seq2seq_hybrid_frontend_tutorial.html" title="混合前端的 seq2seq 模型部署" data-book-page-rel-url="docs/1.0/deploy_seq2seq_hybrid_frontend_tutorial.html" data-book-page-id="11565">混合前端的 seq2seq 模型部署</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/saving_loading_models.html" title="Saving and Loading Models" data-book-page-rel-url="docs/1.0/saving_loading_models.html" data-book-page-id="11566">Saving and Loading Models</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn_tutorial.html" title="What is `torch.nn` _really_?" data-book-page-rel-url="docs/1.0/nn_tutorial.html" data-book-page-id="11567">What is `torch.nn` _really_?</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_image.html" title="图像" data-book-page-rel-url="docs/1.0/tut_image.html" data-book-page-id="11568">图像</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/finetuning_torchvision_models_tutorial.html" title="Torchvision 模型微调" data-book-page-rel-url="docs/1.0/finetuning_torchvision_models_tutorial.html" data-book-page-id="11569">Torchvision 模型微调</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/spatial_transformer_tutorial.html" title="空间变换器网络教程" data-book-page-rel-url="docs/1.0/spatial_transformer_tutorial.html" data-book-page-id="11570">空间变换器网络教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/neural_style_tutorial.html" title="使用 PyTorch 进行图像风格转换" data-book-page-rel-url="docs/1.0/neural_style_tutorial.html" data-book-page-id="11571">使用 PyTorch 进行图像风格转换</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/fgsm_tutorial.html" title="对抗性示例生成" data-book-page-rel-url="docs/1.0/fgsm_tutorial.html" data-book-page-id="11572">对抗性示例生成</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/super_resolution_with_caffe2.html" title="使用 ONNX 将模型从 PyTorch 传输到 Caffe2 和移动端" data-book-page-rel-url="docs/1.0/super_resolution_with_caffe2.html" data-book-page-id="11573">使用 ONNX 将模型从 PyTorch 传输到 Caffe2 和移动端</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_text.html" title="文本" data-book-page-rel-url="docs/1.0/tut_text.html" data-book-page-id="11574">文本</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/chatbot_tutorial.html" title="聊天机器人教程" data-book-page-rel-url="docs/1.0/chatbot_tutorial.html" data-book-page-id="11575">聊天机器人教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/char_rnn_generation_tutorial.html" title="使用字符级别特征的 RNN 网络生成姓氏" data-book-page-rel-url="docs/1.0/char_rnn_generation_tutorial.html" data-book-page-id="11576">使用字符级别特征的 RNN 网络生成姓氏</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/char_rnn_classification_tutorial.html" title="使用字符级别特征的 RNN 网络进行姓氏分类" data-book-page-rel-url="docs/1.0/char_rnn_classification_tutorial.html" data-book-page-id="11577">使用字符级别特征的 RNN 网络进行姓氏分类</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/deep_learning_nlp_tutorial.html" title="Deep Learning for NLP with Pytorch" data-book-page-rel-url="docs/1.0/deep_learning_nlp_tutorial.html" data-book-page-id="11578">Deep Learning for NLP with Pytorch</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_pytorch_tutorial.html" title="PyTorch 介绍" data-book-page-rel-url="docs/1.0/nlp_pytorch_tutorial.html" data-book-page-id="11579">PyTorch 介绍</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_deep_learning_tutorial.html" title="使用 PyTorch 进行深度学习" data-book-page-rel-url="docs/1.0/nlp_deep_learning_tutorial.html" data-book-page-id="11580">使用 PyTorch 进行深度学习</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_word_embeddings_tutorial.html" title="Word Embeddings: Encoding Lexical Semantics" data-book-page-rel-url="docs/1.0/nlp_word_embeddings_tutorial.html" data-book-page-id="11581">Word Embeddings: Encoding Lexical Semantics</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_sequence_models_tutorial.html" title="序列模型和 LSTM 网络" data-book-page-rel-url="docs/1.0/nlp_sequence_models_tutorial.html" data-book-page-id="11582">序列模型和 LSTM 网络</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nlp_advanced_tutorial.html" title="Advanced: Making Dynamic Decisions and the Bi-LSTM CRF" data-book-page-rel-url="docs/1.0/nlp_advanced_tutorial.html" data-book-page-id="11583">Advanced: Making Dynamic Decisions and the Bi-LSTM CRF</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/seq2seq_translation_tutorial.html" title="基于注意力机制的 seq2seq 神经网络翻译" data-book-page-rel-url="docs/1.0/seq2seq_translation_tutorial.html" data-book-page-id="11584">基于注意力机制的 seq2seq 神经网络翻译</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_generative.html" title="生成" data-book-page-rel-url="docs/1.0/tut_generative.html" data-book-page-id="11585">生成</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/dcgan_faces_tutorial.html" title="DCGAN Tutorial" data-book-page-rel-url="docs/1.0/dcgan_faces_tutorial.html" data-book-page-id="11586">DCGAN Tutorial</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_reinforcement_learning.html" title="强化学习" data-book-page-rel-url="docs/1.0/tut_reinforcement_learning.html" data-book-page-id="11587">强化学习</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/reinforcement_q_learning.html" title="Reinforcement Learning (DQN) Tutorial" data-book-page-rel-url="docs/1.0/reinforcement_q_learning.html" data-book-page-id="11588">Reinforcement Learning (DQN) Tutorial</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_extending_pytorch.html" title="扩展 PyTorch" data-book-page-rel-url="docs/1.0/tut_extending_pytorch.html" data-book-page-id="11589">扩展 PyTorch</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/numpy_extensions_tutorial.html" title="用 numpy 和 scipy 创建扩展" data-book-page-rel-url="docs/1.0/numpy_extensions_tutorial.html" data-book-page-id="11590">用 numpy 和 scipy 创建扩展</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cpp_extension.html" title="Custom C++   and CUDA Extensions" data-book-page-rel-url="docs/1.0/cpp_extension.html" data-book-page-id="11591">Custom C++ and CUDA Extensions</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torch_script_custom_ops.html" title="Extending TorchScript with Custom C++   Operators" data-book-page-rel-url="docs/1.0/torch_script_custom_ops.html" data-book-page-id="11592">Extending TorchScript with Custom C++ Operators</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_production_usage.html" title="生产性使用" data-book-page-rel-url="docs/1.0/tut_production_usage.html" data-book-page-id="11593">生产性使用</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/dist_tuto.html" title="Writing Distributed Applications with PyTorch" data-book-page-rel-url="docs/1.0/dist_tuto.html" data-book-page-id="11594">Writing Distributed Applications with PyTorch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/aws_distributed_training_tutorial.html" title="使用 Amazon AWS 进行分布式训练" data-book-page-rel-url="docs/1.0/aws_distributed_training_tutorial.html" data-book-page-id="11595">使用 Amazon AWS 进行分布式训练</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/ONNXLive.html" title="ONNX 现场演示教程" data-book-page-rel-url="docs/1.0/ONNXLive.html" data-book-page-id="11596">ONNX 现场演示教程</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cpp_export.html" title="在 C++ 中加载 PYTORCH 模型" data-book-page-rel-url="docs/1.0/cpp_export.html" data-book-page-id="11597">在 C++ 中加载 PYTORCH 模型</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tut_other_language.html" title="其它语言中的 PyTorch" data-book-page-rel-url="docs/1.0/tut_other_language.html" data-book-page-id="11598">其它语言中的 PyTorch</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cpp_frontend.html" title="使用 PyTorch C++ 前端" data-book-page-rel-url="docs/1.0/cpp_frontend.html" data-book-page-id="11599">使用 PyTorch C++ 前端</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_notes.html" title="注解" data-book-page-rel-url="docs/1.0/docs_notes.html" data-book-page-id="11600">注解</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_autograd.html" title="自动求导机制" data-book-page-rel-url="docs/1.0/notes_autograd.html" data-book-page-id="11601">自动求导机制</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_broadcasting.html" title="广播语义" data-book-page-rel-url="docs/1.0/notes_broadcasting.html" data-book-page-id="11602">广播语义</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_cuda.html" title="CUDA 语义" data-book-page-rel-url="docs/1.0/notes_cuda.html" data-book-page-id="11603">CUDA 语义</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_extending.html" title="Extending PyTorch" data-book-page-rel-url="docs/1.0/notes_extending.html" data-book-page-id="11604">Extending PyTorch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_faq.html" title="Frequently Asked Questions" data-book-page-rel-url="docs/1.0/notes_faq.html" data-book-page-id="11605">Frequently Asked Questions</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_multiprocessing.html" title="Multiprocessing best practices" data-book-page-rel-url="docs/1.0/notes_multiprocessing.html" data-book-page-id="11606">Multiprocessing best practices</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_randomness.html" title="Reproducibility" data-book-page-rel-url="docs/1.0/notes_randomness.html" data-book-page-id="11607">Reproducibility</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_serialization.html" title="Serialization semantics" data-book-page-rel-url="docs/1.0/notes_serialization.html" data-book-page-id="11608">Serialization semantics</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/notes_windows.html" title="Windows FAQ" data-book-page-rel-url="docs/1.0/notes_windows.html" data-book-page-id="11609">Windows FAQ</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_package_ref.html" title="包参考" data-book-page-rel-url="docs/1.0/docs_package_ref.html" data-book-page-id="11610">包参考</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torch.html" title="torch" data-book-page-rel-url="docs/1.0/torch.html" data-book-page-id="11611">torch</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tensors.html" title="torch.Tensor" data-book-page-rel-url="docs/1.0/tensors.html" data-book-page-id="11612">torch.Tensor</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/tensor_attributes.html" title="Tensor Attributes" data-book-page-rel-url="docs/1.0/tensor_attributes.html" data-book-page-id="11613">Tensor Attributes</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/type_info.html" title="数据类型信息" data-book-page-rel-url="docs/1.0/type_info.html" data-book-page-id="11614">数据类型信息</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/sparse.html" title="torch.sparse" data-book-page-rel-url="docs/1.0/sparse.html" data-book-page-id="11615">torch.sparse</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/cuda.html" title="torch.cuda" data-book-page-rel-url="docs/1.0/cuda.html" data-book-page-id="11616">torch.cuda</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/storage.html" title="torch.Storage" data-book-page-rel-url="docs/1.0/storage.html" data-book-page-id="11617">torch.Storage</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn.html" title="torch.nn" data-book-page-rel-url="docs/1.0/nn.html" data-book-page-id="11618">torch.nn</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn_functional.html" title="torch.nn.functional" data-book-page-rel-url="docs/1.0/nn_functional.html" data-book-page-id="11619">torch.nn.functional</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/nn_init.html" title="torch.nn.init" data-book-page-rel-url="docs/1.0/nn_init.html" data-book-page-id="11620">torch.nn.init</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/optim.html" title="torch.optim" data-book-page-rel-url="docs/1.0/optim.html" data-book-page-id="11621">torch.optim</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/autograd.html" title="Automatic differentiation package - torch.autograd" data-book-page-rel-url="docs/1.0/autograd.html" data-book-page-id="11622">Automatic differentiation package - torch.autograd</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/distributed.html" title="Distributed communication package - torch.distributed" data-book-page-rel-url="docs/1.0/distributed.html" data-book-page-id="11623">Distributed communication package - torch.distributed</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/distributions.html" title="Probability distributions - torch.distributions" data-book-page-rel-url="docs/1.0/distributions.html" data-book-page-id="11624">Probability distributions - torch.distributions</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/jit.html" title="Torch Script" data-book-page-rel-url="docs/1.0/jit.html" data-book-page-id="11625">Torch Script</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/multiprocessing.html" title="多进程包 - torch.multiprocessing" data-book-page-rel-url="docs/1.0/multiprocessing.html" data-book-page-id="11626">多进程包 - torch.multiprocessing</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/bottleneck.html" title="torch.utils.bottleneck" data-book-page-rel-url="docs/1.0/bottleneck.html" data-book-page-id="11627">torch.utils.bottleneck</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/checkpoint.html" title="torch.utils.checkpoint" data-book-page-rel-url="docs/1.0/checkpoint.html" data-book-page-id="11628">torch.utils.checkpoint</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_cpp_extension.html" title="torch.utils.cpp_extension" data-book-page-rel-url="docs/1.0/docs_cpp_extension.html" data-book-page-id="11629">torch.utils.cpp_extension</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/data.html" title="torch.utils.data" data-book-page-rel-url="docs/1.0/data.html" data-book-page-id="11630">torch.utils.data</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/dlpack.html" title="torch.utils.dlpack" data-book-page-rel-url="docs/1.0/dlpack.html" data-book-page-id="11631">torch.utils.dlpack</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/hub.html" title="torch.hub" data-book-page-rel-url="docs/1.0/hub.html" data-book-page-id="11632">torch.hub</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/model_zoo.html" title="torch.utils.model_zoo" data-book-page-rel-url="docs/1.0/model_zoo.html" data-book-page-id="11633">torch.utils.model_zoo</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/onnx.html" title="torch.onnx" data-book-page-rel-url="docs/1.0/onnx.html" data-book-page-id="11634">torch.onnx</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/distributed_deprecated.html" title="Distributed communication package (deprecated) - torch.distributed.deprecated" data-book-page-rel-url="docs/1.0/distributed_deprecated.html" data-book-page-id="11635">Distributed communication package (deprecated) - torch.distributed.deprecated</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/docs_torchvision_ref.html" title="torchvision 参考" data-book-page-rel-url="docs/1.0/docs_torchvision_ref.html" data-book-page-id="11636">torchvision 参考</a>
<ul>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_datasets.html" title="torchvision.datasets" data-book-page-rel-url="docs/1.0/torchvision_datasets.html" data-book-page-id="11637">torchvision.datasets</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_models.html" title="torchvision.models" data-book-page-rel-url="docs/1.0/torchvision_models.html" data-book-page-id="11638">torchvision.models</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_transforms.html" title="torchvision.transforms" data-book-page-rel-url="docs/1.0/torchvision_transforms.html" data-book-page-id="11639">torchvision.transforms</a>
</li>
<li>
<a class="pjax" href="../../../../book/169/docs/1.0/torchvision_utils.html" title="torchvision.utils" data-book-page-rel-url="docs/1.0/torchvision_utils.html" data-book-page-id="11640">torchvision.utils</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =169;var bookPageId =11611;var bookPageRelUrl ='docs/1.0/torch.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>