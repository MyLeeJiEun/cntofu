
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>添加新的协议-Scapy 中文文档(Welcome to Scapy's documentation)</title>
<meta content='添加新的协议,Scapy 中文文档,Welcome to Scapy's documentation' name='keywords'>
    <meta content='添加新的协议,Scapy 中文文档,Welcome to Scapy's documentation' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/33/5.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">构建你自己的工具</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/33/7.html">
<span class="">常见问题</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/33/index.html">Scapy 中文文档 (Welcome to Scapy's documentation)</a>
<a target="_blank" rel="nofollow" href="https://github.com/wizardforcel/scapy-docs-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="添加新的协议">添加新的协议</h1>
<blockquote>
<p>译者：<a href="http://blog.csdn.net/dj1174232716/">草帽小子_DJ</a></p>
</blockquote>
<blockquote>
<p>来源：<a href="http://blog.csdn.net/dj1174232716/article/details/49046409">Python Scapy（2.3.1）文档学习(六)：添加新的协议</a></p>
</blockquote>
<blockquote>
<p>原文：<a href="http://www.secdev.org/projects/scapy/doc/build_dissect.html">Adding new protocols</a></p>
</blockquote>
<blockquote>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/">CC BY-NC-SA 2.5</a></p>
</blockquote>
<p>在Scapy中添加新的协议(或者是更加的高级：新的协议层)是非常容易的。所有的魔法都在字段中，如果你需要的字段已经有了，你就不必对这个协议太伤脑筋，几分钟就能搞定了。</p>
<h2 id="简单的例子">简单的例子</h2>
<p>每一个协议层都是<code>Packet</code>类的子类。协议层背后所有逻辑的操作都是被<code>Packet</code>类和继承的类所处理的。一个简单的协议层是被一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为<code>fields_desc</code>的属性中。每一个字段都是一个<code>field</code>类的实例：</p>
<pre><code class="language-py">class Disney(Packet):
    name = "DisneyPacket "
    fields_desc=[ ShortField("mickey",5),
                 XByteField("minnie",3) ,
                 IntEnumField("donald" , 1 ,
                      { 1: "happy", 2: "cool" , 3: "angry" } ) ]
</code></pre>
<p>在这个例子中，我们的协议层有三个字段，第一个字段是一个2个字节的短整型字段，名字为<code>mickey</code>，默认值是5，第二个字段是1个自己的整形字段，名字为<code>minnie</code>，默认值是3，普通的<code>ByteField</code>和<code>XByteField</code>之间的唯一不同的就是首选的字段值是十六进制。最后一个字段是一个4个字节的整数字段，名字为<code>donald</code>，他不同于普通的<code>IntField</code>类型的是他有一些更小的值供选择，类似于枚举类型，比如说，如果他的值是3的话则显示<code>angry</code>。此外，如果<code>cool</code>值被关联到这个字段上，他将会明白接受的是2.</p>
<p>如果你的协议像上面这么简单，他已经可以用了：</p>
<pre><code>&gt;&gt;&gt; d=Disney(mickey=1)
&gt;&gt;&gt; ls(d)
mickey : ShortField = 1 (5)
minnie : XByteField = 3 (3)
donald : IntEnumField = 1 (1)
&gt;&gt;&gt; d.show()
###[ Disney Packet ]###
mickey= 1
minnie= 0x3
donald= happy
&gt;&gt;&gt; d.donald="cool"
&gt;&gt;&gt; str(d)
’\x00\x01\x03\x00\x00\x00\x02’
&gt;&gt;&gt; Disney( )
&lt;Disney mickey=1 minnie=0x3 donald=cool |&gt;
</code></pre>
<p>本章讲解了用Scapy如何构建一个新的协议，这里有两个目标：</p>
<p>分解：这样做是为了当接收到一个数据包时（来自网络或者是文件）能够被转化成Scapy的内部结构。</p>
<p>构建：当想发送一个新的数据包时，有些填充数据需要被自动的额调整。</p>
<h2 id="协议层">协议层</h2>
<p>在深入剖析之前，让我们来看看数据包是怎样组织的。</p>
<pre><code>&gt;&gt;&gt; p = IP()/TCP()/"AAAA"
&gt;&gt;&gt; p
&lt;IP  frag=0 proto=TCP |&lt;TCP  |&lt;Raw  load='AAAA' |&gt;&gt;&gt;
&gt;&gt;&gt; p.summary()
'IP / TCP 127.0.0.1:ftp-data &gt; 127.0.0.1:www S / Raw'
</code></pre>
<p>我们很感兴趣这两个内部的字段类<code>Packet</code>：</p>
<ul>
<li> <p><code>p.underlayer</code></p> </li>
<li> <p><code>p.payload</code></p> </li>
</ul>
<p>这里是主要的“伎俩”。你不必在乎数据包，只关注协议层，一个堆在另一个上面。</p>
<p>一个可以通过协议层的名字容易的访问协议层:<code>p[TCP]</code>返回的是TCP和下面的协议，这是<code>p.getlayer(TCP)</code>的一个快捷方式。</p>
<p>注意：这里有一个可选的参数<code>nb</code>，用来返回所需协议的第几层协议层。</p>
<p>让我们将所有的放在一起，玩玩这个TCP协议层：</p>
<pre><code>&gt;&gt;&gt; tcp=p[TCP]
&gt;&gt;&gt; tcp.underlayer
&lt;IP  frag=0 proto=TCP |&lt;TCP  |&lt;Raw  load='AAAA' |&gt;&gt;&gt;
&gt;&gt;&gt; tcp.payload
&lt;Raw  load='AAAA' |&gt;
</code></pre>
<p>不出所料，<code>tcp.underlayer</code>指向的是我们IP数据包的开始，而<code>tcp.payload</code>是他的有效载荷。</p>
<h3 id="构建一个新的协议层">构建一个新的协议层</h3>
<p>非常简单！一个协议层就是由一系列的字段构成。让我们来看看UDP的定义：</p>
<pre><code class="language-py">class UDP(Packet):
    name = "UDP"
    fields_desc = [ ShortEnumField("sport", 53, UDP_SERVICES),
                    ShortEnumField("dport", 53, UDP_SERVICES),
                    ShortField("len", None),
                    XShortField("chksum", None), ]
</code></pre>
<p>为了方便，内部已经定义了许多字段，看看文档“W”的源码Phil会告诉你的。（这句我也不知道原文是什么意思）。</p>
<p>所以，定义一个协议层就是简单的组合一系列的字段，现在的目标是为每个字段提供有限的默认值，所以当用户构建数据包的时候不必给他们赋值。</p>
<p>主要的机制是基于<code>Field</code>结构，要牢记协议层就只是一系列的字段，不用记得太多。</p>
<p>所以，为了理解协议层是怎样工作的，一个就是需要快速的看看字段是怎么被处理的。</p>
<h3 id="操作数据包操作他们的字段">操作数据包==操作他们的字段</h3>
<p>一个字段应该被考虑到有多种状态</p>
<ul>
<li> <p>i (internal) ：这是Scapy怎样操作它们的方法。</p> </li>
<li> <p>m (machine) ：这是真正的数据，这就是他们在网络上的样子。</p> </li>
<li> <p>h (human) ：如何将数据展示给人们看。</p> </li>
</ul>
<p>这解释了一些神秘的方法<code>i2h()</code>，<code>i2m()</code>，<code>m2i()</code>可以用于每一个字段：他们都是将一种状态转换成另一种状态，用于特殊的用途。</p>
<p>其他特殊的方法有：</p>
<ul>
<li> <p><code>any2i()</code>：猜测输入的状态装换为internal状态。</p> </li>
<li> <p><code>i2repr()</code>：比<code>i2h()</code>更好。</p> </li>
</ul>
<p>然而，所有的这些都是底层的方法。用于添加或提取字段到当前的协议的方法是：</p>
<ul>
<li> <p><code>addfield(self, pkt, s, val)</code>：复制网络上原始的字段值<code>val</code>（属于<code>pkt</code>协议层的）到原始的字符串数据包<code>s</code>：</p> <pre><code class="language-py">class StrFixedLenField(StrField):
    def addfield(self, pkt, s, val):
        return s+struct.pack("%is"%self.length,self.i2m(pkt, val))
</code></pre> </li>
<li> <p><code>getfield(self, pkt, s)</code>：从原始的数据包<code>s</code>中提取出属于协议层<code>pkt</code>的字段值。他返回一个序列，第一个元素是移除了被抽取的字段值的原始的数据包字符串，第二个元素是被抽取字段的internal的表示状态：</p> <pre><code class="language-py">class StrFixedLenField(StrField):
    def getfield(self, pkt, s):
        return s[self.length:], self.m2i(pkt,s[:self.length])
</code></pre> </li>
</ul>
<p>当定义你自己的协议层，你通常只需要定义一些<code>*2*()</code>方法，有时候也会有<code>addfield()</code>和<code>getfield()</code>方法。</p>
<h3 id="示例可变长度的数值">示例：可变长度的数值</h3>
<p>在协议中经常使用可变长度的数值的方法来表示整数，例如处理信号进程（MIDI）。</p>
<p>每一个数值的字节的MSB编码被设置为1，除了最后一个字节。比如，0x123456将会编码为0xC8E856：</p>
<pre><code class="language-py">def vlenq2str(l):
    s = []
    s.append( hex(l &amp; 0x7F) )
    l = l &gt;&gt; 7
    while l&gt;0:
        s.append( hex(0x80 | (l &amp; 0x7F) ) )
        l = l &gt;&gt; 7
    s.reverse()
    return "".join(map( lambda(x) : chr(int(x, 16)) , s))

def str2vlenq(s=""):
    i = l = 0
    while i&lt;len(s) and ord(s[i]) &amp; 0x80:
        l = l &lt;&lt; 7
        l = l + (ord(s[i]) &amp; 0x7F)
        i = i + 1
    if i == len(s):
        warning("Broken vlenq: no ending byte")
    l = l &lt;&lt; 7
    l = l + (ord(s[i]) &amp; 0x7F)

    return s[i+1:], l
</code></pre>
<p>我们将定义一个字段，该字段将自动计算相关联的字符串的长度，但会使用该编码格式：</p>
<pre><code class="language-py">class VarLenQField(Field):
    """ variable length quantities """

    def __init__(self, name, default, fld):
        Field.__init__(self, name, default)
        self.fld = fld

    def i2m(self, pkt, x):
        if x is None:
            f = pkt.get_field(self.fld)
            x = f.i2len(pkt, pkt.getfieldval(self.fld))
            x = vlenq2str(x)
        return str(x)

    def m2i(self, pkt, x):
        if s is None:
            return None, 0
        return str2vlenq(x)[1]

    def addfield(self, pkt, s, val):
        return s+self.i2m(pkt, val)

    def getfield(self, pkt, s):
        return str2vlenq(s)
</code></pre>
<p>现在用这种字段定义一个协议层：</p>
<pre><code class="language-py">class FOO(Packet):
    name = "FOO"
    fields_desc = [ VarLenQField("len", None, "data"),
                    StrLenField("data", "", "len") ]

    &gt;&gt;&gt; f = FOO(data="A"*129)
    &gt;&gt;&gt; f.show()
    ###[ FOO ]###
      len= 0
      data=    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
</code></pre>
<p>这里，<code>len</code>不必被计算，默认值会被直接显示的，这是目前我们协议层internal的表示，让我们强行来计算一下：</p>
<pre><code>&gt;&gt;&gt; f.show2()
###[ FOO ]###
 len= 129
 data= 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
</code></pre>
<p><code>show2()</code>方法显示这些字段被发送到网络中时的值，但是为了人类阅读方便，我们看到<code>len=129</code>。最后但并非最不重要，让我们来看看machine的表示：</p>
<pre><code>&gt;&gt;&gt; str(f)
'\x81\x01AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
</code></pre>
<p>前两个字节是<code>\x81\x01</code>，是129编码后的结果。</p>
<h2 id="剖析">剖析</h2>
<p>协议层只是一系列的字段，但是每一个字段之间使用什么连接的，协议层之间呢？这一节我们将解释这个秘密。</p>
<h3 id="基本的填充数据">基本的填充数据</h3>
<p>剖析数据包的核心的方法是<code>Packet.dissect()</code>。</p>
<pre><code class="language-py">def dissect(self, s):
    s = self.pre_dissect(s)
    s = self.do_dissect(s)
    s = self.post_dissect(s)
    payl,pad = self.extract_padding(s)
    self.do_dissect_payload(payl)
    if pad and conf.padding:
        self.add_payload(Padding(pad))
</code></pre>
<p>当被调用时，<code>s</code>是一个将要被剖析的字符串，<code>self</code>指向当前协议层。</p>
<pre><code>&gt;&gt;&gt; p=IP("A"*20)/TCP("B"*32)
WARNING: bad dataofs (4). Assuming dataofs=5
&gt;&gt;&gt; p
&lt;IP  version=4L ihl=1L tos=0x41 len=16705 id=16705 flags=DF frag=321L ttl=65 proto=65 chksum=0x4141
src=65.65.65.65 dst=65.65.65.65 |&lt;TCP  sport=16962 dport=16962 seq=1111638594L ack=1111638594L dataofs=4L
reserved=2L flags=SE window=16962 chksum=0x4242 urgptr=16962 options=[] |&lt;Raw  load='BBBBBBBBBBBB' |&gt;&gt;&gt;
</code></pre>
<p><code>Packet.dissect()</code>被调用了三次：</p>
<p>1.解析<code>"A"*20</code>为IPv4头</p>
<p>2.解析<code>"B"*32</code>为TCP头</p>
<p>3.到此为止数据包还有12个字节，他们将被解析成原始"Raw"的数据(有一些是默认的协议层类型)。</p>
<p>当传入一个协议层的时候，一切都很简单：</p>
<ul>
<li> <p><code>pre_dissect()</code>在协议层之前被调用。</p> </li>
<li> <p><code>do_dissect()</code>执行协议层真正的解析。</p> </li>
<li> <p><code>post_dissection()</code>当解析时需要更新输入的时候被调用（比如说，解密，解压缩）</p> </li>
<li> <p><code>extract_padding()</code>是一个重要的方法，应该被每一层所调用控制他们的大小，所以他可以被用来区分真正相关联的协议层的有效载荷，并且什么将被视为额外的填充字节。</p> </li>
<li> <p><code>do_dissect_payload()</code>方法主要负责剖析有效载荷（如果有的话）。它基于<code>guess_payload_class()</code>（见下文），一旦是已知类型的有效荷载，该有效载荷将会以新的类型绑定到当前协议层：</p> </li>
</ul>
<pre><code class="language-py">def do_dissect_payload(self, s):
    cls = self.guess_payload_class(s)
    p = cls(s, _internal=1, _underlayer=self)
    self.add_payload(p)
</code></pre>
<p>最后，数据包中所有的协议层都被解析了，并和已知的类型关联在一起。</p>
<h3 id="剖析字段">剖析字段</h3>
<p>所有协议层和它的字段之间的魔法方法是<code>do_dissect()</code>。如果你已经理解了协议层的不同的表示，你也应该理解剖析一个协议层就是将构建它的字段从machine表示转换到internal表示。</p>
<p>猜猜是什么？这正是<code>do_dissect()</code>干的事：</p>
<pre><code class="language-py">def do_dissect(self, s):
    flist = self.fields_desc[:]
    flist.reverse()
    while s and flist:
        f = flist.pop()
        s,fval = f.getfield(self, s)
        self.fields[f] = fval
    return s
</code></pre>
<p>所以，他接受原始的字符串数据包，并进入每一个字段，只要还有数据或者字段剩余：</p>
<pre><code>&gt;&gt;&gt; FOO("\xff\xff"+"B"*8)
&lt;FOO  len=2097090 data='BBBBBBB' |&gt;
</code></pre>
<p>当编写<code>FOO("\xff\xff"+"B"*8)</code>的时候，他调用<code>do_dissect()</code>方法。第一个字段是<code>VarLenQField</code>，因此他接收字节，只要MSB设置过，因此，一直到（包括）第一个"B"。这个映射做到了多亏了<code>VarLenQField.getfield()</code>，并且可以进行交叉检查：</p>
<pre><code>&gt;&gt;&gt; vlenq2str(2097090)
'\xff\xffB'
</code></pre>
<p>然后，下一个字段以相同的方法被提取，直到2097090个字节都放进<code>FOO.data</code>中（或者更少，如果2097090是不可用的）。</p>
<p>如果当剖析完后还剩下一些字节，他们将以相同的方式映射到下一步要处理的(默认是Raw)：</p>
<pre><code>&gt;&gt;&gt; FOO("\x05"+"B"*8)
&lt;FOO  len=5 data='BBBBB' |&lt;Raw  load='BBB' |&gt;&gt;
</code></pre>
<p>因此，现在我们该理解协议层是怎样被绑定在一起的。</p>
<h3 id="绑定协议层">绑定协议层</h3>
<p>Scapy在解析协议层时一个很酷的特性是他试图猜测下一层协议是什么。连接两个协议层官方的方法是<code>bind_layers()</code>:</p>
<p>比如说，如果你有一个<code>HTTP</code>类，你可能会认为所有的接受或者发送的数据包都是80端口的，你将会这样解码，下面是简单的方式：</p>
<pre><code class="language-py">bind_layers( TCP, HTTP, sport=80 )
bind_layers( TCP, HTTP, dport=80 )
</code></pre>
<p>这就是所有的啦！现在所有和80端口相关联的数据包都将被连接到HTTP协议层上，不管他是从<code>pcap</code>文件中读取的，还是从网络中接收到的。</p>
<h4 id="guess-payload-class方法"><code>guess_payload_class()</code>方法</h4>
<p>有时候，猜测一个有效载荷类不是像定义一个单一的端口那么简单。比如说，他可能依赖于当前协议传入的一个字节值。有两个方法是必须的：</p>
<ul>
<li> <p><code>guess_payload_class()</code>必须返回有效载荷的<code>guessed</code>类（下一层协议层的）。默认情况下，它使用类之间已有的关联通过<code>bind_layer()</code>放到合适的位置。</p> </li>
<li> <p><code>default_payload_class()</code>返回默认的值。这个方法在<code>Packet</code>类中定义返回Raw，但是他能被重载。</p> </li>
</ul>
<p>比如说，解码802.11的变化取决于他是否被加密：</p>
<pre><code class="language-py">class Dot11(Packet):
    def guess_payload_class(self, payload):
        if self.FCfield &amp; 0x40:
            return Dot11WEP
        else:
            return Packet.guess_payload_class(self, payload)
</code></pre>
<p>这里有需要的几点意见：</p>
<ul>
<li> <p>这些事是使用<code>bind_layer()</code>不可能完成的，因为测试中应该是<code>"field==value"</code>,但是这里我们测试的字段值比单一的字节要发杂。</p> </li>
<li> <p>如果测试失败了，没有这种假设，我们会回到默认的机制调用<code>Packet.guess_payload_class()</code>。</p> </li>
</ul>
<p>大多数时间，定义一个<code>guess_payload_class()</code>方法是没有必要的，可以从<code>bind_layers()</code>得到相同的结果。</p>
<h4 id="改变默认的行为">改变默认的行为</h4>
<p>如果你不喜欢Scapy得到协议层后的行为，你也可以通过调用<code>split_layer()</code>来改变或者禁用这些行为。比如说你不想要UDP/53绑定到DNS协议，只需要添加代码<code>split_layers(UDP, DNS, sport=53)</code>，现在所有源端口是53的数据包都不会当做DNS协议处理了，但是什么东西你要做特殊处理。</p>
<h3 id="在后台将所有的东西都放在一起">在后台：将所有的东西都放在一起</h3>
<p>事实上，每一个协议层都有一个字段的<code>guess_payload</code>。当你使用<code>bind_layers()</code>的方式，他将定义的下一个添加到该列表中。</p>
<pre><code>&gt;&gt;&gt; p=TCP()
&gt;&gt;&gt; p.payload_guess
[({'dport': 2000}, &lt;class 'scapy.Skinny'&gt;), ({'sport': 2000}, &lt;class 'scapy.Skinny'&gt;), ... )]
</code></pre>
<p>然后，当他需要猜测下一个协议层类，他调用默认的方法<code>Packet.guess_payload_class()</code>，该方法通过<code>payload_guess</code>序列的每一个元素，每一个元素都是一个元组：</p>
<ul>
<li> <p>第一个值是一个字段，我们用<code>('dport':2000)</code>测试</p> </li>
<li> <p>第二个值是<code>guessed</code>类，如果他匹配到Skinny</p> </li>
</ul>
<p>所以，默认的<code>guess_payload_class()</code>尝试序列中所有的元素，知道偶一个匹配到，如果没发现一个元素，他将调用<code>default_payload_class()</code>。如果你重新定义了这个方法，你的方法将会被调用，否则，默认的方法会被调用，Raw将会被返回。</p>
<p><code>Packet.guess_payload_class()</code></p>
<ul>
<li> <p>测试字段中有什么<code>guess_payload</code></p> </li>
<li> <p>调用被重载的<code>guess_payload_class()</code></p> </li>
</ul>
<h2 id="构建">构建</h2>
<p>构建一个数据包跟构建每一个协议层一样简单，然后一些魔法的事情发生了当关联一切的时候，让我们来试一试这些魔法。</p>
<h3 id="基本的填充数据-1">基本的填充数据</h3>
<p>首先要明确，构建是什么意思？正如我们所看到的，一个协议层能被不同的方法所表示(human, internal, machine)，构建的意思是转换到machine格式。</p>
<p>第二个要理解的事情是什么时候一个协议层将会被构建。答案不是那么明显，但是当你需要machine表示的时候，协议层就被构建了：当数据包在网络上被丢弃或者写入一个文件，当他装换成一个字符串，。。。事实上，machine表示应该被视为附加了协议层的大字符串。</p>
<pre><code>&gt;&gt;&gt; p = IP()/TCP()
&gt;&gt;&gt; hexdump(p)
0000 45 00 00 28 00 01 00 00 40 06 7C CD 7F 00 00 01 E..(....@.|.....
0010 7F 00 00 01 00 14 00 50 00 00 00 00 00 00 00 00 .......P........
0020 50 02 20 00 91 7C 00 00 P. ..|..
</code></pre>
<p>调用<code>str()</code>构建这个数据包：</p>
<ul>
<li> <p>没有实例化的字段设置他们的默认值</p> </li>
<li> <p>长度自动更新</p> </li>
<li> <p>计算校验和</p> </li>
<li> <p>等等</p> </li>
</ul>
<p>事实上，使用<code>str()</code>而不是<code>show2()</code>不是一个随机的选择，就像所有的函数构建数据包都要调用<code>Packet.__str__()</code>，然而，<code>__str__()</code>调用了另一个函数：<code>build()</code>：</p>
<pre><code class="language-py">def __str__(self):
    return self.__iter__().next().build()
</code></pre>
<p>重要的也是要理解的是，通常你不必关心machine表示，这就是为什么human和internal也在这里。</p>
<p>所以，核心的函数式<code>build()</code>（代码被缩短了只保留了相关的部分）：</p>
<pre><code class="language-py">def build(self,internal=0):
    pkt = self.do_build()
    pay = self.build_payload()
    p = self.post_build(pkt,pay)
    if not internal:
        pkt = self
        while pkt.haslayer(Padding):
            pkt = pkt.getlayer(Padding)
            p += pkt.load
            pkt = pkt.payload
    return p
</code></pre>
<p>所以，他通过构建当前协议层开始，然后是有效载荷，并且<code>post_build()</code>被调用更新后期的一些评估字段（像是校验和），最后将填充数据添加到数据包的尾部。</p>
<p>当然，构建一个协议层和构建它的字段是一样的，这正是<code>do_build()</code>干的事。</p>
<h3 id="构建字段">构建字段</h3>
<p>构建每一个协议层的每一个字段都会调用<code>Packet.do_build()</code>:</p>
<pre><code class="language-py">def do_build(self):
    p=""
    for f in self.fields_desc:
        p = f.addfield(self, p, self.getfieldval(f))
    return p
</code></pre>
<p>构建字段的核心函数是<code>getfield()</code>,他接收internal字段视图，并将它放在<code>p</code>的后面。通常，这个方法会调用<code>i2m()</code>并返回一些东西，如<code>p.self.i2mval(val)</code>（在<code>val=self.getfieldval(f)</code>处）。</p>
<p>如果<code>val</code>设置了，<code>i2m()</code>只是一个必须使用的格式化的方法，不如，如果预期是一个字节，<code>struct.pack('B',val)</code>是在正确转化他的方法。</p>
<p>然而，如果<code>val</code>没有被设置，事情将会变得更加复杂，这就意味着不能简单的提供默认值，然后这些字段现在或者以后需要计算一些“填充数据”。</p>
<p>“刚刚好”意味着多亏了<code>i2m()</code>，如果所有的信息将是可用的。如果你必须处理一个长度直到遇到一个分隔符。</p>
<p>比如说：计算一个长度直到遇到一个分隔符：</p>
<pre><code class="language-py">class XNumberField(FieldLenField):

    def __init__(self, name, default, sep="\r\n"):
        FieldLenField.__init__(self, name, default, fld)
        self.sep = sep

    def i2m(self, pkt, x):
        x = FieldLenField.i2m(self, pkt, x)
        return "%02x" % x

    def m2i(self, pkt, x):
        return int(x, 16)

    def addfield(self, pkt, s, val):
        return s+self.i2m(pkt, val)

    def getfield(self, pkt, s):
        sep = s.find(self.sep)
        return s[sep:], self.m2i(pkt, s[:sep])
</code></pre>
<p>在这个例子中，在<code>i2m()</code>中，如果<code>x</code>已经有一个值，他将装换为十六进制。如果没有提供任何值，将会返回0。</p>
<p>关联由<code>Packet.do_build()</code>提供，他为协议层的每一个字段调用<code>Field.addfield()</code>并以此调用<code>Field.i2m()</code>：如果值是有效的，协议层将会被构建。</p>
<h3 id="处理默认值do-build">处理默认值：<code>do_build()</code></h3>
<p>字段给定的默认值有时候也不知道或者不可能知道什么时候将字段放在一起。比如说，如果我们在协议层中使用预先定义的<code>XNumberField</code>，我们希望当他被构建是被设置一个被给定的值，然后如果他没有被设置<code>i2m()</code>不会返回任何值。</p>
<p>这个问题的答案是<code>Packet.post_build()</code>。</p>
<p>当这个方法被调用，数据包已经被构建了，但是有些字段还是需要被计算，一个典型的例子就是需要计算检验和或者是长度。这是每一个字段每次都取决于一些东西，而不是当前需要的。所以，让我们假设我们有一个有<code>XNumberField</code>的数据包来看看他的构建过程：</p>
<pre><code class="language-py">class Foo(Packet):
      fields_desc = [
          ByteField("type", 0),
          XNumberField("len", None, "\r\n"),
          StrFixedLenField("sep", "\r\n", 2)
          ]

      def post_build(self, p, pay):
        if self.len is None and pay:
            l = len(pay)
            p = p[:1] + hex(l)[2:]+ p[2:]
        return p+pay
</code></pre>
<p>当<code>post_build()</code>被调用的时候，<code>p</code>是当前的协议层，<code>pay</code>是有效载荷，这就已经构建好了，我们想要我们的长度是将所有的数据都放到分隔符之后的全部长度，所以我们在<code>post_build()</code>中添加他们的计算。</p>
<pre><code>&gt;&gt;&gt; p = Foo()/("X"*32)
&gt;&gt;&gt; p.show2()
###[ Foo ]###
 type= 0
 len= 32
 sep= '\r\n'
###[ Raw ]###
 load= 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
</code></pre>
<p><code>len</code>现在正确的被计算：</p>
<pre><code>&gt;&gt;&gt; hexdump(str(p))
0000   00 32 30 0D 0A 58 58 58  58 58 58 58 58 58 58 58   .20..XXXXXXXXXXX
0010   58 58 58 58 58 58 58 58  58 58 58 58 58 58 58 58   XXXXXXXXXXXXXXXX
0020   58 58 58 58 58 
</code></pre>
<p>而且machine也是期望的那样。</p>
<h3 id="处理默认值自动计算">处理默认值：自动计算</h3>
<p>像我们向前看到的那样，剖析机制是建立在程序员创造的协议层之间的连接之上的。然而，他也可以用在构建的过程中。</p>
<p>在协议层<code>Foo()</code>，我们第一个字节的类型是在下面定义的，比如说，如果<code>type=0</code>，下一层协议层是<code>Bar0</code>，如果是1，下一层是协议层是<code>Bar1</code>，以此类推。我们希望字段在下面自动设置。</p>
<pre><code class="language-py">class Bar1(Packet):
    fields_desc = [
          IntField("val", 0),
          ]

class Bar2(Packet):
    fields_desc = [
          IPField("addr", "127.0.0.1")
          ]
</code></pre>
<p>如果我们除此之外没有做其他的事情，我们在解析数据包的时候将会有麻烦，不会有任何的<code>Bar*</code>绑定在<code>Foo</code>协议层，甚至是当我们通过调用<code>show2()</code>函数明确的构建数据包时也没有。</p>
<pre><code>&gt;&gt;&gt; p = Foo()/Bar1(val=1337)
&gt;&gt;&gt; p
&lt;Foo  |&lt;Bar1  val=1337 |&gt;&gt;
&gt;&gt;&gt; p.show2()
###[ Foo ]###
 type= 0
 len= 4
 sep= '\r\n'
###[ Raw ]###
 load= '\x00\x00\x059'
</code></pre>
<p>问题：</p>
<ul>
<li> <p><code>type</code>还是等于0当我们将它设置为1的时候，我们当然可以通过<code>p=Foo(type=1)/Bar0(val=1337)</code>来构建<code>p</code>，但是这样不方便。</p> </li>
<li> <p>当<code>Bar1</code>注册为Raw的时候，数据包将会被错误的解析。这是因为<code>Foo()</code>和<code>Bar*()</code>之间没有设置任何的连接。</p> </li>
</ul>
<p>为了理解我们应该怎么做才能获得适当的行为，我们必须看看协议层是怎么组装的。当两个独立的数据包实例<code>Foo()</code>和<code>Bar1(val=1337)</code>通过分隔符<code>/</code>连接在一起的时候，将产生一个新的数据包，先前的实例被克隆了（也就是说这来了明确的对象构造不同，但是持有相同的值）。</p>
<pre><code class="language-py">def __div__(self, other):
    if isinstance(other, Packet):
        cloneA = self.copy()
        cloneB = other.copy()
        cloneA.add_payload(cloneB)
        return cloneA
    elif type(other) is str:
        return self/Raw(load=other)
</code></pre>
<p>操作符右边的是左边的有效载荷，这种行为是通过调用<code>add_payload()</code>完成的。最后返回一个新的数据包。</p>
<p>我们可以观察到，如果<code>other</code>是一个字符串而不是一个数据包，Raw将会从<code>payload</code>实例化得来。就像下面的例子：</p>
<pre><code>&gt;&gt;&gt; IP()/"AAAA"
&lt;IP  |&lt;Raw  load='AAAA' |&gt;&gt;
</code></pre>
<p>这样的话<code>add_payload()</code>该执行什么？只是将两个数据包关联在一起吗？不仅仅是这样，在我们的例子中，该方法会适当的设置当前的值给<code>type</code>。</p>
<p>本能的我们可以感觉到上层协议（<code>/</code>右边的协议层）能收集值设置给下层协议（<code>/</code>左边的协议层）。看看向前的解释，这有一个方便的机制来指定两个相邻协议层之间的绑定。</p>
<p>再一次，这些信息必须提供给<code>bind_layer()</code>，内部将调用<code>bind_top_down()</code>让这些字段被重载，在这种情况下，我们需要指定这些：</p>
<pre><code class="language-py">bind_layers( Foo, Bar1, {'type':1} )
bind_layers( Foo, Bar2, {'type':2} )
</code></pre>
<p>然后，<code>add_payload()</code>遍历上面数据包(<code>payload</code>)的<code>overload_fields</code>,得到这些字段相关联的底层数据包(通过他们的<code>type</code>)并插入到<code>overloaded_fields</code>。</p>
<p>现在，当这个字段的值被请求，<code>getfieldval()</code>将返回插到<code>overloaded_fields</code>中的值。</p>
<p>字段被处理有三个方向：</p>
<ul>
<li> <p><code>fields</code>：明确被设置的字段值，像是pdst在TCP中是（pdst='42'）</p> </li>
<li> <p><code>overloaded_fields</code>：重载字段</p> </li>
<li> <p><code>default_fields</code>：所有的字段都是他们的默认值。（这些字段根据<code>fields_desc</code>的初始化构造函数调用<code>init_fields()</code>）</p> </li>
</ul>
<p>在下面代码中，我们可以观察到一个字段是如何选择的并且看到他的返回值：</p>
<pre><code class="language-py">def getfieldval(self, attr):
   for f in self.fields, self.overloaded_fields, self.default_fields:
       if f.has_key(attr):
           return f[attr]
   return self.payload.getfieldval(attr)
</code></pre>
<p>字段被插入到<code>fields</code>有更高的权限，然后是<code>overloaded_fields</code>，最后是<code>default_fields</code>，因此如果字段的type在<code>overloaded_fields</code>中设置，他的值将会被返回而不是在<code>default_fields</code>中获取。</p>
<p>现在我们理解了背后的所有的魔法了！</p>
<pre><code>&gt;&gt;&gt; p = Foo()/Bar1(val=0x1337)
&gt;&gt;&gt; p
&lt;Foo  type=1 |&lt;Bar1  val=4919 |&gt;&gt;
&gt;&gt;&gt; p.show()
###[ Foo ]###
 type= 1
 len= 4
 sep= '\r\n'
###[ Bar1 ]###
 val= 4919
</code></pre>
<p>我们的两个问题都解决了，而没有发太多的功夫。</p>
<h3 id="理解底层把所有的东西放在一起">理解底层：把所有的东西放在一起</h3>
<p>最后但不是不重要，理解当构建数据包的时候每一个函数什么时候被调用是很重要的。</p>
<pre><code>&gt;&gt;&gt; hexdump(str(p))
Packet.str=Foo
Packet.iter=Foo
Packet.iter=Bar1
Packet.build=Foo
Packet.build=Bar1
Packet.post_build=Bar1
Packet.post_build=Foo
</code></pre>
<p>正如你所看到的，他首先运行序列的每一个字段，然从头开始构建，一旦所有的协议层构建好了，他们从头开始调用<code>post_build()</code>。</p>
<h2 id="字段">字段</h2>
<p>这里列出了一些Scapy支持的字段。</p>
<h3 id="简单的数据类型">简单的数据类型</h3>
<p>表示：</p>
<ul>
<li> <p>X --- 十六进制表示</p> </li>
<li> <p>LE --- 小端（默认是大端）</p> </li>
<li> <p>Signal --- 有符号的（默认是无符号的）</p> </li>
</ul>
<pre><code>ByteField
XByteField

ShortField
LEShortField
XShortField

X3BytesField        # three bytes (in hexad

IntField
SignedIntField
LEIntField
LESignedIntField
XIntField

LongField
XLongField
LELongField

IEEEFloatField
IEEEDoubleField
BCDFloatField       # binary coded decimal

BitField
XBitField

BitFieldLenField    # BitField specifying a length (used in RTP)
FlagsField
FloatField
</code></pre>
<h3 id="枚举">枚举</h3>
<p>字段的值可能来自枚举</p>
<pre><code>ByteEnumField("code", 4, {1:"REQUEST",2:"RESPONSE",3:"SUCCESS",4:"FAILURE"})
</code></pre>
<pre><code>EnumField(name, default, enum, fmt = "H")
CharEnumField
BitEnumField
ShortEnumField
LEShortEnumField
ByteEnumField
IntEnumField
SignedIntEnumField
LEIntEnumField
XShortEnumField
</code></pre>
<h3 id="字符串">字符串</h3>
<pre><code>StrField(name, default, fmt="H", remain=0, shift=0)
StrLenField(name, default, fld=None, length_from=None, shift=0):
StrFixedLenField
StrNullField
StrStopField
</code></pre>
<h3 id="序列和定长长度">序列和定长长度</h3>
<pre><code>FieldList(name, default, field, fld=None, shift=0, length_from=None, count_from=None)
  # A list assembled and dissected with many times the same field type

  # field: instance of the field that will be used to assemble and disassemble a list item
  # length_from: name of the FieldLenField holding the list length

FieldLenField     #  holds the list length of a FieldList field
LEFieldLenField

LenField          # contains len(pkt.payload)

PacketField       # holds packets
PacketLenField    # used e.g. in ISAKMP_payload_Proposal
PacketListField
</code></pre>
<h4 id="可变长度字段">可变长度字段</h4>
<p>这是关于Scapy怎么处理字段的可变长度的。这些字段通常可以从另外的字段那知道他们的长度，我们称他们为可变字段和定长字段。其思想是让每一个字段都引用另一个字段，这样当数据包被剖析时，可变就可以从定长字段那知道自己的长度，如果数据包时被组合的，你不必填充满定长字段，直接可以从可变长度推测他的值。</p>
<p>问题出现在你意识到可变长度字段和定长字段之间的关系并不总是明确的。有时候定长字段指示了字节长度，有时候是对象的数量。有时候长度包含首部部分，所以你必须减去固定的头部长度来推算出可变字段的长度。有时候长度不是以字节而是以16位来表示的，有时候相同的不变字段被两个不同的可变字段使用，有时候相同的可变字段引用不同的不可变字段，一个是一个字节，一个是来那个字节。</p>
<h5 id="定长字段">定长字段</h5>
<p>首先，一个定长字段是用FieldLenField定义的（或者是他的派生）。当组装数据包的时候如果他的值是空，他的值将会从引用他的可变长度字段推倒出来。引用用了其他的<code>length_of</code>参数或者<code>count_of</code>参数，<code>count_of</code>参数只有当可变字段拥有一个序列（<code>PacketListField</code>或者<code>FieldListField</code>）的时候才会有意义。该值将用可变长度字段命名，作为一个字符串。根据那个参数使用<code>i2len()</code>或者 <code>i2count()</code>方法将会在不可变字段值找个调用。返回的值将会被函数调整提供给合适的参数。调整将适用于两个参数：<code>i2len()</code>或者<code>i2count()</code>返回的数据包实例和值。默认情况下，调整是不会做什么事的：</p>
<pre><code class="language-py">adjust=lambda pkt,x: x
</code></pre>
<p>比如说，如果<code>the_varfield</code>是一个序列：</p>
<pre><code class="language-py">FieldLenField("the_lenfield", None, count_of="the_varfield")
</code></pre>
<p>或者如果他是16位的：</p>
<pre><code class="language-py">FieldLenField("the_lenfield", None, length_of="the_varfield", adjust=lambda pkt,x:(x+1)/2)
</code></pre>
<h5 id="可变长度字段-1">可变长度字段</h5>
<p>可变长度有：<code>StrLenField</code>, <code>PacketLenField</code>, <code>PacketListField</code>, <code>FieldListField</code>, ...</p>
<p>这有两个第一，当一个数据包被剖析时，他们的长度会从已经已经解析的定长字段长度推到来，连接通络使用length_from参数，应用到一个函数，适用于被解析的数据包的一部分，返回一个字节的长度，例如：</p>
<pre><code class="language-py">StrLenField("the_varfield", "the_default_value", length_from = lambda pkt: pkt.the_lenfield)
</code></pre>
<p>或者：</p>
<pre><code class="language-py">StrLenField("the_varfield", "the_default_value", length_from = lambda pkt: pkt.the_lenfield-12)
</code></pre>
<p>对于<code>PacketListField</code>和<code>FieldListField</code>和他们的派生，当需要长度的时候，工作内容和他们的一样。如果你需要大量的元素，<code>length_from</code>参数必须被忽略并且<code>count_from</code>参数必须被替代，比如说：</p>
<pre><code class="language-py">FieldListField("the_varfield", ["1.2.3.4"], IPField("", "0.0.0.0"), count_from = lambda pkt: pkt.the_lenfield)
</code></pre>
<h4 id="例子">例子</h4>
<pre><code class="language-py">class TestSLF(Packet):
    fields_desc=[ FieldLenField("len", None, length_of="data"),
                  StrLenField("data", "", length_from=lambda pkt:pkt.len) ]

class TestPLF(Packet):
    fields_desc=[ FieldLenField("len", None, count_of="plist"),
                  PacketListField("plist", None, IP, count_from=lambda pkt:pkt.len) ]

class TestFLF(Packet):
    fields_desc=[
       FieldLenField("the_lenfield", None, count_of="the_varfield"),
       FieldListField("the_varfield", ["1.2.3.4"], IPField("", "0.0.0.0"),
                       count_from = lambda pkt: pkt.the_lenfield) ]

class TestPkt(Packet):
    fields_desc = [ ByteField("f1",65),
                    ShortField("f2",0x4244) ]
    def extract_padding(self, p):
        return "", p

class TestPLF2(Packet):
    fields_desc = [ FieldLenField("len1", None, count_of="plist",fmt="H", adjust=lambda pkt,x:x+2),
                    FieldLenField("len2", None, length_of="plist",fmt="I", adjust=lambda pkt,x:(x+1)/2),
                    PacketListField("plist", None, TestPkt, length_from=lambda x:(x.len2*2)/3*3) ]
</code></pre>
<p>测试<code>FieldListField</code>类：</p>
<pre><code>&gt;&gt;&gt; TestFLF("\x00\x02ABCDEFGHIJKL")
&lt;TestFLF  the_lenfield=2 the_varfield=['65.66.67.68', '69.70.71.72'] |&lt;Raw  load='IJKL' |&gt;&gt;
</code></pre>
<h3 id="特殊的">特殊的</h3>
<pre><code>Emph     # Wrapper to emphasize field when printing, e.g. Emph(IPField("dst", "127.0.0.1")),

ActionField

ConditionalField(fld, cond)
        # Wrapper to make field 'fld' only appear if
        # function 'cond' evals to True, e.g.
        # ConditionalField(XShortField("chksum",None),lambda pkt:pkt.chksumpresent==1)

PadField(fld, align, padwith=None)
       # Add bytes after the proxified field so that it ends at
       # the specified alignment from its beginning
</code></pre>
<h3 id="tcpip">TCP/IP</h3>
<pre><code>IPField
SourceIPField

IPoptionsField
TCPOptionsField

MACField
DestMACField(MACField)
SourceMACField(MACField)
ARPSourceMACField(MACField)

ICMPTimeStampField
</code></pre>
<h3 id="80211">802.11</h3>
<pre><code>Dot11AddrMACField
Dot11Addr2MACField
Dot11Addr3MACField
Dot11Addr4MACField
Dot11SCField
</code></pre>
<h3 id="dns">DNS</h3>
<pre><code>DNSStrField
DNSRRCountField
DNSRRField
DNSQRField
RDataField
RDLenField
</code></pre>
<h3 id="asn1">ASN.1</h3>
<pre><code>ASN1F_element
ASN1F_field
ASN1F_INTEGER
ASN1F_enum_INTEGER
ASN1F_STRING
ASN1F_OID
ASN1F_SEQUENCE
ASN1F_SEQUENCE_OF
ASN1F_PACKET
ASN1F_CHOICE
</code></pre>
<h3 id="其他协议">其他协议</h3>
<pre><code>NetBIOSNameField         # NetBIOS (StrFixedLenField)

ISAKMPTransformSetField  # ISAKMP (StrLenField)

TimeStampField           # NTP (BitField)
</code></pre>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/130/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/130/index.html">进击的Python</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/68.html">HuberTRoy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 169个">169</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/170/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/170/index.html">scikit-learn (sklearn) 官方文档中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/18.html">ApacheCN</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">65页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2022个">2022</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/169/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/169/index.html">PyTorch 1.0 中文文档 & 教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/18.html">ApacheCN</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">87页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 874个">874</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/109/index.html">
<img class="uk-book-cover" src="../../static/icons/48/blockchain_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/109/index.html">区块链(BlockChain)技术开发相关资料</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="blockchain">blockchain</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">6页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 3个">3</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/44/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/44/index.html">Shell 编程范例</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/23.html">泰晓科技</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月30日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 296个">296</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/191/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/191/index.html">Linux秘传心法</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/107.html">trimstray</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">81页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 20277个">20277</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/33/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/33/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/33/README.html" title="Scapy 中文文档" data-book-page-rel-url="README.html" data-book-page-id="2014">Scapy 中文文档</a>
</li>
<li>
<a class="pjax" href="../../book/33/1.html" title="介绍" data-book-page-rel-url="1.html" data-book-page-id="2015">介绍</a>
</li>
<li>
<a class="pjax" href="../../book/33/2.html" title="下载和安装" data-book-page-rel-url="2.html" data-book-page-id="2016">下载和安装</a>
</li>
<li>
<a class="pjax" href="../../book/33/3.html" title="使用方法" data-book-page-rel-url="3.html" data-book-page-id="2017">使用方法</a>
</li>
<li>
<a class="pjax" href="../../book/33/4.html" title="高级用法" data-book-page-rel-url="4.html" data-book-page-id="2018">高级用法</a>
</li>
<li>
<a class="pjax" href="../../book/33/5.html" title="构建你自己的工具" data-book-page-rel-url="5.html" data-book-page-id="2019">构建你自己的工具</a>
</li>
<li>
<a class="pjax" href="../../book/33/6.html" title="添加新的协议" data-book-page-rel-url="6.html" data-book-page-id="2020">添加新的协议</a>
</li>
<li>
<a class="pjax" href="../../book/33/7.html" title="常见问题" data-book-page-rel-url="7.html" data-book-page-id="2021">常见问题</a>
</li>
<li>
<a class="pjax" href="../../book/33/8.html" title="Scapy 开发" data-book-page-rel-url="8.html" data-book-page-id="2022">Scapy 开发</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =33;var bookPageId =2020;var bookPageRelUrl ='6.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>