
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>查询集方法参考-Django 1.8 中文文档(Django 1.8 documentation)</title>
<meta content='查询集方法参考,Django 1.8 中文文档,Django 1.8 documentation' name='keywords'>
<meta content='查询集方法参考,Django 1.8 中文文档,Django 1.8 documentation' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/35/2_2_1_Making%20queries.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">执行查询</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/35/2_2_3_Lookup%20expressions.html">
<span class="">查找表达式</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/35/index.html">Django 1.8 中文文档 (Django 1.8 documentation)</a>
<a target="_blank" rel="nofollow" href="https://github.com/wizardforcel/django-chinese-docs-18" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="queryset-api参考">QuerySet API参考</h1>
<p>本文档描述了<code>QuerySet</code> API的详细信息。它建立在<a href="../../topics/db/models.html"><em>模型</em></a>和<a href="../../topics/db/queries.html"><em>数据库查询</em></a>指南的基础上，所以在阅读本文档之前，你也许需要首先阅读这两部分的文档。</p>
<p>本文档将通篇使用在<a href="../../topics/db/queries.html"><em>数据库查询指南</em></a>中用到的<a href="../../topics/db/queries.html#queryset-model-example"><em>Weblog 模型的例子</em></a>。</p>
<h2 id="何时对查询集求值要写到程序里的字段麻烦不要自作聪明翻译谢谢">何时对查询集求值(要写到程序里的字段麻烦不要自作聪明翻译谢谢)</h2>
<p>在内部，可以创建、过滤、切片和传递<code>查询集</code>而不用真实操作数据库。在你对查询集做求值之前，不会发生任何实际的数据库操作。</p>
<p>你可以使用下列方法对<code>查询集</code>求值：</p>
<ul>
<li> <p><strong>迭代。</strong><code>queryset</code>是可迭代的，它在首次迭代查询集时执行实际的数据库查询。例如， 下面的语句会将数据库中所有Entry 的headline 打印出来：</p> <pre><code>for e in Entry.objects.all():
    print(e.headline)

</code></pre> <p>注意：不要使用上面的语句来验证在数据库中是否至少存在一条记录。使用 <a href="#django.db.models.query.QuerySet.exists" title="django.db.models.query.QuerySet.exists"><code>exists()</code></a>方法更高效。</p> </li>
<li> <p><strong>切片。</strong> 正如在<a href="../../topics/db/queries.html#limiting-querysets"><em>限制查询集</em></a>中解释的那样， 可以使用Python 的序列切片语法对一个<code>查询集</code>进行分片。一个未求值的<code>查询集</code>进行切片通常返回另一个未求值的<code>查询集</code>，但是如果你使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。对一个已经求值的<code>查询集</code>进行切片将返回一个列表。</p> <p>还要注意，虽然对未求值的<code>查询集</code>进行切片返回另一个未求值的<code>查询集</code>，但是却不可以进一步修改它了（例如，添加更多的Filter，或者修改排序的方式），因为这将不太好翻译成SQL而且含义也不清晰。</p> </li>
<li> <p><strong>序列化/缓存。</strong> <a href="#pickling-querysets">序列化查询集</a>的细节参见下面一节。本节提到它的目的是强调序列化将读取数据库。</p> </li>
<li> <p><strong>repr()。</strong> 当对<code>查询集</code>调用<code>repr()</code> 时，将对它求值。这是为了在Python 交互式解释器中使用的方便，这样你可以在交互式使用这个API 时立即看到结果。</p> </li>
<li> <p><strong>len()。</strong> 当你对<code>查询集</code>调用<code>len()</code> 时， 将对它求值。正如你期望的那样，返回一个查询结果集的长度。</p> <p>注：如果你只需要知道集合中记录的个数（并不需要真实的对象），使用数据库层级的<code>SELECT COUNT(*)</code> 计数将更加高效。为此，Django 提供了 一个<a href="#django.db.models.query.QuerySet.count" title="django.db.models.query.QuerySet.count"><code>count()</code></a> 方法.</p> </li>
<li> <p><strong>list()。</strong> 对<code>查询集</code>调用<code>list()</code> 将强制对它求值。例如：</p> <pre><code>entry_list = list(Entry.objects.all())

</code></pre> </li>
<li> <p><strong>bool()。</strong> 测试一个<code>查询集</code>的布尔值，例如使用<code>bool()</code>、<code>or</code>、<code>and</code> 或者<code>if</code> 语句将导致查询集的执行。如果至少有一个记录，则<code>查询集</code>为<code>True</code>，否则为<code>False</code>。例如:</p> <pre><code>if Entry.objects.filter(headline="Test"):
   print("There is at least one Entry with the headline Test")

</code></pre> <p>注：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用 <a href="#django.db.models.query.QuerySet.exists" title="django.db.models.query.QuerySet.exists"><code>exists()</code></a> 将更加高效。</p> </li>
</ul>
<h3 id="pickle-查询集">Pickle 查询集</h3>
<p>如果你<a href="https://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code>Pickle</code></a>一个<code>查询集</code>，它将在Pickle 之前强制将所有的结果加载到内存中。Pickle 通常用于缓存之前，并且当缓存的查询集重新加载时，你希望结果已经存在随时准备使用（从数据库读取耗费时间，就失去了缓存的目的）。这意味着当你Unpickle<code>查询集</code>时，它包含Pickle 时的结果，而不是当前数据库中的结果。</p>
<p>如果此后你只想Pickle 必要的信息来从数据库重新创建<code>查询集</code>，可以Pickle<code>查询集</code>的<code>query</code> 属性。然后你可以使用类似下面的代码重新创建原始的<code>查询集</code>（不用加载任何结果）：</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; query = pickle.loads(s)     # Assuming 's' is the pickled string.
&gt;&gt;&gt; qs = MyModel.objects.all()
&gt;&gt;&gt; qs.query = query            # Restore the original 'query'.

</code></pre>
<p><code>query</code> 是一个不透明的对象。它表示查询的内部构造，不属于公开的API。然而，这里讲到的Pickle 和Unpickle 这个属性的内容是安全的（和完全支持的）。</p>
<p>不可以在不同版本之间共享Pickle 的结果</p>
<p><code>查询集</code>的Pickle 只能用于生成它们的Django 版本中。如果你使用Django 的版本N 生成一个Pickle，不保证这个Pickle 在Django 的版本N+1 中可以读取。Pickle 不可用于归档的长期策略。</p>
<p>New in Django 1.8.</p>
<p>因为Pickle 兼容性的错误很难诊断例如产生损坏的对象，当你试图Unpickle 的查询集与Pickle 时的Django 版本不同，将引发一个<code>RuntimeWarning</code>。</p>
<h2 id="查询集-api">查询集 API</h2>
<p>下面是对于<code>查询集</code>的正式定义：</p>
<p><em>class</em> <code>QuerySet</code>([<em>model=None</em>, <em>query=None</em>, <em>using=None</em>])<a href="source">source</a>(../../_modules/django/db/models/query.html#QuerySet)</p>
<p>通常你在使用<code>QuerySet</code>时会以<a href="../../topics/db/queries.html#chaining-filters"><em>链式的filter</em></a> 来使用。为了让这个能工作，大部分<code>QuerySet</code> 方法返回新的QuerySet。这些方法在本节将详细讲述。</p>
<p><code>QuerySet</code> 类具有两个公有属性用于内省：</p>
<p><code>ordered</code><a href="source">source</a>(../../_modules/django/db/models/query.html#QuerySet.ordered)</p>
<p>如果<code>QuerySet</code> 是排好序的则为<code>True</code> —— 例如有一个<a href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a> 子句或者模型有默认的排序。否则为<code>False</code> .</p>
<p><code>db</code><a href="source">source</a>(../../_modules/django/db/models/query.html#QuerySet.db)</p>
<p>如果现在执行，则返回将使用的数据库。</p>
<p>注</p>
<p><a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> 存在<code>query</code> 参数是为了让具有特殊查询用途的子类如<a href="../contrib/gis/geoquerysets.html#django.contrib.gis.db.models.GeoQuerySet" title="django.contrib.gis.db.models.GeoQuerySet"><code>GeoQuerySet</code></a> 可以重新构造内部的查询状态。这个参数的值是查询状态的不透明的表示，不是一个公开的API。简而言之：如果你有疑问，那么你实际上不需要使用它。</p>
<h3 id="返回新的查询集-的方法要写到程序里的字段麻烦不要自作聪明翻译谢谢">返回新的查询集 的方法(要写到程序里的字段麻烦不要自作聪明翻译谢谢)</h3>
<p>Django 提供了一系列 的<code>QuerySet</code>筛选方法，用于改变 <code>QuerySet</code> 返回的结果类型或者SQL查询执行的方式。</p>
<h4 id="filter">filter</h4>
<p><code>filter</code>(<em>**kwargs</em>)</p>
<p>返回一个新的<code>QuerySet</code>，包含与给定的查询参数匹配的对象。</p>
<p>查找的参数（<code>**kwargs</code>）应该满足下文<a href="#id4">字段查找</a>中的格式。在底层的SQL 语句中，多个参数通过<code>AND</code> 连接。</p>
<p>如果你需要执行更复杂的查询（例如，使用<code>OR</code> 语句查询），你可以使用<a href="#django.db.models.Q" title="django.db.models.Q"><code>Q 对象</code></a>。</p>
<h4 id="exclude">exclude</h4>
<p><code>exclude</code>(<em>**kwargs</em>)</p>
<p>返回一个新的<code>QuerySet</code>，它包含_不_满足给定的查找参数的对象。</p>
<p>查找的参数（<code>**kwargs</code>）应该满足下文<a href="#id4">字段查找</a>中的格式。 在底层的SQL 语句中，多个参数通过<code>AND</code> 连接，然后所有的内容放入<code>NOT()</code> 中。</p>
<p>下面的示例排除所有<code>pub_date</code> 晚于2005-1-3 且<code>headline</code> 为“Hello” 的记录：</p>
<pre><code>Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')

</code></pre>
<p>用SQL 语句，它等同于：</p>
<pre><code>SELECT ...
WHERE NOT (pub_date &gt; '2005-1-3' AND headline = 'Hello')

</code></pre>
<p>下面的示例排除所有<code>pub_date</code> 晚于2005-1-3 或者headline 为“Hello” 的记录：</p>
<pre><code>Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).exclude(headline='Hello')

</code></pre>
<p>用SQL 语句，它等同于：</p>
<pre><code>SELECT ...
WHERE NOT pub_date &gt; '2005-1-3'
AND NOT headline = 'Hello'

</code></pre>
<p>注意，第二个示例更严格。</p>
<p>如果你需要执行更复杂的查询（例如，使用<code>OR</code> 语句查询），你可以使用<a href="#django.db.models.Q" title="django.db.models.Q"><code>Q 对象</code></a>。</p>
<h4 id="annotate">annotate</h4>
<p><code>annotate</code>(<em>*args</em>, <em>**kwargs</em>)</p>
<p>使用提供的<a href="expressions.html"><em>查询表达式</em></a>Annotate <code>查询集</code>中的每个对象。查询表达式可以是一个简单的值、模型（或关联模型）字段的一个引用或对<code>查询集</code>中的对象一个聚合函数（平均值、和等）。</p>
<p>New in Django 1.8:</p>
<p>之前版本的Django 值允许聚合函数用作Annotation。现在可以使用各种表达式annotate 一个模型。</p>
<p><code>annotate()</code> 的每个参数都是一个annotation，它将添加到返回的<code>QuerySet</code> 中每个对象。</p>
<p>Django 提供的聚合函数在下文的<a href="#id5">聚合函数</a>文档中讲述。</p>
<p>关键字参数指定的Annotation 将使用关键字作为Annotation 的别名。匿名的参数的别名将基于聚合函数的名称和模型的字段生成。只有引用单个字段的聚合表达式才可以使用匿名参数。其它所有形式都必须用关键字参数。</p>
<p>例如，如果你正在操作一个Blog 列表，你可能想知道每个Blog 有多少Entry：</p>
<pre><code>&gt;&gt;&gt; from django.db.models import Count
&gt;&gt;&gt; q = Blog.objects.annotate(Count('entry'))
# The name of the first blog
&gt;&gt;&gt; q[0].name
'Blogasaurus'
# The number of entries on the first blog
&gt;&gt;&gt; q[0].entry__count
42

</code></pre>
<p><code>Blog</code> 模型本身没有定义<code>entry__count</code> 属性，但是通过使用一个关键字参数来指定聚合函数，你可以控制Annotation 的名称：</p>
<pre><code>&gt;&gt;&gt; q = Blog.objects.annotate(number_of_entries=Count('entry'))
# The number of entries on the first blog, using the name provided
&gt;&gt;&gt; q[0].number_of_entries
42

</code></pre>
<p>聚合的深入讨论，参见 <a href="../../topics/db/aggregation.html"><em>聚合主题的指南</em></a>。</p>
<h4 id="order-by">order_by</h4>
<p><code>order_by</code>(<em>*fields</em>)</p>
<p>默认情况下，<code>QuerySet</code> 根据模型<code>Meta</code> 类的<code>ordering</code> 选项排序。你可以使用<code>order_by</code> 方法给每个<code>QuerySet</code> 指定特定的排序。</p>
<p>例如：</p>
<pre><code>Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')

</code></pre>
<p>上面的结果将按照<code>pub_date</code> 降序排序，然后再按照<code>headline</code> 升序排序。<code>"-pub_date"</code> 前面的负号表示_降序_排序。隐式的是升序排序。若要随机排序，请使用<code>"?"</code>，像这样：</p>
<pre><code>Entry.objects.order_by('?')

</code></pre>
<p>注：<code>order_by('?')</code> 查询可能耗费资源且很慢，这取决于使用的数据库。</p>
<p>若要按照另外一个模型中的字段排序，可以使用查询关联模型时的语法。即通过字段的名称后面跟上两个下划线（<code>__</code>），再跟上新模型中的字段的名称，直至你希望连接的模型。例如：</p>
<pre><code>Entry.objects.order_by('blog__name', 'headline')

</code></pre>
<p>如果排序的字段与另外一个模型关联，Django 将使用关联的模型的默认排序，或者如果没有指定<a href="options.html#django.db.models.Options.ordering" title="django.db.models.Options.ordering"><code>Meta.ordering</code></a> 将通过关联的模型的主键排序。&nbsp;例如，因为<code>Blog</code> 模型没有指定默认的排序：</p>
<pre><code>Entry.objects.order_by('blog')

</code></pre>
<p>... 等同于：</p>
<pre><code>Entry.objects.order_by('blog__id')

</code></pre>
<p>如果<code>Blog</code> 设置<code>ordering = ['name']</code>，那么第一个QuerySet 将等同于：</p>
<pre><code>Entry.objects.order_by('blog__name')

</code></pre>
<p>通过关联字段排序QuerySet 还能够不用带来JOIN 产生的花费，方法是引用关联字段的<code>_id</code>：</p>
<pre><code># No Join
Entry.objects.order_by('blog_id')

# Join
Entry.objects.order_by('blog__id')

</code></pre>
<p>New in Django 1.7:</p>
<p>QuerySet 通过关联字段进行排序不用带来JOIN 产生的开销。</p>
<p>你还可以通过调用表达式的<code>asc()</code> 或者<code>desc()</code>，根据<a href="expressions.html"><em>查询表达式</em></a>排序：</p>
<pre><code>Entry.objects.order_by(Coalesce('summary', 'headline').desc())

</code></pre>
<p>New in Django 1.8:</p>
<p>增加根据查询表达式排序。</p>
<p>如果你还用到<a href="#django.db.models.query.QuerySet.distinct" title="django.db.models.query.QuerySet.distinct"><code>distinct()</code></a>，在根据关联模型中的字段排序时要小心。<a href="#django.db.models.query.QuerySet.distinct" title="django.db.models.query.QuerySet.distinct"><code>distinct()</code></a> 中有一个备注讲述关联模型的排序如何对结果产生影响。</p>
<p>注</p>
<p>指定一个多值字段来排序结果（例如，一个<a href="fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> 字段或者<a href="fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> 字段的反向关联）。</p>
<p>考虑下面的情况：</p>
<pre><code>class Event(Model):
   parent = models.ForeignKey('self', related_name='children')
   date = models.DateField()

Event.objects.order_by('children__date')

</code></pre>
<p>这里，每个<code>Event</code> 可能有多个潜在的排序数据；each <code>Event</code> with multiple <code>children</code> will be returned multiple times into the new <code>QuerySet</code> that <code>order_by()</code> creates. 换句话说, 用 <code>order_by()</code>方法对 <code>QuerySet</code>对象进行操作会返回一个扩大版的新QuerySet对象——新增的条目也许并没有什么卵用，你也用不着它们。</p>
<p>因此，当你使用多值字段对结果进行排序时要格外小心。<strong>如果</strong>，您可以确保每个订单项只有一个订购数据，这种方法不会出现问题。如果不确定，请确保结果是你期望的。</p>
<p>没有方法指定排序是否考虑大小写。对于大小写的敏感性，Django 将根据数据库中的排序方式排序结果。</p>
<p>你可以通过<a href="database-functions.html#django.db.models.functions.Lower" title="django.db.models.functions.Lower"><code>Lower</code></a>将一个字段转换为小写来排序，它将达到大小写一致的排序：</p>
<pre><code>Entry.objects.order_by(Lower('headline').desc())

</code></pre>
<p>New in Django 1.8:</p>
<p>新增根据表达式如<code>Lower</code> 来排序。</p>
<p>如果你不想对查询做任何排序，即使是默认的排序，可以不带参数调用<a href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a>。</p>
<p>你可以通过检查<a href="#django.db.models.query.QuerySet.ordered" title="django.db.models.query.QuerySet.ordered"><code>QuerySet.ordered</code></a> 属性来知道查询是否是排序的，如果<code>QuerySet</code> 有任何方式的排序它将为<code>True</code>。</p>
<p>每个<code>order_by()</code> 都将清除前面的任何排序。例如，下面的查询将按照<code>pub_date</code> 排序，而不是<code>headline</code>：</p>
<pre><code>Entry.objects.order_by('headline').order_by('pub_date')

</code></pre>
<p>警告</p>
<p>排序不是没有开销的操作。添加到排序中的每个字段都将带来数据库的开销。添加的每个外键也都将隐式包含进它的默认排序。</p>
<h4 id="reverse">reverse</h4>
<p><code>reverse</code>()</p>
<p><code>reverse()</code> 方法反向排序QuerySet 中返回的元素。第二次调用<code>reverse()</code> 将恢复到原有的排序。</p>
<p>如要获取QuerySet 中最后五个元素，你可以这样做：</p>
<pre><code>my_queryset.reverse()[:5]

</code></pre>
<p>注意，这与Python 中从一个序列的末尾进行切片有点不一样。上面的例子将首先返回最后一个元素，然后是倒数第二个元素，以此类推。如果我们有一个Python 序列，当我们查看<code>seq[-5:]</code> 时，我们将一下子得到倒数五个元素。Django 不支持这种访问模型（从末尾进行切片），因为它不可能利用SQL 高效地实现。</p>
<p>同时还要注意，<code>reverse()</code> 应该只在一个已经定义排序的<code>QuerySet</code> 上调用（例如，在一个定义了默认排序的模型上，或者使用<a href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a> 的时候）。如果<code>QuerySet</code> 没有定义排序，调用<code>reverse()</code> 将不会有任何效果（在调用<code>reverse()</code> 之前没有定义排序，那么调用之后仍保持没有定义）。</p>
<h4 id="distinct">distinct</h4>
<p><code>distinct</code>([<em>*fields</em>])</p>
<p>返回一个在SQL 查询中使用<code>SELECT DISTINCT</code> 的新<code>QuerySet</code>。它将去除查询结果中重复的行。</p>
<p>默认情况下，<code>QuerySet</code> 不会去除重复的行。在实际应用中，这一般不是个问题，因为像<code>Blog.objects.all()</code> 这样的简单查询不会引入重复的行。但是，如果查询跨越多张表，当对<code>QuerySet</code> 求值时就可能得到重复的结果。这时候你应该使用<code>distinct()</code>。</p>
<p>注</p>
<p><a href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a> 调用中的任何字段都将包含在SQL 的 <code>SELECT</code> 列中。与<code>distinct()</code> 一起使用时可能导致预计不到的结果。如果你根据关联模型的字段排序，这些fields将添加到查询的字段中，它们可能产生本应该是唯一的重复的行。因为多余的列没有出现在返回的结果中（它们只是为了支持排序），有时候看上去像是返回了不明确的结果。</p>
<p>类似地，如果您使用<a href="#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code>values()</code></a>查询来限制所选择的列，则仍然会涉及任何<a href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a>（或默认模型排序）影响结果的唯一性。</p>
<p>这里的道德是，如果你使用<code>distinct()</code>小心有关的模型排序。类似地，当一起使用<code>distinct()</code>和<a href="#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code>values()</code></a>时，请注意字段在不在<a href="#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code>values()</code></a></p>
<p>在PostgreSQL上，您可以传递位置参数（<code>* fields</code>），以便指定<code>DISTINCT</code>应该应用的字段的名称。这转换为<code>SELECT DISTINCT ON</code> SQL查询。这里有区别。对于正常的<code>distinct()</code>调用，数据库在确定哪些行不同时比较每行中的_每个_字段。对于具有指定字段名称的<code>distinct()</code>调用，数据库将仅比较指定的字段名称。</p>
<p>注意</p>
<p>当你指定字段名称时，_必须_在<code>QuerySet</code>中提供<code>order_by()</code>，而且<code>order_by()</code>中的字段必须以<code>distinct()</code>中的字段相同开始并且顺序相同。</p>
<p>例如，<code>SELECT DISTINCT ON （a）</code>列<code>a</code>中的每个值。如果你没有指定一个顺序，你会得到一个任意的行。</p>
<p>示例（除第一个示例外，其他示例都只能在PostgreSQL 上工作）：</p>
<pre><code>&gt;&gt;&gt; Author.objects.distinct()
[...]

&gt;&gt;&gt; Entry.objects.order_by('pub_date').distinct('pub_date')
[...]

&gt;&gt;&gt; Entry.objects.order_by('blog').distinct('blog')
[...]

&gt;&gt;&gt; Entry.objects.order_by('author', 'pub_date').distinct('author', 'pub_date')
[...]

&gt;&gt;&gt; Entry.objects.order_by('blog__name', 'mod_date').distinct('blog__name', 'mod_date')
[...]

&gt;&gt;&gt; Entry.objects.order_by('author', 'pub_date').distinct('author')
[...]

</code></pre>
<p>注释</p>
<p>请记住，<a href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a>使用已定义的任何默认相关模型排序。您可能需要通过关系<code>_id</code>或引用字段显式排序，以确保<code>DISTINCT ON</code>在<code>ORDER BY</code>子句的开头。例如，如果<code>Blog</code>模型通过<code>name</code>定义<a href="options.html#django.db.models.Options.ordering" title="django.db.models.Options.ordering"><code>排序</code></a>：</p>
<pre><code>Entry.objects.order_by('blog').distinct('blog')

</code></pre>
<p>...无法工作，因为查询将按<code>blog__name</code>排序，从而使<code>DISTINCT ON</code>表达式不匹配。你必须按照关系&lt;cite&gt;_id&lt;/cite&gt;字段（在这种情况下为<code>blog_id</code>）或引用的（<code>blog__pk</code>）显式排序来确保两个表达式都匹配。</p>
<h4 id="values">values</h4>
<p><code>values</code>(<em>*fields</em>)</p>
<p>返回一个<code>ValuesQuerySet</code> —— <code>QuerySet</code> 的一个子类，迭代时返回字典而不是模型实例对象。</p>
<p>每个字典表示一个对象，键对应于模型对象的属性名称。</p>
<p>下面的例子将<code>values()</code> 与普通的模型对象进行比较：</p>
<pre><code># This list contains a Blog object.
&gt;&gt;&gt; Blog.objects.filter(name__startswith='Beatles')
[&lt;Blog: Beatles Blog&gt;]

# This list contains a dictionary.
&gt;&gt;&gt; Blog.objects.filter(name__startswith='Beatles').values()
[{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]

</code></pre>
<p><code>values()</code> 接收可选的位置参数<code>*fields</code>，它指定<code>SELECT</code> 应该限制哪些字段。如果指定字段，每个字典将只包含指定的字段的键/值。如果没有指定字段，每个字典将包含数据库表中所有字段的键和值。</p>
<p>例如：</p>
<pre><code>&gt;&gt;&gt; Blog.objects.values()
[{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}],
&gt;&gt;&gt; Blog.objects.values('id', 'name')
[{'id': 1, 'name': 'Beatles Blog'}]

</code></pre>
<p>值得注意的几点：</p>
<ul>
<li> <p>如果你有一个字段<code>foo</code> 是一个<a href="fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>，默认的<code>values()</code> 调用返回的字典将有一个叫做<code>foo_id</code> 的键，因为这是保存实际的值的那个隐藏的模型属性的名称（<code>foo</code> 属性引用关联的模型）。当你调用<code>values()</code> 并传递字段的名称，传递<code>foo</code> 或<code>foo_id</code> 都可以，得到的结果是相同的（字典的键会与你传递的字段名匹配）。</p> <p>例如：</p> <pre><code>&amp;gt;&amp;gt;&amp;gt; Entry.objects.values()
[{'blog_id': 1, 'headline': 'First Entry', ...}, ...]

&amp;gt;&amp;gt;&amp;gt; Entry.objects.values('blog')
[{'blog': 1}, ...]

&amp;gt;&amp;gt;&amp;gt; Entry.objects.values('blog_id')
[{'blog_id': 1}, ...]

</code></pre> </li>
<li> <p>当<code>values()</code> 与<a href="#django.db.models.query.QuerySet.distinct" title="django.db.models.query.QuerySet.distinct"><code>distinct()</code></a> 一起使用时，注意排序可能影响最终的结果。详细信息参见<a href="#django.db.models.query.QuerySet.distinct" title="django.db.models.query.QuerySet.distinct"><code>distinct()</code></a> 中的备注。</p> </li>
<li> <p>如果<code>values()</code> 子句位于<a href="#django.db.models.query.QuerySet.extra" title="django.db.models.query.QuerySet.extra"><code>extra()</code></a> 调用之后，<a href="#django.db.models.query.QuerySet.extra" title="django.db.models.query.QuerySet.extra"><code>extra()</code></a> 中的<code>select</code> 参数定义的字段必须显式包含在<code>values()</code> 调用中。<code>values()</code> 调用后面的<a href="#django.db.models.query.QuerySet.extra" title="django.db.models.query.QuerySet.extra"><code>extra()</code></a> 调用将忽略选择的额外的字段。</p> </li>
<li> <p>在<code>values()</code> 之后调用<a href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code>only()</code></a> 和<a href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code>defer()</code></a> 不太合理，所以将引发一个<code>NotImplementedError</code>。</p> </li>
</ul>
<p>New in Django 1.7:</p>
<p>新增最后一点。以前，在<code>values()</code> 之后调用<a href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code>only()</code></a> 和<a href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code>defer()</code></a> 是允许的，但是它要么会崩溃要么返回错误的结果。</p>
<p><code>ValuesQuerySet</code> 用于你知道你只需要字段的一小部分，而不需要用到模型实例对象的函数。只选择用到的字段当然更高效。</p>
<p>最后，要注意<code>ValuesQuerySet</code> 是<code>QuerySet</code> 的子类，它实现了大部分相同的方法。你可以对它调用<code>filter()</code>、<code>order_by()</code> 等等。这表示下面的两个调用完全相同：</p>
<pre><code>Blog.objects.values().order_by('id')
Blog.objects.order_by('id').values()

</code></pre>
<p>Django 的作者喜欢将影响SQL 的方法放在前面，然后放置影响输出的方法（例如<code>values()</code>），但是实际上无所谓。这是卖弄你个性的好机会。</p>
<p>你可以通过<code>OneToOneField</code>、<code>ForeignKey</code> 和 <code>ManyToManyField</code> 属性反向引用关联的模型的字段：</p>
<pre><code>Blog.objects.values('name', 'entry__headline')
[{'name': 'My blog', 'entry__headline': 'An entry'},
     {'name': 'My blog', 'entry__headline': 'Another entry'}, ...]

</code></pre>
<p>警告</p>
<p>因为<a href="fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> 字段和反向关联可能有多个关联的行，包含它们可能导致结果集的倍数放大。如果你在<code>values()</code> 查询中包含多个这样的字段将更加明显，这种情况下将返回所有可能的组合。</p>
<h4 id="values-list">values_list</h4>
<p><code>values_list</code>(<em>*fields</em>, <em>flat=False</em>)</p>
<p>与<code>values()</code> 类似，只是在迭代时返回的是元组而不是字典。每个元组包含传递给<code>values_list()</code> 调用的字段的值 —— 所以第一个元素为第一个字段，以此类推。例如：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.values_list('id', 'headline')
[(1, 'First entry'), ...]

</code></pre>
<p>如果只传递一个字段，你还可以传递<code>flat</code> 参数。如果为<code>True</code>，它表示返回的结果为单个值而不是元组。一个例子会让它们的区别更加清晰：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.values_list('id').order_by('id')
[(1,), (2,), (3,), ...]

&gt;&gt;&gt; Entry.objects.values_list('id', flat=True).order_by('id')
[1, 2, 3, ...]

</code></pre>
<p>如果有多个字段，传递<code>flat</code> 将发生错误。</p>
<p>如果你不传递任何值给<code>values_list()</code>，它将返回模型中的所有字段，以它们在模型中定义的顺序。</p>
<p>注意，这个方法返回<code>ValuesListQuerySet</code>。这个类的行为类似列表。大部分时候它足够用了，但是如果你需要一个真实的Python 列表对象，可以对它调用<code>list()</code>，这将会对查询集求值。</p>
<h4 id="dates">dates</h4>
<p><code>dates</code>(<em>field</em>, <em>kind</em>, <em>order='ASC'</em>)</p>
<p>返回<code>DateQuerySet</code> - <code>QuerySet</code>，其计算结果为<a href="https://docs.python.org/3/library/datetime.html#datetime.date" title="(in Python v3.4)"><code>datetime.date</code></a>对象列表，表示特定种类的所有可用日期<code>QuerySet</code>。</p>
<p><code>field</code>应为模型的<code>DateField</code>的名称。 <code>kind</code>应为<code>"year"</code>、<code>"month"</code>或<code>"day"</code>。隐式的是升序排序。若要随机排序，请使用<code>"?"</code>，像这样：</p>
<ul>
<li><code>"year"</code> 返回对应该field的所有不同年份值的list。</li>
<li><code>“month”</code>返回字段的所有不同年/月值的列表。</li>
<li><code>“day”</code>返回字段的所有不同年/月/日值的列表。</li>
</ul>
<p><code>order</code>（默认为<code>“ASC”</code>）应为<code>'ASC'</code>或<code>'DESC'</code>。它t指定如何排序结果。</p>
<p>例子：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&gt;&gt;&gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]

</code></pre>
<h4 id="datetimes">datetimes</h4>
<p><code>datetimes</code>(<em>field_name</em>, <em>kind</em>, <em>order='ASC'</em>, <em>tzinfo=None</em>)</p>
<p>返回<code>QuerySet</code>，其计算为<a href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.4)"><code>datetime.datetime</code></a>对象的列表，表示<code>QuerySet</code>内容中特定种类的所有可用日期。</p>
<p><code>field_name</code>应为模型的<code>DateTimeField</code>的名称。</p>
<p><code>种</code>应为<code>“year”</code>，<code>“month”</code>，<code>“day”</code>，<code>“hour”</code>，<code>“分钟”</code>或<code>“秒”</code>。结果列表中的每个<code>datetime.datetime</code>对象被“截断”到给定的<code>类型</code>。</p>
<p><code>order</code>, 默认为<code>'ASC'</code>, 可选项为<code>'ASC'</code> 或者 <code>'DESC'</code>. 这个选项指定了返回结果的排序方式。</p>
<p><code>tzinfo</code>定义在截断之前将数据时间转换到的时区。实际上，给定的datetime具有不同的表示，这取决于使用的时区。此参数必须是<a href="https://docs.python.org/3/library/datetime.html#datetime.tzinfo" title="(in Python v3.4)"><code>datetime.tzinfo</code></a>对象。如果它<code>无</code>，Django使用<a href="../../topics/i18n/timezones.html#default-current-time-zone"><em>当前时区</em></a>。当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>False</code>时，它不起作用。</p>
<p>注意</p>
<p>此函数直接在数据库中执行时区转换。因此，您的数据库必须能够解释<code>tzinfo.tzname(None)</code>的值。这转化为以下要求：</p>
<ul>
<li>SQLite：install <a href="http://pytz.sourceforge.net/">pytz</a> - 转换实际上是在Python中执行的。</li>
<li>PostgreSQL：没有要求（见<a href="http://www.postgresql.org/docs/current/static/datatype-datetime.html#DATATYPE-TIMEZONES">时区</a>）。</li>
<li>Oracle：无要求（请参阅<a href="http://docs.oracle.com/cd/B19306_01/server.102/b14225/ch4datetime.htm#i1006667">选择时区文件</a>）。</li>
<li>MySQL：安装<a href="http://pytz.sourceforge.net/">pytz</a>，并使用<a href="http://dev.mysql.com/doc/refman/5.6/en/mysql-tzinfo-to-sql.html">mysql_tzinfo_to_sql</a>加载时区表。</li>
</ul>
<h4 id="none">none</h4>
<p><code>none</code>()</p>
<p>调用none()将创建一个从不返回任何对象的查询集，并且在访问结果时不会执行任何查询。qs.none()查询集是<code>EmptyQuerySet</code>的一个实例。</p>
<p>例子：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.none()
[]
&gt;&gt;&gt; from django.db.models.query import EmptyQuerySet
&gt;&gt;&gt; isinstance(Entry.objects.none(), EmptyQuerySet)
True

</code></pre>
<h4 id="all">all</h4>
<p><code>all</code>()</p>
<p>返回当前<code>QuerySet</code>（或<code>QuerySet</code> 子类） 的_副本_。它可以用于在你希望传递一个模型管理器或<code>QuerySet</code> 并对结果做进一步过滤的情况。不管对哪一种对象调用<code>all()</code>，你都将获得一个可以工作的<code>QuerySet</code>。</p>
<p>当对<code>QuerySet</code>进行<a href="#when-querysets-are-evaluated"><em>求值</em></a>时，它通常会缓存其结果。如果数据库中的数据在<code>QuerySet</code>求值之后可能已经改变，你可以通过在以前求值过的<code>QuerySet</code>上调用相同的<code>all()</code> 查询以获得更新后的结果。</p>
<h4 id="select-related">select_related</h4>
<p><code>select_related</code>(<em>*fields</em>)</p>
<p>返回一个<code>QuerySet</code>，当执行它的查询时它沿着外键关系查询关联的对象的数据。它会生成一个复杂的查询并引起性能的损耗，但是在以后使用外键关系时将不需要数据库查询。</p>
<p>下面的例子解释了普通查询和<code>select_related()</code> 查询的区别。下面是一个标准的查询：</p>
<pre><code># Hits the database.
e = Entry.objects.get(id=5)

# Hits the database again to get the related Blog object.
b = e.blog

</code></pre>
<p>下面是一个<code>select_related</code> 查询：</p>
<pre><code># Hits the database.
e = Entry.objects.select_related('blog').get(id=5)

# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog

</code></pre>
<p><code>select_related()</code> 可用于任何对象的查询集：</p>
<pre><code>from django.utils import timezone

# Find all the blogs with entries scheduled to be published in the future.
blogs = set()

for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
    # Without select_related(), this would make a database query for each
    # loop iteration in order to fetch the related blog for each entry.
    blogs.add(e.blog)

</code></pre>
<p><code>filter()</code> 和<code>select_related()</code> 链的顺序不重要。下面的查询集是等同的：</p>
<pre><code>Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())

</code></pre>
<p>你可以沿着外键查询。如果你有以下模型：</p>
<pre><code>from django.db import models

class City(models.Model):
    # ...
    pass

class Person(models.Model):
    # ...
    hometown = models.ForeignKey(City)

class Book(models.Model):
    # ...
    author = models.ForeignKey(Person)

</code></pre>
<p>... 那么<code>Book.objects.select_related('author__hometown').get(id=4)</code> 调用将缓存关联的<code>Person</code> _和_关联的 <code>City</code>：</p>
<pre><code>b = Book.objects.select_related('author__hometown').get(id=4)
p = b.author         # Doesn't hit the database.
c = p.hometown       # Doesn't hit the database.

b = Book.objects.get(id=4) # No select_related() in this example.
p = b.author         # Hits the database.
c = p.hometown       # Hits the database.

</code></pre>
<p>在传递给<code>select_related()</code> 的字段中，你可以使用任何<a href="fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> 和<a href="fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code>OneToOneField</code></a>。</p>
<p>在传递给<code>select_related</code> 的字段中，你还可以反向引用<a href="fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code>OneToOneField</code></a> —— 也就是说，你可以回溯到定义<a href="fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code>OneToOneField</code></a> 的字段。此时，可以使用关联对象字段的<a href="fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code>related_name</code></a>，而不要指定字段的名称。</p>
<p>有些情况下，你希望对很多对象调用<code>select_related()</code>，或者你不知道所有的关联关系。在这些情况下，可以调用不带参数的<code>select_related()</code>。它将查找能找到的所有不可为空外键 —— 可以为空的外键必须明确指定。大部分情况下不建议这样做，因为它会使得底层的查询非常复杂并且返回的很多数据都不是真实需要的。</p>
<p>如果你需要清除<code>QuerySet</code> 上以前的<code>select_related</code> 添加的关联字段，可以传递一个<code>None</code> 作为参数：</p>
<pre><code>&gt;&gt;&gt; without_relations = queryset.select_related(None)

</code></pre>
<p>链式调用<code>select_related</code> 的工作方式与其它方法类似 —— 也就是说，<code>select_related('foo', 'bar')</code> 等同于<code>select_related('foo').select_related('bar')</code>。</p>
<p>Changed in Django 1.7:</p>
<p>在以前，后者等同于<code>select_related('bar')</code>。</p>
<h4 id="prefetch-related">prefetch_related</h4>
<p><code>prefetch_related</code>(<em>*lookups</em>)</p>
<p>返回<code>QuerySet</code>，它将在单个批处理中自动检索每个指定查找的相关对象。</p>
<p>这具有与<code>select_related</code>类似的目的，两者都被设计为阻止由访问相关对象而导致的数据库查询的泛滥，但是策略是完全不同的。</p>
<p><code>select_related</code>通过创建SQL连接并在<code>SELECT</code>语句中包括相关对象的字段来工作。因此，<code>select_related</code>在同一数据库查询中获取相关对象。然而，为了避免由于跨越“多个”关系而导致的大得多的结果集，<code>select_related</code>限于单值关系 - 外键和一对一关系。</p>
<p><code>prefetch_related</code>，另一方面，为每个关系单独查找，并在Python中“加入”。这允许它预取多对多和多对一对象，除了外键和一对一关系，它们不能使用<code>select_related</code>来完成。 <code>select_related</code>。它还支持<a href="../contrib/contenttypes.html#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a>和<a href="../contrib/contenttypes.html#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a>的预取。</p>
<p>例如，假设您有这些模型：</p>
<pre><code>from django.db import models

class Topping(models.Model):
    name = models.CharField(max_length=30)

class Pizza(models.Model):
    name = models.CharField(max_length=50)
    toppings = models.ManyToManyField(Topping)

    def __str__(self):              # __unicode__ on Python 2
        return "%s (%s)" % (self.name, ", ".join(topping.name
                                                 for topping in self.toppings.all()))

</code></pre>
<p>并运行：</p>
<pre><code>&gt;&gt;&gt; Pizza.objects.all()
["Hawaiian (ham, pineapple)", "Seafood (prawns, smoked salmon)"...

</code></pre>
<p>问题是每次<code>Pizza .__ str __()</code>要求<code>self.toppings.all()</code>它必须查询数据库，因此<code>Pizza.objects .all()</code>将在Pizza <code>QuerySet</code>中的<strong>每个</strong>项目的Toppings表上运行查询。</p>
<p>我们可以使用<code>prefetch_related</code>减少为只有两个查询：</p>
<pre><code>&gt;&gt;&gt; Pizza.objects.all().prefetch_related('toppings')

</code></pre>
<p>这意味着检索到的每个<code>Pizza</code>都会执行<code>self.toppings.all()</code>；现在每次调用<code>self.toppings.all()</code>，而不是去数据库的项目，它会在预取的<code>QuerySet</code>缓存中找到它们填充在单个查询中。</p>
<p>也就是说，所有相关的配料将在单个查询中提取，并用于使具有相关结果的预填充缓存的<code>QuerySets</code>；这些<code>QuerySets</code>然后在<code>self.toppings.all()</code>调用中使用。</p>
<p><code>prefetch_related()</code>中的附加查询在<code>QuerySet</code>开始计算并且主查询已执行后执行。</p>
<p>请注意，主要<code>QuerySet</code>的结果缓存和所有指定的相关对象将被完全加载到内存中。这改变了<code>QuerySets</code>的典型行为，通常尽量避免在需要之前将所有对象加载到内存中，即使在数据库中执行了查询之后。</p>
<p>注意</p>
<p>请记住，与<code>QuerySets</code>一样，任何后续的链接方法隐含不同的数据库查询将忽略以前缓存的结果，并使用新的数据库查询检索数据。所以，如果你写下面的话：</p>
<pre><code>&gt;&gt;&gt; pizzas = Pizza.objects.prefetch_related('toppings')
&gt;&gt;&gt; [list(pizza.toppings.filter(spicy=True)) for pizza in pizzas]

</code></pre>
<p>...然后事实，已经预取的<code>pizza.toppings.all()</code>不会帮助你。<code>prefetch_related（'toppings'）</code>隐含<code>pizza.toppings.all()</code>，但<code>pizza.toppings.filter()</code>是一个不同的查询。预取的缓存在这里不能帮助；实际上它伤害性能，因为你做了一个你没有使用的数据库查询。所以使用这个功能小心！</p>
<p>您还可以使用正常连接语法来执行相关字段的相关字段。假设我们有一个额外的模型上面的例子：</p>
<pre><code>class Restaurant(models.Model):
    pizzas = models.ManyToMany(Pizza, related_name='restaurants')
    best_pizza = models.ForeignKey(Pizza, related_name='championed_by')

</code></pre>
<p>以下都是合法的：</p>
<pre><code>&gt;&gt;&gt; Restaurant.objects.prefetch_related('pizzas__toppings')

</code></pre>
<p>这将预取所有比萨饼属于餐厅，所有浇头属于那些比萨饼。这将导致总共3个数据库查询 - 一个用于餐馆，一个用于比萨饼，一个用于浇头。</p>
<pre><code>&gt;&gt;&gt; Restaurant.objects.prefetch_related('best_pizza__toppings')

</code></pre>
<p>这将获取最好的比萨饼和每个餐厅最好的披萨的所有浇头。这将在3个数据库查询 - 一个为餐厅，一个为“最佳比萨饼”，一个为一个为浇头。</p>
<p>当然，也可以使用<code>select_related</code>来获取<code>best_pizza</code>关系，以将查询计数减少为2：</p>
<pre><code>&gt;&gt;&gt; Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')

</code></pre>
<p>由于预取在主查询（其包括<code>select_related</code>所需的连接）之后执行，因此它能够检测到<code>best_pizza</code>对象已经被提取，并且请跳过重新获取它们。</p>
<p>链接<code>prefetch_related</code>调用将累积预取的查找。要清除任何<code>prefetch_related</code>行为，请传递<code>None</code>作为参数：</p>
<pre><code>&gt;&gt;&gt; non_prefetched = qs.prefetch_related(None)

</code></pre>
<p>使用<code>prefetch_related</code>时需要注意的一点是，查询创建的对象可以在它们相关的不同对象之间共享，即单个Python模型实例可以出现在树中的多个点返回的对象。这通常会与外键关系发生。通常这种行为不会是一个问题，并且实际上会节省内存和CPU时间。</p>
<p>虽然<code>prefetch_related</code>支持预取<code>GenericForeignKey</code>关系，但查询的数量将取决于数据。由于<code>GenericForeignKey</code>可以引用多个表中的数据，因此需要对每个引用的表进行一次查询，而不是对所有项进行一次查询。如果尚未提取相关行，则可能会对<code>ContentType</code>表执行其他查询。</p>
<p><code>prefetch_related</code>在大多数情况下将使用使用“IN”运算符的SQL查询来实现。这意味着对于一个大的<code>QuerySet</code>，可能会生成一个大的“IN”子句，根据数据库，在解析或执行SQL查询时可能会有性能问题。始终为您的使用情况配置文件！</p>
<p>请注意，如果您使用<code>iterator()</code>来运行查询，则会忽略<code>prefetch_related()</code>调用，因为这两个优化并没有意义。</p>
<p>New in Django 1.7.</p>
<p>您可以使用<a href="#django.db.models.Prefetch" title="django.db.models.Prefetch"><code>Prefetch</code></a>对象进一步控制预取操作。</p>
<p>在其最简单的形式中，<code>Prefetch</code>等效于传统的基于字符串的查找：</p>
<pre><code>&gt;&gt;&gt; Restaurant.objects.prefetch_related(Prefetch('pizzas__toppings'))

</code></pre>
<p>您可以使用可选的<code>queryset</code>参数提供自定义查询集。这可以用于更改查询集的默认顺序：</p>
<pre><code>&gt;&gt;&gt; Restaurant.objects.prefetch_related(
...     Prefetch('pizzas__toppings', queryset=Toppings.objects.order_by('name')))

</code></pre>
<p>或者在适当时调用<a href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a>以进一步减少查询数量：</p>
<pre><code>&gt;&gt;&gt; Pizza.objects.prefetch_related(
...     Prefetch('restaurants', queryset=Restaurant.objects.select_related('best_pizza')))

</code></pre>
<p>您还可以使用可选的<code>to_attr</code>参数将预取结果分配给自定义属性。结果将直接存储在列表中。</p>
<p>这允许使用不同的<code>QuerySet</code>预取相同的关系多次；例如：</p>
<pre><code>&gt;&gt;&gt; vegetarian_pizzas = Pizza.objects.filter(vegetarian=True)
&gt;&gt;&gt; Restaurant.objects.prefetch_related(
...     Prefetch('pizzas', to_attr='menu'),
...     Prefetch('pizzas', queryset=vegetarian_pizzas, to_attr='vegetarian_menu'))

</code></pre>
<p>使用自定义<code>to_attr</code>创建的查找仍然可以像往常一样被其他查找遍历：</p>
<pre><code>&gt;&gt;&gt; vegetarian_pizzas = Pizza.objects.filter(vegetarian=True)
&gt;&gt;&gt; Restaurant.objects.prefetch_related(
...     Prefetch('pizzas', queryset=vegetarian_pizzas, to_attr='vegetarian_menu'),
...     'vegetarian_menu__toppings')

</code></pre>
<p>在过滤预取结果时，建议使用<code>to_attr</code>，因为它比在相关管理器的缓存中存储过滤的结果更不明确：</p>
<pre><code>&gt;&gt;&gt; queryset = Pizza.objects.filter(vegetarian=True)
&gt;&gt;&gt;
&gt;&gt;&gt; # Recommended:
&gt;&gt;&gt; restaurants = Restaurant.objects.prefetch_related(
...     Prefetch('pizzas', queryset=queryset, to_attr='vegetarian_pizzas'))
&gt;&gt;&gt; vegetarian_pizzas = restaurants[0].vegetarian_pizzas
&gt;&gt;&gt;
&gt;&gt;&gt; # Not recommended:
&gt;&gt;&gt; restaurants = Restaurant.objects.prefetch_related(
...     Prefetch('pizzas', queryset=queryset))
&gt;&gt;&gt; vegetarian_pizzas = restaurants[0].pizzas.all()

</code></pre>
<p>自定义预取也适用于单个相关关系，如前<code>ForeignKey</code>或<code>OneToOneField</code>。一般来说，您希望对这些关系使用<a href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a>，但有很多情况下使用自定义<code>QuerySet</code>进行预取是有用的：</p>
<ul>
<li> <p>您想要使用在相关模型上执行进一步预取的<code>QuerySet</code>。</p> </li>
<li> <p>您希望仅预取相关对象的子集。</p> </li>
<li> <p>You want to use performance optimization techniques like <a href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code>deferred fields</code></a>:</p> <pre><code>&amp;gt;&amp;gt;&amp;gt; queryset = Pizza.objects.only('name')
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; restaurants = Restaurant.objects.prefetch_related(
...     Prefetch('best_pizza', queryset=queryset))

</code></pre> </li>
</ul>
<p>注意</p>
<p>查找的顺序很重要。</p>
<p>请看下面的例子：</p>
<pre><code>&gt;&gt;&gt; prefetch_related('pizzas__toppings', 'pizzas')

</code></pre>
<p>即使它是无序的，因为<code>'pizzas__toppings'</code>已经包含所有需要的信息，因此第二个参数<code>'pizzas'</code>实际上是多余的。</p>
<pre><code>&gt;&gt;&gt; prefetch_related('pizzas__toppings', Prefetch('pizzas', queryset=Pizza.objects.all()))

</code></pre>
<p>这将引发<code>ValueError</code>，因为尝试重新定义先前查看的查询的查询集。请注意，创建了隐式查询集，以作为<code>'pizzas__toppings'</code>查找的一部分遍历<code>'pizzas'</code>。</p>
<pre><code>&gt;&gt;&gt; prefetch_related('pizza_list__toppings', Prefetch('pizzas', to_attr='pizza_list'))

</code></pre>
<p>这会触发<code>AttributeError</code>，因为<code>'pizza_list'</code>在处理<code>'pizza_list__toppings'</code>时不存在。</p>
<p>这种考虑不限于使用<code>Prefetch</code>对象。一些高级技术可能需要以特定顺序执行查找以避免创建额外的查询；因此建议始终仔细订购<code>prefetch_related</code>参数。</p>
<h4 id="extra">extra</h4>
<p><code>extra</code>(<em>select=None</em>, <em>where=None</em>, <em>params=None</em>, <em>tables=None</em>, <em>order_by=None</em>, <em>select_params=None</em>)</p>
<p>有些情况下，Django的查询语法难以简单的表达复杂的 <code>WHERE</code> 子句，对于这种情况, Django 提供了 <code>extra()</code> <code>QuerySet</code> 修改机制 — 它能在 <code>QuerySet</code>生成的SQL从句中注入新子句</p>
<p>警告</p>
<p>无论何时你都需要非常小心的使用<code>extra()</code>. 每次使用它时，您都应该转义用户可以使用<code>params</code>控制的任何参数，以防止SQL注入攻击。请详细了解<a href="../../topics/security.html#sql-injection-protection"><em>SQL injection protection</em></a>。</p>
<p>由于产品差异的原因，这些自定义的查询难以保障在不同的数据库之间兼容(因为你手写 SQL 代码的原因)，而且违背了 DRY 原则，所以如非必要，还是尽量避免写 extra。</p>
<p>extra可以指定一个或多个 <code>参数</code>,例如 <code>select</code>, <code>where</code> or <code>tables</code>. 这些参数都不是必须的，但是你至少要使用一个</p>
<ul>
<li> <p><code>select</code></p> <p>The <code>select</code> 参数可以让你在 <code>SELECT</code> 从句中添加其他字段信息，它应该是一个字典，存放着属性名到 SQL 从句的映射。</p> <p>例：</p> <pre><code>Entry.objects.extra(select={'is_recent': "pub_date &amp;gt; '2006-01-01'"})

</code></pre> <p>结果集中每个 <code>Entry</code> 对象都有一个额外的属性<code>is_recent</code>, 它是一个布尔值，表示 Entry对象的<code>pub_date</code> 是否晚于 Jan. 1, 2006.</p> <p>Django 会直接在 <code>SELECT</code> 中加入对应的 SQL 片断，所以转换后的 SQL 如下：</p> <pre><code>SELECT blog_entry.*, (pub_date &amp;gt; '2006-01-01') AS is_recent
FROM blog_entry;

</code></pre> <p>下面这个例子更复杂一些；它会在每个 <code>Blog</code>对象中添加一个 <code>entry_count</code> 属性，它会运行一个子查询，得到相关联的 <code>Entry</code> 对象的数量：</p> <pre><code>Blog.objects.extra(
    select={
        'entry_count': 'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id'
    },
)

</code></pre> <p>在上面这个特例中，我们要了解这个事实，就是 <code>blog_blog</code> 表已经存在于<code>FROM</code>从句中</p> <p>上面例子的结果SQL将是：</p> <pre><code>SELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count
FROM blog_blog;

</code></pre> <p>要注意的是，大多数数据库需要在子句两端添加括号，而在 Django 的<code>select</code>从句中却无须这样。 另请注意，某些数据库后端（如某些MySQL版本）不支持子查询。</p> <p>在少数情况下，您可能希望将参数传递到<code>extra（select = ...）</code>中的SQL片段。为此，请使用<code>select_params</code>参数。由于<code>select_params</code>是一个序列，并且<code>select</code>属性是字典，因此需要注意，以便参数与额外的选择片段正确匹配。在这种情况下，您应该使用<a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" title="(in Python v3.4)"><code>collections.</code></a>OrderedDict用于<code>select</code>值，而不仅仅是一个普通的Python字典。</p> <p>这将工作，例如：</p> <pre><code>Blog.objects.extra(
    select=OrderedDict([('a', '%s'), ('b', '%s')]),
    select_params=('one', 'two'))

</code></pre> <p>如果您需要在选择字符串中使用文本<code>%s</code>，请使用序列<code>%%s</code>。</p> <p>Changed in Django 1.8:</p> <p>在1.8之前，您无法逃离文本<code>%s</code>。</p> </li>
<li> <p><code>where</code> / <code>tables</code></p> <p>您可以使用<code>其中</code>定义显式SQL <code>WHERE</code>子句 - 也许执行非显式连接。您可以使用<code>表</code>手动将表添加到SQL <code>FROM</code>子句。</p> <p><code>其中</code>和<code>表</code>都接受字符串列表。所有<code>其中</code>参数均为“与”任何其他搜索条件。</p> <p>例：</p> <pre><code>Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])

</code></pre> <p>...翻译（大致）以下SQL：</p> <pre><code>SELECT * FROM blog_entry WHERE (foo='a' OR bar='a') AND (baz='a')

</code></pre> <p>如果您要指定已在查询中使用的表，请在使用<code>tables</code>参数时小心。当您通过<code>tables</code>参数添加额外的表时，Django假定您希望该表包含额外的时间（如果已包括）。这会产生一个问题，因为表名将会被赋予一个别名。如果表在SQL语句中多次出现，则第二次和后续出现必须使用别名，以便数据库可以区分它们。如果您指的是在额外的<code>where</code>参数中添加的额外表，这将导致错误。</p> <p>通常，您只需添加尚未显示在查询中的额外表。然而，如果发生上述情况，则有几种解决方案。首先，看看你是否可以不包括额外的表，并使用已经在查询中的一个。如果不可能，请将<code>extra()</code>调用放在查询集结构的前面，以便您的表是该表的第一次使用。最后，如果所有其他失败，请查看生成的查询并重写<code>where</code>添加以使用给您的额外表的别名。每次以相同的方式构造查询集时，别名将是相同的，因此您可以依靠别名不更改。</p> </li>
<li> <p><code>order_by</code></p> <p>如果您需要使用通过<code>extra()</code>包含的一些新字段或表来对结果查询进行排序，请使用<code>order_by</code>参数<code>extra()</code>这些字符串应该是模型字段（如查询集上的正常<a href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a>方法），形式为<code>table_name.column_name</code>或您在<code>select</code>参数到<code>extra()</code>。</p> <p>例如：</p> <pre><code>q = Entry.objects.extra(select={'is_recent': "pub_date &amp;gt; '2006-01-01'"})
q = q.extra(order_by = ['-is_recent'])

</code></pre> <p>这会将<code>is_recent</code>的所有项目排序到结果集的前面（<code>True</code>在<code>False</code>之前按降序排序）。</p> <p>顺便说一句，你可以对<code>extra()</code>进行多次调用，它会按照你的期望（每次添加新的约束）运行。</p> </li>
<li> <p><code>params</code></p> <p>上述<code>where</code>参数可以使用标准Python数据库字符串占位符 - <code>'%s'</code>来指示数据库引擎应自动引用的参数。<code>params</code>参数是要替换的任何额外参数的列表。</p> <p>例：</p> <pre><code>Entry.objects.extra(where=['headline=%s'], params=['Lennon'])

</code></pre> <p>始终使用<code>params</code>而不是将值直接嵌入<code>where</code>，因为<code>params</code>会确保根据您的特定后端正确引用值。例如，引号将被正确转义。</p> <p>坏：</p> <pre><code>Entry.objects.extra(where=["headline='Lennon'"])

</code></pre> <p>好：</p> <pre><code>Entry.objects.extra(where=['headline=%s'], params=['Lennon'])

</code></pre> </li>
</ul>
<p>警告</p>
<p>如果您正在对MySQL执行查询，请注意，MySQL的静默类型强制可能会在混合类型时导致意外的结果。If you query on a string type column, but with an integer value, MySQL will coerce the types of all values in the table to an integer before performing the comparison.例如，如果表包含值<code>'abc'</code>，<code>'def'</code>，并查询<code>WHERE mycolumn = 0</code>，两行都将匹配。为了防止这种情况，请在使用查询中的值之前执行正确的类型转换。</p>
<h4 id="defer">defer</h4>
<p><code>defer</code>(<em>*fields</em>)</p>
<p>在一些复杂的数据建模情况下，您的模型可能包含大量字段，其中一些可能包含大量数据（例如，文本字段），或者需要昂贵的处理来将它们转换为Python对象。如果您在某些情况下使用查询集的结果，当您最初获取数据时不知道是否需要这些特定字段，可以告诉Django不要从数据库中检索它们。</p>
<p>这是通过传递字段名称不加载到<code>defer()</code>：</p>
<pre><code>Entry.objects.defer("headline", "body")

</code></pre>
<p>具有延迟字段的查询集仍将返回模型实例。如果您访问该字段（一次一个，而不是一次所有的延迟字段），将从数据库中检索每个延迟字段。</p>
<p>您可以多次调用<code>defer()</code>。每个调用都向延迟集添加新字段：</p>
<pre><code># Defers both the body and headline fields.
Entry.objects.defer("body").filter(rating=5).defer("headline")

</code></pre>
<p>字段添加到延迟集的顺序无关紧要。调用具有已延迟的字段名称的<code>defer()</code>是无害的（该字段仍将被延迟）。</p>
<p>您可以使用标准的双下划线符号来分隔相关字段，从而推迟相关模型中的字段加载（如果相关模型通过<a href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a>加载）</p>
<pre><code>Blog.objects.select_related().defer("entry__headline", "entry__body")

</code></pre>
<p>如果要清除延迟字段集，请将<code>None</code>作为参数传递到<code>defer()</code>：</p>
<pre><code># Load all fields immediately.
my_queryset.defer(None)

</code></pre>
<p>模型中的某些字段不会被延迟，即使您要求它们。你永远不能推迟加载主键。如果您使用<a href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a>检索相关模型，则不应推迟从主模型连接到相关模型的字段的加载，否则将导致错误。</p>
<p>注意</p>
<p><code>defer()</code>方法（及其表兄弟，<a href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code>only()</code></a>）仅适用于高级用例。They provide an optimization for when you have analyzed your queries closely and understand <em>exactly</em> what information you need and have measured that the difference between returning the fields you need and the full set of fields for the model will be significant.</p>
<p>即使你认为你是在高级用例的情况下，<strong>只使用defer()，当你不能，在查询集加载时，确定是否需要额外的字段或</strong>。如果您经常加载和使用特定的数据子集，最好的选择是规范化模型，并将未加载的数据放入单独的模型（和数据库表）。如果列_必须_由于某种原因保留在一个表中，请创建一个具有<code>Meta.managed = / t4&amp;gt;</code>（请参阅<a href="options.html#django.db.models.Options.managed" title="django.db.models.Options.managed"><code>managed attribute</code></a>文档），只包含您通常需要加载和使用的字段否则调用<code>defer()</code>。这使得你的代码对读者更加明确，稍微更快一些，并且在Python进程中消耗更少的内存。</p>
<p>例如，这两个模型使用相同的底层数据库表：</p>
<pre><code>class CommonlyUsedModel(models.Model):
    f1 = models.CharField(max_length=10)

    class Meta:
        managed = False
        db_table = 'app_largetable'

class ManagedModel(models.Model):
    f1 = models.CharField(max_length=10)
    f2 = models.CharField(max_length=10)

    class Meta:
        db_table = 'app_largetable'

# Two equivalent QuerySets:
CommonlyUsedModel.objects.all()
ManagedModel.objects.all().defer('f2')

</code></pre>
<p>如果许多字段需要在非托管模型中复制，最好使用共享字段创建抽象模型，然后使非托管模型和托管模型从抽象模型继承。</p>
<p>注意</p>
<p>当对具有延迟字段的实例调用<a href="instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>时，仅保存加载的字段。有关详细信息，请参见<a href="instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>。</p>
<h4 id="only">only</h4>
<p><code>only</code>(<em>*fields</em>)</p>
<p><code>only()</code>方法或多或少与<a href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code>defer()</code></a>相反。您调用它时，应该在检索模型时延迟的字段。如果你有一个模型几乎所有的字段需要延迟，使用<code>only()</code>指定补充的字段集可以导致更简单的代码。</p>
<p>假设您有一个包含字段<code>名称</code>，<code>年龄</code>和<code>传记</code>的模型。以下两个查询集是相同的，就延迟字段而言：</p>
<pre><code>Person.objects.defer("age", "biography")
Person.objects.only("name")

</code></pre>
<p>每当您调用<code>（</code>）时，_取代_立即加载的字段集。方法的名称是助记符：<strong>只有</strong>这些字段立即加载；其余的都被推迟。因此，对<code>only()</code>的连续调用仅导致所考虑的最后字段：</p>
<pre><code># This will defer all fields except the headline.
Entry.objects.only("body", "rating").only("headline")

</code></pre>
<p>由于<code>defer()</code>以递增方式动作（向延迟列表中添加字段），因此您可以将调用结合到<code>only()</code>和<code>defer()</code></p>
<pre><code># Final result is that everything except "headline" is deferred.
Entry.objects.only("headline", "body").defer("body")

# Final result loads headline and body immediately (only() replaces any
# existing set of fields).
Entry.objects.defer("body").only("headline", "body")

</code></pre>
<p><a href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code>defer()</code></a>文档注释中的所有注意事项也适用于<code>only()</code>。使用它谨慎，只有耗尽了你的其他选项。</p>
<p>使用<a href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code>only()</code></a>并省略使用<a href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a>请求的字段也是错误。</p>
<p>注意</p>
<p>当对具有延迟字段的实例调用<a href="instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>时，仅保存加载的字段。有关详细信息，请参见<a href="instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>。</p>
<h4 id="using">using</h4>
<p><code>using</code>(<em>alias</em>)</p>
<p>如果你使用多个数据库，这个方法用于控制<code>QuerySet</code> 将在哪个数据库上求值。这个方法的唯一参数是数据库的别名，定义在<a href="../settings.html#std:setting-DATABASES"><code>DATABASES</code></a>。</p>
<p>例如：</p>
<pre><code># queries the database with the 'default' alias.
&gt;&gt;&gt; Entry.objects.all()

# queries the database with the 'backup' alias
&gt;&gt;&gt; Entry.objects.using('backup')

</code></pre>
<h4 id="select-for-update">select_for_update</h4>
<p><code>select_for_update</code>(<em>nowait=False</em>)</p>
<p>返回一个 queryset &nbsp;，会锁定相关行直到事务结束。在支持的数据库上面产生一个<code>SELECT ...</code> FORUPDATE语句</p>
<p>例如:</p>
<pre><code>entries = Entry.objects.select_for_update().filter(author=request.user)

</code></pre>
<p>所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。</p>
<p>一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。如果这不是你想要的行为，请使用<code>select_for_update(nowait=True)</code>. 这将使查询不阻塞。如果其它事务持有冲突的锁, 那么查询将引发 <a href="../exceptions.html#django.db.DatabaseError" title="django.db.DatabaseError"><code>DatabaseError</code></a> 异常.</p>
<p>目前 &nbsp;<code>postgresql_psycopg2</code>, <code>oracle</code> 和 <code>mysql</code> 数据库后端 <code>select_for_update()</code>. 但是 MySQL 不支持 <code>nowait</code> 参数。显然，用户应该检查后端的支持情况。</p>
<p>当在不支持<code>nowait</code>功能的数据库后端(例如 MySql) 使用<code>nowait=True</code> 参数调用 <code>select_for_update()</code> &nbsp;时将引发 <a href="../exceptions.html#django.db.DatabaseError" title="django.db.DatabaseError"><code>DatabaseError</code></a> 异常. 这是防止意外造成代码被阻塞。</p>
<p>在自动提交模式下使用 <code>select_for_update()</code> 将引发 <a href="../exceptions.html#django.db.transaction.TransactionManagementError" title="django.db.transaction.TransactionManagementError"><code>TransactionManagementError</code></a> 异常，原因是自动提交模式下不支持锁定行。如果允许这个调用，那么可能造成数据损坏，而且这个功能很容易在事务外被调用。</p>
<p>对于不支持 <code>SELECT ...</code> FORUPDATE的后端 (例如SQLite) &nbsp;select_for_update() 将没有效果。</p>
<p>Changed in Django 1.6.3:</p>
<p>在自动提交模式下，使用<code>select_for_update()</code>执行查询现在是一个错误。在1.6系列的早期版本中，它是一个无操作。</p>
<p>警告</p>
<p>Although <code>select_for_update()</code> normally fails in autocommit mode, since <a href="../../topics/testing/tools.html#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a> automatically wraps each test in a transaction, calling <code>select_for_update()</code> in a <code>TestCase</code> even outside an <a href="../../topics/db/transactions.html#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block will (perhaps unexpectedly) pass without raising a <code>TransactionManagementError</code>. 要正确测试<code>select_for_update()</code>，您应该使用<a href="../../topics/testing/tools.html#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>TransactionTestCase</code></a>。</p>
<h4 id="raw">raw</h4>
<p><code>raw</code>(<em>raw_query</em>, <em>params=None</em>, <em>translations=None</em>)</p>
<p>Changed in Django 1.7:</p>
<p><code>raw</code> 移动到<code>QuerySet</code> 类中。以前，它只位于<a href="../../topics/db/managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> 中。</p>
<p>接收一个原始的SQL 查询，执行它并返回一个<code>django.db.models.query.RawQuerySet</code> 实例。这个<code>RawQuerySet</code> 实例可以迭代以提供实例对象，就像普通的<code>QuerySet</code> 一样。</p>
<p>更多信息参见<a href="../../topics/db/sql.html"><em>执行原始的SQL 查询</em></a>。</p>
<p>警告</p>
<p><code>raw()</code> 永远触发一个新的查询，而与之前的filter 无关。因此，它通常应该从<code>Manager</code> 或一个全新的<code>QuerySet</code> 实例调用。</p>
<h3 id="不会返回querysets的方法">不会返回QuerySets的方法</h3>
<p>以下<code>QuerySet</code>方法评估<code>QuerySet</code>并返回_而不是_ a <code>QuerySet</code>。</p>
<p>这些方法不使用高速缓存（请参阅<a href="../../topics/db/queries.html#caching-and-querysets"><em>Caching and QuerySets</em></a>）。这些方法每次被调用的时候都会查询数据库。</p>
<h4 id="get">get</h4>
<p><code>get</code>(<em>**kwargs</em>)</p>
<p>返回按照查询参数匹配到的对象，参数的格式应该符合 <a href="#id4">Field lookups</a>的要求.</p>
<p>如果匹配到的对象个数不只一个的话，<code>get()</code> 将会触发<a href="../exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code>MultipleObjectsReturned</code></a> 异常. <a href="../exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code>MultipleObjectsReturned</code></a> 异常是模型类的属性.</p>
<p>如果根据给出的参数匹配不到对象的话，<code>get()</code> 将触发<a href="instances.html#django.db.models.Model.DoesNotExist" title="django.db.models.Model.DoesNotExist"><code>DoesNotExist</code></a> 异常. 这个异常是模型类的属性. 例：</p>
<pre><code>Entry.objects.get(id='foo') # raises Entry.DoesNotExist

</code></pre>
<p><a href="instances.html#django.db.models.Model.DoesNotExist" title="django.db.models.Model.DoesNotExist"><code>DoesNotExist</code></a>异常从<a href="../exceptions.html#django.core.exceptions.ObjectDoesNotExist" title="django.core.exceptions.ObjectDoesNotExist"><code>django.core.exceptions.ObjectDoesNotExist</code></a>继承，因此您可以定位多个<a href="instances.html#django.db.models.Model.DoesNotExist" title="django.db.models.Model.DoesNotExist"><code>DoesNotExist</code></a>异常。例：</p>
<pre><code>from django.core.exceptions import ObjectDoesNotExist
try:
    e = Entry.objects.get(id=3)
    b = Blog.objects.get(id=1)
except ObjectDoesNotExist:
    print("Either the entry or blog doesn't exist.")

</code></pre>
<h4 id="create">create</h4>
<p><code>create</code>(<em>**kwargs</em>)</p>
<p>一个在一步操作中同时创建对象并且保存的便捷方法. 所以:</p>
<pre><code>p = Person.objects.create(first_name="Bruce", last_name="Springsteen")

</code></pre>
<p>和:</p>
<pre><code>p = Person(first_name="Bruce", last_name="Springsteen")
p.save(force_insert=True)

</code></pre>
<p>是等同的.</p>
<p>参数 <a href="instances.html#ref-models-force-insert"><em>force_insert</em></a> 在其他的文档中有介绍, 它意味着一个新的对象一定会被创建. 正常情况中，你不必要担心这点. 然而, 如果你的model中有一个你手动设置主键， 并且这个值已经存在于数据库中, 调用 <code>create()</code>将会失败并且触发 <a href="../exceptions.html#django.db.IntegrityError" title="django.db.IntegrityError"><code>IntegrityError</code></a> 因为主键必须是唯一的. 如果你手动设置了主键，做好异常处理的准备.</p>
<h4 id="get-or-create">get_or_create</h4>
<p><code>get_or_create</code>(<em>defaults=None</em>, <em>**kwargs</em>)</p>
<p>一个通过给出的<code>kwargs</code> 来查询对象的便捷方法（如果你的模型中的所有字段都有默认值，可以为空），需要的话创建一个对象。</p>
<p>返回一个由<code>(object, created)</code>组成的元组，元组中的<code>object</code> 是一个查询到的或者是被创建的对象， <code>created</code> 是一个表示是否创建了新的对象的布尔值。</p>
<p>这主要用作样板代码的一种快捷方式。例如：</p>
<pre><code>try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
except Person.DoesNotExist:
    obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
    obj.save()

</code></pre>
<p>如果模型的字段数量较大的话，这种模式就变的非常不易用了。上面的示例可以用<code>get_or_create()</code>重写 &nbsp;:</p>
<pre><code>obj, created = Person.objects.get_or_create(first_name='John', last_name='Lennon',
                  defaults={'birthday': date(1940, 10, 9)})

</code></pre>
<p>任何传递给 <code>get_or_create()</code> 的关键字参数，<em>除了一个可选的</em><code>defaults</code>，都将传递给<a href="#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> 调用。如果查找到一个对象，<code>get_or_create()</code> 返回一个包含匹配到的对象以及<code>False</code> 组成的元组。如果查找到的对象超过一个以上，<code>get_or_create</code> 将引发<a href="../exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code>MultipleObjectsReturned</code></a>。<em>如果查找不到对象</em>， <code>get_or_create()</code> 将会实例化并保存一个新的对象，返回一个由新的对象以及<code>True</code> 组成的元组。新的对象将会大概按照以下的逻辑创建:</p>
<pre><code>params = {k: v for k, v in kwargs.items() if '__' not in k}
params.update(defaults)
obj = self.model(**params)
obj.save()

</code></pre>
<p>它表示从非<code>'defaults'</code> 且不包含双下划线的关键字参数开始（暗示这是一个不精确的查询）。然后将<code>defaults</code> 的内容添加进来，覆盖必要的键，并使用结果作为关键字参数传递给模型类。这是对用到的算法的简单描述，但它包含了所有的相关的细节。内部的实现有更多的错误检查并处理一些边缘条件；如果感兴趣，请阅读代码。</p>
<p>如果你有一个名为<code>defaults</code>的字段，并且想在<code>get_or_create()</code> 是用它作为精确查询，只需要使用<code>'defaults__exact'</code>，像这样：</p>
<pre><code>Foo.objects.get_or_create(defaults__exact='bar', defaults={'defaults': 'baz'})

</code></pre>
<p>当你使用手动指定的主键时，<code>get_or_create()</code> 方法与<a href="#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><code>create()</code></a>方法有相似的错误行为 。如果需要创建一个对象而该对象的主键早已存在于数据库中，<a href="../exceptions.html#django.db.IntegrityError" title="django.db.IntegrityError"><code>IntegrityError</code></a> 异常将会被触发。</p>
<p>这个方法假设正确使用原子操作，正确的数据库配置和底层数据库的正确行为。然而，如果数据库级别没有对<code>get_or_create</code> 中用到的<code>kwargs</code> 强制要求唯一性（参见<a href="fields.html#django.db.models.Field.unique" title="django.db.models.Field.unique"><code>unique</code></a> 和 <a href="options.html#django.db.models.Options.unique_together" title="django.db.models.Options.unique_together"><code>unique_together</code></a>），这个方法容易导致竞态条件可能会仍具有相同参数的多行同时插入。</p>
<p>如果你正在使用MySQL，请确保使用<code>READ COMMITTED</code> 隔离级别而不是默认的<code>REPEATABLE READ</code>，否则你将会遇到<code>get_or_create</code> 引发<a href="../exceptions.html#django.db.IntegrityError" title="django.db.IntegrityError"><code>IntegrityError</code></a> 但对象在接下来的<a href="#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> 调用中并不存在的情况。</p>
<p>最后讲一句<code>get_or_create()</code> 在Django 视图中的使用。请确保只在<code>POST</code> 请求中使用，除非你有充分的理由。<code>GET</code> 请求不应该对数据有任何影响。而<code>POST</code> 则用于对数据产生影响的请求。更多信息，参见HTTP 细则中的<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1">安全的方法</a>。</p>
<p>警告</p>
<p>你可以通过<a href="fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> 属性和反向关联使用<code>get_or_create()</code>。在这种情况下，你应该限制查询在关联的上下文内部。如果你不一致地使用它，将可能导致完整性问题。</p>
<p>根据下面的模型：</p>
<pre><code>class Chapter(models.Model):
    title = models.CharField(max_length=255, unique=True)

class Book(models.Model):
    title = models.CharField(max_length=256)
    chapters = models.ManyToManyField(Chapter)

</code></pre>
<p>你可以通过Book 的chapters 字段使用<code>get_or_create()</code>，但是它只会获取该Book 内部的上下文：</p>
<pre><code>&gt;&gt;&gt; book = Book.objects.create(title="Ulysses")
&gt;&gt;&gt; book.chapters.get_or_create(title="Telemachus")
(&lt;Chapter: Telemachus&gt;, True)
&gt;&gt;&gt; book.chapters.get_or_create(title="Telemachus")
(&lt;Chapter: Telemachus&gt;, False)
&gt;&gt;&gt; Chapter.objects.create(title="Chapter 1")
&lt;Chapter: Chapter 1&gt;
&gt;&gt;&gt; book.chapters.get_or_create(title="Chapter 1")
# Raises IntegrityError

</code></pre>
<p>发生这个错误时因为它尝试通过Book “Ulysses” 获取或者创建“Chapter 1”，但是它不能：关联关系不能获取这个chapter 因为它与这个book 不关联，但因为<code>title</code> 字段是唯一的它仍然不能创建。</p>
<h4 id="update-or-create">update_or_create</h4>
<p><code>update_or_create</code>(<em>defaults=None</em>, <em>**kwargs</em>)</p>
<p>New in Django 1.7.</p>
<p>一个通过给出的<code>kwargs</code> 来更新对象的便捷方法， 如果需要的话创建一个新的对象。<code>defaults</code> 是一个由 (field, value) 对组成的字典，用于更新对象。</p>
<p>返回一个由 <code>(object, created)</code>组成的元组,元组中的<code>object</code> 是一个创建的或者是被更新的对象， <code>created</code> 是一个标示是否创建了新的对象的布尔值。</p>
<p><code>update_or_create</code> 方法尝试通过给出的<code>kwargs</code> 去从数据库中获取匹配的对象。如果找到匹配的对象，它将会依据<code>defaults</code> 字典给出的值更新字段。</p>
<p>这用作样板代码的一种快捷方式。例如：</p>
<pre><code>try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
    for key, value in updated_values.iteritems():
        setattr(obj, key, value)
    obj.save()
except Person.DoesNotExist:
    updated_values.update({'first_name': 'John', 'last_name': 'Lennon'})
    obj = Person(**updated_values)
    obj.save()

</code></pre>
<p>如果模型的字段数量较大的话，这种模式就变的非常不易用。上面的示例可以用 <code>update_or_create()</code> 重写:</p>
<pre><code>obj, created = Person.objects.update_or_create(
    first_name='John', last_name='Lennon', defaults=updated_values)

</code></pre>
<p><code>kwargs</code> 中的名称如何解析的详细描述可以参见<a href="#django.db.models.query.QuerySet.get_or_create" title="django.db.models.query.QuerySet.get_or_create"><code>get_or_create()</code></a>。</p>
<p>和上文描述的<a href="#django.db.models.query.QuerySet.get_or_create" title="django.db.models.query.QuerySet.get_or_create"><code>get_or_create()</code></a> 一样，这个方式容易导致竞态条件，如果数据库层级没有前置唯一性它会让多行同时插入。</p>
<h4 id="bulk-create">bulk_create</h4>
<p><code>bulk_create</code>(<em>objs</em>, <em>batch_size=None</em>)</p>
<p>此方法以有效的方式（通常只有1个查询，无论有多少对象）将提供的对象列表插入到数据库中：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.bulk_create([
...     Entry(headline="Django 1.0 Released"),
...     Entry(headline="Django 1.1 Announced"),
...     Entry(headline="Breaking: Django is awesome")
... ])

</code></pre>
<p>这有一些注意事项：</p>
<ul>
<li>将不会调用模型的<code>save()</code>方法，并且不会发送<code>pre_save</code>和<code>post_save</code>信号。</li>
<li>它不适用于多表继承场景中的子模型。</li>
<li>如果模型的主键是<a href="fields.html#django.db.models.AutoField" title="django.db.models.AutoField"><code>AutoField</code></a>，它不会像<code>save()</code>那样检索和设置主键属性。</li>
<li>它不适用于多对多关系。</li>
</ul>
<p><code>batch_size</code>参数控制在单个查询中创建的对象数。默认值是在一个批处理中创建所有对象，除了SQLite，其中默认值为每个查询最多使用999个变量。</p>
<h4 id="count">count</h4>
<p><code>count</code>()</p>
<p>返回在数据库中对应的 <code>QuerySet</code>.对象的个数。&nbsp;<code>count()</code> 永远不会引发异常。</p>
<p>例：</p>
<pre><code># Returns the total number of entries in the database.
Entry.objects.count()

# Returns the number of entries whose headline contains 'Lennon'
Entry.objects.filter(headline__contains='Lennon').count()

</code></pre>
<p><code>count()</code>在后台执行<code>SELECT COUNT（*）</code> <code>count()</code>，而不是将所有的记录加载到Python对象中并在结果上调用<code>len()</code>（除非你需要将对象加载到内存中， <code>len()</code>会更快）。</p>
<p>根据您使用的数据库（例如PostgreSQL vs. MySQL），<code>count()</code>可能返回一个长整型而不是普通的Python整数。这是一个潜在的实现方案，不应该引起任何真实世界的问题。</p>
<p>请注意，如果您想要<code>QuerySet</code>中的项目数量，并且还要从中检索模型实例（例如，通过迭代它），使用<code>len（查询集）</code>，这不会导致额外的数据库查询，如<code>count()</code>。</p>
<h4 id="in-bulk">in_bulk</h4>
<p><code>in_bulk</code>(<em>id_list</em>)</p>
<p>获取主键值的列表，并返回将每个主键值映射到具有给定ID的对象的实例的字典。</p>
<p>例：</p>
<pre><code>&gt;&gt;&gt; Blog.objects.in_bulk([1])
{1: &lt;Blog: Beatles Blog&gt;}
&gt;&gt;&gt; Blog.objects.in_bulk([1, 2])
{1: &lt;Blog: Beatles Blog&gt;, 2: &lt;Blog: Cheddar Talk&gt;}
&gt;&gt;&gt; Blog.objects.in_bulk([])
{}

</code></pre>
<p>如果你传递<code>in_bulk()</code>一个空列表，你会得到一个空的字典。</p>
<h4 id="iterator">iterator</h4>
<p><code>iterator</code>()</p>
<p>评估<code>QuerySet</code>（通过执行查询），并返回一个迭代器（参见 <a href="http://www.python.org/dev/peps/pep-0234"><strong>PEP 234</strong></a>）。<code>QuerySet</code>通常在内部缓存其结果，以便重复计算不会导致其他查询。相反，<code>iterator()</code>将直接读取结果，而不在<code>QuerySet</code>级别执行任何缓存（内部，默认迭代器调用<code>iterator()</code>并高速缓存返回值）。对于返回大量只需要访问一次的对象的<code>QuerySet</code>，这可以带来更好的性能和显着减少内存。</p>
<p>请注意，在已经评估的<code>QuerySet</code>上使用<code>iterator()</code>会强制它再次计算，重复查询。</p>
<p>此外，使用<code>iterator()</code>会导致先前的<code>prefetch_related()</code>调用被忽略，因为这两个优化一起没有意义。</p>
<p>警告</p>
<p>一些Python数据库驱动程序如<code>psycopg2</code>如果使用客户端游标（使用<code>connection.cursor()</code>实例化和Django的ORM使用）执行缓存。使用<code>iterator()</code>不会影响数据库驱动程序级别的缓存。要禁用此缓存，请查看<a href="http://initd.org/psycopg/docs/usage.html#server-side-cursors">服务器端游标</a>。</p>
<h4 id="latest">latest</h4>
<p><code>latest</code>(<em>field_name=None</em>)</p>
<p>使用作为日期字段提供的<code>field_name</code>，按日期返回表中的最新对象。</p>
<p>此示例根据<code>pub_date</code>字段返回表中的最新<code>条目</code>：</p>
<pre><code>Entry.objects.latest('pub_date')

</code></pre>
<p>如果模型的<a href="../../topics/db/models.html#meta-options"><em>Meta</em></a>指定<a href="options.html#django.db.models.Options.get_latest_by" title="django.db.models.Options.get_latest_by"><code>get_latest_by</code></a>，则可以将<code>field_name</code>参数留给<code>earliest()</code>或者<code>latest()</code>。默认情况下，Django将使用<a href="options.html#django.db.models.Options.get_latest_by" title="django.db.models.Options.get_latest_by"><code>get_latest_by</code></a>中指定的字段。</p>
<p>像<a href="#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a>，<code>earliest()</code>和<code>latest()</code> raise <a href="instances.html#django.db.models.Model.DoesNotExist" title="django.db.models.Model.DoesNotExist"><code>DoesNotExist</code></a>参数。</p>
<p>请注意，<code>earliest()</code>和<code>latest()</code>仅仅是为了方便和可读性。</p>
<h4 id="earliest">earliest</h4>
<p><code>earliest</code>(<em>field_name=None</em>)</p>
<p>除非方向更改，否则像<a href="#django.db.models.query.QuerySet.latest" title="django.db.models.query.QuerySet.latest"><code>latest()</code></a>。</p>
<h4 id="first">first</h4>
<p><code>first</code>()</p>
<p>返回结果集的第一个对象, 当没有找到时返回<code>None</code>.如果 <code>QuerySet</code> 没有设置排序,则将会自动按主键进行排序</p>
<p>例：</p>
<pre><code>p = Article.objects.order_by('title', 'pub_date').first()

</code></pre>
<p>笔记:<code>first()</code> 是一个简便方法 下面这个例子和上面的代码效果是一样</p>
<pre><code>try:
    p = Article.objects.order_by('title', 'pub_date')[0]
except IndexError:
    p = None

</code></pre>
<h4 id="last">last</h4>
<p><code>last</code>()</p>
<p>工作方式类似<a href="#django.db.models.query.QuerySet.first" title="django.db.models.query.QuerySet.first"><code>first()</code></a>，只是返回的是查询集中最后一个对象。</p>
<h4 id="aggregate聚合查询">aggregate（聚合查询）</h4>
<p><code>aggregate</code>(<em>*args</em>, <em>**kwargs</em>)</p>
<p>返回一个字典，包含根据<code>QuerySet</code> 计算得到的聚合值（平均数、和等等）。<code>aggregate()</code> 的每个参数指定返回的字典中将要包含的值。</p>
<p>Django 提供的聚合函数在下文的<a href="#id5">聚合函数</a>中讲述。因为聚合也是<a href="expressions.html"><em>查询表达式</em></a>，你可以组合多个聚合以及值来创建复杂的聚合。</p>
<p>使用关键字参数指定的聚合将使用关键字参数的名称作为Annotation 的名称。匿名的参数的名称将基于聚合函数的名称和模型字段生成。复杂的聚合不可以使用匿名参数，它们必须指定一个关键字参数作为别名。</p>
<p>例如，当你使用Blog Entry 时，你可能想知道对Author 贡献的Blog Entry 的数目：</p>
<pre><code>&gt;&gt;&gt; from django.db.models import Count
&gt;&gt;&gt; q = Blog.objects.aggregate(Count('entry'))
{'entry__count': 16}

</code></pre>
<p>通过使用关键字参数来指定聚合函数，你可以控制返回的聚合的值的名称：</p>
<pre><code>&gt;&gt;&gt; q = Blog.objects.aggregate(number_of_entries=Count('entry'))
{'number_of_entries': 16}

</code></pre>
<p>聚合的深入讨论，参见<a href="../../topics/db/aggregation.html"><em>聚合的指南</em></a>。</p>
<h4 id="exists">exists</h4>
<p><code>exists</code>()</p>
<p>如果<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> 包含任何结果，则返回<code>True</code>，否则返回<code>False</code>。它会试图用最简单和最快的方法完成查询，但它执行的方法与普通的_QuerySet_ 查询<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>确实</code></a>几乎相同。</p>
<p><a href="#django.db.models.query.QuerySet.exists" title="django.db.models.query.QuerySet.exists"><code>exists()</code></a> 用于搜寻对象是否在<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> 中以及<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> 是否存在任何对象，特别是<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> 比较大的时候。</p>
<p>查找具有唯一性字段（例如<code>primary_key</code>）的模型是否在一个<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> 中的最高效的方法是：</p>
<pre><code>entry = Entry.objects.get(pk=123)
if some_queryset.filter(pk=entry.pk).exists():
    print("Entry contained in queryset")

</code></pre>
<p>它将比下面的方法快很多，这个方法要求对QuerySet 求值并迭代整个QuerySet：</p>
<pre><code>if entry in some_queryset:
   print("Entry contained in QuerySet")

</code></pre>
<p>若要查找一个QuerySet 是否包含任何元素：</p>
<pre><code>if some_queryset.exists():
    print("There is at least one object in some_queryset")

</code></pre>
<p>将快于：</p>
<pre><code>if some_queryset:
    print("There is at least one object in some_queryset")

</code></pre>
<p>... 但不会快很多（因为这需要很大的QuerySet 以获得效率的提升）。</p>
<p>另外，如果<code>some_queryset</code> 还没有求值，但你知道它将在某个时刻求值，那么使用<code>some_queryset.exists()</code> 将比简单地使用<code>bool(some_queryset)</code> 完成更多的工作（一个查询用于存在性检查，另外一个是后面的求值），后者将求值并检查是否有结果返回。</p>
<h4 id="update">update</h4>
<p><code>update</code>(<em>**kwargs</em>)</p>
<p>对指定的字段执行SQL更新查询，并返回匹配的行数（如果某些行已具有新值，则可能不等于已更新的行数）。</p>
<p>例如，要对2010年发布的所有博客条目启用评论，您可以执行以下操作：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.filter(pub_date__year=2010).update(comments_on=False)

</code></pre>
<p>（假设您的<code>输入</code>模型具有字段<code>pub_date</code>和<code>comments_on</code>。）</p>
<p>您可以更新多个字段 - 没有多少字段的限制。例如，在这里我们更新<code>comments_on</code>和<code>标题</code>字段：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')

</code></pre>
<p><code>update()</code>方法立即应用，对更新的<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>的唯一限制是它只能更新模型主表中的列，而不是相关模型。你不能这样做，例如：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.update(blog__name='foo') # Won't work!

</code></pre>
<p>仍然可以根据相关字段进行过滤：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.filter(blog__id=1).update(comments_on=True)

</code></pre>
<p>您不能在<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>上调用<code>update()</code>，该查询已截取一个切片，或者无法再进行过滤。</p>
<p><code>update()</code>方法返回受影响的行数：</p>
<pre><code>&gt;&gt;&gt; Entry.objects.filter(id=64).update(comments_on=True)
1

&gt;&gt;&gt; Entry.objects.filter(slug='nonexistent-slug').update(comments_on=True)
0

&gt;&gt;&gt; Entry.objects.filter(pub_date__year=2010).update(comments_on=False)
132

</code></pre>
<p>如果你只是更新一个记录，不需要对模型对象做任何事情，最有效的方法是调用<code>update()</code>，而不是将模型对象加载到内存中。例如，而不是这样做：</p>
<pre><code>e = Entry.objects.get(id=10)
e.comments_on = False
e.save()

</code></pre>
<p>...做这个：</p>
<pre><code>Entry.objects.filter(id=10).update(comments_on=False)

</code></pre>
<p>使用<code>update()</code>还可以防止在加载对象和调用<code>save()</code>之间的短时间内数据库中某些内容可能发生更改的竞争条件。</p>
<p>Finally, realize that <code>update()</code> does an update at the SQL level and, thus, does not call any <code>save()</code> methods on your models, nor does it emit the <a href="../signals.html#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code>pre_save</code></a> or <a href="../signals.html#django.db.models.signals.post_save" title="django.db.models.signals.post_save"><code>post_save</code></a> signals (which are a consequence of calling <a href="instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>Model.save()</code></a>). 如果你想更新一个具有自定义<a href="instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>方法的模型的记录，请循环遍历它们并调用<a href="instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>，如下所示：</p>
<pre><code>for e in Entry.objects.filter(pub_date__year=2010):
    e.comments_on = False
    e.save()

</code></pre>
<h4 id="delete">delete</h4>
<p><code>delete</code>()</p>
<p>对<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>中的所有行执行SQL删除查询。立即应用<code>delete()</code>。您不能在<a href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>上调用<code>delete()</code>，该查询已采取切片或以其他方式无法过滤。</p>
<p>例如，要删除特定博客中的所有条目：</p>
<pre><code>&gt;&gt;&gt; b = Blog.objects.get(pk=1)

# Delete all the entries belonging to this Blog.
&gt;&gt;&gt; Entry.objects.filter(blog=b).delete()

</code></pre>
<p>默认情况下，Django的<a href="fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>模拟SQL约束<code>ON DELETE CASCADE</code>字，任何具有指向要删除的对象的外键的对象将与它们一起被删除。例如：</p>
<pre><code>blogs = Blog.objects.all()
# This will delete all Blogs and all of their Entry objects.
blogs.delete()

</code></pre>
<p>此级联行为可通过<a href="fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>的<a href="fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code>on_delete</code></a>参数自定义。</p>
<p><code>delete()</code>方法执行批量删除，并且不会在模型上调用任何<code>delete()</code>方法。但它会为所有已删除的对象（包括级联删除）发出<a href="../signals.html#django.db.models.signals.pre_delete" title="django.db.models.signals.pre_delete"><code>pre_delete</code></a>和<a href="../signals.html#django.db.models.signals.post_delete" title="django.db.models.signals.post_delete"><code>post_delete</code></a>信号。</p>
<p>Django需要获取对象到内存中以发送信号和处理级联。然而，如果没有级联和没有信号，那么Django可以采取快速路径并删除对象而不提取到内存中。对于大型删除，这可以显着减少内存使用。执行的查询量也可以减少。</p>
<p>设置为<a href="fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code>on_delete</code></a> <code>DO_NOTHING</code>的外键不会阻止删除快速路径。</p>
<p>请注意，在对象删除中生成的查询是实施详细信息，可能会更改。</p>
<h4 id="as-manager">as_manager</h4>
<p><em>classmethod</em> <code>as_manager</code>()</p>
<p>New in Django 1.7.</p>
<p>类方法，返回<a href="../../topics/db/managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a>的实例与<code>QuerySet</code>的方法的副本。有关详细信息，请参见<a href="../../topics/db/managers.html#create-manager-with-queryset-methods"><em>Creating Manager with QuerySet methods</em></a>。</p>
<h3 id="字段查找">字段查找</h3>
<p>字段查询是指如何指定SQL <code>WHERE</code>子句的内容. 它们通过<code>查询集</code>的<a href="#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a>, <a href="#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a> and <a href="#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a>的关键字参数指定.</p>
<p>查阅简介, 请参考 <a href="../../topics/db/queries.html#field-lookups-intro"><em>模型与数据库查询</em></a>.</p>
<p>Django的内置查找列在下面。也可以为模型字段写入<a href="../../howto/custom-lookups.html"><em>custom lookups</em></a>。</p>
<p>为了方便当没有提供查找类型时（例如<code>Entry.objects.get(id=14)</code>），假设查找类型为<a href="#std:fieldlookup-exact"><code>exact</code></a>。</p>
<h4 id="exact">exact</h4>
<p>精确匹配。如果为比较提供的值为<code>None</code>，它将被解释为SQL <code>NULL</code>（有关详细信息，请参阅<a href="#std:fieldlookup-isnull"><code>isnull</code></a>）。</p>
<p>例子：</p>
<pre><code>Entry.objects.get(id__exact=14)
Entry.objects.get(id__exact=None)

</code></pre>
<p>SQL等价物：</p>
<pre><code>SELECT ... WHERE id = 14;
SELECT ... WHERE id IS NULL;

</code></pre>
<p>MySQL比较</p>
<p>在MySQL中，数据库表的“排序规则”设置确定<code>exact</code>比较是否区分大小写。这是一个数据库设置，_而不是_一个Django设置。可以配置MySQL表以使用区分大小写的比较，但涉及一些折衷。有关详细信息，请参阅<a href="../databases.html"><em>databases</em></a>文档中的<a href="../databases.html#mysql-collation"><em>collation section</em></a>。</p>
<h4 id="iexact">iexact</h4>
<p>不区分大小写的精确匹配</p>
<p>Changed in Django 1.7:</p>
<p>如果为比较提供的值为<code>None</code>，它将被解释为SQL <code>NULL</code>（有关详细信息，请参阅<a href="#std:fieldlookup-isnull"><code>isnull</code></a>）。</p>
<p>例：</p>
<pre><code>Blog.objects.get(name__iexact='beatles blog')
Blog.objects.get(name__iexact=None)

</code></pre>
<p>SQL等价物：</p>
<pre><code>SELECT ... WHERE name ILIKE 'beatles blog';
SELECT ... WHERE name IS NULL;

</code></pre>
<p>请注意，第一个查询将匹配 <code>'Beatles Blog'</code>, <code>'beatles blog'</code>, <code>'BeAtLes BLoG'</code>, etc.</p>
<p>SQLite用户</p>
<p>当使用SQLite后端和Unicode（非ASCII）字符串时，请记住关于字符串比较的<a href="../databases.html#sqlite-string-matching"><em>数据库注释</em></a>。SQLite不对Unicode字符串进行不区分大小写的匹配。</p>
<h4 id="contains">contains</h4>
<p>区分敏感遏制试验。</p>
<p>例：</p>
<pre><code>Entry.objects.get(headline__contains='Lennon')

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE headline LIKE '%Lennon%';

</code></pre>
<p>请注意，这将匹配标题<code>'Lennon honored today'</code>，但不符合<code>'lennon honored today'</code>.</p>
<p>SQLite用户</p>
<p>SQLite不支持区分大小写的<code>LIKE</code>语句；<code>contains</code> 用于SQLite的<code>icontains</code>。有关详细信息，请参阅<a href="../databases.html#sqlite-string-matching"><em>数据库注释</em></a>。</p>
<h4 id="icontains">icontains</h4>
<p>不区分大小写的遏制试验。</p>
<p>例：</p>
<pre><code>Entry.objects.get(headline__icontains='Lennon')

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE headline ILIKE '%Lennon%';

</code></pre>
<p>SQLite用户</p>
<p>当使用SQLite后端和Unicode（非ASCII）字符串时，请记住关于字符串比较的<a href="../databases.html#sqlite-string-matching"><em>数据库注释</em></a>。</p>
<h4 id="in">in</h4>
<p>在给定的列表。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(id__in=[1, 3, 4])

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE id IN (1, 3, 4);

</code></pre>
<p>您还可以使用查询集动态评估值列表，而不是提供文字值列表：</p>
<pre><code>inner_qs = Blog.objects.filter(name__contains='Cheddar')
entries = Entry.objects.filter(blog__in=inner_qs)

</code></pre>
<p>此查询集将作为subselect语句求值：</p>
<pre><code>SELECT ... WHERE blog.id IN (SELECT id FROM ... WHERE NAME LIKE '%Cheddar%')

</code></pre>
<p>如果您传入<code>ValuesQuerySet</code>或<code>ValuesListQuerySet</code>（调用<code>values()</code>或<code>values_list()</code>查询集）作为<code>__在</code>查找的值，您需要确保您只提取结果中的一个字段。例如，这将工作（过滤博客名称）：</p>
<pre><code>inner_qs = Blog.objects.filter(name__contains='Ch').values('name')
entries = Entry.objects.filter(blog__name__in=inner_qs)

</code></pre>
<p>这个例子将产生一个异常，由于内查询试图提取两个字段的值，但是查询语句只期望提取一个字段的值：</p>
<pre><code># Bad code! Will raise a TypeError.
inner_qs = Blog.objects.filter(name__contains='Ch').values('name', 'id')
entries = Entry.objects.filter(blog__name__in=inner_qs)

</code></pre>
<p>性能注意事项</p>
<p>对于使用嵌套查询和了解数据库服务器的性能特征（如果有疑问，去做基准测试）要谨慎。一些数据库后端，最着名的是MySQL，不能很好地优化嵌套查询。在这些情况下，提取值列表然后将其传递到第二个查询中更有效。也就是说，执行两个查询，而不是一个：</p>
<pre><code>values = Blog.objects.filter(
        name__contains='Cheddar').values_list('pk', flat=True)
entries = Entry.objects.filter(blog__in=list(values))

</code></pre>
<p>请注意<code>list()</code>调用Blog <code>QuerySet</code>以强制执行第一个查询。没有它，将执行嵌套查询，因为<a href="../../topics/db/queries.html#querysets-are-lazy"><em>QuerySet是惰性的</em></a>。</p>
<h4>）</h4>
<p>大于</p>
<p>例子:</p>
<pre><code>Entry.objects.filter(id__gt=4)

</code></pre>
<p>SQL语句相当于：</p>
<pre><code>SELECT ... WHERE id &gt; 4;

</code></pre>
<h4 id="gte">gte</h4>
<p>大于或等于</p>
<h4 id="1">1</h4>
<p>小于</p>
<h4 id="lte">lte</h4>
<p>小于或等于</p>
<h4 id="startswith">startswith</h4>
<p>区分大小写，开始位置匹配</p>
<p>例：</p>
<pre><code>Entry.objects.filter(headline__startswith='Will')

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE headline LIKE 'Will%';

</code></pre>
<p>SQLite 不支持区分大小写 <code>LIKE</code> 语句; Sqlite 下<code>startswith</code> 等于 <code>istartswith</code> .</p>
<h4 id="istartswith">istartswith</h4>
<p>不区分大小写，开始位置匹配</p>
<p>例：</p>
<pre><code>Entry.objects.filter(headline__istartswith='will')

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE headline ILIKE 'Will%';

</code></pre>
<p>SQLite用户</p>
<p>当使用SQLite后端和Unicode（非ASCII）字符串时，请记住关于字符串比较的<a href="../databases.html#sqlite-string-matching"><em>数据库注释</em></a>。</p>
<h4 id="endswith">endswith</h4>
<p>区分大小写。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(headline__endswith='cats')

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE headline LIKE '%cats';

</code></pre>
<p>SQLite用户</p>
<p>SQLite不支持区分大小写的<code>LIKE</code>语句；<code>endswith</code>用作SQLite的<code>iendswith</code>。有关更多信息，请参阅<a href="../databases.html#sqlite-string-matching"><em>数据库注释</em></a>文档。</p>
<h4 id="iendswith">iendswith</h4>
<p>不区分大小写。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(headline__iendswith='will')

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE headline ILIKE '%will'

</code></pre>
<p>SQLite用户</p>
<p>当使用SQLite后端和Unicode（非ASCII）字符串时，请记住关于字符串比较的<a href="../databases.html#sqlite-string-matching"><em>数据库注释</em></a>。</p>
<h4 id="range">range</h4>
<p>范围测试（包含于之中）。</p>
<p>例：</p>
<pre><code>import datetime
start_date = datetime.date(2005, 1, 1)
end_date = datetime.date(2005, 3, 31)
Entry.objects.filter(pub_date__range=(start_date, end_date))

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE pub_date BETWEEN '2005-01-01' and '2005-03-31';

</code></pre>
<p>您可以在任何可以使用<code>BETWEEN</code>的SQL中使用<code>范围</code>（对于日期，数字和偶数字符）。</p>
<p>警告</p>
<p>过滤具有日期的<code>DateTimeField</code>不会包含最后一天的项目，因为边界被解释为“给定日期的0am”。如果<code>pub_date</code>是<code>DateTimeField</code>，上面的表达式将变成这个SQL：</p>
<pre><code>SELECT ... WHERE pub_date BETWEEN '2005-01-01 00:00:00' and '2005-03-31 00:00:00';

</code></pre>
<p>一般来说，不能混合使用日期和数据时间。</p>
<h4 id="year">year</h4>
<p>对于日期和日期时间字段，确切的年匹配。整数年。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(pub_date__year=2005)

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE pub_date BETWEEN '2005-01-01' AND '2005-12-31';

</code></pre>
<p>（确切的SQL语法因每个数据库引擎而异）。</p>
<p>当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>True</code>时，在过滤之前，datetime字段将转换为当前时区。</p>
<h4 id="month">month</h4>
<p>对于日期和日期时间字段，确切的月份匹配。取整数1（1月）至12（12月）。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(pub_date__month=12)

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE EXTRACT('month' FROM pub_date) = '12';

</code></pre>
<p>（确切的SQL语法因每个数据库引擎而异）。</p>
<p>当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>True</code>时，在过滤之前，datetime字段将转换为当前时区。这需要数据库中的<a href="#database-time-zone-definitions"><em>时区定义</em></a>。</p>
<h4 id="day要写到程序里的字段麻烦不要自作聪明翻译谢谢">day(要写到程序里的字段麻烦不要自作聪明翻译谢谢)</h4>
<p>对于日期和日期时间字段，具体到某一天的匹配。取一个整数的天数。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(pub_date__day=3)

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE EXTRACT('day' FROM pub_date) = '3';

</code></pre>
<p>（确切的SQL语法因每个数据库引擎而异）。</p>
<p>请注意，这将匹配每月第三天（例如1月3日，7月3日等）的任何包含pub_date的记录。</p>
<p>当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>True</code>时，在过滤之前，datetime字段将转换为当前时区。这需要数据库中的<a href="#database-time-zone-definitions"><em>time zone definitions in the database</em></a>。</p>
<h4 id="week-day">week_day</h4>
<p>对于日期和日期时间字段，“星期几”匹配。</p>
<p>取整数值，表示星期几从1（星期日）到7（星期六）。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(pub_date__week_day=2)

</code></pre>
<p>（此查找不包括等效的SQL代码片段，因为相关查询的实现因不同数据库引擎而异）。</p>
<p>请注意，这将匹配落在星期一（星期二）的任何记录（<code>pub_date</code>），而不管其出现的月份或年份。周日被索引，第1天为星期天，第7天为星期六。</p>
<p>当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>True</code>时，在过滤之前，datetime字段将转换为当前时区。这需要数据库中的<a href="#database-time-zone-definitions"><em>时区定义</em></a>。</p>
<h4 id="hour">hour</h4>
<p>对于日期时间字段，精确的小时匹配。取0和23之间的整数。</p>
<p>例：</p>
<pre><code>Event.objects.filter(timestamp__hour=23)

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE EXTRACT('hour' FROM timestamp) = '23';

</code></pre>
<p>（确切的SQL语法因每个数据库引擎而异）。</p>
<p>当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>True</code>时，在过滤之前将值转换为当前时区。</p>
<h4 id="minute">minute</h4>
<p>对于日期时间字段，精确的分钟匹配。取0和59之间的整数。</p>
<p>例：</p>
<pre><code>Event.objects.filter(timestamp__minute=29)

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE EXTRACT('minute' FROM timestamp) = '29';

</code></pre>
<p>（确切的SQL语法因每个数据库引擎而异）。</p>
<p>当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>True</code>时，在过滤之前将值转换为当前时区。</p>
<h4 id="second">second</h4>
<p>对于datetime字段，精确的第二个匹配。取0和59之间的整数。</p>
<p>例：</p>
<pre><code>Event.objects.filter(timestamp__second=31)

</code></pre>
<p>等同于SQL语句:</p>
<pre><code>SELECT ... WHERE EXTRACT('second' FROM timestamp) = '31';

</code></pre>
<p>（确切的SQL语法因每个数据库引擎而异）。</p>
<p>当<a href="../settings.html#std:setting-USE_TZ"><code>USE_TZ</code></a>为<code>True</code>时，在过滤之前将值转换为当前时区。</p>
<h4 id="isnull">isnull</h4>
<p>值为 <code>True</code> 或 <code>False</code>, 相当于 SQL语句<code>IS NULL</code>和<code>IS NOT NULL</code>.</p>
<p>例：</p>
<pre><code>Entry.objects.filter(pub_date__isnull=True)

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE pub_date IS NULL;

</code></pre>
<h4 id="search">search</h4>
<p>一个Boolean类型的全文搜索，以全文搜索的优势。这个很像 <a href="#std:fieldlookup-contains"><code>contains</code></a> ，但是由于全文索引的优势，以使它更显著的快。</p>
<p>例：</p>
<pre><code>Entry.objects.filter(headline__search="+Django -jazz Python")

</code></pre>
<p>SQL等效：</p>
<pre><code>SELECT ... WHERE MATCH(tablename, headline) AGAINST (+Django -jazz Python IN BOOLEAN MODE);

</code></pre>
<p>注意，这仅在MySQL中可用，并且需要直接操作数据库以添加全文索引。默认情况下，Django使用BOOLEAN MODE进行全文搜索。有关其他详细信息，请参阅<a href="http://dev.mysql.com/doc/refman/5.6/en/fulltext-boolean.html">MySQL文档</a>。</p>
<h4 id="正则表达式">正则表达式</h4>
<p>区分大小写的正则表达式匹配。</p>
<p>正则表达式语法是正在使用的数据库后端的语法。在SQLite没有内置正则表达式支持的情况下，此功能由（Python）用户定义的REGEXP函数提供，因此正则表达式语法是Python的<code>re</code>模块。</p>
<p>例：</p>
<pre><code>Entry.objects.get(title__regex=r'^(An?|The) +')

</code></pre>
<p>SQL等价物：</p>
<pre><code>SELECT ... WHERE title REGEXP BINARY '^(An?|The) +'; -- MySQL

SELECT ... WHERE REGEXP_LIKE(title, '^(an?|the) +', 'c'); -- Oracle

SELECT ... WHERE title ~ '^(An?|The) +'; -- PostgreSQL

SELECT ... WHERE title REGEXP '^(An?|The) +'; -- SQLite

</code></pre>
<p>建议使用原始字符串（例如，<code>r'foo'</code>而不是<code>'foo'</code>）来传递正则表达式语法。</p>
<h4 id="iregex">iregex</h4>
<p>不区分大小写的正则表达式匹配。</p>
<p>例：</p>
<pre><code>Entry.objects.get(title__iregex=r'^(an?|the) +')

</code></pre>
<p>SQL等价物：</p>
<pre><code>SELECT ... WHERE title REGEXP '^(an?|the) +'; -- MySQL

SELECT ... WHERE REGEXP_LIKE(title, '^(an?|the) +', 'i'); -- Oracle

SELECT ... WHERE title ~* '^(an?|the) +'; -- PostgreSQL

SELECT ... WHERE title REGEXP '(?i)^(an?|the) +'; -- SQLite

</code></pre>
<h3 id="聚合函数">聚合函数</h3>
<p>Django 的<code>django.db.models</code> 模块提供以下聚合函数。关于如何使用这些聚合函数的细节，参见<a href="../../topics/db/aggregation.html"><em>聚合函数的指南</em></a>。关于如何创建聚合函数，参数<a href="expressions.html#django.db.models.Aggregate" title="django.db.models.Aggregate"><code>聚合函数</code></a> 的文档。</p>
<p>警告</p>
<p>SQLite 不能直接处理日期/时间字段的聚合。这是因为SQLite 中没有原生的日期/时间字段，Django 目前使用文本字段模拟它的功能。在SQLite 中对日期/时间字段使用聚合将引发<code>NotImplementedError</code>。</p>
<p>注</p>
<p>在<code>QuerySet</code> 为空时，聚合函数函数将返回<code>None</code>。 例如，如果<code>QuerySet</code> 中没有记录，<code>Sum</code> 聚合函数将返回<code>None</code> 而不是<code>0</code>。<code>Count</code> 是一个例外，如果<code>QuerySet</code> 为空，它将返回<code>0</code>。</p>
<p>所有聚合函数具有以下共同的参数：</p>
<h4 id="表达">表达</h4>
<p>引用模型字段的一个字符串，或者一个<a href="expressions.html"><em>查询表达式</em></a>。</p>
<p>New in Django 1.8:</p>
<p>现在在复杂的计算中，聚合函数可以引用多个字段。</p>
<h4 id="output-field">output_field</h4>
<p>用来表示返回值的<a href="fields.html"><em>模型字段</em></a>，它是一个可选的参数。</p>
<p>New in Django 1.8:</p>
<p>添加<code>output_field</code> 参数。</p>
<p>注</p>
<p>在组合多个类型的字段时，只有在所有的字段都是相同类型的情况下，Django 才能确定<code>output_field</code>。否则，你必须自己提供<code>output_field</code> 参数。</p>
<h4 id="额外">**额外</h4>
<p>这些关键字参数可以给聚合函数生成的SQL 提供额外的信息。</p>
<h4 id="avg">avg</h4>
<p><em>class</em> <code>Avg</code>(<em>expression</em>, <em>output_field=None</em>, <em>**extra</em>)</p>
<p>返回给定expression 的平均值，其中expression 必须为数值。</p>
<ul>
<li>默认的别名：<code>&amp;lt;field&amp;gt;__avg</code></li>
<li>返回类型：<code>float</code></li>
</ul>
<h4 id="count-1">Count</h4>
<p><em>class</em> <code>Count</code>(<em>expression</em>, <em>distinct=False</em>, <em>**extra</em>)</p>
<p>返回与expression 相关的对象的个数。</p>
<ul>
<li>默认的别名：<code>&amp;lt;field&amp;gt;__count</code></li>
<li>返回类型：<code>int</code></li>
</ul>
<p>有一个可选的参数：</p>
<p><code>distinct</code></p>
<p>如果<code>distinct=True</code>，Count 将只计算唯一的实例。它等同于<code>COUNT(DISTINCT &amp;lt;field&amp;gt;)</code> SQL 语句。默认值为<code>False</code>。</p>
<h4 id="max">Max</h4>
<p><em>class</em> <code>Max</code>(<em>expression</em>, <em>output_field=None</em>, <em>**extra</em>)</p>
<p>返回expression 的最大值。</p>
<ul>
<li>默认的别名：<code>&amp;lt;field&amp;gt;__max</code></li>
<li>返回类型：与输入字段的类型相同，如果提供则为 <code>output_field</code> 类型</li>
</ul>
<h4 id="min">Min</h4>
<p><em>class</em> <code>Min</code>(<em>expression</em>, <em>output_field=None</em>, <em>**extra</em>)</p>
<p>返回expression 的最小值。</p>
<ul>
<li>默认的别名：<code>&amp;lt;field&amp;gt;__min</code></li>
<li>返回的类型：与输入字段的类型相同，如果提供则为 <code>output_field</code> 类型</li>
</ul>
<h4 id="stddev">StdDev</h4>
<p><em>class</em> <code>StdDev</code>(<em>expression</em>, <em>sample=False</em>, <em>**extra</em>)</p>
<p>返回expression 的标准差。</p>
<ul>
<li>默认的别名：<code>&amp;lt;field&amp;gt;__stddev</code></li>
<li>返回类型：<code>float</code></li>
</ul>
<p>有一个可选的参数：</p>
<p><code>sample</code></p>
<p>默认情况下，<code>StdDev</code> 返回群体的标准差。但是，如果<code>sample=True</code>，返回的值将是样本的标准差。</p>
<p>SQLite</p>
<p>SQLite 没有直接提供<code>StdDev</code>。有一个可用的实现是SQLite 的一个扩展模块。参见<a href="http://www.sqlite.org/contrib">SQlite 的文档</a> 中获取并安装这个扩展的指南。</p>
<h4 id="sum">Sum</h4>
<p><em>class</em> <code>Sum</code>(<em>expression</em>, <em>output_field=None</em>, <em>**extra</em>)</p>
<p>计算expression 的所有值的和。</p>
<ul>
<li>默认的别名：<code>&amp;lt;field&amp;gt;__sum</code></li>
<li>返回类型：与输入的字段相同，如果提供则为<code>output_field</code> 的类型</li>
</ul>
<h4 id="variance">Variance</h4>
<p><em>class</em> <code>Variance</code>(<em>expression</em>, <em>sample=False</em>, <em>**extra</em>)</p>
<p>返回expression 的方差。</p>
<ul>
<li>默认的别名：<code>&amp;lt;field&amp;gt;__variance</code></li>
<li>返回的类型：<code>float</code></li>
</ul>
<p>有一个可选的参数：</p>
<p><code>sample</code></p>
<p>默认情况下，<code>Variance</code> 返回群体的方差。但是，如果<code>sample=True</code>，返回的值将是样本的方差。</p>
<p>SQLite</p>
<p>SQLite 没有直接提供<code>Variance</code>。有一个可用的实现是SQLite 的一个扩展模块。 参见<a href="http://www.sqlite.org/contrib">SQlite 的文档</a> 中获取并安装这个扩展的指南。</p>
<h2 id="查询相关的类">查询相关的类</h2>
<p>本节提供查询相关的工具的参考资料，它们其它地方没有文档。</p>
<h3 id="q-对象"><code>Q()</code> 对象</h3>
<p><em>class</em> <code>Q</code></p>
<p><code>Q()</code> 对象和<a href="expressions.html#django.db.models.F" title="django.db.models.F"><code>F</code></a> 对象类似，把一个SQL 表达式封装在Python 对象中，这个对象可以用于数据库相关的操作。</p>
<p>通常，<code>Q() 对象</code> 使得定义查询条件然后重用成为可能。这允许<a href="../../topics/db/queries.html#complex-lookups-with-q"><em>construction of complex database queries</em></a>使用<code>|</code> (<code>OR</code>) 和 <code>&amp;</code> (<code>AND</code>) 操作符; 否则<code>QuerySets</code>中使用不了<code>OR</code>。</p>
<h3 id="prefetch对象"><code>Prefetch()</code>对象</h3>
<p>New in Django 1.7.</p>
<p><em>class</em> <code>Prefetch</code>(<em>lookup</em>, <em>queryset=None</em>, <em>to_attr=None</em>)</p>
<p><code>Prefetch()</code>对象可用于控制<a href="#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code>prefetch_related()</code></a>的操作。</p>
<p><code>lookup</code>参数描述了跟随的关系，并且工作方式与传递给<a href="#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code>prefetch_related()</code></a>的基于字符串的查找相同。例如：</p>
<pre><code>&gt;&gt;&gt; Question.objects.prefetch_related(Prefetch('choice_set')).get().choice_set.all()
[&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]
# This will only execute two queries regardless of the number of Question
# and Choice objects.
&gt;&gt;&gt; Question.objects.prefetch_related(Prefetch('choice_set')).all()
[&lt;Question: Question object&gt;]

</code></pre>
<p><code>查询集</code>参数为给定的查找提供基本<code>QuerySet</code>。这对于进一步过滤预取操作或从预取关系调用<a href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a>很有用，因此进一步减少查询数量：</p>
<pre><code>&gt;&gt;&gt; voted_choices = Choice.objects.filter(votes__gt=0)
&gt;&gt;&gt; voted_choices
[&lt;Choice: The sky&gt;]
&gt;&gt;&gt; prefetch = Prefetch('choice_set', queryset=voted_choices)
&gt;&gt;&gt; Question.objects.prefetch_related(prefetch).get().choice_set.all()
[&lt;Choice: The sky&gt;]

</code></pre>
<p><code>to_attr</code>参数将预取操作的结果设置为自定义属性：</p>
<pre><code>&gt;&gt;&gt; prefetch = Prefetch('choice_set', queryset=voted_choices, to_attr='voted_choices')
&gt;&gt;&gt; Question.objects.prefetch_related(prefetch).get().voted_choices
[&lt;Choice: The sky&gt;]
&gt;&gt;&gt; Question.objects.prefetch_related(prefetch).get().choice_set.all()
[&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]

</code></pre>
<p>注意</p>
<p>当使用<code>to_attr</code>时，预取的结果存储在列表中。这可以提供比存储在<code>QuerySet</code>实例内的缓存结果的传统<code>prefetch_related</code>调用显着的速度改进。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/112/index.html">
<img class="uk-book-cover" src="../../static/icons/48/django_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/112/index.html">从Python到Django入门教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="django">django</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">41页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/120/index.html">
<img class="uk-book-cover" src="../../static/icons/48/spark_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/120/index.html">Openstack用户指南（简体中文版）</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="spark">spark</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">47页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/190/index.html">
<img class="uk-book-cover" src="../../static/icons/48/nginx_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/190/index.html">Nginx 管理员手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/107.html">trimstray</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="nginx">nginx</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">307页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8424个">8424</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/193/index.html">
<img class="uk-book-cover" src="../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/193/index.html">Pixi教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/109.html">Zainking</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">56页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2020年5月17日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/135/index.html">
<img class="uk-book-cover" src="../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/135/index.html">微前端的那些事儿</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">55页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/200/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/200/index.html">软件开发基础知识宝典</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/112.html">frank-lam</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/35/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/35/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_First%20steps.html" title="新手入门" data-book-page-rel-url="1_First%20steps.html" data-book-page-id="2038">新手入门</a>
<ul>
<li>
<a class="pjax" href="../../book/35/1_1.html" title="从零开始" data-book-page-rel-url="1_1.html" data-book-page-id="2039">从零开始</a>
<ul>
<li>
<a class="pjax" href="../../book/35/1_1_1_Django%20at%20a%20glance.html" title="概览" data-book-page-rel-url="1_1_1_Django%20at%20a%20glance.html" data-book-page-id="2040">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_1_2_Quick%20install%20guide.html" title="安装" data-book-page-rel-url="1_1_2_Quick%20install%20guide.html" data-book-page-id="2041">安装</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/1_2.html" title="教程" data-book-page-rel-url="1_2.html" data-book-page-id="2042">教程</a>
<ul>
<li>
<a class="pjax" href="../../book/35/1_2_1_Part%201%20Models.html" title="第1部分：模型" data-book-page-rel-url="1_2_1_Part%201%20Models.html" data-book-page-id="2043">第1部分：模型</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_2_2_Part%202%20The%20admin%20site.html" title="第2部分：管理站点" data-book-page-rel-url="1_2_2_Part%202%20The%20admin%20site.html" data-book-page-id="2044">第2部分：管理站点</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_2_3_Part%203%20Views%20and%20templates.html" title="第3部分：视图和模板" data-book-page-rel-url="1_2_3_Part%203%20Views%20and%20templates.html" data-book-page-id="2045">第3部分：视图和模板</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_2_4_Part%204%20Forms%20and%20generic%20views.html" title="第4部分：表单和通用视图" data-book-page-rel-url="1_2_4_Part%204%20Forms%20and%20generic%20views.html" data-book-page-id="2046">第4部分：表单和通用视图</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_2_5_Part%205%20Testing.html" title="第5部分：测试" data-book-page-rel-url="1_2_5_Part%205%20Testing.html" data-book-page-id="2047">第5部分：测试</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_2_6_Part%206%20Static%20files.html" title="第6部分：静态文件" data-book-page-rel-url="1_2_6_Part%206%20Static%20files.html" data-book-page-id="2048">第6部分：静态文件</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/1_3.html" title="高级教程" data-book-page-rel-url="1_3.html" data-book-page-id="2049">高级教程</a>
<ul>
<li>
<a class="pjax" href="../../book/35/1_3_1_How%20to%20write%20reusable%20apps.html" title="如何编写可重用的应用" data-book-page-rel-url="1_3_1_How%20to%20write%20reusable%20apps.html" data-book-page-id="2050">如何编写可重用的应用</a>
</li>
<li>
<a class="pjax" href="../../book/35/1_3_2_Writing%20your%20first%20patch%20for%20Django.html" title="为Django编写首个补丁" data-book-page-rel-url="1_3_2_Writing%20your%20first%20patch%20for%20Django.html" data-book-page-id="2051">为Django编写首个补丁</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/2_The%20model%20layer.html" title="模型层" data-book-page-rel-url="2_The%20model%20layer.html" data-book-page-id="2052">模型层</a>
<ul>
<li>
<a class="pjax" href="../../book/35/2_1.html" title="模型" data-book-page-rel-url="2_1.html" data-book-page-id="2053">模型</a>
<ul>
<li>
<a class="pjax" href="../../book/35/2_1_1_Model%20syntax.html" title="模型语法" data-book-page-rel-url="2_1_1_Model%20syntax.html" data-book-page-id="2054">模型语法</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_1_2_Field%20types.html" title="字段类型" data-book-page-rel-url="2_1_2_Field%20types.html" data-book-page-id="2055">字段类型</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_1_3_Meta%20options.html" title="元选项" data-book-page-rel-url="2_1_3_Meta%20options.html" data-book-page-id="2056">元选项</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_1_4_Model%20class.html" title="模型类" data-book-page-rel-url="2_1_4_Model%20class.html" data-book-page-id="2057">模型类</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/2_2.html" title="查询集" data-book-page-rel-url="2_2.html" data-book-page-id="2058">查询集</a>
<ul>
<li>
<a class="pjax" href="../../book/35/2_2_1_Making%20queries.html" title="执行查询" data-book-page-rel-url="2_2_1_Making%20queries.html" data-book-page-id="2059">执行查询</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_2_2_QuerySet%20method%20reference.html" title="查询集方法参考" data-book-page-rel-url="2_2_2_QuerySet%20method%20reference.html" data-book-page-id="2060">查询集方法参考</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_2_3_Lookup%20expressions.html" title="查找表达式" data-book-page-rel-url="2_2_3_Lookup%20expressions.html" data-book-page-id="2061">查找表达式</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/2_3.html" title="模型的实例" data-book-page-rel-url="2_3.html" data-book-page-id="2062">模型的实例</a>
<ul>
<li>
<a class="pjax" href="../../book/35/2_3_1_Instance%20methods.html" title="实例方法" data-book-page-rel-url="2_3_1_Instance%20methods.html" data-book-page-id="2063">实例方法</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_3_2_Accessing%20related%20objects.html" title="访问关联对象" data-book-page-rel-url="2_3_2_Accessing%20related%20objects.html" data-book-page-id="2064">访问关联对象</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/2_4.html" title="迁移" data-book-page-rel-url="2_4.html" data-book-page-id="2065">迁移</a>
<ul>
<li>
<a class="pjax" href="../../book/35/2_4_1_Introduction%20to%20Migrations.html" title="迁移简介" data-book-page-rel-url="2_4_1_Introduction%20to%20Migrations.html" data-book-page-id="2066">迁移简介</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_4_2_Operations%20reference.html" title="操作参考" data-book-page-rel-url="2_4_2_Operations%20reference.html" data-book-page-id="2067">操作参考</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_4_3_SchemaEditor.html" title="模式编辑器" data-book-page-rel-url="2_4_3_SchemaEditor.html" data-book-page-id="2068">模式编辑器</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_4_4_Writing%20migrations.html" title="编写迁移" data-book-page-rel-url="2_4_4_Writing%20migrations.html" data-book-page-id="2069">编写迁移</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/2_5.html" title="高级" data-book-page-rel-url="2_5.html" data-book-page-id="2070">高级</a>
<ul>
<li>
<a class="pjax" href="../../book/35/2_5_1_Manager.html" title="管理器" data-book-page-rel-url="2_5_1_Manager.html" data-book-page-id="2071">管理器</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_2_Performing%20raw%20SQL%20queries.html" title="原始的SQL查询" data-book-page-rel-url="2_5_2_Performing%20raw%20SQL%20queries.html" data-book-page-id="2072">原始的SQL查询</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_3_Transactions.html" title="事务" data-book-page-rel-url="2_5_3_Transactions.html" data-book-page-id="2073">事务</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_4_Aggregation.html" title="聚合" data-book-page-rel-url="2_5_4_Aggregation.html" data-book-page-id="2074">聚合</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_5_Custom%20fields.html" title="自定义字段" data-book-page-rel-url="2_5_5_Custom%20fields.html" data-book-page-id="2075">自定义字段</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_6_Multiple%20databases.html" title="多数据库" data-book-page-rel-url="2_5_6_Multiple%20databases.html" data-book-page-id="2076">多数据库</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_7_Custom%20lookups.html" title="自定义查找" data-book-page-rel-url="2_5_7_Custom%20lookups.html" data-book-page-id="2077">自定义查找</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_8_Query%20Expressions.html" title="查询表达式" data-book-page-rel-url="2_5_8_Query%20Expressions.html" data-book-page-id="2078">查询表达式</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_9_Conditional%20Expressions.html" title="条件表达式" data-book-page-rel-url="2_5_9_Conditional%20Expressions.html" data-book-page-id="2079">条件表达式</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_5_10_Database%20Functions.html" title="数据库函数" data-book-page-rel-url="2_5_10_Database%20Functions.html" data-book-page-id="2080">数据库函数</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/2_6.html" title="其它" data-book-page-rel-url="2_6.html" data-book-page-id="2081">其它</a>
<ul>
<li>
<a class="pjax" href="../../book/35/2_6_1_Supported%20databases.html" title="支持的数据库" data-book-page-rel-url="2_6_1_Supported%20databases.html" data-book-page-id="2082">支持的数据库</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_6_2_Legacy%20databases.html" title="遗留的数据库" data-book-page-rel-url="2_6_2_Legacy%20databases.html" data-book-page-id="2083">遗留的数据库</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_6_3_Providing%20initial%20data.html" title="提供初始数据" data-book-page-rel-url="2_6_3_Providing%20initial%20data.html" data-book-page-id="2084">提供初始数据</a>
</li>
<li>
<a class="pjax" href="../../book/35/2_6_4_Optimize%20database%20access.html" title="优化数据库访问" data-book-page-rel-url="2_6_4_Optimize%20database%20access.html" data-book-page-id="2085">优化数据库访问</a>
</li>
<li>
<a class="pjax" href="../../book/35/SUMMARY.html" title="PostgreSQL特色功能" data-book-page-rel-url="SUMMARY.html" data-book-page-id="2086">PostgreSQL特色功能</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/3_The%20view%20layer.html" title="视图层" data-book-page-rel-url="3_The%20view%20layer.html" data-book-page-id="2087">视图层</a>
<ul>
<li>
<a class="pjax" href="../../book/35/3_1.html" title="基础" data-book-page-rel-url="3_1.html" data-book-page-id="2088">基础</a>
<ul>
<li>
<a class="pjax" href="../../book/35/3_1_1_URLconfs.html" title="URL配置" data-book-page-rel-url="3_1_1_URLconfs.html" data-book-page-id="2089">URL配置</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_1_2_View%20functions.html" title="视图函数" data-book-page-rel-url="3_1_2_View%20functions.html" data-book-page-id="2090">视图函数</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_1_3_Shortcuts.html" title="快捷函数" data-book-page-rel-url="3_1_3_Shortcuts.html" data-book-page-id="2091">快捷函数</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_1_4_Decorators.html" title="装饰器" data-book-page-rel-url="3_1_4_Decorators.html" data-book-page-id="2092">装饰器</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/3_2.html" title="参考" data-book-page-rel-url="3_2.html" data-book-page-id="2093">参考</a>
<ul>
<li>
<a class="pjax" href="../../book/35/3_2_1_Built-in%20Views.html" title="内建的视图" data-book-page-rel-url="3_2_1_Built-in%20Views.html" data-book-page-id="2094">内建的视图</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_2_2_Request%20response%20objects.html" title="请求/响应 对象" data-book-page-rel-url="3_2_2_Request%20response%20objects.html" data-book-page-id="2095">请求/响应 对象</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_2_3_TemplateResponse%20objects.html" title="TemplateResponse 对象" data-book-page-rel-url="3_2_3_TemplateResponse%20objects.html" data-book-page-id="2096">TemplateResponse 对象</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_2_4_TemplateResponse%20objects.html" title="TemplateResponse 和SimpleTemplateResponse" data-book-page-rel-url="3_2_4_TemplateResponse%20objects.html" data-book-page-id="2097">TemplateResponse 和SimpleTemplateResponse</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/3_3.html" title="文件上传" data-book-page-rel-url="3_3.html" data-book-page-id="2098">文件上传</a>
<ul>
<li>
<a class="pjax" href="../../book/35/3_3_1_Overview.html" title="概览" data-book-page-rel-url="3_3_1_Overview.html" data-book-page-id="2099">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_3_2_File%20objects.html" title="File 对象" data-book-page-rel-url="3_3_2_File%20objects.html" data-book-page-id="2100">File 对象</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_3_3_Storage%20API.html" title="储存API" data-book-page-rel-url="3_3_3_Storage%20API.html" data-book-page-id="2101">储存API</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_3_4_Managing%20files.html" title="管理文件" data-book-page-rel-url="3_3_4_Managing%20files.html" data-book-page-id="2102">管理文件</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_3_5_Custom%20storage.html" title="自定义存储" data-book-page-rel-url="3_3_5_Custom%20storage.html" data-book-page-id="2103">自定义存储</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/3_4.html" title="基于类的视图" data-book-page-rel-url="3_4.html" data-book-page-id="2104">基于类的视图</a>
<ul>
<li>
<a class="pjax" href="../../book/35/3_4_1_Overview.html" title="概览" data-book-page-rel-url="3_4_1_Overview.html" data-book-page-id="2105">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_4_2_Built-in%20display%20views.html" title="内建显示视图" data-book-page-rel-url="3_4_2_Built-in%20display%20views.html" data-book-page-id="2106">内建显示视图</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_4_3_Built-in%20editing%20views.html" title="内建编辑视图" data-book-page-rel-url="3_4_3_Built-in%20editing%20views.html" data-book-page-id="2107">内建编辑视图</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_4_4_Using%20mixins.html" title="使用Mixin" data-book-page-rel-url="3_4_4_Using%20mixins.html" data-book-page-id="2108">使用Mixin</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_4_5_API%20reference.html" title="API参考" data-book-page-rel-url="3_4_5_API%20reference.html" data-book-page-id="2109">API参考</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_4_6_Flattened%20index.html" title="分类索引" data-book-page-rel-url="3_4_6_Flattened%20index.html" data-book-page-id="2110">分类索引</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/3_5.html" title="高级" data-book-page-rel-url="3_5.html" data-book-page-id="2111">高级</a>
<ul>
<li>
<a class="pjax" href="../../book/35/3_5_1_Generating%20CSV.html" title="生成 CSV" data-book-page-rel-url="3_5_1_Generating%20CSV.html" data-book-page-id="2112">生成 CSV</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_5_2_Generating%20PDF.html" title="生成 PDF" data-book-page-rel-url="3_5_2_Generating%20PDF.html" data-book-page-id="2113">生成 PDF</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/3_6.html" title="中间件" data-book-page-rel-url="3_6.html" data-book-page-id="2114">中间件</a>
<ul>
<li>
<a class="pjax" href="../../book/35/3_6_1_Overview.html" title="概览" data-book-page-rel-url="3_6_1_Overview.html" data-book-page-id="2115">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/3_6_2_Built-in%20middleware%20classes.html" title="内建的中间件类" data-book-page-rel-url="3_6_2_Built-in%20middleware%20classes.html" data-book-page-id="2116">内建的中间件类</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/4_The%20template%20layer.html" title="模板层" data-book-page-rel-url="4_The%20template%20layer.html" data-book-page-id="2117">模板层</a>
<ul>
<li>
<a class="pjax" href="../../book/35/4_1.html" title="基础" data-book-page-rel-url="4_1.html" data-book-page-id="2118">基础</a>
<ul>
<li>
<a class="pjax" href="../../book/35/4_1_1_Overview.html" title="概览" data-book-page-rel-url="4_1_1_Overview.html" data-book-page-id="2119">概览</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/4_2.html" title="面向设计师" data-book-page-rel-url="4_2.html" data-book-page-id="2120">面向设计师</a>
<ul>
<li>
<a class="pjax" href="../../book/35/4_2_1_Language%20overview.html" title="语言概览" data-book-page-rel-url="4_2_1_Language%20overview.html" data-book-page-id="2121">语言概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/4_2_2_Built-in%20tags%20and%20filters.html" title="内建标签和过滤器" data-book-page-rel-url="4_2_2_Built-in%20tags%20and%20filters.html" data-book-page-id="2122">内建标签和过滤器</a>
</li>
<li>
<a class="pjax" href="../../book/35/4_2_3_Web%20design%20helpers.html" title="网页设计助手(已废弃)" data-book-page-rel-url="4_2_3_Web%20design%20helpers.html" data-book-page-id="2123">网页设计助手(已废弃)</a>
</li>
<li>
<a class="pjax" href="../../book/35/4_2_4_Humanization.html" title="人性化" data-book-page-rel-url="4_2_4_Humanization.html" data-book-page-id="2124">人性化</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/4_3.html" title="面向程序员" data-book-page-rel-url="4_3.html" data-book-page-id="2125">面向程序员</a>
<ul>
<li>
<a class="pjax" href="../../book/35/4_3_1_Template%20API.html" title="模板API" data-book-page-rel-url="4_3_1_Template%20API.html" data-book-page-id="2126">模板API</a>
</li>
<li>
<a class="pjax" href="../../book/35/4_3_2_Custom%20tags%20and%20filters.html" title="自定义标签和过滤器" data-book-page-rel-url="4_3_2_Custom%20tags%20and%20filters.html" data-book-page-id="2127">自定义标签和过滤器</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/5_Forms.html" title="表单" data-book-page-rel-url="5_Forms.html" data-book-page-id="2128">表单</a>
<ul>
<li>
<a class="pjax" href="../../book/35/5_1.html" title="基础" data-book-page-rel-url="5_1.html" data-book-page-id="2129">基础</a>
<ul>
<li>
<a class="pjax" href="../../book/35/5_1_1_Overview.html" title="概览" data-book-page-rel-url="5_1_1_Overview.html" data-book-page-id="2130">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/5_1_2_Form%20API.html" title="表单API" data-book-page-rel-url="5_1_2_Form%20API.html" data-book-page-id="2131">表单API</a>
</li>
<li>
<a class="pjax" href="../../book/35/5_1_3_Built-in%20widgets.html" title="内建的字段" data-book-page-rel-url="5_1_3_Built-in%20widgets.html" data-book-page-id="2132">内建的字段</a>
</li>
<li>
<a class="pjax" href="../../book/35/5_1_4_Built-in%20widgets.html" title="内建的Widget" data-book-page-rel-url="5_1_4_Built-in%20widgets.html" data-book-page-id="2133">内建的Widget</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/5_2.html" title="高级" data-book-page-rel-url="5_2.html" data-book-page-id="2134">高级</a>
<ul>
<li>
<a class="pjax" href="../../book/35/5_2_1_Forms%20for%20models.html" title="模型表单" data-book-page-rel-url="5_2_1_Forms%20for%20models.html" data-book-page-id="2135">模型表单</a>
</li>
<li>
<a class="pjax" href="../../book/35/5_2_2_Integrating%20media.html" title="整合媒体" data-book-page-rel-url="5_2_2_Integrating%20media.html" data-book-page-id="2136">整合媒体</a>
</li>
<li>
<a class="pjax" href="../../book/35/5_2_3_Formsets.html" title="表单集" data-book-page-rel-url="5_2_3_Formsets.html" data-book-page-id="2137">表单集</a>
</li>
<li>
<a class="pjax" href="../../book/35/5_2_4_Customizing%20validation.html" title="自定义验证" data-book-page-rel-url="5_2_4_Customizing%20validation.html" data-book-page-id="2138">自定义验证</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/6_The%20development%20process.html" title="开发过程" data-book-page-rel-url="6_The%20development%20process.html" data-book-page-id="2139">开发过程</a>
<ul>
<li>
<a class="pjax" href="../../book/35/6_1.html" title="设置" data-book-page-rel-url="6_1.html" data-book-page-id="2140">设置</a>
<ul>
<li>
<a class="pjax" href="../../book/35/6_1_1_Overview.html" title="概览" data-book-page-rel-url="6_1_1_Overview.html" data-book-page-id="2141">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_1_2_Full%20list%20of%20settings.html" title="完整设置列表" data-book-page-rel-url="6_1_2_Full%20list%20of%20settings.html" data-book-page-id="2142">完整设置列表</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/6_2.html" title="应用程序" data-book-page-rel-url="6_2.html" data-book-page-id="2143">应用程序</a>
<ul>
<li>
<a class="pjax" href="../../book/35/6_2_Overview.html" title="概览" data-book-page-rel-url="6_2_Overview.html" data-book-page-id="2144">概览</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/6_3.html" title="异常" data-book-page-rel-url="6_3.html" data-book-page-id="2145">异常</a>
<ul>
<li>
<a class="pjax" href="../../book/35/6_3_Overview.html" title="概览" data-book-page-rel-url="6_3_Overview.html" data-book-page-id="2146">概览</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/6_4.html" title="django-admin 和 manage.py" data-book-page-rel-url="6_4.html" data-book-page-id="2147">django-admin 和 manage.py</a>
<ul>
<li>
<a class="pjax" href="../../book/35/6_4_1_Overview.html" title="概览" data-book-page-rel-url="6_4_1_Overview.html" data-book-page-id="2148">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_4_2_Adding%20custom%20commands.html" title="添加自定义的命令" data-book-page-rel-url="6_4_2_Adding%20custom%20commands.html" data-book-page-id="2149">添加自定义的命令</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/6_5.html" title="测试" data-book-page-rel-url="6_5.html" data-book-page-id="2150">测试</a>
<ul>
<li>
<a class="pjax" href="../../book/35/6_5_1_Introduction.html" title="介绍" data-book-page-rel-url="6_5_1_Introduction.html" data-book-page-id="2151">介绍</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_5_2_Writing%20and%20running%20tests.html" title="编写并运行测试" data-book-page-rel-url="6_5_2_Writing%20and%20running%20tests.html" data-book-page-id="2152">编写并运行测试</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_5_3_Included%20testing%20tools.html" title="包含的测试工具" data-book-page-rel-url="6_5_3_Included%20testing%20tools.html" data-book-page-id="2153">包含的测试工具</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_5_4_Advanced%20topics.html" title="高级主题" data-book-page-rel-url="6_5_4_Advanced%20topics.html" data-book-page-id="2154">高级主题</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/6_6.html" title="部署" data-book-page-rel-url="6_6.html" data-book-page-id="2155">部署</a>
<ul>
<li>
<a class="pjax" href="../../book/35/6_6_1_Overview.html" title="概述" data-book-page-rel-url="6_6_1_Overview.html" data-book-page-id="2156">概述</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_6_2_WSGI%20servers.html" title="WSGI服务器" data-book-page-rel-url="6_6_2_WSGI%20servers.html" data-book-page-id="2157">WSGI服务器</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_6_3_FastCGI%20SCGI%20AJP.html" title="FastCGI/SCGI/AJP (已废弃)" data-book-page-rel-url="6_6_3_FastCGI%20SCGI%20AJP.html" data-book-page-id="2158">FastCGI/SCGI/AJP (已废弃)</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_6_4_Deploying%20static%20files.html" title="部署静态文件" data-book-page-rel-url="6_6_4_Deploying%20static%20files.html" data-book-page-id="2159">部署静态文件</a>
</li>
<li>
<a class="pjax" href="../../book/35/6_6_5_Tracking%20code%20errors%20by%20email.html" title="通过email追踪代码错误" data-book-page-rel-url="6_6_5_Tracking%20code%20errors%20by%20email.html" data-book-page-id="2160">通过email追踪代码错误</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/7_Admin.html" title="Admin" data-book-page-rel-url="7_Admin.html" data-book-page-id="2161">Admin</a>
<ul>
<li>
<a class="pjax" href="../../book/35/7_1_Admin%20site.html" title="管理站点" data-book-page-rel-url="7_1_Admin%20site.html" data-book-page-id="2162">管理站点</a>
</li>
<li>
<a class="pjax" href="../../book/35/7_2_Admin%20actions.html" title="管理操作" data-book-page-rel-url="7_2_Admin%20actions.html" data-book-page-id="2163">管理操作</a>
</li>
<li>
<a class="pjax" href="../../book/35/7_3_Admin%20documentation%20generator.html" title="管理文档生成器" data-book-page-rel-url="7_3_Admin%20documentation%20generator.html" data-book-page-id="2164">管理文档生成器</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/8_Security.html" title="安全" data-book-page-rel-url="8_Security.html" data-book-page-id="2165">安全</a>
<ul>
<li>
<a class="pjax" href="../../book/35/8_1_Security%20overview.html" title="安全概述" data-book-page-rel-url="8_1_Security%20overview.html" data-book-page-id="2166">安全概述</a>
</li>
<li>
<a class="pjax" href="../../book/35/8_2_Disclosed%20security%20issues%20in%20Django.html" title="说明Django中的安全问题" data-book-page-rel-url="8_2_Disclosed%20security%20issues%20in%20Django.html" data-book-page-id="2167">说明Django中的安全问题</a>
</li>
<li>
<a class="pjax" href="../../book/35/8_3_Clickjacking%20protection.html" title="点击劫持保护" data-book-page-rel-url="8_3_Clickjacking%20protection.html" data-book-page-id="2168">点击劫持保护</a>
</li>
<li>
<a class="pjax" href="../../book/35/8_4_Cross%20Site%20Request%20Forgery%20protection.html" title="伪造跨站请求保护" data-book-page-rel-url="8_4_Cross%20Site%20Request%20Forgery%20protection.html" data-book-page-id="2169">伪造跨站请求保护</a>
</li>
<li>
<a class="pjax" href="../../book/35/8_5_Cryptographic%20signing.html" title="加密签名" data-book-page-rel-url="8_5_Cryptographic%20signing.html" data-book-page-id="2170">加密签名</a>
</li>
<li>
<a class="pjax" href="../../book/35/8_6_Security%20Middleware.html" title="安全中间件" data-book-page-rel-url="8_6_Security%20Middleware.html" data-book-page-id="2171">安全中间件</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/9_Internationalization%20and%20localization.html" title="国际化和本地化" data-book-page-rel-url="9_Internationalization%20and%20localization.html" data-book-page-id="2172">国际化和本地化</a>
<ul>
<li>
<a class="pjax" href="../../book/35/9_1_1_Overview.html" title="概述" data-book-page-rel-url="9_1_1_Overview.html" data-book-page-id="2173">概述</a>
</li>
<li>
<a class="pjax" href="../../book/35/9_1_2_Internationalization.html" title="国际化" data-book-page-rel-url="9_1_2_Internationalization.html" data-book-page-id="2174">国际化</a>
</li>
<li>
<a class="pjax" href="../../book/35/9_1_4_Localized%20Web%20UI%20formatting%20and%20form%20input.html" title="本地化WEB UI格式化输入" data-book-page-rel-url="9_1_4_Localized%20Web%20UI%20formatting%20and%20form%20input.html" data-book-page-id="2175">本地化WEB UI格式化输入</a>
</li>
<li>
<a class="pjax" href="../../book/35/9_2_“Local%20flavor”.html" title="“本地特色”" data-book-page-rel-url="9_2_“Local%20flavor”.html" data-book-page-id="2176">“本地特色”</a>
</li>
<li>
<a class="pjax" href="../../book/35/9_3_Time%20zones.html" title="时区" data-book-page-rel-url="9_3_Time%20zones.html" data-book-page-id="2177">时区</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/10_Performance%20and%20optimization%20overview.html" title="性能和优化" data-book-page-rel-url="10_Performance%20and%20optimization%20overview.html" data-book-page-id="2178">性能和优化</a>
</li>
<li>
<a class="pjax" href="../../book/35/11_Python%20compatibility.html" title="Python 的兼容性" data-book-page-rel-url="11_Python%20compatibility.html" data-book-page-id="2179">Python 的兼容性</a>
<ul>
<li>
<a class="pjax" href="../../book/35/11_1_Jython%20support.html" title="Jython 支持" data-book-page-rel-url="11_1_Jython%20support.html" data-book-page-id="2180">Jython 支持</a>
</li>
<li>
<a class="pjax" href="../../book/35/11_2_Python%203%20compatibility.html" title="Python 3 兼容性" data-book-page-rel-url="11_2_Python%203%20compatibility.html" data-book-page-id="2181">Python 3 兼容性</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/13_Common%20Web%20application%20tools.html" title="常见的网站应用工具" data-book-page-rel-url="13_Common%20Web%20application%20tools.html" data-book-page-id="2182">常见的网站应用工具</a>
<ul>
<li>
<a class="pjax" href="../../book/35/13_1.html" title="认证" data-book-page-rel-url="13_1.html" data-book-page-id="2183">认证</a>
<ul>
<li>
<a class="pjax" href="../../book/35/13_1_1_Overview.html" title="概览" data-book-page-rel-url="13_1_1_Overview.html" data-book-page-id="2184">概览</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_1_2_Using%20the%20authentication%20system.html" title="使用认证系统" data-book-page-rel-url="13_1_2_Using%20the%20authentication%20system.html" data-book-page-id="2185">使用认证系统</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_1_3_Password%20management.html" title="密码管理" data-book-page-rel-url="13_1_3_Password%20management.html" data-book-page-id="2186">密码管理</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_1_4_Customizing%20authentication.html" title="自定义认证" data-book-page-rel-url="13_1_4_Customizing%20authentication.html" data-book-page-id="2187">自定义认证</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_1_5_API%20Reference.html" title="API参考" data-book-page-rel-url="13_1_5_API%20Reference.html" data-book-page-id="2188">API参考</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/13_2_Caching.html" title="缓存" data-book-page-rel-url="13_2_Caching.html" data-book-page-id="2189">缓存</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_3_Logging.html" title="日志" data-book-page-rel-url="13_3_Logging.html" data-book-page-id="2190">日志</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_4_Sending%20emails.html" title="发送邮件" data-book-page-rel-url="13_4_Sending%20emails.html" data-book-page-id="2191">发送邮件</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_5_Syndication%20feeds.html" title="组织 feeds (RSS/Atom)" data-book-page-rel-url="13_5_Syndication%20feeds.html" data-book-page-id="2192">组织 feeds (RSS/Atom)</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_6_Pagination.html" title="分页" data-book-page-rel-url="13_6_Pagination.html" data-book-page-id="2193">分页</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_7_Messages%20framework.html" title="消息框架" data-book-page-rel-url="13_7_Messages%20framework.html" data-book-page-id="2194">消息框架</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_8_Serialization.html" title="序列化" data-book-page-rel-url="13_8_Serialization.html" data-book-page-id="2195">序列化</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_9_1_Sessions.html" title="会话" data-book-page-rel-url="13_9_1_Sessions.html" data-book-page-id="2196">会话</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_10_Sitemaps.html" title="网站地图" data-book-page-rel-url="13_10_Sitemaps.html" data-book-page-id="2197">网站地图</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_11_Static%20files%20management.html" title="静态文件处理" data-book-page-rel-url="13_11_Static%20files%20management.html" data-book-page-id="2198">静态文件处理</a>
</li>
<li>
<a class="pjax" href="../../book/35/13_12_Data%20validation.html" title="数据验证" data-book-page-rel-url="13_12_Data%20validation.html" data-book-page-id="2199">数据验证</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/35/14_Other%20core%20functionalities.html" title="其它核心功能" data-book-page-rel-url="14_Other%20core%20functionalities.html" data-book-page-id="2200">其它核心功能</a>
<ul>
<li>
<a class="pjax" href="../../book/35/14_1_Conditional%20content%20processing.html" title="按需内容处理" data-book-page-rel-url="14_1_Conditional%20content%20processing.html" data-book-page-id="2201">按需内容处理</a>
</li>
<li>
<a class="pjax" href="../../book/35/14_2_Content%20types%20and%20generic%20relations.html" title="内容类型和泛型关系" data-book-page-rel-url="14_2_Content%20types%20and%20generic%20relations.html" data-book-page-id="2202">内容类型和泛型关系</a>
</li>
<li>
<a class="pjax" href="../../book/35/14_3_Flatpages.html" title="Flatpage" data-book-page-rel-url="14_3_Flatpages.html" data-book-page-id="2203">Flatpage</a>
</li>
<li>
<a class="pjax" href="../../book/35/14_4_1_Redirects.html" title="重定向" data-book-page-rel-url="14_4_1_Redirects.html" data-book-page-id="2204">重定向</a>
</li>
<li>
<a class="pjax" href="../../book/35/14_5_Signals.html" title="信号" data-book-page-rel-url="14_5_Signals.html" data-book-page-id="2205">信号</a>
</li>
<li>
<a class="pjax" href="../../book/35/14_6_System%20check%20framework.html" title="系统检查框架" data-book-page-rel-url="14_6_System%20check%20framework.html" data-book-page-id="2206">系统检查框架</a>
</li>
<li>
<a class="pjax" href="../../book/35/14_7_The%20sites%20framework.html" title="网站框架" data-book-page-rel-url="14_7_The%20sites%20framework.html" data-book-page-id="2207">网站框架</a>
</li>
<li>
<a class="pjax" href="../../book/35/14_8_Unicode%20in%20Django.html" title="Django中的Unicode编码" data-book-page-rel-url="14_8_Unicode%20in%20Django.html" data-book-page-id="2208">Django中的Unicode编码</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =35;var bookPageId =2060;var bookPageRelUrl ='2_2_2_QuerySet%20method%20reference.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>