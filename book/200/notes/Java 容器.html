
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Java 容器-软件开发基础知识宝典</title>
<meta content='Java 容器,软件开发基础知识宝典' name='keywords'>
<meta content='Java 容器,软件开发基础知识宝典' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/200/notes/Java%20并发.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">Java 并发</span>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/200/index.html">软件开发基础知识宝典</a>
<a target="_blank" rel="nofollow" href="https://github.com/frank-lam/Interview-Notebook" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<ul>
<li><a href="#一概览">一、概览</a>
<ul>
<li><a href="#collection">Collection</a></li>
<li><a href="#map">Map</a></li>
</ul> </li>
<li><a href="#二容器中的设计模式">二、容器中的设计模式</a>
<ul>
<li><a href="#迭代器模式">迭代器模式</a></li>
<li><a href="#适配器模式">适配器模式</a></li>
</ul> </li>
<li><a href="#三源码分析">三、源码分析</a>
<ul>
<li><a href="#arraylist">ArrayList</a></li>
<li><a href="#vector">Vector</a></li>
<li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a></li>
<li><a href="#linkedlist">LinkedList</a></li>
<li><a href="#hashmap">HashMap</a></li>
<li><a href="#concurrenthashmap">ConcurrentHashMap</a></li>
<li><a href="#linkedhashmap">LinkedHashMap</a></li>
<li><a href="#weekhashmap">WeekHashMap</a></li>
</ul> </li>
<li><a href="#附录">附录</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<h1 id="一概览">一、概览</h1>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="collection">Collection</h2>
<div align="center">
<a href="https://img.cntofu.com/book/Interview-Notebook/pics//VP4n3i8m34Ntd28NQ4_0KCJ2q044Oez.png" data-uk-lightbox><img src="https://img.cntofu.com/book/Interview-Notebook/pics//VP4n3i8m34Ntd28NQ4_0KCJ2q044Oez.png"></a>
</div>
<br>
<h3 id="1-set">1. Set</h3>
<ul>
<li> <p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p> </li>
<li> <p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p> </li>
<li> <p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p> </li>
</ul>
<h3 id="2-list">2. List</h3>
<ul>
<li> <p>ArrayList：基于动态数组实现，支持随机访问。</p> </li>
<li> <p>Vector：和 ArrayList 类似，但它是线程安全的。</p> </li>
<li> <p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p> </li>
</ul>
<h3 id="3-queue">3. Queue</h3>
<ul>
<li> <p>LinkedList：可以用它来实现双向队列。</p> </li>
<li> <p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</p> </li>
</ul>
<h2 id="map">Map</h2>
<div align="center">
<a href="https://img.cntofu.com/book/Interview-Notebook/pics//SoWkIImgAStDuUBAp2j9BKfBJ4vLy4q.png" data-uk-lightbox><img src="https://img.cntofu.com/book/Interview-Notebook/pics//SoWkIImgAStDuUBAp2j9BKfBJ4vLy4q.png"></a>
</div>
<br>
<ul>
<li> <p>TreeMap：基于红黑树实现。</p> </li>
<li> <p>HashMap：基于哈希表实现。</p> </li>
<li> <p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p> </li>
<li> <p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p> </li>
</ul>
<h1 id="二容器中的设计模式">二、容器中的设计模式</h1>
<h2 id="迭代器模式">迭代器模式</h2>
<div align="center">
<a href="https://img.cntofu.com/book/Interview-Notebook/pics//SoWkIImgAStDuUBAp2j9BKfBJ4vLy0G.png" data-uk-lightbox><img src="https://img.cntofu.com/book/Interview-Notebook/pics//SoWkIImgAStDuUBAp2j9BKfBJ4vLy0G.png"></a>
</div>
<br>
<p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("a");
list.add("b");
for (String item : list) {
    System.out.println(item);
}
</code></pre>
<h2 id="适配器模式">适配器模式</h2>
<p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<pre><code class="language-java">@SafeVarargs
public static &lt;T&gt; List&lt;T&gt; asList(T... a)
</code></pre>
<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<pre><code class="language-java">Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
</code></pre>
<p>也可以使用以下方式调用 asList()：</p>
<pre><code class="language-java">List list = Arrays.asList(1,2,3);
</code></pre>
<h1 id="三源码分析">三、源码分析</h1>
<p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h2 id="arraylist">ArrayList</h2>
<h3 id="1-概览">1. 概览</h3>
<p>实现了 RandomAccess 接口，因此支持随机访问。这是理所当然的，因为 ArrayList 是基于数组实现的。</p>
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<p>数组的默认大小为 10。</p>
<pre><code class="language-java">private static final int DEFAULT_CAPACITY = 10;
</code></pre>
<h3 id="2-序列化">2. 序列化</h3>
<p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<pre><code class="language-java">transient Object[] elementData; // non-private to simplify nested class access
</code></pre>
<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<pre><code class="language-java">private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}
</code></pre>
<pre><code class="language-java">private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<pre><code class="language-java">ArrayList list = new ArrayList();
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
oos.writeObject(list);
</code></pre>
<h3 id="3-扩容">3. 扩容</h3>
<p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<h3 id="4-删除元素">4. 删除元素</h3>
<p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p>
<pre><code class="language-java">public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
</code></pre>
<h3 id="5-fail-fast">5. Fail-Fast</h3>
<p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<pre><code class="language-java">private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre>
<h2 id="vector">Vector</h2>
<h3 id="1-同步">1. 同步</h3>
<p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<pre><code class="language-java">public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
</code></pre>
<h3 id="2-与-arraylist-的比较">2. 与 ArrayList 的比较</h3>
<ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="3-替代方案">3. 替代方案</h3>
<p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;String&gt; synList = Collections.synchronizedList(list);
</code></pre>
<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<pre><code class="language-java">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<h2 id="copyonwritearraylist">CopyOnWriteArrayList</h2>
<h3 id="读写分离">读写分离</h3>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<pre><code class="language-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}
</code></pre>
<pre><code class="language-java">@SuppressWarnings("unchecked")
private E get(Object[] a, int index) {
    return (E) a[index];
}
</code></pre>
<h3 id="适用场景">适用场景</h3>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="linkedlist">LinkedList</h2>
<h3 id="1-概览-1">1. 概览</h3>
<p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<pre><code class="language-java">private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
}
</code></pre>
<p>每个链表存储了 first 和 last 指针：</p>
<pre><code class="language-java">transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;
</code></pre>
<div align="center">
<a href="https://img.cntofu.com/book/Interview-Notebook/pics//49495c95-52e5-4c9a-b27b-92cf235ff5ec.png" data-uk-lightbox><img src="https://img.cntofu.com/book/Interview-Notebook/pics//49495c95-52e5-4c9a-b27b-92cf235ff5ec.png" width="500"></a>
</div>
<br>
<h3 id="2-与-arraylist-的比较-1">2. 与 ArrayList 的比较</h3>
<ul>
<li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li>
<li>ArrayList 支持随机访问，LinkedList 不支持；</li>
<li>LinkedList 在任意位置添加删除元素更快。</li>
</ul>
<h2 id="hashmap">HashMap</h2>
<p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<h3 id="1-存储结构">1. 存储结构</h3>
<p>内部包含了一个 Entry 类型的数组 table。</p>
<pre><code class="language-java">transient Entry[] table;
</code></pre>
<p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。</p>
<div align="center">
<a href="https://img.cntofu.com/book/Interview-Notebook/pics//8fe838e3-ef77-4f63-bf45-417b6bc5c6bb.png" data-uk-lightbox><img src="https://img.cntofu.com/book/Interview-Notebook/pics//8fe838e3-ef77-4f63-bf45-417b6bc5c6bb.png" width="600"></a>
</div>
<br>
<pre><code class="language-java">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;

    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                return true;
        }
        return false;
    }

    public final int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }

    public final String toString() {
        return getKey() + "=" + getValue();
    }

    /**
     * This method is invoked whenever the value in an entry is
     * overwritten by an invocation of put(k,v) for a key k that's already
     * in the HashMap.
     */
    void recordAccess(HashMap&lt;K,V&gt; m) {
    }

    /**
     * This method is invoked whenever the entry is
     * removed from the table.
     */
    void recordRemoval(HashMap&lt;K,V&gt; m) {
    }
}
</code></pre>
<h3 id="2-拉链法的工作原理">2. 拉链法的工作原理</h3>
<pre><code class="language-java">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put("K1", "V1");
map.put("K2", "V2");
map.put("K3", "V3");
</code></pre>
<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<div align="center">
<a href="https://img.cntofu.com/book/Interview-Notebook/pics//49d6de7b-0d0d-425c-9e49-a1559dc23b10.png" data-uk-lightbox><img src="https://img.cntofu.com/book/Interview-Notebook/pics//49d6de7b-0d0d-425c-9e49-a1559dc23b10.png" width="600"></a>
</div>
<br>
<h3 id="3-put-操作">3. put 操作</h3>
<pre><code class="language-java">public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
</code></pre>
<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<pre><code class="language-java">private V putForNullKey(V value) {
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}
</code></pre>
<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    // 头插法，链表头部指向新的键值对
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}
</code></pre>
<pre><code class="language-java">Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
    value = v;
    next = n;
    key = k;
    hash = h;
}
</code></pre>
<h3 id="4-确定桶下标">4. 确定桶下标</h3>
<p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<pre><code class="language-java">int hash = hash(key);
int i = indexFor(hash, table.length);
</code></pre>
<p>（一）计算 hash 值</p>
<pre><code class="language-java">final int hash(Object k) {
    int h = hashSeed;
    if (0 != h &amp;&amp; k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
</code></pre>
<pre><code class="language-java">public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}
</code></pre>
<p>（二）取模</p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<pre><code>x   : 00010000
x-1 : 00001111
</code></pre>
<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<pre><code>y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010
</code></pre>
<p>这个性质和 y 对 x 取模效果是一样的：</p>
<pre><code>y   : 10110010
x   : 00010000
y%x : 00000010
</code></pre>
<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<pre><code class="language-java">static int indexFor(int h, int length) {
    return h &amp; (length-1);
}
</code></pre>
<h3 id="5-扩容-基本原理">5. 扩容-基本原理</h3>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">capacity</td>
<td align="left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td align="center">size</td>
<td align="left">table 的实际使用量。</td>
</tr>
<tr>
<td align="center">threshold</td>
<td align="left">size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</td>
</tr>
<tr>
<td align="center">loadFactor</td>
<td align="left">装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">static final int DEFAULT_INITIAL_CAPACITY = 16;

static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

static final float DEFAULT_LOAD_FACTOR = 0.75f;

transient Entry[] table;

transient int size;

int threshold;

final float loadFactor;

transient int modCount;
</code></pre>
<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    if (size++ &gt;= threshold)
        resize(2 * table.length);
}
</code></pre>
<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<pre><code class="language-java">void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}

void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j &lt; src.length; j++) {
        Entry&lt;K,V&gt; e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry&lt;K,V&gt; next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
</code></pre>
<h3 id="6-扩容-重新计算桶下标">6. 扩容-重新计算桶下标</h3>
<p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<pre><code class="language-html">capacity     : 00010000
new capacity : 00100000
</code></pre>
<p>对于一个 Key，</p>
<ul>
<li>它的哈希值如果在第 6 位上为 0，那么取模得到的结果和之前一样；</li>
<li>如果为 1，那么得到的结果为原来的结果 +16。</li>
</ul>
<h3 id="7-扩容-计算数组容量">7. 扩容-计算数组容量</h3>
<p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<pre><code>mask |= mask &gt;&gt; 1    11011000
mask |= mask &gt;&gt; 2    11111100
mask |= mask &gt;&gt; 4    11111111
</code></pre>
<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<pre><code>num     10010000
mask+1 100000000
</code></pre>
<p>以下是 HashMap 中计算数组容量的代码：</p>
<pre><code class="language-java">static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<h3 id="8-链表转红黑树">8. 链表转红黑树</h3>
<p>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-hashtable-的比较">9. 与 HashTable 的比较</h3>
<ul>
<li>HashTable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2 id="concurrenthashmap">ConcurrentHashMap</h2>
<h3 id="1-存储结构-1">1. 存储结构</h3>
<pre><code class="language-java">static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}
</code></pre>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<pre><code class="language-java">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {

    private static final long serialVersionUID = 2249069246763182397L;

    static final int MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;

    transient volatile HashEntry&lt;K,V&gt;[] table;

    transient int count;

    transient int modCount;

    transient int threshold;

    final float loadFactor;
}
</code></pre>
<pre><code class="language-java">final Segment&lt;K,V&gt;[] segments;
</code></pre>
<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<pre><code class="language-java">static final int DEFAULT_CONCURRENCY_LEVEL = 16;
</code></pre>
<div align="center">
<a href="https://img.cntofu.com/book/Interview-Notebook/pics//3fdfc89d-719e-4d93-b518-29fa612b3b18.png" data-uk-lightbox><img src="https://img.cntofu.com/book/Interview-Notebook/pics//3fdfc89d-719e-4d93-b518-29fa612b3b18.png"></a>
</div>
<br>
<h3 id="2-size-操作">2. size 操作</h3>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<pre><code class="language-java">/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
</code></pre>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<pre><code class="language-java">
/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;

public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &lt; segments.length; ++j) {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                }
            }
            // 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries &gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
</code></pre>
<h3 id="3-jdk-18-的改动">3. JDK 1.8 的改动</h3>
<p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<h3 id="存储结构">存储结构</h3>
<p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre>
<p>内存维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<pre><code class="language-java">/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<pre><code class="language-java">final boolean accessOrder;
</code></pre>
<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }
</code></pre>
<h3 id="afternodeaccess">afterNodeAccess()</h3>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre>
<h3 id="afternodeinsertion">afterNodeInsertion()</h3>
<p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 ture 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<pre><code class="language-java">void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
</code></pre>
<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<pre><code class="language-java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
</code></pre>
<h3 id="lru-缓存">LRU 缓存</h3>
<p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<pre><code class="language-java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() &gt; MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();
    cache.put(1, "a");
    cache.put(2, "b");
    cache.put(3, "c");
    cache.get(1);
    cache.put(4, "d");
    System.out.println(cache.keySet());
}
</code></pre>
<pre><code class="language-html">[3, 1, 4]
</code></pre>
<h2 id="weekhashmap">WeekHashMap</h2>
<h3 id="存储结构-1">存储结构</h3>
<p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<pre><code class="language-java">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;
</code></pre>
<h3 id="concurrentcache">ConcurrentCache</h3>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<pre><code class="language-java">public final class ConcurrentCache&lt;K, V&gt; {

    private final int size;

    private final Map&lt;K, V&gt; eden;

    private final Map&lt;K, V&gt; longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap&lt;&gt;(size);
        this.longterm = new WeakHashMap&lt;&gt;(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() &gt;= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
</code></pre>
<h1 id="附录">附录</h1>
<p>Collection 绘图源码：</p>
<pre><code>@startuml

interface Collection
interface Set
interface List
interface Queue
interface SortSet

class HashSet
class LinkedHashSet
class TreeSet
class ArrayList
class Vector
class LinkedList
class PriorityQueue


Collection &lt;|-- Set
Collection &lt;|-- List
Collection &lt;|-- Queue
Set &lt;|-- SortSet

Set &lt;|.. HashSet
Set &lt;|.. LinkedHashSet
SortSet &lt;|.. TreeSet
List &lt;|.. ArrayList
List &lt;|.. Vector
List &lt;|.. LinkedList
Queue &lt;|.. LinkedList
Queue &lt;|.. PriorityQueue

@enduml
</code></pre>
<p>Map 绘图源码</p>
<pre><code>@startuml

interface Map
interface SortMap

class HashTable
class LinkedHashMap
class HashMap
class TreeMap

Map &lt;|.. HashTable
Map &lt;|.. LinkedHashMap
Map &lt;|.. HashMap
Map &lt;|-- SortMap
SortMap &lt;|.. TreeMap

@enduml
</code></pre>
<p>迭代器类图</p>
<pre><code>@startuml

interface Iterable
interface Collection
interface List
interface Set
interface Queue
interface Iterator
interface ListIterator

Iterable &lt;|-- Collection
Collection &lt;|.. List
Collection &lt;|.. Set
Collection &lt;|-- Queue
Iterator &lt;-- Iterable
Iterator &lt;|.. ListIterator
ListIterator &lt;-- List

@enduml
</code></pre>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li>
<li><a href="https://www.w3resource.com/java-tutorial/java-collections.php">Java Collection Framework</a></li>
<li><a href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm">Iterator 模式</a></li>
<li><a href="https://tech.meituan.com/java-hashmap.html">Java 8 系列之重新认识 HashMap</a></li>
<li><a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html">What is difference between HashMap and Hashtable in Java?</a></li>
<li><a href="http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/">Java 集合之 HashMap</a></li>
<li><a href="http://www.programering.com/a/MDO3QDNwATM.html">The principle of ConcurrentHashMap analysis</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
<li><a href="https://www.jianshu.com/p/75adf47958a7">HashMap 相关面试题及其解答</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html">Java 集合细节（二）：asList 的缺陷</a></li>
<li><a href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/">Java Collection Framework – The LinkedList Class</a></li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/206/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/206/index.html">HTTP/2 标准(RFC 7540)中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/116.html">abbshr</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 374个">374</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/117/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/117/index.html">成为专业程序员路上用到的各种优秀资料、神器及框架</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title=""></span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title=""></span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">26页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/184/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/184/index.html">对开发人员有用的定律、理论、原则和模式</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/103.html">nusr</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">80页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2325个">2325</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/104/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/104/index.html">Linux 内核揭密</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/63.html">ye11ow</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">83页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/194/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/postgresql_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/194/index.html">postgresql教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/110.html">hfpp2012</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="postgresql">postgresql</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">17页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 9个">9</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/109/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/blockchain_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/109/index.html">区块链(BlockChain)技术开发相关资料</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="blockchain">blockchain</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">6页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 3个">3</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/200/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/200/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/剑指%20offer%20题解.html" title="剑指 Offer 题解" data-book-page-rel-url="notes/剑指%20offer%20题解.html" data-book-page-id="13487">剑指 Offer 题解</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Leetcode%20题解.html" title="Leetcode 题解" data-book-page-rel-url="notes/Leetcode%20题解.html" data-book-page-id="13488">Leetcode 题解</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/算法.html" title="算法" data-book-page-rel-url="notes/算法.html" data-book-page-id="13489">算法</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/计算机操作系统.html" title="计算机操作系统" data-book-page-rel-url="notes/计算机操作系统.html" data-book-page-id="13490">计算机操作系统</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Linux.html" title="Linux" data-book-page-rel-url="notes/Linux.html" data-book-page-id="13491">Linux</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/计算机网络.html" title="计算机网络" data-book-page-rel-url="notes/计算机网络.html" data-book-page-id="13492">计算机网络</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/HTTP.html" title="HTTP" data-book-page-rel-url="notes/HTTP.html" data-book-page-id="13493">HTTP</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Socket.html" title="Socket" data-book-page-rel-url="notes/Socket.html" data-book-page-id="13494">Socket</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/设计模式.html" title="设计模式" data-book-page-rel-url="notes/设计模式.html" data-book-page-id="13495">设计模式</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/面向对象思想.html" title="面向对象思想" data-book-page-rel-url="notes/面向对象思想.html" data-book-page-id="13496">面向对象思想</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/数据库系统原理.html" title="数据库系统原理" data-book-page-rel-url="notes/数据库系统原理.html" data-book-page-id="13497">数据库系统原理</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/SQL.html" title="SQL" data-book-page-rel-url="notes/SQL.html" data-book-page-id="13498">SQL</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Leetcode-Database%20题解.html" title="Leetcode-Database 题解" data-book-page-rel-url="notes/Leetcode-Database%20题解.html" data-book-page-id="13499">Leetcode-Database 题解</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/MySQL.html" title="MySQL" data-book-page-rel-url="notes/MySQL.html" data-book-page-id="13500">MySQL</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Redis.html" title="Redis" data-book-page-rel-url="notes/Redis.html" data-book-page-id="13501">Redis</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Java%20基础.html" title="Java 基础" data-book-page-rel-url="notes/Java%20基础.html" data-book-page-id="13502">Java 基础</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Java%20虚拟机.html" title="Java 虚拟机" data-book-page-rel-url="notes/Java%20虚拟机.html" data-book-page-id="13503">Java 虚拟机</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Java%20并发.html" title="Java 并发" data-book-page-rel-url="notes/Java%20并发.html" data-book-page-id="13504">Java 并发</a>
</li>
<li>
<a class="pjax" href="../../../book/200/notes/Java%20容器.html" title="Java 容器" data-book-page-rel-url="notes/Java%20容器.html" data-book-page-id="13505">Java 容器</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Java I/O" disabled data-book-page-rel-url="notes/Java%20I/O.html" data-book-page-id="13506">Java I/O</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="一致性" disabled data-book-page-rel-url="notes/一致性.html" data-book-page-id="13507">一致性</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="分布式问题分析" disabled data-book-page-rel-url="notes/分布式问题分析.html" data-book-page-id="13508">分布式问题分析</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =200;var bookPageId =13505;var bookPageRelUrl ='notes/Java%20容器.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>