
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>近似匹配-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='近似匹配,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='近似匹配,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/multi-field-search.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">多字段搜索</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/partial-matching.html">
<span class="">部分匹配</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="proximity-matching">近似匹配</h2>
<div class="paragraph">
<p>使用 TF/IDF 的标准全文检索将文档或者文档中的字段作一大袋的词语处理。 <code>match</code> 查询可以告知我们这大袋子中是否包含查询的词条，但却无法告知词语之间的关系。</p>
</div>
<div class="paragraph">
<p>思考下面这几个句子的不同：</p>
</div>
<div class="ulist">
<ul>
<li> <p>Sue ate the alligator.</p> </li>
<li> <p>The alligator ate Sue.</p> </li>
<li> <p>Sue never goes anywhere without her alligator-skin purse.</p> </li>
</ul>
</div>
<div class="paragraph">
<p>用 <code>match</code> 搜索 <code>sue alligator</code> 上面的三个文档都会得到匹配，但它却不能确定这两个词是否只来自于一种语境，甚至都不能确定是否来自于同一个段落。</p>
</div>
<div class="paragraph">
<p>理解分词之间的关系是一个复杂的难题，我们也无法通过换一种查询方式去解决。但我们至少可以通过出现在彼此附近或者仅仅是彼此相邻的分词来判断一些似乎相关的分词。</p>
</div>
<div class="paragraph">
<p>每个文档可能都比我们上面这个例子要长： <code>Sue</code> 和 <code>alligator</code> 这两个词可能会分散在其他的段落文字中，我们可能会希望得到尽可能包含这两个词的文档，但我们也同样需要这些文档与分词有很高的相关度。</p>
</div>
<div class="paragraph">
<p>这就是短语匹配或者近似匹配的所属领域。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>在这一章节，我们还是使用在<a href="#match-test-data"><code>match</code> 查询</a>中使用过的文档作为例子。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="phrase-matching">短语匹配</h3>
<div class="paragraph">
<p>就像 <code>match</code> 查询对于标准全文检索是一种最常用的查询一样，当你想找到彼此邻近搜索词的查询方法时，就会想到 <code>match_phrase</code> 查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/my_type/_search
{
    "query": {
        "match_phrase": {
            "title": "quick brown fox"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似 <code>match</code> 查询， <code>match_phrase</code> 查询首先将查询字符串解析成一个词项列表，然后对这些词项进行搜索，但只保留那些包含 <em>全部</em> 搜索词项，且 <em>位置</em> 与搜索词项相同的文档。 比如对于 <code>quick fox</code> 的短语搜索可能不会匹配到任何文档，因为没有文档包含的 <code>quick</code> 词之后紧跟着 <code>fox</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p><code>match_phrase</code> 查询同样可写成一种类型为 <code>phrase</code> 的 <code>match</code> 查询:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"match": {
    "title": {
        "query": "quick brown fox",
        "type":  "phrase"
    }
}</code></pre>
</div>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_词项的位置">词项的位置</h4>
<div class="paragraph">
<p>当一个字符串被分词后，这个分析器不但会返回一个词项列表，而且还会返回各词项在原始字符串中的 <em>位置</em> 或者顺序关系：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_analyze?analyzer=standard
Quick brown fox</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回信息如下：</p>
</div>
<div class="listingblock pagebreak-before">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "tokens": [
      {
         "token": "quick",
         "start_offset": 0,
         "end_offset": 5,
         "type": "&lt;ALPHANUM&gt;",
         "position": 1 <b class="conum">(1)</b>
      },
      {
         "token": "brown",
         "start_offset": 6,
         "end_offset": 11,
         "type": "&lt;ALPHANUM&gt;",
         "position": 2 <b class="conum">(1)</b>
      },
      {
         "token": "fox",
         "start_offset": 12,
         "end_offset": 15,
         "type": "&lt;ALPHANUM&gt;",
         "position": 3 <b class="conum">(1)</b>
      }
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>position</code> 代表各词项在原始字符串中的位置。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>位置信息可以被存储在倒排索引中，因此 <code>match_phrase</code> 查询这类对词语位置敏感的查询， 就可以利用位置信息去匹配包含所有查询词项，且各词项顺序也与我们搜索指定一致的文档，中间不夹杂其他词项。</p>
</div>
</div>
<div class="sect3">
<h4 id="_什么是短语">什么是短语</h4>
<div class="paragraph">
<p>一个被认定为和短语 <code>quick brown fox</code> 匹配的文档，必须满足以下这些要求：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>quick</code> 、 <code>brown</code> 和 <code>fox</code> 需要全部出现在域中。</p> </li>
<li> <p><code>brown</code> 的位置应该比 <code>quick</code> 的位置大 <code>1</code> 。</p> </li>
<li> <p><code>fox</code> 的位置应该比 <code>quick</code> 的位置大 <code>2</code> 。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>如果以上任何一个选项不成立，则该文档不能认定为匹配。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>本质上来讲，<code>match_phrase</code> 查询是利用一种低级别的 <code>span</code> 查询族（query family）去做词语位置敏感的匹配。 Span 查询是一种词项级别的查询，所以它们没有分词阶段；它们只对指定的词项进行精确搜索。</p>
</div>
<div class="paragraph">
<p>值得庆幸的是，<code>match_phrase</code> 查询已经足够优秀，大多数人是不会直接使用 <code>span</code> 查询。 然而，在一些专业领域，例如专利检索，还是会采用这种低级别查询去执行非常具体而又精心构造的位置搜索。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="slop">混合起来</h3>
<div class="paragraph">
<p>精确短语匹配 或许是过于严格了。也许我们想要包含 <code>quick brown fox'' 的文档也能够匹配 </code>quick fox,'' ， 尽管情形不完全相同。</p>
</div>
<div class="paragraph">
<p>我们能够通过使用 <code>slop</code> 参数将灵活度引入短语匹配中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/my_type/_search
{
    "query": {
        "match_phrase": {
            "title": {
            	"query": "quick fox",
            	"slop":  1
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>slop</code> 参数告诉 <code>match_phrase</code> 查询词条相隔多远时仍然能将文档视为匹配 。 相隔多远的意思是为了让查询和文档匹配你需要移动词条多少次？</p>
</div>
<div class="paragraph">
<p>我们以一个简单的例子开始吧。 为了让查询 <code>quick fox</code> 能匹配一个包含 <code>quick brown fox</code> 的文档， 我们需要 <code>slop</code> 的值为 <code>1</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>            Pos 1         Pos 2         Pos 3
-----------------------------------------------
Doc:        quick         brown         fox
-----------------------------------------------
Query:      quick         fox
Slop 1:     quick                 ↳     fox</pre>
</div>
</div>
<div class="paragraph">
<p>尽管在使用了 <code>slop</code> 短语匹配中所有的单词都需要出现， 但是这些单词也不必为了匹配而按相同的序列排列。 有了足够大的 <code>slop</code> 值， 单词就能按照任意顺序排列了。</p>
</div>
<div class="paragraph">
<p>为了使查询 <code>fox quick</code> 匹配我们的文档， 我们需要 <code>slop</code> 的值为 <code>3</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>            Pos 1         Pos 2         Pos 3
-----------------------------------------------
Doc:        quick         brown         fox
-----------------------------------------------
Query:      fox           quick
Slop 1:     fox|quick  ↵  <b class="conum">(1)</b>
Slop 2:     quick      ↳  fox
Slop 3:     quick                 ↳     fox</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>注意 <code>fox</code> 和 <code>quick</code> 在这步中占据同样的位置。 因此将 <code>fox quick</code> 转换顺序成 <code>quick fox</code> 需要两步， 或者值为 <code>2</code> 的 <code>slop</code> 。</p> </li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_multivalue_fields_2">多值字段</h3>
<div class="paragraph">
<p>对多值字段使用短语匹配时会发生奇怪的事。 想象一下你索引这个文档:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/groups/1
{
    "names": [ "John Abraham", "Lincoln Smith"]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后运行一个对 <code>Abraham Lincoln</code> 的短语查询:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/groups/_search
{
    "query": {
        "match_phrase": {
            "names": "Abraham Lincoln"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>令人惊讶的是， 即使 <code>Abraham</code> 和 <code>Lincoln</code> 在 <code>names</code> 数组里属于两个不同的人名， 我们的文档也匹配了查询。 这一切的原因在Elasticsearch数组的索引方式。</p>
</div>
<div class="paragraph">
<p>在分析 <code>John Abraham</code> 的时候， 产生了如下信息：</p>
</div>
<div class="ulist">
<ul>
<li> <p>Position 1: <code>john</code></p> </li>
<li> <p>Position 2: <code>abraham</code></p> </li>
</ul>
</div>
<div class="paragraph">
<p>然后在分析 <code>Lincoln Smith</code> 的时候， 产生了：</p>
</div>
<div class="ulist">
<ul>
<li> <p>Position 3: <code>lincoln</code></p> </li>
<li> <p>Position 4: <code>smith</code></p> </li>
</ul>
</div>
<div class="paragraph">
<p>换句话说， Elasticsearch对以上数组分析生成了与分析单个字符串 <code>John Abraham Lincoln Smith</code> 一样几乎完全相同的语汇单元。 我们的查询示例寻找相邻的 <code>lincoln</code> 和 <code>abraham</code> ， 而且这两个词条确实存在，并且它们俩正好相邻， 所以这个查询匹配了。</p>
</div>
<div class="paragraph">
<p>幸运的是， 在这样的情况下有一种叫做 <code>position_increment_gap</code> 的简单的解决方案， 它在字段映射中配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /my_index/groups/ <b class="conum">(1)</b>

PUT /my_index/_mapping/groups <b class="conum">(2)</b>
{
    "properties": {
        "names": {
            "type":                "string",
            "position_increment_gap": 100
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>首先删除映射 <code>groups</code> 以及这个类型内的所有文档。</p> </li>
<li> <p>然后创建一个有正确值的新的映射 <code>groups</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p><code>position_increment_gap</code> 设置告诉 Elasticsearch 应该为数组中每个新元素增加当前词条 <code>position</code> 的指定值。 所以现在当我们再索引 names 数组时，会产生如下的结果：</p>
</div>
<div class="ulist">
<ul>
<li> <p>Position 1: <code>john</code></p> </li>
<li> <p>Position 2: <code>abraham</code></p> </li>
<li> <p>Position 103: <code>lincoln</code></p> </li>
<li> <p>Position 104: <code>smith</code></p> </li>
</ul>
</div>
<div class="paragraph">
<p>现在我们的短语查询可能无法匹配该文档因为 <code>abraham</code> 和 <code>lincoln</code> 之间的距离为 100 。 为了匹配这个文档你必须添加值为 100 的 <code>slop</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_closer_is_better">越近越好</h3>
<div class="paragraph">
<p>鉴于一个短语查询仅仅排除了不包含确切查询短语的文档， 而 <em>邻近查询</em> — 一个 <code>slop</code> 大于 <code>0</code>— 的短语查询将查询词条的邻近度考虑到最终相关度 <code>_score</code> 中。 通过设置一个像 <code>50</code> 或者 <code>100</code> 这样的高 <code>slop</code> 值, 你能够排除单词距离太远的文档， 但是也给予了那些单词临近的的文档更高的分数。</p>
</div>
<div class="paragraph">
<p>下列对 <code>quick dog</code> 的邻近查询匹配了同时包含 <code>quick</code> 和 <code>dog</code> 的文档， 但是也给了与 quick 和 dog 更加临近的文档更高的分数 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /my_index/my_type/_search
{
   "query": {
      "match_phrase": {
         "title": {
            "query": "quick dog",
            "slop":  50 <b class="conum">(1)</b>
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>注意高 <code>slop</code> 值。</p> </li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "hits": [
     {
        "_id":      "3",
        "_score":   0.75, <b class="conum">(1)</b>
        "_source": {
           "title": "The quick brown fox jumps over the quick dog"
        }
     },
     {
        "_id":      "2",
        "_score":   0.28347334, <b class="conum">(2)</b>
        "_source": {
           "title": "The quick brown fox jumps over the lazy dog"
        }
     }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>分数较高因为 <code>quick</code> 和 <code>dog</code> 很接近</p> </li>
<li> <p>分数较低因为 <code>quick</code> 和 <code>dog</code> 分开较远</p> </li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="proximity-relevance">使用邻近度提高相关度</h3>
<div class="paragraph">
<p>虽然邻近查询很有用， 但是所有词条都出现在文档的要求过于严格了。 我们讨论 <a href="#full-text-search">全文搜索</a> 一章的 <a href="#match-precision">控制精度</a> 也是同样的问题： 如果七个词条中有六个匹配， 那么这个文档对用户而言就已经足够相关了， 但是 <code>match_phrase</code> 查询可能会将它排除在外。</p>
</div>
<div class="paragraph">
<p>相比将使用邻近匹配作为绝对要求， 我们可以将它作为 <em>信号</em>— 使用， 作为许多潜在查询中的一个， 会对每个文档的最终分值做出贡献 (参考 <a href="#most-fields">多数字段</a>)。</p>
</div>
<div class="paragraph">
<p>实际上我们想将多个查询的分数累计起来意味着我们应该用 <code>bool</code> 查询将它们合并。</p>
</div>
<div class="paragraph">
<p>我们可以将一个简单的 <code>match</code> 查询作为一个 <code>must</code> 子句。 这个查询将决定哪些文档需要被包含到结果集中。 我们可以用 <code>minimum_should_match</code> 参数去除长尾。 然后我们可以以 <code>should</code> 子句的形式添加更多特定查询。 每一个匹配成功的都会增加匹配文档的相关度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/my_type/_search
{
  "query": {
    "bool": {
      "must": {
        "match": { <b class="conum">(1)</b>
          "title": {
            "query":                "quick brown fox",
            "minimum_should_match": "30%"
          }
        }
      },
      "should": {
        "match_phrase": { <b class="conum">(2)</b>
          "title": {
            "query": "quick brown fox",
            "slop":  50
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>must</code> 子句从结果集中包含或者排除文档。</p> </li>
<li> <p><code>should</code> 子句增加了匹配到文档的相关度评分。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>我们当然可以在 <code>should</code> 子句里面添加其它的查询， 其中每一个查询只针对某一特定方面的相关度。</p>
</div>
</div>
<div class="sect2 pagebreak-before">
<h3 id="_Improving_Performance">性能优化</h3>
<div class="paragraph">
<p>短语查询和邻近查询都比简单的 <code>query</code> 查询代价更高。 一个 <code>match</code> 查询仅仅是看词条是否存在于倒排索引中，而一个 <code>match_phrase</code> 查询是必须计算并比较多个可能重复词项的位置。</p>
</div>
<div class="paragraph">
<p><a href="http://people.apache.org/~mikemccand/lucenebench/">Lucene nightly benchmarks</a> 表明一个简单的 <code>term</code> 查询比一个短语查询大约快 10 倍，比邻近查询(有 <code>slop</code> 的短语 查询)大约快 20 倍。当然，这个代价指的是在搜索时而不是索引时。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>通常，短语查询的额外成本并不像这些数字所暗示的那么吓人。事实上，性能上的差距只是证明一个简单的 <code>term</code> 查询有多快。标准全文数据的短语查询通常在几毫秒内完成，因此实际上都是完全可用，即使是在一个繁忙的集群上。</p>
</div>
<div class="paragraph">
<p>在某些特定病理案例下，短语查询可能成本太高了，但比较少见。一个典型例子就是DNA序列，在序列里很多同样的词项在很多位置重复出现。在这里使用高 <code>slop</code> 值会到导致位置计算大量增加。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>那么我们应该如何限制短语查询和邻近近查询的性能消耗呢？一种有用的方法是减少需要通过短语查询检查的文档总数。</p>
</div>
<div class="sect3">
<h4 id="rescore-api">结果集重新评分</h4>
<div class="paragraph">
<p>在<a href="#proximity-relevance">先前的章节中</a> ，我们讨论了而使用邻近查询来调整相关度，而不是使用它将文档从结果列表中添加或者排除。一个查询可能会匹配成千上万的结果，但我们的用户很可能只对结果的前几页感兴趣。</p>
</div>
<div class="paragraph">
<p>一个简单的 <code>match</code> 查询已经通过排序把包含所有含有搜索词条的文档放在结果列表的前面了。事实上，我们只想对这些 <em>顶部文档</em> 重新排序，来给同时匹配了短语查询的文档一个额外的相关度升级。</p>
</div>
<div class="paragraph">
<p><code>search</code> API 通过 <em>重新评分</em> 明确支持该功能。重新评分阶段支持一个代价更高的评分算法—​比如 <code>phrase</code> 查询—​只是为了从每个分片中获得前 <code>K</code> 个结果。 然后会根据它们的最新评分 重新排序。</p>
</div>
<div class="paragraph">
<p>该请求如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/my_type/_search
{
    "query": {
        "match": {  <b class="conum">(1)</b>
            "title": {
                "query":                "quick brown fox",
                "minimum_should_match": "30%"
            }
        }
    },
    "rescore": {
        "window_size": 50, <b class="conum">(2)</b>
        "query": {         <b class="conum">(3)</b>
            "rescore_query": {
                "match_phrase": {
                    "title": {
                        "query": "quick brown fox",
                        "slop":  50
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>match</code> 查询决定哪些文档将包含在最终结果集中，并通过 TF/IDF 排序。</p> </li>
<li> <p><code>window_size</code> 是每一分片进行重新评分的顶部文档数量。</p> </li>
<li> <p>目前唯一支持的重新打分算法就是另一个查询，但是以后会有计划增加更多的算法。</p> </li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="shingles">寻找相关词</h3>
<div class="paragraph">
<p>短语查询和邻近查询都很好用，但仍有一个缺点。它们过于严格了：为了匹配短语查询，所有词项都必须存在，即使使用了 <code>slop</code> 。 </p>
</div>
<div class="paragraph">
<p>用 <code>slop</code> 得到的单词顺序的灵活性也需要付出代价，因为失去了单词对之间的联系。即使可以识别 <code>sue</code> 、 <code>alligator</code> 和 <code>ate</code> 相邻出现的文档，但无法分辨是 <em>Sue ate</em> 还是 <em>alligator ate</em> 。</p>
</div>
<div class="paragraph">
<p>当单词相互结合使用的时候，表达的含义比单独使用更丰富。两个子句 <em>I’m not happy I’m working</em> 和 <em>I’m happy I’m not working</em> 包含相同 的单词，也拥有相同的邻近度，但含义截然不同。</p>
</div>
<div class="paragraph">
<p>如果索引单词对而不是索引独立的单词，就能对这些单词的上下文尽可能多的保留。</p>
</div>
<div class="paragraph">
<p>对句子 <code>Sue ate the alligator</code> ，不仅要将每一个单词（或者 <em>unigram</em> ）作为词项索引</p>
</div>
<div class="literalblock">
<div class="content">
<pre>["sue", "ate", "the", "alligator"]</pre>
</div>
</div>
<div class="paragraph">
<p>也要将每个单词 <em>以及它的邻近词</em> 作为单个词项索引：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>["sue ate", "ate the", "the alligator"]</pre>
</div>
</div>
<div class="paragraph">
<p>这些单词对（或者 <em>bigrams</em> ）被称为 <em>shingles</em> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>Shingles 不限于单词对；你也可以索引三个单词（ <em>trigrams</em> ）：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>["sue ate the", "ate the alligator"]</pre>
</div>
</div>
<div class="paragraph">
<p>Trigrams 提供了更高的精度，但是也大大增加了索引中唯一词项的数量。在大多数情况下，Bigrams 就够了。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>当然，只有当用户输入的查询内容和在原始文档中顺序相同时，shingles 才是有用的；对 <code>sue alligator</code> 的查询可能会匹配到单个单词，但是不会匹配任何 shingles 。</p>
</div>
<div class="paragraph">
<p>幸运的是，用户倾向于使用和搜索数据相似的构造来表达搜索意图。但这一点很重要：只是索引 bigrams 是不够的；我们仍然需要 unigrams ，但可以将匹配 bigrams 作为增加相关度评分的信号。</p>
</div>
<div class="sect3">
<h4 id="_生成_shingles">生成 Shingles</h4>
<div class="paragraph">
<p>Shingles 需要在索引时作为分析过程的一部分被创建。我们可以将 unigrams 和 bigrams 都索引到单个字段中， 但将它们分开保存在能被独立查询的字段会更清晰。unigrams 字段将构成我们搜索的基础部分，而 bigrams 字段用来提高相关度。</p>
</div>
<div class="paragraph">
<p>首先，我们需要在创建分析器时使用 <code>shingle</code> 语汇单元过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /my_index

PUT /my_index
{
    "settings": {
        "number_of_shards": 1,  <b class="conum">(1)</b>
        "analysis": {
            "filter": {
                "my_shingle_filter": {
                    "type":             "shingle",
                    "min_shingle_size": 2, <b class="conum">(2)</b>
                    "max_shingle_size": 2, <b class="conum">(2)</b>
                    "output_unigrams":  false   <b class="conum">(3)</b>
                }
            },
            "analyzer": {
                "my_shingle_analyzer": {
                    "type":             "custom",
                    "tokenizer":        "standard",
                    "filter": [
                        "lowercase",
                        "my_shingle_filter" <b class="conum">(4)</b>
                    ]
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>参考 <a href="#relevance-is-broken">被破坏的相关度！</a> 。</p> </li>
<li> <p>默认最小/最大的 shingle 大小是 <code>2</code> ，所以实际上不需要设置。</p> </li>
<li> <p><code>shingle</code> 语汇单元过滤器默认输出 unigrams ，但是我们想让 unigrams 和 bigrams 分开。</p> </li>
<li> <p><code>my_shingle_analyzer</code> 使用我们常规的 <code>my_shingles_filter</code> 语汇单元过滤器。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>首先，用 <code>analyze</code> API 测试下分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/_analyze?analyzer=my_shingle_analyzer
Sue ate the alligator</code></pre>
</div>
</div>
<div class="paragraph">
<p>果然， 我们得到了 3 个词项：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>sue ate</code></p> </li>
<li> <p><code>ate the</code></p> </li>
<li> <p><code>the alligator</code></p> </li>
</ul>
</div>
<div class="paragraph">
<p>现在我们可以继续创建一个使用新的分析器的字段。</p>
</div>
</div>
<div class="sect3">
<h4 id="_多字段">多字段</h4>
<div class="paragraph">
<p>我们曾谈到将 unigrams 和 bigrams 分开索引更清晰，所以 <code>title</code> 字段将创建成一个多字段（参考 <a href="#multi-fields">字符串排序与多字段</a> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/_mapping/my_type
{
    "my_type": {
        "properties": {
            "title": {
                "type": "string",
                "fields": {
                    "shingles": {
                        "type":     "string",
                        "analyzer": "my_shingle_analyzer"
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过这个映射， JSON 文档中的 <code>title</code> 字段将会被以 unigrams (<code>title</code>)和 bigrams (<code>title.shingles</code>)被索引，这意味着可以独立地查询这些字段。</p>
</div>
<div class="paragraph">
<p>最后，我们可以索引以下示例文档:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /my_index/my_type/_bulk
{ "index": { "_id": 1 }}
{ "title": "Sue ate the alligator" }
{ "index": { "_id": 2 }}
{ "title": "The alligator ate Sue" }
{ "index": { "_id": 3 }}
{ "title": "Sue never goes anywhere without her alligator skin purse" }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_搜索_shingles">搜索 Shingles</h4>
<div class="paragraph">
<p>为了理解添加 <code>shingles</code> 字段的好处，让我们首先来看 <code>The hungry alligator ate Sue</code> 进行简单 <code>match</code> 查询的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/my_type/_search
{
   "query": {
        "match": {
           "title": "the hungry alligator ate sue"
        }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个查询返回了所有的三个文档， 但是注意文档 1 和 2 有相同的相关度评分因为他们包含了相同的单词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "hits": [
     {
        "_id": "1",
        "_score": 0.44273707, <b class="conum">(1)</b>
        "_source": {
           "title": "Sue ate the alligator"
        }
     },
     {
        "_id": "2",
        "_score": 0.44273707, <b class="conum">(1)</b>
        "_source": {
           "title": "The alligator ate Sue"
        }
     },
     {
        "_id": "3", <b class="conum">(2)</b>
        "_score": 0.046571054,
        "_source": {
           "title": "Sue never goes anywhere without her alligator skin purse"
        }
     }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>两个文档都包含 <code>the</code> 、 <code>alligator</code> 和 <code>ate</code> ，所以获得相同的评分。</p> </li>
<li> <p>我们可以通过设置 <code>minimum_should_match</code> 参数排除文档 3 ，参考 <a href="#match-precision">控制精度</a> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>现在在查询里添加 <code>shingles</code> 字段。不要忘了在 <code>shingles</code> 字段上的匹配是充当一 种信号—​为了提高相关度评分—​所以我们仍然需要将基本 <code>title</code> 字段包含到查询中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/my_type/_search
{
   "query": {
      "bool": {
         "must": {
            "match": {
               "title": "the hungry alligator ate sue"
            }
         },
         "should": {
            "match": {
               "title.shingles": "the hungry alligator ate sue"
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>仍然匹配到了所有的 3 个文档， 但是文档 2 现在排到了第一名因为它匹配了 shingled 词项 <code>ate sue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "hits": [
     {
        "_id": "2",
        "_score": 0.4883322,
        "_source": {
           "title": "The alligator ate Sue"
        }
     },
     {
        "_id": "1",
        "_score": 0.13422975,
        "_source": {
           "title": "Sue ate the alligator"
        }
     },
     {
        "_id": "3",
        "_score": 0.014119488,
        "_source": {
           "title": "Sue never goes anywhere without her alligator skin purse"
        }
     }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使查询包含的单词 <code>hungry</code> 没有在任何文档中出现，我们仍然使用单词邻近度返回了最相关的文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="_performance性能">Performance性能</h4>
<div class="paragraph">
<p>shingles 不仅比短语查询更灵活，而且性能也更好。 shingles 查询跟一个简单的 <code>match</code> 查询一样高效，而不用每次搜索花费短语查询的代价。只是在索引期间因为更多词项需要被索引会付出一些小的代价， 这也意味着有 shingles 的字段会占用更多的磁盘空间。 然而，大多数应用写入一次而读取多次，所以在索引期间优化我们的查询速度是有意义的。</p>
</div>
<div class="paragraph">
<p>这是一个在 Elasticsearch 里会经常碰到的话题：不需要任何前期进行过多的设置，就能够在搜索的时候有很好的效果。 一旦更清晰的理解了自己的需求，就能在索引时通过正确的为你的数据建模获得更好结果和性能。 </p>
</div>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/56/index.html">
<img class="uk-book-cover" src="../../static/icons/48/machine-learning_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/56/index.html">神经网络与深度学习</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/32.html">tigerneil</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="machine-learning">machine-learning</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">9页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 239个">239</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/28/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/28/index.html">笨办法学 Linux</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 326个">326</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/5/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/5/index.html">超级棒的"派神"书</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/5.html">zhaoolee</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/46/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/46/index.html">软件开发平台及语言笔记大全(超详细)</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/22.html">jasonblog</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="cplusplus">cplusplus</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1,399页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月30日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 16个">16</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/124/index.html">
<img class="uk-book-cover" src="../../static/icons/48/nginx_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/124/index.html">Nginx学习笔记</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/66.html">tyloafer</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="nginx">nginx</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">11页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/175/index.html">
<img class="uk-book-cover" src="../../static/icons/48/nodejs_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/175/index.html">Node.js面试题，侧重后端应用与对Node核心的理解</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/97.html">jimuyouyou</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="nodejs">nodejs</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">8页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1483个">1483</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9269;var bookPageRelUrl ='proximity-matching.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>