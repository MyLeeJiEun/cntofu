
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>将单词还原为词根-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='将单词还原为词根,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='将单词还原为词根,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/token-normalization.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">归一化词元</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/stopwords.html">
<span class="">停用词: 性能与精度</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="stemming">将单词还原为词根</h2>
<div class="paragraph">
<p>大多数语言的单词都可以 <em>词形变化</em> ，意味着下列单词可以改变它们的形态用来表达不同的意思：</p>
</div>
<div class="ulist">
<ul>
<li> <p><em>单复数变化</em> ： fox 、foxes</p> </li>
<li> <p><em>时态变化</em> ： pay 、 paid 、 paying</p> </li>
<li> <p><em>性别变化</em> ： waiter 、 waitress</p> </li>
<li> <p><em>动词人称变化</em> ： hear 、 hears</p> </li>
<li> <p><em>代词变化</em> ： I 、 me 、 my</p> </li>
<li> <p><em>不规则变化</em> ： ate 、 eaten</p> </li>
<li> <p><em>情景变化</em> ： so be it 、 were it so</p> </li>
</ul>
</div>
<div class="paragraph">
<p>虽然词形变化有助于表达，但它干扰了检索，一个单一的词根 <em>词义</em> （或意义）可能被很多不同的字母序列表达。 英语是一种弱词形变化语言（你可以忽略词形变化并且能得到合理的搜索结果），但是一些其他语言是高度词形变化的并且需要额外的工作来保证高质量的搜索结果。</p>
</div>
<div class="paragraph">
<p><em>词干提取</em> 试图移除单词的变化形式之间的差别，从而达到将每个词都提取为它的词根形式。 例如 <code>foxes</code> 可能被提取为词根 <code>fox</code> ，移除单数和复数之间的区别跟我们移除大小写之间的区别的方式是一样的。</p>
</div>
<div class="paragraph">
<p>单词的词根形式甚至有可能不是一个真的单词，单词 <code>jumping</code> 和 <code>jumpiness</code> 或许都会被提取词干为 <code>jumpi</code> 。 这并没有什么问题—​只要在索引时和搜索时产生相同的词项，搜索会正常的工作。</p>
</div>
<div class="paragraph">
<p>如果词干提取很容易的话，那只要一个插件就够了。不幸的是，词干提取是一种遭受两种困扰的模糊的技术：词干弱提取和词干过度提取。</p>
</div>
<div class="paragraph">
<p><em>词干弱提取</em> 就是无法将同样意思的单词缩减为同一个词根。例如， <code>jumped</code> 和 <code>jumps</code> 可能被提取为 <code>jump</code> ， 但是 <code>jumping</code> 可能被提取为 <code>jumpi</code> 。弱词干提取会导致搜索时无法返回相关文档。</p>
</div>
<div class="paragraph">
<p><em>词干过度提取</em> 就是无法将不同含义的单词分开。例如， <code>general</code> 和 <code>generate</code> 可能都被提取为 <code>gener</code> 。 词干过度提取会降低精准度：不相干的文档会在不需要他们返回的时候返回。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
词形还原
</div>
<div class="paragraph">
<p>原词是一组相关词的规范形式，或词典形式 — <code>paying</code> 、 <code>paid</code> 和 <code>pays</code> 的原词是 <code>pay</code> 。 通常原词很像与其相关的词，但有时也不像 — <code>is</code> 、 <code>was</code> 、 <code>am</code> 和 <code>being</code> 的原词是 <code>be</code> 。</p>
</div>
<div class="paragraph">
<p>词形还原，很像词干提取，试图归类相关单词，但是它比词干提取先进一步的是它企图按单词的 <em>词义</em> ，或意义归类。 同样的单词可能表现出两种意思—例如， <em>wake</em> 可以表现为 <em>to wake up</em> 或 <em>a funeral</em> 。然而词形还原试图区分两个词的词义，词干提取却会将其混为一谈。</p>
</div>
<div class="paragraph">
<p>词形还原是一种更复杂和高资源消耗的过程，它需要理解单词出现的上下文来决定词的意思。实践中，词干提取似乎比词形还原更高效，且代价更低。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>首先我们会讨论下两个 Elasticsearch 使用的经典词干提取器 — <a href="#algorithmic-stemmers">词干提取算法</a> 和 <a href="#dictionary-stemmers">字典词干提取器</a> — 并且在 <a href="#choosing-a-stemmer">选择一个词干提取器</a> 讨论了怎么根据你的需要选择合适的词干提取器。 最后将在 <a href="#controlling-stemming">控制词干提取</a> 和 <a href="#stemming-in-situ">原形词干提取</a> 中讨论如何裁剪词干提取。</p>
</div>
<div class="sect2">
<h3 id="algorithmic-stemmers">词干提取算法</h3>
<div class="paragraph">
<p>Elasticsearch 中的大部分 stemmers （词干提取器）是基于算法的，它们提供了一系列规则用于将一个词提取为它的词根形式，例如剥离复数词末尾的 <code>s</code> 或 <code>es</code> 。提取单词词干时并不需要知道该词的任何信息。</p>
</div>
<div class="paragraph">
<p>这些基于算法的 stemmers 优点是：可以作为插件使用，速度快，占用内存少，有规律的单词处理效果好。缺点是：没规律的单词例如 <code>be</code> 、 <code>are</code> 、和 <code>am</code> ，或 <code>mice</code> 和 <code>mouse</code> 效果不好。</p>
</div>
<div class="paragraph">
<p>最早的一个基于算法的英文词干提取器是 Porter stemmer ，该英文词干提取器现在依然推荐使用。 Martin Porter 后来为了开发词干提取算法创建了 <a href="http://snowball.tartarus.org/">Snowball language</a> 网站， 很多 Elasticsearch 中使用的词干提取器就是用 Snowball 语言写的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-kstem-tokenfilter.html"><code>kstem</code> token filter</a> 是一款合并了词干提取算法和内置词典的英语分词过滤器。为了避免模糊词不正确提取，这个词典包含一系列根词单词和特例单词。 <code>kstem</code> 分词过滤器相较于 Porter 词干提取器而言不那么激进。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_使用基于算法的词干提取器">使用基于算法的词干提取器</h4>
<div class="paragraph">
<p>你可以使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-porterstem-tokenfilter.html"><code>porter_stem</code></a> 词干提取器或直接使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-kstem-tokenfilter.html"><code>kstem</code></a> 分词过滤器，或使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-snowball-tokenfilter.html"><code>snowball</code></a> 分词过滤器创建一个具体语言的 Snowball 词干提取器。所有基于算法的词干提取器都暴露了用来接受 <code>语言</code> 参数的统一接口： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stemmer-tokenfilter.html"><code>stemmer</code> token filter</a> 。</p>
</div>
<div class="paragraph">
<p>例如，假设你发现 <code>英语</code> 分析器使用的默认词干提取器太激进并且你想使它不那么激进。首先应在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-lang-analyzer.html">language analyzers</a> 查看 <code>英语</code> 分析器配置文件，配置文件展示如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "settings": {
    "analysis": {
      "filter": {
        "english_stop": {
          "type":       "stop",
          "stopwords":  "_english_"
        },
        "english_keywords": {
          "type":       "keyword_marker", <b class="conum">(1)</b>
          "keywords":   []
        },
        "english_stemmer": {
          "type":       "stemmer",
          "language":   "english" <b class="conum">(2)</b>
        },
        "english_possessive_stemmer": {
          "type":       "stemmer",
          "language":   "possessive_english" <b class="conum">(2)</b>
        }
      },
      "analyzer": {
        "english": {
          "tokenizer":  "standard",
          "filter": [
            "english_possessive_stemmer",
            "lowercase",
            "english_stop",
            "english_keywords",
            "english_stemmer"
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>keyword_marker</code> 分词过滤器列出那些不用被词干提取的单词。这个过滤器默认情况下是一个空的列表。</p> </li>
<li> <p><code>english</code> 分析器使用了两个词干提取器： <code>possessive_english</code> 词干提取器和 <code>english</code> 词干提取器。 所有格词干提取器会在任何词传递到 <code>english_stop</code> 、 <code>english_keywords</code> 和 <code>english_stemmer</code> 之前去除 <code>'s</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>重新审视下现在的配置，添加上以下修改，我们可以把这份配置当作新分析器的基本配置：</p>
</div>
<div class="ulist">
<ul>
<li> <p>修改 <code>english_stemmer</code> ，将 <code>english</code> （https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-porterstem-tokenfilter.html[<code>porter_stem</code>] 分词过滤器的映射）替换为 <code>light_english</code> （非激进的 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-kstem-tokenfilter.html"><code>kstem</code></a> 分词过滤器的映射）。</p> </li>
<li> <p>添加 <a href="#asciifolding-token-filter"><code>asciifolding</code></a> 分词过滤器用以移除外语的附加符号。</p> </li>
<li> <p>移除 <code>keyword_marker</code> 分词过滤器，因为我们不需要它。（我们会在 <a href="#controlling-stemming">控制词干提取</a> 中详细讨论它）</p> </li>
</ul>
</div>
<div class="paragraph">
<p>新定义的分析器会像下面这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
  "settings": {
    "analysis": {
      "filter": {
        "english_stop": {
          "type":       "stop",
          "stopwords":  "_english_"
        },
        "light_english_stemmer": {
          "type":       "stemmer",
          "language":   "light_english" <b class="conum">(1)</b>
        },
        "english_possessive_stemmer": {
          "type":       "stemmer",
          "language":   "possessive_english"
        }
      },
      "analyzer": {
        "english": {
          "tokenizer":  "standard",
          "filter": [
            "english_possessive_stemmer",
            "lowercase",
            "english_stop",
            "light_english_stemmer", <b class="conum">(1)</b>
            "asciifolding" <b class="conum">(2)</b>
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>将 <code>english</code> 词干提取器替换为非激进的 <code>light_english</code> 词干提取器</p> </li>
<li> <p>添加 <code>asciifolding</code> 分词过滤器</p> </li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dictionary-stemmers">字典词干提取器</h3>
<div class="paragraph">
<p><em>字典词干提取器</em> 在工作机制上与 <a href="#algorithmic-stemmers">算法化词干提取器</a> 完全不同。 不同于应用一系列标准规则到每个词上，字典词干提取器只是简单地在字典里查找词。理论上可以给出比算法化词干提取器更好的结果。一个字典词干提取器应当可以：</p>
</div>
<div class="ulist">
<ul>
<li> <p>返回不规则形式如 <code>feet</code> 和 <code>mice</code> 的正确词干</p> </li>
<li> <p>区分出词形相似但词义不同的情形，比如 <code>organ</code> and <code>organization</code></p> </li>
</ul>
</div>
<div class="paragraph">
<p>实践中一个好的算法化词干提取器一般优于一个字典词干提取器。应该有以下两大原因：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
字典质量
</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>一个字典词干提取器再好也就跟它的字典一样。 据牛津英语字典网站估计，英语包含大约75万个单词（包含变音变形词）。电脑上的大部分英语字典只包含其中的 10% 。</p>
</div>
<div class="paragraph">
<p>词的含义随时光变迁。<code>mobility</code> 提取词干 <code>mobil</code> 先前可能讲得通，但现在合并进了手机可移动性的含义。字典需要保持最新，这是一项很耗时的任务。通常等到一个字典变得好用后，其中的部分内容已经过时。</p>
</div>
<div class="paragraph">
<p>字典词干提取器对于字典中不存在的词无能为力。而一个基于算法的词干提取器，则会继续应用之前的相同规则，结果可能正确或错误。</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">
大小与性能
</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>字典词干提取器需要加载所有词汇、 所有前缀，以及所有后缀到内存中。这会显著地消耗内存。找到一个词的正确词干，一般比算法化词干提取器的相同过程更加复杂。</p>
</div>
<div class="paragraph">
<p>依赖于不同的字典质量，去除前后缀的过程可能会更加高效或低效。低效的情形可能会明显地拖慢整个词干提取过程。</p>
</div>
<div class="paragraph">
<p>另一方面，算法化词干提取器通常更简单、轻量和快速。</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content"> 如果你所使用的语言有比较好的算法化词干提取器，这通常是比一个基于字典的词干提取器更好的选择。对于算法化词干提取器效果比较差（或者压根没有）的语言，可以使用拼写检查（Hunspell）字典词干提取器，下一个章节会讨论。 </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="hunspell">Hunspell 词干提取器</h3>
<div class="paragraph">
<p>Elasticsearch 提供了基于词典提取词干的 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-hunspell-tokenfilter.html"><code>hunspell</code> 语汇单元过滤器（token filter）</a>. Hunspell <a href="http://hunspell.github.io/"><em>hunspell.github.io</em></a> 是一个 Open Office、LibreOffice、Chrome、Firefox、Thunderbird 等众多其它开源项目都在使用的拼写检查器。</p>
</div>
<div class="paragraph">
<p>可以从这里获取 Hunspell 词典 ：</p>
</div>
<div class="ulist">
<ul>
<li> <p><a href="http://extensions.openoffice.org/"><em>extensions.openoffice.org</em></a>: 下载解压 <code>.oxt</code> 后缀的文件。</p> </li>
<li> <p><a href="http://mzl.la/157UORf"><em>addons.mozilla.org</em></a>: 下载解压 <code>.xpi</code> 扩展文件。</p> </li>
<li> <p><a href="http://download.services.openoffice.org/contrib/dictionaries/">OpenOffice archive</a>: 下载解压 <code>.zip</code> 文件。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>一个 Hunspell 词典由两个文件组成 — 具有相同的文件名和两个不同的后缀 — 如 <code>en_US</code>—和下面的两个后缀的其中一个：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>.dic</code>
</dt>
<dd>
<p>包含所有词根，采用字母顺序，再加上一个代表所有可能前缀和后缀的代码表 【集体称之为词缀( <em>affixes</em> 】</p>
</dd>
<dt class="hdlist1">
<code>.aff</code>
</dt>
<dd>
<p>包含实际 <code>.dic</code> 文件每一行代码表对应的前缀和后缀转换</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_安装一个词典">安装一个词典</h4>
<div class="paragraph">
<p>Hunspell 语汇单元过滤器在特定的 Hunspell 目录里寻找词典， 默认目录是 <code>./config/hunspell/</code> 。 <code>.dic</code> 文件和 <code>.aff</code> 文件应该要以子目录且按语言/区域的方式来命名。 例如，我们可以为美式英语创建一个 Hunspell 词干提取器，目录结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">config/
  └ hunspell/ <b class="conum">(1)</b>
      └ en_US/ <b class="conum">(2)</b>
          ├ en_US.dic
          ├ en_US.aff
          └ settings.yml <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>Hunspell 目录位置可以通过编辑 <code>config/elasticsearch.yml</code> 文件的： <code>indices.analysis.hunspell.dictionary.location</code> 设置来修改。</p> </li>
<li> <p><code>en_US</code> 是这个区域的名字，也是我们传给 <code>hunspell</code> 语汇单元过滤器参数 <code>language</code> 值。</p> </li>
<li> <p>一个语言一个设置文件，下面的章节会具体介绍。</p> </li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_按语言设置">按语言设置</h4>
<div class="paragraph">
<p>在语言的目录设置文件 <code>settings.yml</code> 包含适用于所有字典内的语言目录的设置选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
ignore_case:          true
strict_affix_parsing: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些选项的意思如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>ignore_case</code>
</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Hunspell 目录默认是区分大小写的，如，姓氏 <code>Booker</code> 和名词 <code>booker</code> 是不同的词，所以应该分别进行词干提取。 也许让 <code>hunspell</code> 提取器区分大小写是一个好主意，不过也可能让事情变得复杂：</p>
</div>
<div class="ulist">
<ul>
<li> <p>一个句子的第一个词可能会被大写，因此感觉上会像是一个名词。</p> </li>
<li> <p>输入的文本可能全是大写，如果这样那几乎一个词都找不到。</p> </li>
<li> <p>用户也许会用小写来搜索名字，在这种情况下，大写开头的词将找不到。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>一般来说，设置参数 <code>ignore_case</code> 为 <code>true</code> 是一个好主意。</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">
<code>strict_affix_parsing</code>
</dt>
<dd>
<p>词典的质量千差万别。 一些网上的词典的 <code>.aff</code> 文件有很多畸形的规则。 默认情况下，如果 Lucene 不能正常解析一个词缀(affix)规则， 它会抛出一个异常。 你可以通过设置 <code>strict_affix_parsing</code> 为 <code>false</code> 来告诉 Lucene 忽略错误的规则。</p>
</dd>
</dl>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
自定义词典
</div>
<div class="paragraph">
<p>如果一个目录放置了多个词典 (<code>.dic</code> 文件)， 他们会在加载时合并到一起。这可以让你以自定义的词典的方式对下载的词典进行定制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">config/
  └ hunspell/
      └ en_US/  <b class="conum">(1)</b>
          ├ en_US.dic
          ├ en_US.aff <b class="conum">(2)</b>
          ├ custom.dic
          └ settings.yml</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>custom</code> 词典和 <code>en_US</code> 词典将合并到一起。</p> </li>
<li> <p>多个 <code>.aff</code> 文件是不允许的，因为会产生规则冲突。</p> </li>
</ol>
</div>
<div class="paragraph">
<p><code>.dic</code> 文件和 <code>.aff</code> 文件的格式在这里讨论： <a href="#hunspell-dictionary-format">Hunspell 词典格式</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_创建一个_hunspell_语汇单元过滤器">创建一个 Hunspell 语汇单元过滤器</h4>
<div class="paragraph">
<p>一旦你在所有节点上安装好了词典，你就能像这样定义一个 <code>hunspell</code> 语汇单元过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "filter": {
        "en_US": {
          "type":     "hunspell",
          "language": "en_US" <b class="conum">(1)</b>
        }
      },
      "analyzer": {
        "en_US": {
          "tokenizer":  "standard",
          "filter":   [ "lowercase", "en_US" ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>参数 <code>language</code> 和目录下对应的名称相同。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>你可以通过 <code>analyze</code> API 来测试这个新的分析器， 然后和 <code>english</code> 分析器比较一下它们的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/_analyze?analyzer=en_US <b class="conum">(1)</b>
reorganizes

GET /_analyze?analyzer=english <b class="conum">(2)</b>
reorganizes</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>返回 <code>organize</code></p> </li>
<li> <p>返回 <code>reorgan</code></p> </li>
</ol>
</div>
<div class="paragraph">
<p>在前面的例子中，<code>hunspell</code> 提取器有一个有意思的事情，它不仅能移除前缀还能移除后缀。大多数算法词干提取仅能移除后缀。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>Hunspell 词典会占用几兆的内存。幸运的是，Elasticsearch 每个节点只会创建一个词典的单例。 所有的分片都会使用这个相同的 Hunspell 分析器。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="hunspell-dictionary-format">Hunspell 词典格式</h4>
<div class="paragraph">
<p>尽管使用 <code>hunspell</code> 不必了解 Hunspell 词典的格式， 不过了解格式可以帮助我们编写自己的自定义的词典。其实很简单。</p>
</div>
<div class="paragraph">
<p>例如，在美式英语词典（US English dictionary），<code>en_US.dic</code> 文件包含了一个包含词 <code>analyze</code> 的实体，看起来如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">analyze/ADSG</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>en_US.aff</code> 文件包含了一个针对标记 <code>A</code> 、 <code>G</code> 、<code>D</code> 和 <code>S</code> 的前后缀的规则。 其中应该只有一个能匹配，每一个规则的格式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">[type] [flag] [letters to remove] [letters to add] [condition]</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，下面的后缀 (<code>SFX</code>) 规则 <code>D</code> 。它是说，当一个词由一个辅音 (除了 <code>a</code> 、<code>e</code> 、<code>i</code> 、<code>o</code> 或 <code>u</code> 外的任意音节) 后接一个 <code>y</code> ，那么它可以移除 <code>y</code> 和添加 <code>ied</code> 结尾 （如，<code>ready</code> → <code>readied</code> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">SFX    D      y   ied  [^aeiou]y</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面提到的 <code>A</code> 、 <code>G</code> 、<code>D</code> 和 <code>S</code> 标记对应规则如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">SFX D Y 4
SFX D   0     d          e <b class="conum">(1)</b>
SFX D   y     ied        [^aeiou]y
SFX D   0     ed         [^ey]
SFX D   0     ed         [aeiou]y

SFX S Y 4
SFX S   y     ies        [^aeiou]y
SFX S   0     s          [aeiou]y
SFX S   0     es         [sxzh]
SFX S   0     s          [^sxzhy] <b class="conum">(2)</b>

SFX G Y 2
SFX G   e     ing        e <b class="conum">(3)</b>
SFX G   0     ing        [^e]

PFX A Y 1
PFX A   0     re         . <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>analyze</code> 以一个 <code>e</code> 结尾，所以它可以添加一个 <code>d</code> 变成 <code>analyzed</code> 。</p> </li>
<li> <p><code>analyze</code> 不是由 <code>s</code> 、<code>x</code> 、<code>z</code> 、<code>h</code> 或 <code>y</code> 结尾，所以，它可以添加一个 <code>s</code> 变成 <code>analyzes</code> 。</p> </li>
<li> <p><code>analyze</code> 以一个 <code>e</code> 结尾，所以，它可以移除 <code>e</code> 和添加 <code>ing</code> 然后变成 <code>analyzing</code> 。</p> </li>
<li> <p>可以添加前缀 <code>re</code> 来形成 <code>reanalyze</code> 。这个规则可以组合后缀规则一起形成： <code>reanalyzes</code> 、<code>reanalyzed</code> 、 <code>reanalyzing</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>了解更多关于 Hunspell 的语法，可以前往 <a href="http://sourceforge.net/projects/hunspell/files/Hunspell/Documentation/">Hunspell 文档</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="choosing-a-stemmer">选择一个词干提取器</h3>
<div class="paragraph">
<p>在文档 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stemmer-tokenfilter.html"><code>stemmer</code></a> token filter 里面列出了一些针对语言的若干词干提取器。 就英语来说我们有如下提取器：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>english</code>
</dt>
<dd>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-porterstem-tokenfilter.html"><code>porter_stem</code></a> 语汇单元过滤器（token filter）。</p>
</dd>
<dt class="hdlist1">
<code>light_english</code>
</dt>
<dd>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-kstem-tokenfilter.html"><code>kstem</code></a> 语汇单元过滤器（token filter）。</p>
</dd>
<dt class="hdlist1">
<code>minimal_english</code>
</dt>
<dd>
<p>Lucene 里面的 <code>EnglishMinimalStemmer</code> ，用来移除复数。</p>
</dd>
<dt class="hdlist1">
<code>lovins</code>
</dt>
<dd>
<p>基于 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-snowball-tokenfilter.html">Snowball</a> 的 <a href="http://snowball.tartarus.org/algorithms/lovins/stemmer.html">Lovins</a> 提取器, 第一个词干提取器。</p>
</dd>
<dt class="hdlist1">
<code>porter</code>
</dt>
<dd>
<p>基于 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-snowball-tokenfilter.html">Snowball</a> 的 <a href="http://snowball.tartarus.org/algorithms/porter/stemmer.html">Porter</a> 提取器。</p>
</dd>
<dt class="hdlist1">
<code>porter2</code>
</dt>
<dd>
<p>基于 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-snowball-tokenfilter.html">Snowball</a> 的 <a href="http://snowball.tartarus.org/algorithms/english/stemmer.html">Porter2</a> 提取器。</p>
</dd>
<dt class="hdlist1">
<code>possessive_english</code>
</dt>
<dd>
<p>Lucene 里面的 <code>EnglishPossessiveFilter</code> ，移除 <code>'s</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Hunspell 词干提取器也要纳入到上面的列表中，还有多种英文的词典可用。</p>
</div>
<div class="paragraph">
<p>有一点是可以肯定的：当一个问题存在多个解决方案的时候，这意味着没有一个解决方案充分解决这个问题。 这一点同样体现在词干提取上 — 每个提取器使用不同的方法不同程度的对单词进行了弱提取或是过度提取。</p>
</div>
<div class="paragraph">
<p>在 <code>stemmer</code> 文档 中，使用粗体高亮了每一个语言的推荐的词干提取器， 通常是因为它提供了一个在性能和质量之间合理的妥协。也就是说，推荐的词干提取器也许不适用所有场景。 关于哪个是最好的词干提取器，不存在一个唯一的正确答案 — 它要看你具体的需求。 这里有3个方面的因素需要考虑在内： 性能、质量、程度。</p>
</div>
<div class="sect3">
<h4 id="stemmer-performance">提取性能</h4>
<div class="paragraph">
<p>算法提取器一般来说比 Hunspell 提取器快4到5倍。 <code>`Handcrafted'' 算法提取器通常（不是永远） 要比 Snowball 快或是差不多。 比如，`porter_stem</code> 语汇单元过滤器（token filter）就明显要比基于 Snowball 实现的 Porter 提取器要快的多。</p>
</div>
<div class="paragraph">
<p>Hunspell 提取器需要加载所有的词典、前缀和后缀表到内存，可能需要消耗几兆的内存。而算法提取器，由一点点代码组成，只需要使用很少内存。</p>
</div>
</div>
<div class="sect3">
<h4 id="stemmer-quality">提取质量</h4>
<div class="paragraph">
<p>所有的语言，除了世界语（Esperanto）都是不规范的。 最日常用语使用的词往往不规则，而更正式的书面用语则往往遵循规律。 一些提取算法经过多年的开发和研究已经能够产生合理的高质量的结果了，其他人只需快速组装做很少的研究就能解决大部分的问题了。</p>
</div>
<div class="paragraph">
<p>虽然 Hunspell 提供了精确地处理不规则词语的承诺，但在实践中往往不足。 一个基于词典的提取器往往取决于词典的好坏。如果 Hunspell 碰到的这个词不在词典里，那它什么也不能做。 Hunspell 需要一个广泛的、高质量的、最新的词典以产生好的结果；这样级别的词典可谓少之又少。 另一方面，一个算法提取器，将愉快的处理新词而不用为新词重新设计算法。</p>
</div>
<div class="paragraph">
<p>如果一个好的算法词干提取器可用于你的语言，那明智的使用它而不是 Hunspell。它会更快并且消耗更少内存，并且会产生和通常一样好或者比 Hunspell 等价的结果.</p>
</div>
<div class="paragraph">
<p>如果精度和可定制性对你很重要，那么你需要（和有精力）来维护一个自定义的词典，那么 Hunspell 会给你比算法提取器更大的灵活性。 (查看 <a href="#controlling-stemming">控制词干提取</a> 来了解可用于任何词干提取器的自定义技术。)</p>
</div>
</div>
<div class="sect3">
<h4 id="stemmer-degree">提取程度</h4>
<div class="paragraph">
<p>不同的词干提取器会将词弱提取或过度提取到一定的程度。 <code>light_</code> 提取器提干力度不及标准的提取器。 <code>minimal_</code> 提取器同样也不那么积极。Hunspell 提取力度要激进一些。</p>
</div>
<div class="paragraph">
<p>是否想要积极提取还是轻量提取取决于你的场景。如果你的搜索结果是要用于聚类算法，你可能会希望匹配的更广泛一点（因此，提取力度要更大一点）。 如果你的搜索结果是面向最终用户，轻量的提取一般会产生更好的结果。对搜索来说，将名称和形容词提干比动词提干更重要，当然这也取决于语言。</p>
</div>
<div class="paragraph">
<p>另外一个要考虑的因素就是你的文档集的大小。 一个只有 10,000 个产品的小集合，你可能要更激进的提干来确保至少匹配到一些文档。 如果你的文档集很大，使用轻量的弱提取可能会得到更好的匹配结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_做一个选择">做一个选择</h4>
<div class="paragraph">
<p>从推荐的一个词干提取器出发，如果它工作的很好，那没有什么需要调整的。如果不是，你将需要花点时间来调查和比较该语言可用的各种不同提取器， 来找到最适合你目的的那一个。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="controlling-stemming">控制词干提取</h3>
<div class="paragraph">
<p>开箱即用的词干提取方案永远也不可能完美。 尤其是算法提取器，他们可以愉快的将规则应用于任何他们遇到的词，包含那些你希望保持独立的词。 也许，在你的场景，保持独立的 <code>skies</code> 和 <code>skiing</code> 是重要的，你不希望把他们提取为 <code>ski</code> （正如 <code>english</code> 分析器那样）。</p>
</div>
<div class="paragraph">
<p>语汇单元过滤器 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-keyword-marker-tokenfilter.html"><code>keyword_marker</code></a> 和 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stemmer-override-tokenfilter.html"><code>stemmer_override</code></a> 能让我们自定义词干提取过程。</p>
</div>
<div class="sect3">
<h4 id="preventing-stemming">阻止词干提取</h4>
<div class="paragraph">
<p>语言分析器（查看 <a href="#configuring-language-analyzers">配置语言分析器</a>）的参数 <a href="#stem-exclusion"><code>stem_exclusion</code></a> 允许我们指定一个词语列表，让他们不被词干提取。</p>
</div>
<div class="paragraph">
<p>在内部，这些语言分析器使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-keyword-marker-tokenfilter.html"><code>keyword_marker</code> 语汇单元过滤器</a> 来标记这些词语列表为 <em>keywords</em> ，用来阻止后续的词干提取过滤器来触碰这些词语。</p>
</div>
<div class="paragraph">
<p>例如，我们创建一个简单自定义分析器，使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-porterstem-tokenfilter.html"><code>porter_stem</code></a> 语汇单元过滤器，同时阻止 <code>skies</code> 的词干提取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "filter": {
        "no_stem": {
          "type": "keyword_marker",
          "keywords": [ "skies" ] <b class="conum">(1)</b>
        }
      },
      "analyzer": {
        "my_english": {
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "no_stem",
            "porter_stem"
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>参数 <code>keywords</code> 可以允许接收多个词语。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>使用 <code>analyze</code> API 来测试，可以看到词 <code>skies</code> 没有被提取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/_analyze?analyzer=my_english
sky skies skiing skis <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>返回: <code>sky</code>, <code>skies</code>, <code>ski</code>, <code>ski</code></p> </li>
</ol>
</div>
<div id="keyword-path" class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>虽然语言分析器只允许我们通过参数 <code>stem_exclusion</code> 指定一个词语列表来排除词干提取， 不过 <code>keyword_marker</code> 语汇单元过滤器同样还接收一个 <code>keywords_path</code> 参数允许我们将所有的关键字存在一个文件。 这个文件应该是每行一个字，并且存在于集群的每个节点。查看 <a href="#updating-stopwords">更新停用词（Updating Stopwords）</a> 了解更新这些文件的提示。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="customizing-stemming">自定义提取</h4>
<div class="paragraph">
<p>在上面的例子中，我们阻止了 <code>skies</code> 被词干提取，但是也许我们希望他能被提干为 <code>sky</code> 。 The <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stemmer-override-tokenfilter.html"><code>stemmer_override</code></a> 语汇单元过滤器允许我们指定自定义的提取规则。 与此同时，我们可以处理一些不规则的形式，如：<code>mice</code> 提取为 <code>mouse</code> 和 <code>feet</code> 到 <code>foot</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "filter": {
        "custom_stem": {
          "type": "stemmer_override",
          "rules": [ <b class="conum">(1)</b>
            "skies=&gt;sky",
            "mice=&gt;mouse",
            "feet=&gt;foot"
          ]
        }
      },
      "analyzer": {
        "my_english": {
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "custom_stem", <b class="conum">(2)</b>
            "porter_stem"
          ]
        }
      }
    }
  }
}

GET /my_index/_analyze?analyzer=my_english
The mice came down from the skies and ran over my feet <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>规则来自 <code>original⇒stem</code> 。</p> </li>
<li> <p><code>stemmer_override</code> 过滤器必须放置在词干提取器之前。</p> </li>
<li> <p>返回 <code>the</code>, <code>mouse</code>, <code>came</code>, <code>down</code>, <code>from</code>, <code>the</code>, <code>sky</code>, <code>and</code>, <code>ran</code>, <code>over</code>, <code>my</code>, <code>foot</code> 。</p> </li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content"> 正如 <code>keyword_marker</code> 语汇单元过滤器，规则可以被存放在一个文件中，通过参数 <code>rules_path</code> 来指定位置。 </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stemming-in-situ">原形词干提取</h3>
<div class="paragraph">
<p>为了完整地 完成本章的内容，我们将讲解如何将已提取词干的词和原词索引到同一个字段中。举个例子，分析句子 <em>The quick foxes jumped</em> 将会得到以下词项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Pos 1: (the)
Pos 2: (quick)
Pos 3: (foxes,fox) <b class="conum">(1)</b>
Pos 4: (jumped,jump) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>已提取词干的形式和未提取词干的形式位于相同的位置。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>Warning：使用此方法前请先阅读 <a href="#stemming-in-situ-good-idea">原形词干提取是个好主意吗</a> 。</p>
</div>
<div class="paragraph">
<p>为了归档词干提取出的 <em>原形</em> ，我们将使用 <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-keyword-repeat-tokenfilter.html"><code>keyword_repeat</code></a> 过滤器，跟 <code>keyword_marker</code> 过滤器 ( see <a href="#preventing-stemming">阻止词干提取</a> ) 一样，它把每一个词项都标记为关键词，以防止后续词干提取器对其修改。但是，它依然会在相同位置上重复词项，并且这个重复的词项 <strong>是</strong> 提取的词干。</p>
</div>
<div class="paragraph">
<p>单独使用 <code>keyword_repeat</code> token 过滤器将得到以下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Pos 1: (the,the) <b class="conum">(1)</b>
Pos 2: (quick,quick) <b class="conum">(1)</b>
Pos 3: (foxes,fox)
Pos 4: (jumped,jump)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>提取词干前后的形式一样，所以只是不必要的重复。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>为了防止提取和未提取词干形式相同的词项中的无意义重复，我们增加了组合的 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-unique-tokenfilter.html"><code>unique</code></a> 语汇单元过滤器 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "filter": {
        "unique_stem": {
          "type": "unique",
          "only_on_same_position": true <b class="conum">(1)</b>
        }
      },
      "analyzer": {
        "in_situ": {
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "keyword_repeat", <b class="conum">(2)</b>
            "porter_stem",
            "unique_stem" <b class="conum">(3)</b>
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>设置 <code>unique</code> 类型语汇单元过滤器，是为了只有当重复语汇单元出现在相同位置时，移除它们。</p> </li>
<li> <p>语汇单元过滤器必须出现在词干提取器之前。</p> </li>
<li> <p><code>unique_stem</code> 过滤器是在词干提取器完成之后移除重复词项。</p> </li>
</ol>
</div>
<div class="sect3">
<h4 id="stemming-in-situ-good-idea">原形词干提取是个好主意吗</h4>
<div class="paragraph">
<p>用户喜欢 <em>原形</em> 词干提取这个主意：``如果我可以只用一个组合字段，为什么还要分别存一个未提取词干和已提取词干的字段呢？'' 但这是一个好主意吗？答案一直都是否定的。因为有两个问题：</p>
</div>
<div class="paragraph">
<p>第一个问题是无法区分精准匹配和非精准匹配。本章中，我们看到了多义词经常会被展开成相同的词干词：<code>organs</code> 和 <code>organization</code> 都会被提取为 <code>organ</code> 。</p>
</div>
<div class="paragraph">
<p>在 <a href="#using-language-analyzers">使用语言分析器</a> 我们展示了如何整合一个已提取词干属性的查询(为了增加召回率)和一个未提取词干属性的查询（为了提升相关度）。 当提取和未提取词干的属性相互独立时，单个属性的贡献可以通过给其中一个属性增加boost值来优化(参见 <a href="#prioritising-clauses">语句的优先级</a> )。相反地，如果已提取和未提取词干的形式置于同一个属性，就没有办法来优化搜索结果了。</p>
</div>
<div class="paragraph">
<p>第二个问题是，必须搞清楚 相关度分值是否如何计算的。在 <a href="#relevance-intro">什么是相关性?</a> 我们解释了部分计算依赖于逆文档频率（IDF）—— 即一个词在索引库的所有文档中出现的频繁程度。 在一个包含文本 <code>jump jumped jumps</code> 的文档上使用原形词干提取，将得到下列词项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Pos 1: (jump)
Pos 2: (jumped,jump)
Pos 3: (jumps,jump)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>jumped</code> 和 <code>jumps</code> 各出现一次，所以有正确的IDF值；<code>jump</code> 出现了3次，作为一个搜索词项，与其他未提取词干的形式相比，这明显降低了它的IDF值。</p>
</div>
<div class="paragraph">
<p>基于这些原因，我们不推荐使用原形词干提取。</p>
</div>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/182/index.html">
<img class="uk-book-cover" src="../../static/icons/48/amazonwebservices_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/182/index.html">亚马逊(aws)web服务实用指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/102.html">open-guides</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="amazonwebservices">amazonwebservices</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">314页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 24000个">24000</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/205/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/205/index.html">从0到1实战微服务架构</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/115.html">skyline75489</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="mysql">mysql</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="netty">netty</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="nginx">nginx</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">62页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/7/index.html">
<img class="uk-book-cover" src="../../static/icons/48/netty_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/7/index.html">Netty 4.x 用户指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/6.html">waylau</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="netty">netty</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1131个">1131</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/119/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/119/index.html">给小白看的设计模式书</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">13页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/159/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/159/index.html">im-service 简介</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/91.html">yu000hong</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">37页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/130/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/130/index.html">进击的Python</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/68.html">HuberTRoy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 169个">169</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9276;var bookPageRelUrl ='stemming.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>