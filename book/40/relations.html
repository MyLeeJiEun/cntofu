
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>关联关系处理-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='关联关系处理,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='关联关系处理,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/modeling-your-data.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">数据建模</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/nested-objects.html">
<span class="">嵌套对象</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="relations">关联关系处理</h2>
<div class="paragraph">
<p>现实世界有很多重要的关联关系：博客帖子有一些评论，银行账户有多次交易记录，客户有多个银行账户，订单有多个订单明细，文件目录有多个文件和子目录。</p>
</div>
<div class="paragraph">
<p>关系型数据库被明确设计—​毫不意外—​用来进行关联关系管理：</p>
</div>
<div class="ulist">
<ul>
<li> <p>每个实体（或 <em>行</em> ，在关系世界中）可以被 <em>主键</em> 唯一标识。</p> </li>
<li> <p>实体 <em>规范化</em> （范式）。唯一实体的数据只存储一次，而相关实体只存储它的主键。只能在一个具体位置修改这个实体的数据。</p> </li>
<li> <p>实体可以进行关联查询，可以跨实体搜索。</p> </li>
<li> <p>单个实体的变化是 <em>原子的</em> ， <em>一致的</em> ， <em>隔离的</em> ， 和 <em>持久的</em> 。 （可以在 <a href="http://en.wikipedia.org/wiki/ACID_transactions"><em>ACID Transactions</em></a> 中查看更多细节。）</p> </li>
<li> <p>大多数关系数据库支持跨多个实体的 ACID 事务。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>但是关系型数据库有其局限性，包括对全文检索有限的支持能力。 实体关联查询时间消耗是很昂贵的，关联的越多，消耗就越昂贵。特别是跨服务器进行实体关联时成本极其昂贵，基本不可用。 但单个的服务器上又存在数据量的限制。</p>
</div>
<div class="paragraph">
<p>Elasticsearch ，和大多数 NoSQL 数据库类似，是扁平化的。索引是独立文档的集合体。 文档是否匹配搜索请求取决于它是否包含所有的所需信息。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 中单个文档的数据变更是 <a href="http://en.wikipedia.org/wiki/ACID_transactions">ACIDic</a> 的， 而涉及多个文档的事务则不是。当一个事务部分失败时，无法回滚索引数据到前一个状态。</p>
</div>
<div class="paragraph">
<p>扁平化有以下优势：</p>
</div>
<div class="ulist">
<ul>
<li> <p>索引过程是快速和无锁的。</p> </li>
<li> <p>搜索过程是快速和无锁的。</p> </li>
<li> <p>因为每个文档相互都是独立的，大规模数据可以在多个节点上进行分布。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>但关联关系仍然非常重要。某些时候，我们需要缩小扁平化和现实世界关系模型的差异。以下四种常用的方法，用来在 Elasticsearch 中进行关系型数据的管理：</p>
</div>
<div class="ulist">
<ul>
<li> <p><a href="#application-joins">Application-side joins</a></p> </li>
<li> <p><a href="#denormalization">Data denormalization</a></p> </li>
<li> <p><a href="#nested-objects">Nested objects</a></p> </li>
<li> <p><a href="#parent-child">Parent/child relationships</a></p> </li>
</ul>
</div>
<div class="paragraph">
<p>通常都需要结合其中的某几个方法来得到最终的解决方案。</p>
</div>
<div class="sect2">
<h3 id="application-joins">应用层联接</h3>
<div class="paragraph">
<p>我们通过在我们的应用程序中实现联接可以（部分）模拟关系数据库。 例如，比方说我们正在对用户和他们的博客文章进行索引。在关系世界中，我们会这样来操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index/user/1 <b class="conum">(1)</b>
{
  "name":     "John Smith",
  "email":    "john@smith.com",
  "dob":      "1970/10/24"
}

PUT /my_index/blogpost/2 <b class="conum">(1)</b>
{
  "title":    "Relationships",
  "body":     "It's complicated...",
  "user":     1 <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>每个文档的 <code>index</code>, <code>type</code>, 和 <code>id</code> 一起构造成主键。</p> </li>
<li> <p><code>blogpost</code> 通过用户的 <code>id</code> 链接到用户。<code>index</code> 和 <code>type</code> 并不需要因为在我们的应用程序中已经硬编码。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>通过用户的 ID <code>1</code> 可以很容易的找到博客帖子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/blogpost/_search
{
  "query": {
    "filtered": {
      "filter": {
        "term": { "user": 1 }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了找到用户叫做 John 的博客帖子，我们需要运行两次查询： 第一次会查找所有叫做 John 的用户从而获取他们的 ID 集合，接着第二次会将这些 ID 集合放到类似于前面一个例子的查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/user/_search
{
  "query": {
    "match": {
      "name": "John"
    }
  }
}

GET /my_index/blogpost/_search
{
  "query": {
    "filtered": {
      "filter": {
        "terms": { "user": [1] }  <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>执行第一个查询得到的结果将填充到 <code>terms</code> 过滤器中。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>应用层联接的主要优点是可以对数据进行标准化处理。只能在 <code>user</code> 文档中修改用户的名称。缺点是，为了在搜索时联接文档，必须运行额外的查询。</p>
</div>
<div class="paragraph">
<p>在这个例子中，只有一个用户匹配我们的第一个查询，但在现实世界中，我们可以很轻易的遇到数以百万计的叫做 John 的用户。 包含所有这些用户的 IDs 会产生一个非常大的查询，这是一个数百万词项的查找。</p>
</div>
<div class="paragraph">
<p>这种方法适用于第一个实体（例如，在这个例子中 <code>user</code> ）只有少量的文档记录的情况，并且最好它们很少改变。这将允许应用程序对结果进行缓存，并避免经常运行第一次查询。</p>
</div>
</div>
<div class="sect2">
<h3 id="denormalization">非规范化你的数据</h3>
<div class="paragraph">
<p>使用 Elasticsearch 得到最好的搜索性能的方法是有目的的通过在索引时进行非规范化 <a href="http://en.wikipedia.org/wiki/Denormalization">denormalizing</a>。对每个文档保持一定数量的冗余副本可以在需要访问时避免进行关联。</p>
</div>
<div class="paragraph">
<p>如果我们希望能够通过某个用户姓名找到他写的博客文章，可以在博客文档中包含这个用户的姓名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index/user/1
{
  "name":     "John Smith",
  "email":    "john@smith.com",
  "dob":      "1970/10/24"
}

PUT /my_index/blogpost/2
{
  "title":    "Relationships",
  "body":     "It's complicated...",
  "user":     {
    "id":       1,
    "name":     "John Smith" <b class="conum">(1)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>这部分用户的字段数据已被冗余到 <code>blogpost</code> 文档中。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>现在，我们通过单次查询就能够通过 <code>relationships</code> 找到用户 <code>John</code> 的博客文章。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/blogpost/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "title":     "relationships" }},
        { "match": { "user.name": "John"          }}
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>数据非规范化的优点是速度快。因为每个文档都包含了所需的所有信息，当这些信息需要在查询进行匹配时，并不需要进行昂贵的联接操作。</p>
</div>
</div>
<div class="sect2">
<h3 id="top-hits">字段折叠</h3>
<div class="paragraph">
<p>一个普遍的需求是需要通过特定字段进行分组。例如我们需要按照用户名称 <em>分组</em> 返回最相关的博客文章。 按照用户名分组意味着进行 <code>terms</code> 聚合。 为能够按照用户 <em>整体</em> 名称进行分组，名称字段应保持 <code>not_analyzed</code> 的形式， 具体说明参考 <a href="#aggregations-and-analysis">聚合与分析</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index/_mapping/blogpost
{
  "properties": {
    "user": {
      "properties": {
        "name": { <b class="conum">(1)</b>
          "type": "string",
          "fields": {
            "raw": { <b class="conum">(2)</b>
              "type":  "string",
              "index": "not_analyzed"
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>user.name</code> 字段将用来进行全文检索。</p> </li>
<li> <p><code>user.name.raw</code> 字段将用来通过 <code>terms</code> 聚合进行分组。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>然后添加一些数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index/user/1
{
  "name": "John Smith",
  "email": "john@smith.com",
  "dob": "1970/10/24"
}

PUT /my_index/blogpost/2
{
  "title": "Relationships",
  "body": "It's complicated...",
  "user": {
    "id": 1,
    "name": "John Smith"
  }
}

PUT /my_index/user/3
{
  "name": "Alice John",
  "email": "alice@john.com",
  "dob": "1979/01/04"
}

PUT /my_index/blogpost/4
{
  "title": "Relationships are cool",
  "body": "It's not complicated at all...",
  "user": {
    "id": 3,
    "name": "Alice John"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们来查询标题包含 <code>relationships</code> 并且作者名包含 <code>John</code> 的博客，查询结果再按作者名分组，感谢 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-aggregations-metrics-top-hits-aggregation.html"><code>top_hits</code> aggregation</a> 提供了按照用户进行分组的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/blogpost/_search
{
  "size" : 0, <b class="conum">(1)</b>
  "query": { <b class="conum">(2)</b>
    "bool": {
      "must": [
        { "match": { "title":     "relationships" }},
        { "match": { "user.name": "John"          }}
      ]
    }
  },
  "aggs": {
    "users": {
      "terms": {
        "field":   "user.name.raw",      <b class="conum">(3)</b>
        "order": { "top_score": "desc" } <b class="conum">(4)</b>
      },
      "aggs": {
        "top_score": { "max":      { "script":  "_score"           }}, <b class="conum">(4)</b>
        "blogposts": { "top_hits": { "_source": "title", "size": 5 }}  <b class="conum">(5)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>我们感兴趣的博客文章是通过 <code>blogposts</code> 聚合返回的，所以我们可以通过将 <code>size</code> 设置成 0 来禁止 <code>hits</code> 常规搜索。</p> </li>
<li> <p><code>query</code> 返回通过 <code>relationships</code> 查找名称为 <code>John</code> 的用户的博客文章。</p> </li>
<li> <p><code>terms</code> 聚合为每一个 <code>user.name.raw</code> 创建一个桶。</p> </li>
<li> <p><code>top_score</code> 聚合对通过 <code>users</code> 聚合得到的每一个桶按照文档评分对词项进行排序。</p> </li>
<li> <p><code>top_hits</code> 聚合仅为每个用户返回五个最相关的博客文章的 <code>title</code> 字段。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>这里显示简短响应结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">...
"hits": {
  "total":     2,
  "max_score": 0,
  "hits":      [] <b class="conum">(1)</b>
},
"aggregations": {
  "users": {
     "buckets": [
        {
           "key":       "John Smith", <b class="conum">(2)</b>
           "doc_count": 1,
           "blogposts": {
              "hits": { <b class="conum">(3)</b>
                 "total":     1,
                 "max_score": 0.35258877,
                 "hits": [
                    {
                       "_index": "my_index",
                       "_type":  "blogpost",
                       "_id":    "2",
                       "_score": 0.35258877,
                       "_source": {
                          "title": "Relationships"
                       }
                    }
                 ]
              }
           },
           "top_score": { <b class="conum">(4)</b>
              "value": 0.3525887727737427
           }
        },
...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>因为我们设置 <code>size</code> 为 0 ，所以 <code>hits</code> 数组是空的。</p> </li>
<li> <p>在顶层查询结果中出现的每一个用户都会有一个对应的桶。</p> </li>
<li> <p>在每个用户桶下面都会有一个 <code>blogposts.hits</code> 数组包含针对这个用户的顶层查询结果。</p> </li>
<li> <p>用户桶按照每个用户最相关的博客文章进行排序。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>使用 <code>top_hits</code> 聚合等效执行一个查询返回这些用户的名字和他们最相关的博客文章，然后为每一个用户执行相同的查询，以获得最好的博客。但前者的效率要好很多。</p>
</div>
<div class="paragraph">
<p>每一个桶返回的顶层查询命中结果是基于最初主查询进行的一个轻量 <em>迷你查询</em> 结果集。这个迷你查询提供了一些你期望的常用特性，例如高亮显示以及分页功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="denormalization-concurrency">非规范化和并发</h3>
<div class="paragraph">
<p>当然，数据非规范化也有弊端。 第一个缺点是索引会更大因为每个博客文章文档的 <code>_source</code> 将会更大，并且这里有很多的索引字段。这通常不是一个大问题。数据写到磁盘将会被高度压缩，而且磁盘已经很廉价了。Elasticsearch 可以愉快地应付这些额外的数据。</p>
</div>
<div class="paragraph">
<p>更重要的问题是，如果用户改变了他的名字，他所有的博客文章也需要更新了。幸运的是，用户不经常更改名称。即使他们做了， 用户也不可能写超过几千篇博客文章，所以更新博客文章通过 <a href="#scroll"><code>scroll</code></a> 和 <a href="#bulk"><code>bulk</code></a> APIs 大概耗费不到一秒。</p>
</div>
<div class="paragraph">
<p>然而，让我们考虑一个更复杂的场景，其中的变化很常见，影响深远，而且非常重要，并发。</p>
</div>
<div class="paragraph">
<p>在这个例子中，我们将在 Elasticsearch 模拟一个文件系统的目录树，非常类似 Linux 文件系统：根目录是 <code>/</code> ，每个目录可以包含文件和子目录。</p>
</div>
<div class="paragraph">
<p>我们希望能够搜索到一个特定目录下的文件，等效于：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>grep "some text" /clinton/projects/elasticsearch/*</pre>
</div>
</div>
<div class="paragraph">
<p>这就要求我们索引文件所在目录的路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs/file/1
{
  "name":     "README.txt", <b class="conum">(1)</b>
  "path":     "../../clinton/projects/elasticsearch", <b class="conum">(2)</b>
  "contents": "Starting a new Elasticsearch project is easy..."
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>文件名</p> </li>
<li> <p>文件所在目录的全路径</p> </li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>事实上，我们也应当索引 <code>directory</code> 文档，如此我们可以在目录内列出所有的文件和子目录，但为了简洁，我们将忽略这个需求。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>我们也希望能够搜索到一个特定目录下的目录树包含的的任何文件，相当于此：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>grep -r "some text" /clinton</pre>
</div>
</div>
<div class="paragraph">
<p>为了支持这一点，我们需要对路径层次结构进行索引：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>/clinton</code></p> </li>
<li> <p><code>/clinton/projects</code></p> </li>
<li> <p><code>/clinton/projects/elasticsearch</code></p> </li>
</ul>
</div>
<div class="paragraph">
<p>这种层次结构能够通过 <code>path</code> 字段使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-pathhierarchy-tokenizer.html"><code>path_hierarchy</code> tokenizer</a> 自动生成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs
{
  "settings": {
    "analysis": {
      "analyzer": {
        "paths": { <b class="conum">(1)</b>
          "tokenizer": "path_hierarchy"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>自定义的 <code>paths</code> 分析器在默认设置中使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-pathhierarchy-tokenizer.html"><code>path_hierarchy</code> tokenizer</a>。</p> </li>
</ol>
</div>
<div class="paragraph">
<p><code>file</code> 类型的映射看起来如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs/_mapping/file
{
  "properties": {
    "name": { <b class="conum">(1)</b>
      "type":  "string",
      "index": "not_analyzed"
    },
    "path": { <b class="conum">(2)</b>
      "type":  "string",
      "index": "not_analyzed",
      "fields": {
        "tree": { <b class="conum">(2)</b>
          "type":     "string",
          "analyzer": "paths"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>name</code> 字段将包含确切名称。</p> </li>
<li> <p><code>path</code> 字段将包含确切的目录名称，而 <code>path.tree</code> 字段将包含路径层次结构。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>一旦索引建立并且文件已被编入索引，我们可以执行一个搜索，在 <code>/clinton/projects/elasticsearch</code> 目录中包含 <code>elasticsearch</code> 的文件，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /fs/file/_search
{
  "query": {
    "filtered": {
      "query": {
        "match": {
          "contents": "elasticsearch"
        }
      },
      "filter": {
        "term": { <b class="conum">(1)</b>
          "path": "../../clinton/projects/elasticsearch"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>仅在该目录中查找文件。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>所有在 <code>/clinton</code> 下面的任何子目录存放的文件将在 <code>path.tree</code> 字段中包含 <code>/clinton</code> 词项。所以我们能够搜索 <code>/clinton</code> 的任何子目录中的所有文件，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /fs/file/_search
{
  "query": {
    "filtered": {
      "query": {
        "match": {
          "contents": "elasticsearch"
        }
      },
      "filter": {
        "term": { <b class="conum">(1)</b>
          "path.tree": "../../clinton"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>在这个目录或其下任何子目录中查找文件。</p> </li>
</ol>
</div>
<div class="sect3">
<h4 id="_重命名文件和目录">重命名文件和目录</h4>
<div class="paragraph">
<p>到目前为止一切顺利。 重命名一个文件很容易—​所需要的只是一个简单的 <code>update</code> 或 <code>index</code> 请求。 你甚至可以使用 <a href="#optimistic-concurrency-control">optimistic concurrency control</a> 确保你的变化不会与其他用户的变化发生冲突：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs/file/1?version=2 <b class="conum">(1)</b>
{
  "name":     "README.asciidoc",
  "path":     "../../clinton/projects/elasticsearch",
  "contents": "Starting a new Elasticsearch project is easy..."
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>version</code> 编号确保该更改仅应用于该索引中具有此相同的版本号的文档。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>我们甚至可以重命名一个目录，但这意味着更新所有存在于该目录下路径层次结构中的所有文件。 这可能快速或缓慢，取决于有多少文件需要更新。我们所需要做的就是使用 <a href="#scroll"><code>scroll</code></a> 来检索所有的文件， 以及 <a href="#bulk"><code>bulk</code> API</a> 来更新它们。这个过程不是原子的，但是所有的文件将会迅速转移到他们的新存放位置。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrency-solutions">解决并发问题</h3>
<div class="paragraph">
<p>当我们允许多个人 <em>同时</em> 重命名文件或目录时，问题就来了。 设想一下，你正在对一个包含了成百上千文件的目录 <code>/clinton</code> 进行重命名操作。 同时，另一个用户对这个目录下的单个文件 <code>/clinton/projects/elasticsearch/README.txt</code> 进行重命名操作。 这个用户的修改操作，尽管在你的操作后开始，但可能会更快的完成。</p>
</div>
<div class="paragraph">
<p>以下有两种情况可能出现：</p>
</div>
<div class="ulist">
<ul>
<li> <p>你决定使用 <code>version</code> （版本）号，在这种情况下，当与 <code>README.txt</code> 文件重命名的版本号产生冲突时，你的批量重命名操作将会失败。</p> </li>
<li> <p>你没有使用版本控制，你的变更将覆盖其他用户的变更。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>问题的原因是 Elasticsearch 不支持 <a href="http://en.wikipedia.org/wiki/ACID_transactions">ACID 事务</a>。 对单个文件的变更是 ACIDic 的，但包含多个文档的变更不支持。</p>
</div>
<div class="paragraph">
<p>如果你的主要数据存储是关系数据库，并且 Elasticsearch 仅仅作为一个搜索引擎 或一种提升性能的方法，可以首先在数据库中执行变更动作，然后在完成后将这些变更复制到 Elasticsearch。 通过这种方式，你将受益于数据库 ACID 事务支持，并且在 Elasticsearch 中以正确的顺序产生变更。 并发在关系数据库中得到了处理。</p>
</div>
<div class="paragraph">
<p>如果你不使用关系型存储，这些并发问题就需要在 Elasticsearch 的事务水准进行处理。 以下是三个切实可行的使用 Elasticsearch 的解决方案，它们都涉及某种形式的锁：</p>
</div>
<div class="ulist">
<ul>
<li> <p>全局锁</p> </li>
<li> <p>文档锁</p> </li>
<li> <p>树锁</p> </li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>当使用一个外部系统替代 Elasticsearch 时，本节中所描述的解决方案可以通过相同的原则来实现。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="global-lock">全局锁</h4>
<div class="paragraph">
<p>通过在任何时间只允许一个进程来进行变更动作，我们可以完全避免并发问题。 大多数的变更只涉及少量文件，会很快完成。一个顶级目录的重命名操作会对其他变更造成较长时间的阻塞，但可能很少这样做。</p>
</div>
<div class="paragraph">
<p>因为在 Elasticsearch 文档级别的变更支持 ACIDic，我们可以使用一个文档是否存在的状态作为一个全局锁。 为了请求得到锁，我们尝试 <code>create</code> 全局锁文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs/lock/global/_create
{}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这个 <code>create</code> 请求因冲突异常而失败，说明另一个进程已被授予全局锁，我们将不得不稍后再试。 如果请求成功了，我们自豪的成为全局锁的主人，然后可以继续完成我们的变更。一旦完成，我们就必须通过删除全局锁文档来释放锁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">DELETE /fs/lock/global</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据变更的频繁程度以及时间消耗，一个全局锁能对系统造成大幅度的性能限制。 我们可以通过让我们的锁更细粒度的方式来增加并行度。</p>
</div>
</div>
<div class="sect3">
<h4 id="document-locking">文档锁</h4>
<div class="paragraph">
<p>我们可以使用前面描述相同的方法技术来锁定个体文档，而不是锁定整个文件系统。 我们可以使用 <a href="#scroll">scrolled search</a> 检索所有的文档，这些文档会被变更影响因此每一个文档都创建了一个锁文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs/lock/_bulk
{ "create": { "_id": 1}} <b class="conum">(1)</b>
{ "process_id": 123    } <b class="conum">(2)</b>
{ "create": { "_id": 2}}
{ "process_id": 123    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>lock</code> 文档的 ID 将与应被锁定的文件的 ID 相同。</p> </li>
<li> <p><code>process_id</code> 代表要执行变更进程的唯一 ID。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>如果一些文件已被锁定，部分的 <code>bulk</code> 请求将失败，我们将不得不再次尝试。</p>
</div>
<div class="paragraph">
<p>当然，如果我们试图再次锁定 <em>所有</em> 的文件， 我们前面使用的 <code>create</code> 语句将会失败，因为所有文件都已被我们锁定！ 我们需要一个 <code>update</code> 请求带 <code>upsert</code> 参数以及下面这个 <code>script</code> ，而不是一个简单的 <code>create</code> 语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">if ( ctx._source.process_id != process_id ) { <b class="conum">(1)</b>
  assert false;  <b class="conum">(2)</b>
}
ctx.op = 'noop'; <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>process_id</code> 是传递到脚本的一个参数。</p> </li>
<li> <p><code>assert false</code> 将引发异常，导致更新失败。</p> </li>
<li> <p>将 <code>op</code> 从 <code>update</code> 更新到 <code>noop</code> 防止更新请求作出任何改变，但仍返回成功。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>完整的 <code>update</code> 请求如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /fs/lock/1/_update
{
  "upsert": { "process_id": 123 },
  "script": "if ( ctx._source.process_id != process_id )
  { assert false }; ctx.op = 'noop';"
  "params": {
    "process_id": 123
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文档并不存在， <code>upsert</code> 文档将会被插入—​和前面 <code>create</code> 请求相同。 但是，如果该文件 <em>确实</em> 存在，该脚本会查看存储在文档上的 <code>process_id</code> 。 如果 <code>process_id</code> 匹配，更新不会执行（ <code>noop</code> ）但脚本会返回成功。 如果两者并不匹配， <code>assert false</code> 抛出一个异常，你也知道了获取锁的尝试已经失败。</p>
</div>
<div class="paragraph">
<p>一旦所有锁已成功创建，你就可以继续进行你的变更。</p>
</div>
<div class="paragraph">
<p>之后，你必须释放所有的锁，通过检索所有的锁文档并进行批量删除，可以完成锁的释放：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /fs/_refresh <b class="conum">(1)</b>

GET /fs/lock/_search?scroll=1m <b class="conum">(2)</b>
{
    "sort" : ["_doc"],
    "query": {
        "match" : {
            "process_id" : 123
        }
    }
}

PUT /fs/lock/_bulk
{ "delete": { "_id": 1}}
{ "delete": { "_id": 2}}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>refresh</code> 调用确保所有 <code>lock</code> 文档对搜索请求可见。</p> </li>
<li> <p>当你需要在单次搜索请求返回大量的检索结果集时，你可以使用 <a href="#scroll"><code>scroll</code></a> 查询。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>文档级锁可以实现细粒度的访问控制，但是为数百万文档创建锁文件开销也很大。 在某些情况下，你可以用少得多的工作量实现细粒度的锁定，如以下目录树场景中所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="tree-locking">树锁</h4>
<div class="paragraph">
<p>在前面的例子中，我们可以锁定的目录树的一部分，而不是锁定每一个涉及的文档。 我们将需要独占访问我们要重命名的文件或目录，它可以通过 <em>独占锁</em> 文档来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{ "lock_type": "exclusive" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>同时我们需要共享锁定所有的父目录，通过 <em>共享锁</em> 文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "lock_type":  "shared",
  "lock_count": 1 <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>lock_count</code> 记录持有共享锁进程的数量。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>对 <code>/clinton/projects/elasticsearch/README.txt</code> 进行重命名的进程需要在这个文件上有 <em>独占锁</em> ， 以及在 <code>/clinton</code> 、 <code>/clinton/projects</code> 和 <code>/clinton/projects/elasticsearch</code> 目录有 <em>共享锁</em> 。</p>
</div>
<div class="paragraph">
<p>一个简单的 <code>create</code> 请求将满足独占锁的要求，但共享锁需要脚本的更新来实现一些额外的逻辑：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">if (ctx._source.lock_type == 'exclusive') {
  assert false; <b class="conum">(1)</b>
}
ctx._source.lock_count++ <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>如果 <code>lock_type</code> 是 <code>exclusive</code> （独占）的，<code>assert</code> 语句将抛出一个异常，导致更新请求失败。</p> </li>
<li> <p>否则，我们对 <code>lock_count</code> 进行增量处理。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>这个脚本处理了 <code>lock</code> 文档已经存在的情况，但我们还需要一个用来处理的文档还不存在情况的 <code>upsert</code> 文档。 完整的更新请求如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /fs/lock/%2Fclinton/_update <b class="conum">(1)</b>
{
  "upsert": { <b class="conum">(2)</b>
    "lock_type":  "shared",
    "lock_count": 1
  },
  "script": "if (ctx._source.lock_type == 'exclusive')
  { assert false }; ctx._source.lock_count++"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>文档的 ID 是 <code>/clinton</code> ，经过URL编码后成为 <code>%2fclinton</code> 。</p> </li>
<li> <p><code>upsert</code> 文档如果不存在，则会被插入。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>一旦我们成功地在所有的父目录中获得一个共享锁，我们尝试在文件本身 <code>create</code> 一个独占锁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs/lock/%2Fclinton%2fprojects%2felasticsearch%2fREADME.txt/_create
{ "lock_type": "exclusive" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果有其他人想要重新命名 <code>/clinton</code> 目录，他们将不得不在这条路径上获得一个独占锁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /fs/lock/%2Fclinton/_create
{ "lock_type": "exclusive" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个请求将失败，因为一个具有相同 ID 的 <code>lock</code> 文档已经存在。 另一个用户将不得不等待我们的操作完成以及释放我们的锁。独占锁只能这样被删除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">DELETE /fs/lock/%2Fclinton%2fprojects%2felasticsearch%2fREADME.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>共享锁需要另一个脚本对 <code>lock_count</code> 递减，如果计数下降到零，删除 <code>lock</code> 文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">if (--ctx._source.lock_count == 0) {
  ctx.op = 'delete' <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>一旦 <code>lock_count</code> 达到0， <code>ctx.op</code> 会从 <code>update</code> 被修改成 <code>delete</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>此更新请求将为每级父目录由下至上的执行，从最长路径到最短路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /fs/lock/%2Fclinton%2fprojects%2felasticsearch/_update
{
  "script": "if (--ctx._source.lock_count == 0) { ctx.op = 'delete' } "
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>树锁用最小的代价提供了细粒度的并发控制。当然，它不适用于所有的情况—​数据模型必须有类似于目录树的顺序访问路径才能使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>这三个方案—​全局、文档或树锁—​都没有处理锁最棘手的问题：如果持有锁的进程死了怎么办？</p>
</div>
<div class="paragraph">
<p>一个进程的意外死亡给我们留下了2个问题：</p>
</div>
<div class="ulist">
<ul>
<li> <p>我们如何知道我们可以释放的死亡进程中所持有的锁？</p> </li>
<li> <p>我们如何清理死去的进程没有完成的变更？</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些主题超出了本书的范围，但是如果你决定使用锁，你需要给对他们进行一些思考。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>当非规范化成为很多项目的一个很好的选择，采用锁方案的需求会带来复杂的实现逻辑。 作为替代方案，Elasticsearch 提供两个模型帮助我们处理相关联的实体： <em>嵌套的对象</em> 和 <em>父子关系</em> 。</p>
</div>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/46/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/46/index.html">软件开发平台及语言笔记大全(超详细)</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/22.html">jasonblog</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="cplusplus">cplusplus</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1,399页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月30日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 16个">16</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/31/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/31/index.html">操作系统思考</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 74个">74</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/110/index.html">
<img class="uk-book-cover" src="../../static/icons/48/react_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/110/index.html">React 学习之道</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="react">react</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">11页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/166/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/166/index.html">What the f*ck Python中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/95.html">leisurelicht</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">70页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7300个">7300</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/125/index.html">
<img class="uk-book-cover" src="../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/125/index.html">前端早读课</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/67.html">if2er</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7个">7</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/148/index.html">
<img class="uk-book-cover" src="../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/148/index.html">移动前端开发收藏夹</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/80.html">hoosin</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1405个">1405</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9298;var bookPageRelUrl ='relations.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>