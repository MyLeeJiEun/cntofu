
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>停用词: 性能与精度-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='停用词: 性能与精度,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='停用词: 性能与精度,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/stemming.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">将单词还原为词根</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/synonyms.html">
<span class="">同义词</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="stopwords">停用词: 性能与精度</h2>
<div class="paragraph">
<p>从早期的信息检索到如今， 我们已习惯于磁盘空间和内存被限制为很小一部分，所以 必须使你的索引尽可能小。 每个字节都意味着巨大的性能提升。 (查看 <a href="#stemming">将单词还原为词根</a> ) 词干提取的重要性不仅是因为它让搜索的内容更广泛、让检索的能力更深入，还因为它是压缩索引空间的工具。</p>
</div>
<div class="paragraph">
<p>一种最简单的减少索引大小的方法就是 <em>索引更少的词</em>。 有些词要比其他词更重要，只索引那些更重要的词来可以大大减少索引的空间。</p>
</div>
<div class="paragraph">
<p>那么哪些词条可以被过滤呢？ 我们可以简单分为两组:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
低频词（Low-frequency terms）
</dt>
<dd>
<p>在文档集合中相对出现较少的词，因为它们稀少，所以它们的权重值更高。</p>
</dd>
<dt class="hdlist1">
高频词（High-frequency terms）
</dt>
<dd>
<p>在索引下的文档集合中出现较多的常用词，例如 <code>the</code>、<code>and</code>、和`is`。 这些词的权重小，对相关度评分影响不大。</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>当然，频率实际上是个可以衡量的标尺而不是非 <em>高</em> 即 <em>低</em> 的标签。我们可以在标尺的任何位置选取一个标准，低于这个标准的属于低频词，高于它的属于高频词。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>词项到底是低频或是高频取决于它们所处的文档。单词 <code>and</code> 如果在所有都是中文的文档里可能是个低频词。在关于数据库的文档集合里，单词 <code>database</code> 可能是一个高频词项，它对搜索这个特定集合毫无帮助。</p>
</div>
<div class="paragraph">
<p>每种语言都存在一些非常常见的单词，它们对搜索没有太大价值。在 Elasticsearch 中，英语默认的停用词为:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a, an, and, are, as, at, be, but, by, for, if, in, into, is, it,
no, not, of, on, or, such, that, the, their, then, there, these,
they, this, to, was, will, with</pre>
</div>
</div>
<div class="paragraph">
<p>这些 <em>停用词</em> 通常在索引前就可以被过滤掉，同时对检索的负面影响不大。但是这样做真的是一个较好的解决方案？</p>
</div>
<div class="sect2">
<h3 id="pros-cons-stopwords">停用词的优缺点</h3>
<div class="paragraph">
<p>现在我们拥有更大的磁盘空间，更多内存，并且还有更好的压缩算法。 将之前的 33 个常见词从索引中移除，每百万文档只能节省 4MB 空间。 所以使用停用词减少索引大小不再是一个有效的理由。 (不过这种说法还有一点需要注意，我们在 <a href="#stopwords-phrases">停用词与短语查询</a> 讨论。)</p>
</div>
<div class="paragraph">
<p>在此基础上，从索引里将这些词移除会使我们降低某种类型的搜索能力。将前面这些所列单词移除会让我们难以完成以下事情：</p>
</div>
<div class="ulist">
<ul>
<li> <p>区分 <em>happy</em> 和 <em>not happy</em>。</p> </li>
<li> <p>搜索乐队名称 The The。</p> </li>
<li> <p>查找莎士比亚的名句 ``To be, or not to be'' （生存还是毁灭)。</p> </li>
<li> <p>使用挪威的国家代码: <code>no</code>。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>移除停用词的最主要好处是性能，假设我们在个具有上百万文档的索引中搜索单词 <code>fox</code>。或许 <code>fox 只在其中 20 个文档中出现，也就是说 Elasticsearch 需要计算 20 个文档的相关度评分 `_score `从而排出前十。现在我们把搜索条件改为 `the OR fox</code>，几乎所有的文件都包含 <code>the</code> 这个词，也就是说 Elasticsearch 需要为所有一百万文档计算评分 <code>_score</code>。 由此可见第二个查询肯定没有第一个的结果好。</p>
</div>
<div class="paragraph">
<p>幸运的是，我们可以用来保持常用词搜索，同时还可以保持良好的性能。首先我们一块学习如何使用停用词。</p>
</div>
</div>
<div class="sect2">
<h3 id="using-stopwords">使用停用词</h3>
<div class="paragraph">
<p>移除停用词的工作是由 <code>stop</code> 停用词过滤器完成的，可以通过创建自定义的分析器来使用它（参见 使用停用词过滤器https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stop-tokenfilter.html[<code>stop</code> 停用词过滤器])。但是，也有一些自带的分析器预置使用停用词过滤器：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-lang-analyzer.html">语言分析器</a>
</dt>
<dd>
<p>每个语言分析器默认使用与该语言相适的停用词列表，例如：<code>english</code> 英语分析器使用 <code><em>english</em></code> 停用词列表。</p>
</dd>
<dt class="hdlist1">
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-standard-analyzer.html"><code>standard</code> 标准分析器</a>
</dt>
<dd>
<p>默认使用空的停用词列表：<code><em>none</em></code> ，实际上是禁用了停用词。</p>
</dd>
<dt class="hdlist1">
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-pattern-analyzer.html"><code>pattern</code> 模式分析器</a>
</dt>
<dd>
<p>默认使用空的停用词列表：为 <code><em>none</em></code> ，与 <code>standard</code> 分析器类似。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_停用词和标准分析器_stopwords_and_the_standard_analyzer">停用词和标准分析器（Stopwords and the Standard Analyzer）</h4>
<div class="paragraph">
<p>为了让标准分析器能与自定义停用词表连用，我们要做的只需创建一个分析器的配置好的版本，然后将停用词列表传入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer": { <b class="conum">(1)</b>
          "type": "standard", <b class="conum">(2)</b>
          "stopwords": [ "and", "the" ] <b class="conum">(3)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>自定义的分析器名称为 <code>my_analyzer</code> 。</p> </li>
<li> <p>这个分析器是一个标准 <code>standard</code> 分析器，进行了一些自定义配置。</p> </li>
<li> <p>过滤掉的停用词包括 <code>and</code> 和 <code>the</code> 。</p> </li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content"> 任何语言分析器都可以使用相同的方式配置自定义停用词。 </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="maintaining-positions">保持位置（Maintaining Positions）</h4>
<div class="paragraph">
<p><code>analyzer</code> API的输出结果很有趣:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/_analyze?analyzer=my_analyzer
The quick and the dead</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
   "tokens": [
      {
         "token":        "quick",
         "start_offset": 4,
         "end_offset":   9,
         "type":         "&lt;ALPHANUM&gt;",
         "position":     1 <b class="conum">(1)</b>
      },
      {
         "token":        "dead",
         "start_offset": 18,
         "end_offset":   22,
         "type":         "&lt;ALPHANUM&gt;",
         "position":     4
      }
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>position</code> 标记每个词汇单元的位置。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>停用词如我们期望被过滤掉了，但有趣的是两个词项的位置 <code>position</code> 没有变化：<code>quick</code> 是原句子的第二个词，<code>dead</code> 是第五个。这对短语查询十分重要，因为如果每个词项的位置被调整了，一个短语查询 <code>quick dead</code> 会与以上示例中的文档错误匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="specifying-stopwords">指定停用词（Specifying Stopwords）</h4>
<div class="paragraph">
<p>停用词可以以内联的方式传入，就像我们在前面的例子中那样，通过指定数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">"stopwords": [ "and", "the" ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>特定语言的默认停用词，可以通过使用 <code><em>lang</em></code> 符号来指定:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">"stopwords": "_english_"</code></pre>
</div>
</div>
<div class="paragraph">
<p>TIP: Elasticsearch 中预定义的与语言相关的停用词列表可以在文档"languages", "predefined stopword lists for")<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stop-tokenfilter.html"><code>stop</code> 停用词过滤器</a> 中找到。</p>
</div>
<div class="paragraph">
<p>停用词可以通过指定一个特殊列表 <code><em>none</em></code> 来禁用。例如，使用 <code><em>english</em></code> 分析器而不使用停用词，可以通过以下方式做到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_english": {
          "type":      "english", <b class="conum">(1)</b>
          "stopwords": "_none_" <b class="conum">(2)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>my_english</code> 分析器是基于 <code>english</code> 分析器。</p> </li>
<li> <p>但禁用了停用词。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>最后，停用词还可以使用一行一个单词的格式保存在文件中。此文件必须在集群的所有节点上，并且通过 <code>stopwords_path</code> 参数设置路径:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_english": {
          "type":           "english",
          "stopwords_path": "stopwords/english.txt" <b class="conum">(1)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>停用词文件的路径，该路径相对于 Elasticsearch 的 <code>config</code> 目录。</p> </li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="stop-token-filter">使用停用词过滤器（Using the stop Token Filter）</h4>
<div class="paragraph">
<p>当你创建 <code>custom</code> 分析器时候，可以组合多个 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stop-tokenfilter.html"><code>stop</code> 停用词过滤器</a> 分词器。例如：我们想要创建一个西班牙语的分析器:</p>
</div>
<div class="ulist">
<ul>
<li> <p>自定义停用词列表</p> </li>
<li> <p><code>light_spanish</code> 词干提取器</p> </li>
<li> <p>在 <code>asciifolding</code> 词汇单元过滤器中除去附加符号</p> </li>
</ul>
</div>
<div class="paragraph">
<p>我们可以通过以下设置完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "filter": {
        "spanish_stop": {
          "type":        "stop",
          "stopwords": [ "si", "esta", "el", "la" ]  <b class="conum">(1)</b>
        },
        "light_spanish": { <b class="conum">(2)</b>
          "type":     "stemmer",
          "language": "light_spanish"
        }
      },
      "analyzer": {
        "my_spanish": {
          "tokenizer": "spanish",
          "filter": [ <b class="conum">(3)</b>
            "lowercase",
            "asciifolding",
            "spanish_stop",
            "light_spanish"
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>停用词过滤器采用与 <code>standard</code> 分析器相同的参数 <code>stopwords</code> 和 <code>stopwords_path</code> 。</p> </li>
<li> <p>参见 算法提取器（Algorithmic Stemmers）。</p> </li>
<li> <p>过滤器的顺序非常重要，下面会进行解释。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>我们将 <code>spanish_stop</code> 过滤器放置在 <code>asciifolding</code> 过滤器之后.这意味着以下三个词组 <code>esta</code> 、<code>ésta</code> 、<code>está</code> ，先通过 <code>asciifolding</code> 过滤器过滤掉特殊字符变成了 <code>esta</code> ，随后使用停用词过滤器会将 <code>esta</code> 去除。 如果我们只想移除 <code>esta</code> 和 <code>ésta</code> ，但是 <code>está</code> 不想移除。必须将 <code>spanish_stop</code> 过滤器放置在 <code>asciifolding</code> 之前，并且需要在停用词中指定 <code>esta</code> 和 <code>ésta</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="updating-stopwords">更新停用词（Updating Stopwords）</h4>
<div class="paragraph">
<p>想要更新分析器的停用词列表有多种方式， 分析器在创建索引时，当集群节点重启时候，或者关闭的索引重新打开的时候。</p>
</div>
<div class="paragraph">
<p>如果你使用 <code>stopwords</code> 参数以内联方式指定停用词，那么你只能通过关闭索引，更新分析器的配置https://www.elastic.co/guide/en/elasticsearch/reference/5.6/indices-update-settings.html#update-settings-analysis[update index settings API]，然后在重新打开索引才能更新停用词。</p>
</div>
<div class="paragraph">
<p>如果你使用 <code>stopwords_path</code> 参数指定停用词的文件路径 ，那么更新停用词就简单了。你只需更新文件(在每一个集群节点上)，然后通过两者之中的任何一个操作来强制重新创建分析器:</p>
</div>
<div class="ulist">
<ul>
<li> <p>关闭和重新打开索引 (参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/indices-open-close.html">索引的开与关</a>)，</p> </li>
<li> <p>一一重启集群下的每个节点。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>当然，更新的停用词不会改变任何已经存在的索引。这些停用词的只适用于新的搜索或更新文档。如果要改变现有的文档，则需要重新索引数据。参加 <a href="#reindex">重新索引你的数据</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stopwords-performance">停用词与性能</h3>
<div class="paragraph">
<p>保留停用词最大的缺点就影响搜索性能。使用 Elasticsearch 进行全文搜索，它需要为所有匹配的文档计算相关度评分 <code>_score</code> 从而返回最相关的前 10 个文档。</p>
</div>
<div class="paragraph">
<p>通常大多数的单词在所有文档中出现的频率低于0.1％，但是有少数词（例如 <code>the</code> ）几乎存在于所有的文档中。假设有一个索引含有100万个文档，查询 <code>quick brown fox</code> 词组，能够匹配上的可能少于1000个文档。但是如果查询 <code>the quick brown fox</code> 词组，几乎需要对索引中的100万个文档进行评分和排序，只是为了返回前 10 名最相关的文档。</p>
</div>
<div class="paragraph">
<p>问题的关键是 <code>the quick brown fox</code> 词组实际是查询 <code>the</code> 或 <code>quick</code> 或 <code>brown</code> 或 <code>fox</code>— 任何文档即使它什么内容都没有而只包含 <code>the</code> 这个词也会被包括在结果集中。因此，我们需要找到一种降低待评分文档数量的方法。</p>
</div>
<div class="sect3">
<h4 id="stopwords-and">and 操作符 (and Operator)</h4>
<div class="paragraph">
<p>我们想要减少待评分文档的数量，最简单的方式就是在<a href="#match-improving-precision"><code>and</code> 操作符</a> <code>match</code> 查询时使用 <code>and</code> 操作符，这样可以让所有词都是必须的。</p>
</div>
<div class="paragraph">
<p>以下是 <code>match</code> 查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "match": {
        "text": {
            "query":    "the quick brown fox",
            "operator": "and"
             }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述查询被重写为 <code>bool</code> 查询如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "bool": {
        "must": [
            { "term": { "text": "the" }},
            { "term": { "text": "quick" }},
            { "term": { "text": "brown" }},
            { "term": { "text": "fox" }}
        ]
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>bool</code> 查询会智能的根据较优的顺序依次执行每个 <code>term</code> 查询：它会从最低频的词开始。因为所有词项都必须匹配，只要包含低频词的文档才有可能匹配。使用 <code>and</code> 操作符可以大大提升多词查询的速度。</p>
</div>
</div>
<div class="sect3">
<h4 id="_最少匹配数_minimum_should_match">最少匹配数(minimum_should_match)</h4>
<div class="paragraph">
<p>在精度匹配<a href="#match-precision">控制精度</a>的章节里面，我们讨论过使用 <code>minimum_should_match</code> 配置去掉结果中次相关的长尾。虽然它只对这个目的奏效，但是也为我们从侧面带来一个好处，它提供 <code>and</code> 操作符相似的性能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "match": {
        "text": {
            "query": "the quick brown fox",
            "minimum_should_match": "75%"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面这个示例中，四分之三的词都必须匹配，这意味着我们只需考虑那些包含最低频或次低频词的文档。 相比默认使用 <code>or</code> 操作符的简单查询，这为我们带来了巨大的性能提升。不过我们有办法可以做得更好……</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="common-terms">词项的分别管理</h3>
<div class="paragraph">
<p>在查询字符串中的词项可以分为更重要（低频词）和次重要（高频词）这两类。 只与次重要词项匹配的文档很有可能不太相关。实际上，我们想要文档能尽可能多的匹配那些更重要的词项。</p>
</div>
<div class="paragraph">
<p><code>match</code> 查询接受一个参数 <code>cutoff_frequency</code> ，从而可以让它将查询字符串里的词项分为低频和高频两组。低频组（更重要的词项）组成 <code>bulk</code> 大量查询条件，而高频组（次重要的词项）只会用来评分，而不参与匹配过程。通过对这两组词的区分处理，我们可以在之前慢查询的基础上获得巨大的速度提升。</p>
</div>
<div class="paragraph">
<p>领域相关的停用词（Domain-Specific Stopwords）</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><code>cutoff_frequency</code> 配置的好处是，你在 <em>特定领域</em> 使用停用词不受约束。例如，关于电影网站使用的词 <em>movie</em> 、 <em>color</em> 、 <em>black</em> 和 <em>white</em> ，这些词我们往往认为几乎没有任何意义。使用 <code>stop</code> 词汇单元过滤器，这些特定领域的词必须手动添加到停用词列表中。然而 <code>cutoff_frequency</code> 会查看索引里词项的具体频率，这些词会被自动归类为 <em>高频词汇</em> 。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下面查询为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "match": {
    "text": {
      "query": "Quick and the dead",
      "cutoff_frequency": 0.01 <b class="conum">(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>任何词项出现在文档中超过1%，被认为是高频词。<code>cutoff_frequency</code> 配置可以指定为一个分数（ <code>0.01</code> ）或者一个正整数（ <code>5</code> ）。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>此查询通过 <code>cutoff_frequency</code> 配置，将查询条件划分为低频组（ <code>quick</code> , <code>dead</code> ）和高频组（ <code>and</code> , <code>the</code> ）。然后，此查询会被重写为以下的 <code>bool</code> 查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "bool": {
    "must": { <b class="conum">(1)</b>
      "bool": {
        "should": [
          { "term": { "text": "quick" }},
          { "term": { "text": "dead"  }}
        ]
      }
    },
    "should": { <b class="conum">(2)</b>
      "bool": {
        "should": [
          { "term": { "text": "and" }},
          { "term": { "text": "the" }}
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>必须匹配至少一个低频／更重要的词项。</p> </li>
<li> <p>高频/次重要性词项是非必须的。</p> </li>
</ol>
</div>
<div class="paragraph">
<p><code>must</code> 意味着至少有一个低频词— <code>quick</code> 或者 <code>dead</code> —必须出现在被匹配文档中。所有其他的文档被排除在外。 <code>should</code> 语句查找高频词 <code>and</code> 和 <code>the</code> ，但也只是在 <code>must</code> 语句查询的结果集文档中查询。 <code>should</code> 语句的唯一的工作就是在对如 <code>Quick <em>and the</em> dead</code> 和 <code><em>The</em> quick but　dead</code> 语句进行评分时，前者得分比后者高。这种方式可以大大减少需要进行评分计算的文档数量。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>将操作符参数设置成 <code>and</code> 会要求所有低频词都必须匹配，同时对包含所有高频词的文档给予更高评分。但是，在匹配文档时，并不要求文档必须包含所有高频词。如果希望文档包含所有的低频和高频词，我们应该使用一个 <code>bool</code> 来替代。正如我们在<a href="#stopwords-and">and 操作符 (and Operator)</a>中看到的，它的查询效率已经很高了。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_控制精度_2">控制精度</h4>
<div class="paragraph">
<p><code>minimum_should_match</code> 参数可以与 <code>cutoff_frequency</code> 组合使用，但是此参数仅适用与低频词。如以下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "match": {
    "text": {
      "query": "Quick and the dead",
      "cutoff_frequency": 0.01,
      "minimum_should_match": "75%"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将被重写为如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "bool": {
    "must": {
      "bool": {
        "should": [
          { "term": { "text": "quick" }},
          { "term": { "text": "dead"  }}
        ],
        "minimum_should_match": 1 <b class="conum">(1)</b>
      }
    },
    "should": { <b class="conum">(2)</b>
      "bool": {
        "should": [
          { "term": { "text": "and" }},
          { "term": { "text": "the" }}
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;1&gt;　因为只有两个词，原来的75%向下取整为 <code>1</code> ，意思是：必须匹配低频词的两者之一。 &lt;2&gt;　高频词仍可选的，并且仅用于评分使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_高频词">高频词</h4>
<div class="paragraph">
<p>当使用 <code>or</code> 查询高频词条，如— <code>To be, or not to be</code> —进行查询时性能最差。只是为了返回最匹配的前十个结果就对只是包含这些词的所有文档进行评分是盲目的。我们真正的意图是查询整个词条出现的文档，所以在这种情况下，不存低频所言，这个查询需要重写为所有高频词条都必须：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "bool": {
    "must": [
      { "term": { "text": "to" }},
      { "term": { "text": "be" }},
      { "term": { "text": "or" }},
      { "term": { "text": "not" }},
      { "term": { "text": "to" }},
      { "term": { "text": "be" }}
    ]
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_对常用词使用更多控制_more_control_with_common_terms">对常用词使用更多控制（More Control with Common Terms）</h4>
<div class="paragraph">
<p>尽管高频/低频的功能在 <code>match</code> 查询中是有用的，有时我们还希望能对它有更多的控制，想控制它对高频和低频词分组的行为。　<code>match</code> 查询针对 <code>common</code> 词项查询提供了一组功能。</p>
</div>
<div class="paragraph">
<p>例如，我们可以让所有低频词都必须匹配，而只对那些包括超过 75% 的高频词文档进行评分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "common": {
    "text": {
      "query":                  "Quick and the dead",
      "cutoff_frequency":       0.01,
      "low_freq_operator":      "and",
      "minimum_should_match": {
        "high_freq":            "75%"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多配置项参见　<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/query-dsl-common-terms-query.html"><code>common</code> terms query</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stopwords-phrases">停用词与短语查询</h3>
<div class="paragraph">
<p>所有查询中 <a href="#phrase-matching">短语匹配</a> 大约占到5%，但是在慢查询里面它们又占大部分。 短语查询性能相对较差，特别是当短语中包括常用词的时候，如 <code>“To be, or not to be”</code> 短语全部由停用词组成，这是一种极端情况。原因在于几乎需要匹配全量的数据。</p>
</div>
<div class="paragraph">
<p>在 停用词的两面 <a href="#pros-cons-stopwords">停用词的优缺点</a>,中，我们提到移除停用词只能节省倒排索引中的一小部分空间。这句话只部分正确，一个典型的索引会可能包含部分或所有以下数据：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
词项字典（Terms dictionary）
</dt>
<dd>
<p>索引中所有文档内所有词项的有序列表，以及包含该词的文档数量。</p>
</dd>
<dt class="hdlist1">
倒排表（Postings list）
</dt>
<dd>
<p>包含每个词项的文档（ID）列表。</p>
</dd>
<dt class="hdlist1">
词频（Term frequency）
</dt>
<dd>
<p>每个词项在每个文档里出现的频率。</p>
</dd>
<dt class="hdlist1">
位置（Positions）
</dt>
<dd>
<p>每个词项在每个文档里出现的位置，供短语查询或近似查询使用。</p>
</dd>
<dt class="hdlist1">
偏移（Offsets）
</dt>
<dd>
<p>每个词项在每个文档里开始与结束字符的偏移，供词语高亮使用，默认是禁用的。</p>
</dd>
<dt class="hdlist1">
规范因子（Norms）
</dt>
<dd>
<p>用来对字段长度进行规范化处理的因子，给较短字段予以更多权重。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>将停用词从索引中移除会节省 <em>词项字典</em> 和 <em>倒排表</em> 里的少量空间，但 <em>位置</em> 和 <em>偏移</em> 是另一码事。位置和偏移数据很容易变成索引大小的两倍、三倍、甚至四倍。</p>
</div>
<div class="sect3">
<h4 id="_位置信息">位置信息</h4>
<div class="paragraph">
<p><code>analyzed</code> 字符串字段的位置信息默认是开启的， 所以短语查询能随时使用到它。 词项出现的越频繁，用来存储它位置信息的空间就越多。在一个大的文档集合中，对于那些非常常见的词，它们的位置信息可能占用成百上千兆的空间。</p>
</div>
<div class="paragraph">
<p>运行一个针对高频词 <code>the</code> 的短语查询可能会导致从磁盘读取好几G的数据。这些数据会被存储到内核文件系统的缓存中，以提高后续访问的速度，这看似是件好事，但这可能会导致其他数据从缓存中被剔除，进一步使后续查询变慢。</p>
</div>
<div class="paragraph">
<p>这显然是我们需要解决的问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="index-options">索引选项</h4>
<div class="paragraph">
<p>我们首先应该问自己：是否真的需要使用短语查询或 近似查询？</p>
</div>
<div class="paragraph">
<p>答案通常是：不需要。在很多应用场景下，比如说日志，我们需要知道一个词 <em>是否</em> 在文档中（这个信息由倒排表提供）而不是关心词的位置在哪里。或许我们要对一两个字段使用短语查询，但是我们完全可以在其他 <code>analyzed</code> 字符串字段上禁用位置信息。</p>
</div>
<div class="paragraph">
<p><code>index_options</code> 参数 允许我们控制索引里为每个字段存储的信息。 可选值如下:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>docs</code>
</dt>
<dd>
<p>只存储文档及其包含词项的信息。这对 <code>not_analyzed</code> 字符串字段是默认的。</p>
</dd>
<dt class="hdlist1">
<code>freqs</code>
</dt>
<dd>
<p>存储 <code>docs</code> 信息，以及每个词在每个文档里出现的频次。词频是完成<a href="#relevance-intro">TF/IDF</a> 相关度计算的必要条件，但如果只想知道一个文档是否包含某个特定词项，则无需使用它。</p>
</dd>
<dt class="hdlist1">
<code>positions</code>
</dt>
<dd>
<p>存储 <code>docs</code> 、 <code>freqs</code> 、 <code>analyzed</code> ，以及每个词项在每个文档里出现的位置。 这对 <code>analyzed</code> 字符串字段是默认的，但当不需使用短语或近似匹配时，可以将其禁用。</p>
</dd>
<dt class="hdlist1">
<code>offsets</code>
</dt>
<dd>
<p>存储 <code>docs</code>,<code>freqs</code>,<code>positions</code>, 以及每个词在原始字符串中开始与结束字符的偏移信息( <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-request-highlighting.html#postings-highlighter"><code>postings</code> highlighter</a> )。这个信息被用以高亮搜索结果，但它默认是禁用的。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>我们可以在索引创建的时候为字段设置 <code>index_options</code> 选项，或者在使用 <code>put-mapping</code> API新增字段映射的时候设置。我们无法修改已有字段的这个设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "mappings": {
    "my_type": {
      "properties": {
        "title": { <b class="conum">(1)</b>
          "type":          "string"
       },
        "content": { <b class="conum">(2)</b>
          "type":          "string",
          "index_options": "freqs"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>title</code> 字段使用默认的 <code>positions</code> 设置，所以它适于短语或近似查询。</p> </li>
<li> <p><code>content</code> 字段的位置设置是禁用的，所以它无法用于短语或近似查询。</p> </li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_停用词">停用词</h4>
<div class="paragraph">
<p>删除停用词是能显著降低位置信息所占空间的一种方式。 一个被删除停用词的索引仍然可以使用短语查询，因为剩下的词的原始位置仍然被保存着，这正如 <a href="#maintaining-positions">保持位置（Maintaining Positions）</a> 中看到的那样。 尽管如此，将词项从索引中排除终究会降低搜索能力，这使我们难以区分 <em>Man in the moon</em> 与 <em>Man on the moon</em> 这两个短语。</p>
</div>
<div class="paragraph">
<p>幸运的是，鱼与熊掌是可以兼得的：请查看 <a href="#common-grams"><code>common_grams</code> 过滤器</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="common-grams">common_grams 过滤器</h3>
<div class="paragraph">
<p><code>common_grams</code> 过滤器是针对短语查询能更高效的使用停用词而设计的。 它与 shingles 过滤器类似（参见 查找相关词（<a href="#shingles">寻找相关词</a>)), 为每个相邻词对生成 ，用示例解释更为容易。</p>
</div>
<div class="paragraph">
<p><code>common_grams</code> 过滤器根据 <code>query_mode</code> 设置的不同而生成不同输出结果：<code>false</code> （为索引使用） 或 <code>true</code> （为搜索使用），所以我们必须创建两个独立的分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index
{
  "settings": {
    "analysis": {
      "filter": {
        "index_filter": { <b class="conum">(1)</b>
          "type":         "common_grams",
          "common_words": "_english_" <b class="conum">(2)</b>
        },
        "search_filter": { <b class="conum">(1)</b>
          "type":         "common_grams",
          "common_words": "_english_", <b class="conum">(2)</b>
          "query_mode":   true
        }
      },
      "analyzer": {
        "index_grams": { <b class="conum">(3)</b>
          "tokenizer":  "standard",
          "filter":   [ "lowercase", "index_filter" ]
        },
        "search_grams": { <b class="conum">(3)</b>
          "tokenizer": "standard",
          "filter":  [ "lowercase", "search_filter" ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>首先我们基于 <code>common_grams</code> 过滤器创建两个过滤器： <code>index_filter</code> 在索引时使用（此时 <code>query_mode</code> 的默认设置是 <code>false</code> ）， <code>search_filter</code> 在查询时使用（此时 <code>query_mode</code> 的默认设置是 <code>true</code> ）。</p> </li>
<li> <p><code>common_words</code> 参数可以接受与 <code>stopwords</code> 参数同样的选项（参见 指定停用词 <a href="#specifying-stopwords">指定停用词（Specifying Stopwords）</a> ）。这个过滤器还可以接受参数 <code>common_words_path</code> ，使用存于文件里的常用词。</p> </li>
<li> <p>然后我们使用过滤器各创建一个索引时分析器和查询时分析器。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>有了自定义分析器，我们可以创建一个字段在索引时使用 <code>index_grams</code> 分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_index/_mapping/my_type
{
  "properties": {
    "text": {
      "type":            "string",
      "analyzer":  "index_grams", <b class="conum">(1)</b>
      "search_analyzer": "standard" <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>text</code> 字段索引时使用 <code>index_grams</code> 分析器，但是在搜索时默认使用 <code>standard</code> 分析器，稍后我们会解释其原因。</p> </li>
</ol>
</div>
<div class="sect3">
<h4 id="_索引时_at_index_time">索引时（At Index Time）</h4>
<div class="paragraph">
<p>如果我们对短语 <em>The quick and brown fox</em> 进行拆分，它生成如下词项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Pos 1: the_quick
Pos 2: quick_and
Pos 3: and_brown
Pos 4: brown_fox</code></pre>
</div>
</div>
<div class="paragraph">
<p>新的 <code>index_grams</code> 分析器生成以下词项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Pos 1: the, the_quick
Pos 2: quick, quick_and
Pos 3: and, and_brown
Pos 4: brown
Pos 5: fox</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的词项都是以 <code>unigrams</code> 形式输出的（the、quick 等等），但是如果一个词本身是常用词或者跟随着常用词，那么它同时还会在 <code>unigram</code> 同样的位置以 <code>bigram</code> 形式输出：<code>the_quick</code> ， <code>quick_and</code> ， <code>and_brown</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_单字查询_unigram_queries">单字查询（Unigram Queries）</h4>
<div class="paragraph">
<p>因为索引包含 <code>unigrams</code> ，可以使用与其他字段相同的技术进行查询，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/_search
{
  "query": {
    "match": {
      "text": {
        "query": "the quick and brown fox",
        "cutoff_frequency": 0.01
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面这个查询字符串是通过为文本字段配置的 <code>search_analyzer</code> 分析器 --本例中使用的是 <code>standard</code> 分析器-- 进行分析的， 它生成的词项为： <code>the</code> ， <code>quick</code> ， <code>and</code> ， <code>brown</code> ， <code>fox</code> 。</p>
</div>
<div class="paragraph">
<p>因为 <code>text</code> 字段的索引中包含与 <code>standard</code> 分析去生成的一样的 <code>unigrams</code> ，搜索对于任何普通字段都能正常工作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_二元语法短语查询_bigram_phrase_queries">二元语法短语查询（Bigram Phrase Queries）</h4>
<div class="paragraph">
<p>但是，当我们进行短语查询时，我们可以用专门的 <code>search_grams</code> 分析器让整个过程变得更高效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/_search
{
  "query": {
    "match_phrase": {
      "text": {
        "query":    "The quick and brown fox",
        "analyzer": "search_grams" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>对于短语查询，我们重写了默认的 <code>search_analyzer</code> 分析器，而使用 <code>search_grams</code> 分析器。</p> </li>
</ol>
</div>
<div class="paragraph">
<p><code>search_grams</code> 分析器会生成以下词项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Pos 1: the_quick
Pos 2: quick_and
Pos 3: and_brown
Pos 4: brown
Pos 5: fox</code></pre>
</div>
</div>
<div class="paragraph">
<p>分析器排除了所有常用词的 <code>unigrams</code>，只留下常用词的 <code>bigrams</code> 以及低频的 <code>unigrams</code>。如 <code>the_quick</code> 这样的 <code>bigrams</code> 比单个词项 <code>the</code> 更为少见，这样有两个好处：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>the_quick</code> 的位置信息要比 <code>the</code> 的小得多，所以它读取磁盘更快，对系统缓存的影响也更小。</p> </li>
<li> <p>词项 <code>the_quick</code> 没有 <code>the</code> 那么常见，所以它可以大量减少需要计算的文档。</p> </li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_两词短语_two_word_phrases">两词短语（Two-Word Phrases）</h4>
<div class="paragraph">
<p>我们的优化可以更进一步，因为大多数的短语查询只由两个词组成，如果其中一个恰好又是常用词，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /my_index/_search
{
  "query": {
    "match_phrase": {
      "text": {
        "query":    "The quick",
        "analyzer": "search_grams"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么 <code>search_grams</code> 分析器会输出单个语汇单元：<code>the_quick</code> 。这将原来昂贵的查询（查询 <code>the</code> 和 <code>quick</code> ）转换成了对单个词项的高效查找。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stopwords-relavance">停用词与相关性</h3>
<div class="paragraph">
<p>在结束停用词相关内容之前，最后一个话题是关于相关性的。在索引中保留停用词会降低相关度计算的准确性，特别是当我们的文档非常长时。</p>
</div>
<div class="paragraph">
<p>正如我们在 <a href="#bm25-saturation">词频饱和度</a> 已经讨论过的， 原因在于 <a href="#bm25-saturation">词频饱和度</a> 并没有强制对词频率的影响设置上限 。 基于逆文档频率的影响，非常常用的词可能只有很低的权重，但是在长文档中，单个文档出现的绝对数量很大的停用词会导致这些词被不自然的加权。</p>
</div>
<div class="paragraph">
<p>可以考虑对包含停用词的较长字段使用 <a href="#bm25">Okapi BM25</a> 相似度算法，而不是默认的 Lucene 相似度。</p>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/57/index.html">
<img class="uk-book-cover" src="../../static/icons/48/influxdb_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/57/index.html">InfluxDB简明手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/33.html">xtutu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="influxdb">influxdb</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">18页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 199个">199</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/188/index.html">
<img class="uk-book-cover" src="../../static/icons/48/git_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/188/index.html">git基本概念，git flow，git提交规范，git插件以及常见问题解决</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="git">git</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/187/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/187/index.html">软件开发的工程化</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 112个">112</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/175/index.html">
<img class="uk-book-cover" src="../../static/icons/48/nodejs_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/175/index.html">Node.js面试题，侧重后端应用与对Node核心的理解</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/97.html">jimuyouyou</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="nodejs">nodejs</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">8页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1483个">1483</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/165/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/165/index.html">Python学习知识库</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/94.html">coco369</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">85页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 190个">190</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/189/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/189/index.html">每日 30 秒 , 一段代码 ,一个场景</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/106.html">pushmetop</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">46页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 265个">265</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9277;var bookPageRelUrl ='stopwords.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>