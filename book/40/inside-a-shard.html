
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>分片内部原理-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='分片内部原理,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='分片内部原理,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/index-management.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">索引管理</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/search-in-depth.html">
<span class="">深入搜索</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="inside-a-shard">分片内部原理</h2>
<div class="paragraph">
<p>在 <a href="#distributed-cluster">集群内的原理</a>, 我们介绍了 <em>分片</em>, 并将它 描述成最小的 <em>工作单元</em>。但是究竟什么 <em>是</em> 一个分片，它是如何工作的？ 在这个章节，我们回答以下问题:</p>
</div>
<div class="ulist">
<ul>
<li> <p>为什么搜索是 <em>近</em> 实时的？</p> </li>
<li> <p>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 <em>实时</em> 的?</p> </li>
<li> <p>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</p> </li>
<li> <p>为什么删除文档不会立刻释放空间？</p> </li>
<li> <p><code>refresh</code>, <code>flush</code>, 和 <code>optimize</code> API 都做了什么, 你什么情况下应该是用他们？</p> </li>
</ul>
</div>
<div class="paragraph">
<p>最简单的理解一个分片如何工作的方式是上一堂历史课。 我们将要审视提供一个带近实时搜索和分析的 分布式持久化数据存储需要解决的问题。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
内容警告
</div>
<div class="paragraph">
<p>本章展示的这些信息仅供您兴趣阅读。为了使用 Elasticsearch 您并不需要理解和记忆所有的细节。 读这个章节是为了了解工作机制，并且为了将来您需要这些信息时，知道这些信息在哪里。但是不要被这些细节所累。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="making-text-searchable">使文本可被搜索</h3>
<div class="paragraph">
<p>必须解决的第一个挑战是如何使文本可被搜索。 传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值(这里指单词)的能力。</p>
</div>
<div class="paragraph">
<p>最好的支持 <em>一个字段多个值</em> 需求的数据结构是我们在 <a href="#inverted-index">倒排索引</a> 章节中介绍过的 <em>倒排索引</em> 。 倒排索引包含一个有序列表，列表包含所有文档出现过的不重复个体，或称为 <em>词项</em> ，对于每一个词项，包含了它所有曾出现过文档的列表。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Term  | Doc 1 | Doc 2 | Doc 3 | ...
------------------------------------
brown |   X   |       |  X    | ...
fox   |   X   |   X   |  X    | ...
quick |   X   |   X   |       | ...
the   |   X   |       |  X    | ...</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>当讨论倒排索引时，我们会谈到 <em>文档</em> 标引，因为历史原因，倒排索引被用来对整个非结构化文本文档进行标引。 Elasticsearch 中的 <em>文档</em> 是有字段和值的结构化 JSON 文档。事实上，在 JSON 文档中， 每个被索引的字段都有自己的倒排索引。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数， 在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息允许 Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，这些内容在 <a href="#relevance-intro">什么是相关性?</a> 中有描述。</p>
</div>
<div class="paragraph">
<p>为了能够实现预期功能，倒排索引需要知道集合中的 <em>所有</em> 文档，这是需要认识到的关键问题。</p>
</div>
<div class="paragraph">
<p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_不变性">不变性</h4>
<div class="paragraph">
<p>倒排索引被写入磁盘后是 <em>不可改变</em> 的:它永远不会修改。 不变性有重要的价值：</p>
</div>
<div class="ulist">
<ul>
<li> <p>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</p> </li>
<li> <p>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</p> </li>
<li> <p>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</p> </li>
<li> <p>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-indices">动态更新索引</h3>
<div class="paragraph">
<p>下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？答案是: 用更多的索引。</p>
</div>
<div class="paragraph">
<p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到—​从最早的开始—​查询完后再对结果进行合并。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 基于 Lucene, 这个 java 库引入了 <em>按段搜索</em> 的概念。 每一 <em>段</em> 本身都是一个倒排索引， 但 <em>索引</em> 在 Lucene 中除表示所有 <em>段</em> 的集合外， 还增加了 <em>提交点</em> 的概念 — 一个列出了所有已知段的文件，就像在 <a href="#img-index-segments">一个 Lucene 索引包含一个提交点和三个段</a> 中描绘的那样。 如 <a href="#img-memory-buffer">一个在内存缓存中包含新文档的 Lucene 索引</a> 所示，新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，如 <a href="#img-post-commit">在一次提交后，一个新的段被添加到提交点而且缓存被清空。</a> 所示。</p>
</div>
<div id="img-index-segments" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1101.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1101.png" alt="A Lucene index with a commit point and three segments"></a>
</div>
<div class="title">
Figure 16. 一个 Lucene 索引包含一个提交点和三个段
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
索引与分片的比较
</div>
<div class="paragraph">
<p>被混淆的概念是，一个 <em>Lucene 索引</em> 我们在 Elasticsearch 称作 <em>分片</em> 。 一个 Elasticsearch <em>索引</em> 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 <a href="#distributed-search">执行分布式检索</a> 提到的那样，合并每个分片的结果到一个全局的结果集。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>逐段搜索会以如下流程进行工作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>新文档被收集到内存索引缓存， 见 <a href="#img-memory-buffer">一个在内存缓存中包含新文档的 Lucene 索引</a> 。</p> </li>
<li> <p>不时地, 缓存被 <em>提交</em> ：</p>
<div class="ulist">
<ul>
<li> <p>一个新的段—​一个追加的倒排索引—​被写入磁盘。</p> </li>
<li> <p>一个新的包含新段名字的 <em>提交点</em> 被写入磁盘。</p> </li>
<li> <p>磁盘进行 <em>同步</em> &amp;#x2014; 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。</p> </li>
</ul>
</div> </li>
<li> <p>新的段被开启，让它包含的文档可见以被搜索。</p> </li>
<li> <p>内存缓存被清空，等待接收新的文档。</p> </li>
</ol>
</div>
<div id="img-memory-buffer" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1102.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1102.png" alt="A Lucene index with new documents in the in-memory buffer, ready to commit"></a>
</div>
<div class="title">
Figure 17. 一个在内存缓存中包含新文档的 Lucene 索引
</div>
</div>
<div id="img-post-commit" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1103.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1103.png" alt="After a commit, a new segment is added to the index and the buffer is cleared"></a>
</div>
<div class="title">
Figure 18. 在一次提交后，一个新的段被添加到提交点而且缓存被清空。
</div>
</div>
<div class="paragraph">
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。 这种方式可以用相对较低的成本将新文档添加到索引。</p>
</div>
<div class="sect3">
<h4 id="deletes-and-updates">删除和更新</h4>
<div class="paragraph">
<p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 <code>.del</code> 文件，文件中会列出这些被删除文档的段信息。</p>
</div>
<div class="paragraph">
<p>当一个文档被 “删除” 时，它实际上只是在 <code>.del</code> 文件中被 <em>标记</em> 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</p>
</div>
<div class="paragraph">
<p>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
</div>
<div class="paragraph">
<p>在 <a href="#merge-process">段合并</a> , 我们展示了一个被删除的文档是怎样被文件系统移除的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="near-real-time">近实时搜索</h3>
<div class="paragraph">
<p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。</p>
</div>
<div class="paragraph">
<p>磁盘在这里成为了瓶颈。提交（Commiting）一个新的段到磁盘需要一个 <a href="http://en.wikipedia.org/wiki/Fsync"><code>fsync</code></a> 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 <code>fsync</code> 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
</div>
<div class="paragraph">
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着 <code>fsync</code> 要从整个过程中被移除。</p>
</div>
<div class="paragraph">
<p>在Elasticsearch和磁盘之间是文件系统缓存。 像之前描述的一样， 在内存索引缓冲区（ <a href="#img-pre-refresh">在内存缓冲区中包含了新文档的 Lucene 索引</a> ）中的文档会被写入到一个新的段中（ <a href="#img-post-refresh">缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交</a> ）。 但是这里新段会被先写入到文件系统缓存—​这一步代价会比较低，稍后再被刷新到磁盘—​这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。</p>
</div>
<div id="img-pre-refresh" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1104.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1104.png" alt="A Lucene index with new documents in the in-memory buffer"></a>
</div>
<div class="title">
Figure 19. 在内存缓冲区中包含了新文档的 Lucene 索引
</div>
</div>
<div class="paragraph">
<p>Lucene 允许新段被写入和打开—​使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
</div>
<div id="img-post-refresh" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1105.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1105.png" alt="The buffer contents have been written to a segment, which is searchable, but is not yet commited"></a>
</div>
<div class="title">
Figure 20. 缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交
</div>
</div>
<div class="sect3">
<h4 id="refresh-api">refresh API</h4>
<div class="paragraph">
<p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 <em>refresh</em> 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是 <em>近</em> 实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
</div>
<div class="paragraph">
<p>这些行为可能会对新用户造成困惑: 他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 <code>refresh</code> API 执行一次手动刷新:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /_refresh <b class="conum">(1)</b>
POST /blogs/_refresh <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>刷新（Refresh）所有的索引。</p> </li>
<li> <p>只刷新（Refresh） <code>blogs</code> 索引。</p> </li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候， 手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。 相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 <code>refresh_interval</code> ， 降低每个索引的刷新频率：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_logs
{
  "settings": {
    "refresh_interval": "30s" <b class="conum">(1)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>每30秒刷新 <code>my_logs</code> 索引。</p> </li>
</ol>
</div>
<div class="paragraph">
<p><code>refresh_interval</code> 可以在既存索引上进行动态更新。 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_logs/_settings
{ "refresh_interval": -1 } <b class="conum">(1)</b>

PUT /my_logs/_settings
{ "refresh_interval": "1s" } <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>关闭自动刷新。</p> </li>
<li> <p>每秒自动刷新。</p> </li>
</ol>
</div>
<div class="admonitionblock caution">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Caution
</div> </td>
<td class="content"> <code>refresh_interval</code> 需要一个 <em>持续时间</em> 值， 例如 <code>1s</code> （1 秒） 或 <code>2m</code> （2 分钟）。 一个绝对值 <em>1</em> 表示的是 <em>1毫秒</em> --无疑会使你的集群陷入瘫痪。 </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="translog">持久化变更</h3>
<div class="paragraph">
<p>如果没有用 <code>fsync</code> 把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证 Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。</p>
</div>
<div class="paragraph">
<p>在 <a href="#dynamic-indices">动态更新索引</a>，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
</div>
<div class="paragraph">
<p>即使通过每秒刷新（refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？我们也不希望丢失掉这些数据。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 增加了一个 <em>translog</em> ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。通过 translog ，整个流程看起来是下面这样：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>一个文档被索引之后，就会被添加到内存缓冲区，<em>并且</em> 追加到了 translog ，正如 <a href="#img-xlog-pre-refresh">新的文档被添加到内存缓冲区并且被追加到了事务日志</a> 描述的一样。</p>
<div id="img-xlog-pre-refresh" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1106.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1106.png" alt="New documents are added to the in-memory buffer and appended to the transaction log"></a>
</div>
<div class="title">
Figure 21. 新的文档被添加到内存缓冲区并且被追加到了事务日志
</div>
</div> </li>
<li> <p>刷新（refresh）使分片处于 <a href="#img-xlog-post-refresh">刷新（refresh）完成后, 缓存被清空但是事务日志不会</a> 描述的状态，分片每秒被刷新（refresh）一次：</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li> <p>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行 <code>fsync</code> 操作。</p> </li>
<li> <p>这个段被打开，使其可被搜索。</p> </li>
<li> <p>内存缓冲区被清空。</p> </li>
</ul>
</div>
<div id="img-xlog-post-refresh" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1107.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1107.png" alt="After a refresh, the buffer is cleared but the transaction log is not"></a>
</div>
<div class="title">
Figure 22. 刷新（refresh）完成后, 缓存被清空但是事务日志不会
</div>
</div>
</div>
</div> </li>
<li> <p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志（见 <a href="#img-xlog-pre-flush">事务日志不断积累文档</a> ）。</p>
<div id="img-xlog-pre-flush" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1108.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1108.png" alt="The transaction log keeps accumulating documents"></a>
</div>
<div class="title">
Figure 23. 事务日志不断积累文档
</div>
</div> </li>
<li> <p>每隔一段时间—​例如 translog 变得越来越大—​索引被刷新（flush）；一个新的 translog 被创建，并且一个全量提交被执行（见 <a href="#img-xlog-post-flush">在刷新（flush）之后，段被全量提交，并且事务日志被清空</a> ）：</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li> <p>所有在内存缓冲区的文档都被写入一个新的段。</p> </li>
<li> <p>缓冲区被清空。</p> </li>
<li> <p>一个提交点被写入硬盘。</p> </li>
<li> <p>文件系统缓存通过 <code>fsync</code> 被刷新（flush）。</p> </li>
<li> <p>老的 translog 被删除。</p> </li>
</ul>
</div>
</div>
</div> </li>
</ol>
</div>
<div class="paragraph">
<p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候， 它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。</p>
</div>
<div class="paragraph">
<p>translog 也被用来提供实时 CRUD 。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前， 首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
</div>
<div id="img-xlog-post-flush" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1109.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1109.png" alt="After a flush, the segments are fully commited and the transaction log is cleared"></a>
</div>
<div class="title">
Figure 24. 在刷新（flush）之后，段被全量提交，并且事务日志被清空
</div>
</div>
<div class="sect3">
<h4 id="flush-api">flush API</h4>
<div class="paragraph">
<p>这个执行一个提交并且截断 translog 的行为在 Elasticsearch 被称作一次 <em>flush</em> 。 分片每30分钟被自动刷新（flush），或者在 translog 太大的时候也会刷新。请查看 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/index-modules-translog.html#_translog_settings"><code>translog</code> 文档</a> 来设置，它可以用来 控制这些阈值：</p>
</div>
<div class="paragraph">
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/indices-flush.html"><code>flush</code> API</a> 可以被用来执行一个手工的刷新（flush）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /blogs/_flush <b class="conum">(1)</b>

POST /_flush?wait_for_ongoing <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>刷新（flush） <code>blogs</code> 索引。</p> </li>
<li> <p>刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>你很少需要自己手动执行一个的 <code>flush</code> 操作；通常情况下，自动刷新就足够了。</p>
</div>
<div class="paragraph">
<p>这就是说，在重启节点或关闭索引之前执行 <a href="#flush-api">flush</a> 有益于你的索引。当 Elasticsearch 尝试恢复或重新打开一个索引， 它需要重放 translog 中所有的操作，所以如果日志越短，恢复越快。</p>
</div>
<div id="how-safe-is-the-translog" class="sidebarblock">
<div class="content">
<div class="title">
Translog 有多安全?
</div>
<div class="paragraph">
<p>translog 的目的是保证操作不会丢失。这引出了这个问题： Translog 有多安全？</p>
</div>
<div class="paragraph">
<p>在文件被 fsync 到磁盘前，被写入的文件在重启之后就会丢失。默认 translog 是每 5 秒被 fsync 刷新到硬盘， 或者在每次写请求完成之后执行(e.g. index, delete, update, bulk)。这个过程在主分片和复制分片都会发生。最终， 基本上，这意味着在整个请求被 fsync 到主分片和复制分片的translog之前，你的客户端不会得到一个 200 OK 响应。</p>
</div>
<div class="paragraph">
<p>在每次请求后都执行一个 fsync 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是bulk导入，它在一次请求中平摊了大量文档的开销）。</p>
</div>
<div class="paragraph">
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync 还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync 。</p>
</div>
<div class="paragraph">
<p>这个行为可以通过设置 <code>durability</code> 参数为 <code>async</code> 来启用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/_settings
{
    "index.translog.durability": "async",
    "index.translog.sync_interval": "5s"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 translog 的话，你需要 <em>保证</em> 在发生crash时，丢失掉 <code>sync_interval</code> 时间段的数据也无所谓。请在决定前知晓这个特性。</p>
</div>
<div class="paragraph">
<p>如果你不确定这个行为的后果，最好是使用默认的参数（ <code>"index.translog.durability": "request"</code> ）来避免数据丢失。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="merge-process">段合并</h3>
<div class="paragraph">
<p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
</div>
<div class="paragraph">
<p>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
</div>
<div class="paragraph">
<p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p>
</div>
<div class="paragraph">
<p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。这个流程像在 <a href="#img-merge">两个提交了的段和一个未提交的段正在被合并到一个更大的段</a> 中提到的一样工作：</p>
</div>
<div class="paragraph">
<p>1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</p>
</div>
<div class="paragraph">
<p>2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
</div>
<div id="img-merge" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1110.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1110.png" alt="Two commited segments and one uncommited segment in the process of being merged into a bigger segment"></a>
</div>
<div class="title">
Figure 25. 两个提交了的段和一个未提交的段正在被合并到一个更大的段
</div>
</div>
<div class="paragraph">
<p>3、 <a href="#img-post-merge">一旦合并结束，老的段被删除</a> 说明合并完成时的活动：</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li> <p>新的段被刷新（flush）到了磁盘。 &nbsp; ** 写入一个包含新段且排除旧的和较小的段的新提交点。</p> </li>
<li> <p>新的段被打开用来搜索。</p> </li>
<li> <p>老的段被删除。</p> </li>
</ul>
</div>
<div id="img-post-merge" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1111.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_1111.png" alt="一旦合并结束，老的段被删除"></a>
</div>
<div class="title">
Figure 26. 一旦合并结束，老的段被删除
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>合并大的段需要消耗大量的I/O和CPU资源，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然 有足够的资源很好地执行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content"> 查看 <a href="#segments-and-merging">段和合并</a> 来为你的实例获取关于合并调整的建议。 </td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="optimize-api">optimize API</h4>
<div class="paragraph">
<p><code>optimize</code> API大可看做是 <em>强制合并</em> API。它会将一个分片强制合并到 <code>max_num_segments</code> 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Warning
</div> </td>
<td class="content"> <code>optimize</code> API <em>不应该</em> 被用在一个动态索引————一个正在被活跃更新的索引。后台合并流程已经可以很好地完成工作。 optimizing 会阻碍这个进程。不要干扰它！ </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在特定情况下，使用 <code>optimize</code> API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。 老的索引实质上是只读的；它们也并不太可能会发生变化。</p>
</div>
<div class="paragraph">
<p>在这种情况下，使用optimize优化老的索引，将每一个分片合并为一个单独的段就很有用了；这样既可以节省资源，也可以使搜索更加快速：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /logstash-2014-10/_optimize?max_num_segments=1 <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>合并索引中的每个分片为一个单独的段</p> </li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Warning
</div> </td>
<td class="content">
<div class="paragraph">
<p>请注意，使用 <code>optimize</code> API 触发段合并的操作一点也不会受到任何资源上的限制。这可能会消耗掉你节点上全部的I/O资源, 使其没有余裕来处理搜索请求，从而有可能使集群失去响应。 如果你想要对索引执行 <code>optimize</code>，你需要先使用分片分配（查看 <a href="#migrate-indices">迁移旧索引</a>）把索引移到一个安全的节点，再执行。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/77/index.html">
<img class="uk-book-cover" src="../../static/icons/48/openstack_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/77/index.html">深入理解 Neutron -- OpenStack 网络实现</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/48.html">yeasy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="openstack">openstack</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">47页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 136个">136</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/104/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/104/index.html">Linux 内核揭密</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/63.html">ye11ow</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">83页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/55/index.html">
<img class="uk-book-cover" src="../../static/icons/48/rust_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/55/index.html">Rust 程序设计语言 中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/31.html">hltj</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="rust">rust</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">71页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/2/index.html">
<img class="uk-book-cover" src="../../static/icons/48/typescript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/2/index.html">TypeScript使用手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/2.html">zhongsp</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="typescript">typescript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">83页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1879个">1879</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/28/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/28/index.html">笨办法学 Linux</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 326个">326</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/186/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/186/index.html">leetcode题解，记录自己的leetcode解题之路</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8204个">8204</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9264;var bookPageRelUrl ='inside-a-shard.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>