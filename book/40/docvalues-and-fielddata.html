
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Doc Values and Fielddata-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='Doc Values and Fielddata,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='Doc Values and Fielddata,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/significant-terms.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">通过聚合发现异常指标</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/_closing_thoughts.html">
<span class="">总结</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="docvalues-and-fielddata">Doc Values and Fielddata</h2>
<div class="sect2">
<h3 id="docvalues">Doc Values</h3>
<div class="paragraph">
<p>聚合使用一个叫 <em>doc values</em> 的数据结构（在 <a href="#docvalues-intro">Doc Values 介绍</a> 里简单介绍）。 Doc values 可以使聚合更快、更高效并且内存友好，所以理解它的工作方式十分有益。</p>
</div>
<div class="paragraph">
<p>Doc values 的存在是因为倒排索引只对某些操作是高效的。 倒排索引的优势 在于查找包含某个项的文档，而对于从另外一个方向的相反操作并不高效，即：确定哪些项是否存在单个文档里，聚合需要这种次级的访问模式。</p>
</div>
<div class="paragraph">
<p>对于以下倒排索引：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Term      Doc_1   Doc_2   Doc_3
------------------------------------
brown   |   X   |   X   |
dog     |   X   |       |   X
dogs    |       |   X   |   X
fox     |   X   |       |   X
foxes   |       |   X   |
in      |       |   X   |
jumped  |   X   |       |   X
lazy    |   X   |   X   |
leap    |       |   X   |
over    |   X   |   X   |   X
quick   |   X   |   X   |   X
summer  |       |   X   |
the     |   X   |       |   X
------------------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想要获得所有包含 brown 的文档的词的完整列表，我们会创建如下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/_search
{
  "query" : {
    "match" : {
      "body" : "brown"
    }
  },
  "aggs" : {
    "popular_terms": {
      "terms" : {
        "field" : "body"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>查询部分简单又高效。倒排索引是根据项来排序的，所以我们首先在词项列表中找到 brown ，然后扫描所有列，找到包含 brown 的文档。我们可以快速看到 <code>Doc_1</code> 和 <code>Doc_2</code> 包含 brown 这个 token。</p>
</div>
<div class="paragraph">
<p>然后，对于聚合部分，我们需要找到 <code>Doc_1</code> 和 <code>Doc_2</code> 里所有唯一的词项。 用倒排索引做这件事情代价很高： 我们会迭代索引里的每个词项并收集 <code>Doc_1</code> 和 <code>Doc_2</code> 列里面 token。这很慢而且难以扩展：随着词项和文档的数量增加，执行时间也会增加。</p>
</div>
<div class="paragraph">
<p>Doc values 通过转置两者间的关系来解决这个问题。倒排索引将词项映射到包含它们的文档，doc values 将文档映射到它们包含的词项：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Doc      Terms
-----------------------------------------------------------------
Doc_1 | brown, dog, fox, jumped, lazy, over, quick, the
Doc_2 | brown, dogs, foxes, in, lazy, leap, over, quick, summer
Doc_3 | dog, dogs, fox, jumped, over, quick, the
-----------------------------------------------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>当数据被转置之后，想要收集到 <code>Doc_1</code> 和 <code>Doc_2</code> 的唯一 token 会非常容易。获得每个文档行，获取所有的词项，然后求两个集合的并集。</p>
</div>
<div class="paragraph">
<p>因此，搜索和聚合是相互紧密缠绕的。搜索使用倒排索引查找文档，聚合操作收集和聚合 doc values 里的数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>Doc values 不仅可以用于聚合。 任何需要查找某个文档包含的值的操作都必须使用它。 除了聚合，还包括排序，访问字段值的脚本，父子关系处理（参见 <a href="#parent-child">父-子关系文档</a> ）。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_deep_dive_on_doc_values">深入理解 Doc Values</h3>
<div class="paragraph">
<p>在上一节一开头我们就说 <code>Doc Values</code> 是 <em>"快速、高效并且内存友好"</em> 。 这个口号听不起来不错，不过话说回来 <code>Doc Values</code> 到底是如何工作的呢？</p>
</div>
<div class="paragraph">
<p><code>Doc Values</code> 是在索引时与 <code>倒排索引</code> 同时生成。也就是说 <code>Doc Values</code> 和 <code>倒排索引</code> 一样，基于 <code>Segement</code> 生成并且是不可变的。同时 <code>Doc Values</code> 和 <code>倒排索引</code> 一样序列化到磁盘，这样对性能和扩展性有很大帮助。</p>
</div>
<div class="paragraph">
<p><code>Doc Values</code> 通过序列化把数据结构持久化到磁盘，我们可以充分利用操作系统的内存，而不是 <code>JVM</code> 的 <code>Heap</code> 。 当 <code>working set</code> 远小于系统的可用内存，系统会自动将 <code>Doc Values</code> 驻留在内存中，使得其读写十分快速；不过，当其远大于可用内存时，系统会根据需要从磁盘读取 <code>Doc Values</code>，然后选择性放到分页缓存中。很显然，这样性能会比在内存中差很多，但是它的大小就不再局限于服务器的内存了。如果是使用 <code>JVM</code> 的 <code>Heap</code> 来实现那么只能是因为 <code>OutOfMemory</code> 导致程序崩溃了。 &nbsp;</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>因为 <code>Doc Values</code> 不是由 <code>JVM</code> 来管理，所以 <code>Elasticsearch</code> 实例可以配置一个很小的 <code>JVM Heap</code>，这样给系统留出来更多的内存。同时更小的 <code>Heap</code> 可以让 <code>JVM</code> 更加快速和高效的回收。</p>
</div>
<div class="paragraph">
<p>之前，我们会建议分配机器内存的 <code>50%</code> 来给 <code>JVM Heap</code>。但是对于 <code>Doc Values</code>，这样可能不是最合适的方案了。 以 <code>64gb</code> 内存的机器为例，可能给 <code>Heap</code> 分配 <code>4-16gb</code> 的内存更合适，而不是 <code>32gb</code>。</p>
</div>
<div class="paragraph">
<p>有关更详细的讨论，查看 <a href="#heap-sizing">堆内存:大小和交换</a>.</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_列式存储的压缩">列式存储的压缩</h4>
<div class="paragraph">
<p>从广义来说，<code>Doc Values</code> 本质上是一个序列化的 <em>列式存储</em> 。 正如我们上一节所讨论的，<em>列式存储</em> 适用于聚合、排序、脚本等操作。</p>
</div>
<div class="paragraph">
<p>而且，这种存储方式也非常便于压缩，特别是数字类型。这样可以减少磁盘空间并且提高访问速度。现代 <code>CPU</code> 的处理速度要比磁盘快几个数量级（尽管即将到来的 NVMe 驱动器正在迅速缩小差距）。所以我们必须减少直接存磁盘读取数据的大小，尽管需要额外消耗 <code>CPU</code> 运算用来进行解压。</p>
</div>
<div class="paragraph">
<p>要了解它如何压缩数据的，来看一组数字类型的 <code>Doc Values</code>：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Doc      Terms
-----------------------------------------------------------------
Doc_1 | 100
Doc_2 | 1000
Doc_3 | 1500
Doc_4 | 1200
Doc_5 | 300
Doc_6 | 1900
Doc_7 | 4200
-----------------------------------------------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>按列布局意味着我们有一个连续的数据块： <code>[100,1000,1500,1200,300,1900,4200]</code> 。因为我们已经知道他们都是数字（而不是像文档或行中看到的异构集合），所以我们可以使用统一的偏移来将他们紧紧排列。</p>
</div>
<div class="paragraph">
<p>而且，针对这样的数字有很多种压缩技巧。你会注意到这里每个数字都是 100 的倍数，<code>Doc Values</code> 会检测一个段里面的所有数值，并使用一个 <em>最大公约数</em> ，方便做进一步的数据压缩。</p>
</div>
<div class="paragraph">
<p>如果我们保存 <code>100</code> 作为此段的除数，我们可以对每个数字都除以 100，然后得到： <code>[1,10,15,12,3,19,42]</code> 。现在这些数字变小了，只需要很少的位就可以存储下，也减少了磁盘存放的大小。</p>
</div>
<div class="paragraph">
<p><code>Doc Values</code> 在压缩过程中使用如下技巧。它会按依次检测以下压缩模式:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>如果所有的数值各不相同（或缺失），设置一个标记并记录这些值</p> </li>
<li> <p>如果这些值小于 256，将使用一个简单的编码表</p> </li>
<li> <p>如果这些值大于 256，检测是否存在一个最大公约数</p> </li>
<li> <p>如果没有存在最大公约数，从最小的数值开始，统一计算偏移量进行编码</p> </li>
</ol>
</div>
<div class="paragraph">
<p>你会发现这些压缩模式不是传统的通用的压缩方式，比如 <code>DEFLATE</code> 或是 <code>LZ4</code>。 因为列式存储的结构是严格且良好定义的，我们可以通过使用专门的模式来达到比通用压缩算法（如 LZ4 ）更高的压缩效果。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>你也许会想 <em>"好吧，貌似对数字很好，不知道字符串怎么样？"</em> 通过借助顺序表（ordinal table），<code>String</code> 类型也是类似进行编码的。<code>String</code> 类型是去重之后存放到顺序表的，通过分配一个 <code>ID</code>，然后通过数字类型的 <code>ID</code> 构建 <code>Doc Values</code>。这样 <code>String</code> 类型和数值类型可以达到同样的压缩效果。</p>
</div>
<div class="paragraph">
<p>顺序表本身也有很多压缩技巧，比如固定长度、变长或是前缀字符编码等等。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_禁用_doc_values">禁用 Doc Values</h4>
<div class="paragraph">
<p><code>Doc Values</code> 默认对所有字段启用，除了 <code>analyzed strings</code>。也就是说所有的数字、地理坐标、日期、IP 和不分析（ <code>not_analyzed</code> ）字符类型都会默认开启。</p>
</div>
<div class="paragraph">
<p><code>analyzed strings</code> 暂时还不能使用 <code>Doc Values</code>。文本经过分析流程生成很多 <code>Token</code>，使得 <code>Doc Values</code> 不能高效运行。我们将在 <a href="#aggregations-and-analysis">聚合与分析</a> 讨论如何使用分析字符类型来做聚合。</p>
</div>
<div class="paragraph">
<p>因为 <code>Doc Values</code> 默认启用，你可以选择对你数据集里面的大多数字段进行聚合和排序操作。但是如果你知道你永远也不会对某些字段进行聚合、排序或是使用脚本操作？ 尽管这并不常见，但是你可以通过禁用特定字段的 <code>Doc Values</code> 。这样不仅节省磁盘空间，也许会提升索引的速度。</p>
</div>
<div class="paragraph">
<p>要禁用 <code>Doc Values</code> ，在字段的映射（mapping）设置 <code>doc_values: false</code> 即可。例如，这里我们创建了一个新的索引，字段 <code>"session_id"</code> 禁用了 <code>Doc Values</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT my_index
{
  "mappings": {
    "my_type": {
      "properties": {
        "session_id": {
          "type":       "string",
          "index":      "not_analyzed",
          "doc_values": false <b class="conum">(1)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>通过设置 <code>doc_values: false</code> ，这个字段将不能被用于聚合、排序以及脚本操作</p> </li>
</ol>
</div>
<div class="paragraph">
<p>反过来也是可以进行配置的：让一个字段可以被聚合，通过禁用倒排索引，使它不能被正常搜索，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT my_index
{
  "mappings": {
    "my_type": {
      "properties": {
        "customer_token": {
          "type":       "string",
          "index":      "not_analyzed",
          "doc_values": true, <b class="conum">(1)</b>
          "index": "no" <b class="conum">(2)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>Doc Values</code> 被启用来允许聚合</p> </li>
<li> <p>索引被禁用了，这让该字段不能被查询/搜索</p> </li>
</ol>
</div>
<div class="paragraph">
<p>通过设置 <code>doc_values: true</code> 和 <code>index: no</code> ，我们得到一个只能被用于聚合/排序/脚本的字段。无可否认，这是一个非常少见的情况，但有时很有用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aggregations-and-analysis">聚合与分析</h3>
<div class="paragraph">
<p>有些聚合，比如 <code>terms</code> 桶， 操作字符串字段。字符串字段可能是 <code>analyzed</code> 或者 <code>not_analyzed</code> ， 那么问题来了，分析是怎么影响聚合的呢？</p>
</div>
<div class="paragraph">
<p>答案是影响“很多”，有两个原因：分析影响聚合中使用的 tokens ，并且 doc values <em>不能使用于</em> 分析字符串。</p>
</div>
<div class="paragraph">
<p>让我们解决第一个问题：分析 tokens 的产生如何影响聚合。首先索引一些代表美国各个州的文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /agg_analysis/data/_bulk
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New Jersey" }
{ "index": {}}
{ "state" : "New Mexico" }
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New York" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们希望创建一个数据集里各个州的唯一列表，并且计数。 简单，让我们使用 <code>terms</code> 桶：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /agg_analysis/data/_search
{
    "size" : 0,
    "aggs" : {
        "states" : {
            "terms" : {
                "field" : "state"
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>得到结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
...
   "aggregations": {
      "states": {
         "buckets": [
            {
               "key": "new",
               "doc_count": 5
            },
            {
               "key": "york",
               "doc_count": 3
            },
            {
               "key": "jersey",
               "doc_count": 1
            },
            {
               "key": "mexico",
               "doc_count": 1
            }
         ]
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>宝贝儿，这完全不是我们想要的！没有对州名计数，聚合计算了每个词的数目。背后的原因很简单：聚合是基于倒排索引创建的，倒排索引是 后置分析（ <em>post-analysis</em> ）的。</p>
</div>
<div class="paragraph">
<p>当我们把这些文档加入到 Elasticsearch 中时，字符串 <code>"New York"</code> 被分析/分析成 <code>["new", "york"]</code> 。这些单独的 tokens ，都被用来填充聚合计数，所以我们最终看到 <code>new</code> 的数量而不是 <code>New York</code> 。</p>
</div>
<div class="paragraph">
<p>这显然不是我们想要的行为，但幸运的是很容易修正它。</p>
</div>
<div class="paragraph">
<p>我们需要为 state 定义 multifield 并且设置成 <code>not_analyzed</code> 。这样可以防止 <code>New York</code> 被分析，也意味着在聚合过程中它会以单个 token 的形式存在。让我们尝试完整的过程，但这次指定一个 <em>raw</em> multifield：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /agg_analysis/
PUT /agg_analysis
{
  "mappings": {
    "data": {
      "properties": {
        "state" : {
          "type": "string",
          "fields": {
            "raw" : {
              "type": "string",
              "index": "not_analyzed"<b class="conum">(1)</b>
            }
          }
        }
      }
    }
  }
}

POST /agg_analysis/data/_bulk
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New Jersey" }
{ "index": {}}
{ "state" : "New Mexico" }
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New York" }

GET /agg_analysis/data/_search
{
  "size" : 0,
  "aggs" : {
    "states" : {
        "terms" : {
            "field" : "state.raw" <b class="conum">(2)</b>
        }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>这次我们显式映射 state 字段并包括一个 <code>not_analyzed</code> 辅字段。</p> </li>
<li> <p>聚合针对 state.raw 字段而不是 state 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>现在运行聚合，我们得到了合理的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
...
   "aggregations": {
      "states": {
         "buckets": [
            {
               "key": "New York",
               "doc_count": 3
            },
            {
               "key": "New Jersey",
               "doc_count": 1
            },
            {
               "key": "New Mexico",
               "doc_count": 1
            }
         ]
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在实际中，这样的问题很容易被察觉，我们的聚合会返回一些奇怪的桶，我们会记住分析的问题。 总之，很少有在聚合中使用分析字段的实例。当我们疑惑时，只要增加一个 multifield 就能有两种选择。</p>
</div>
<div class="sect3">
<h4 id="_分析字符串和_fielddata_analyzed_strings_and_fielddata">分析字符串和 Fielddata（Analyzed strings and Fielddata）</h4>
<div class="paragraph">
<p>当第一个问题涉及如何聚合数据并显示给用户，第二个问题主要是技术和幕后。</p>
</div>
<div class="paragraph">
<p>Doc values 不支持 <code>analyzed</code> 字符串字段，因为它们不能很有效的表示多值字符串。 Doc values 最有效的是，当每个文档都有一个或几个 tokens 时， 但不是无数的，分析字符串（想象一个 PDF ，可能有几兆字节并有数以千计的独特 tokens）。</p>
</div>
<div class="paragraph">
<p>出于这个原因，doc values 不生成分析的字符串，然而，这些字段仍然可以使用聚合，那怎么可能呢？</p>
</div>
<div class="paragraph">
<p>答案是一种被称为 <em>fielddata</em> 的数据结构。与 doc values 不同，fielddata 构建和管理 100% 在内存中，常驻于 JVM 内存堆。这意味着它本质上是不可扩展的，有很多边缘情况下要提防。 本章的其余部分是解决在分析字符串上下文中 fielddata 的挑战。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content"> 从历史上看，fielddata 是 <em>所有</em> 字段的默认设置。但是 Elasticsearch 已迁移到 doc values 以减少 OOM 的几率。分析的字符串是仍然使用 fielddata 的最后一块阵地。 最终目标是建立一个序列化的数据结构类似于 doc values ，可以处理高维度的分析字符串，逐步淘汰 fielddata。 </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_高基数内存的影响_high_cardinality_memory_implications">高基数内存的影响（High-Cardinality Memory Implications）</h4>
<div class="paragraph">
<p>避免分析字段的另外一个原因就是：高基数字段在加载到 fielddata 时会消耗大量内存。 分析的过程会经常（尽管不总是这样）生成大量的 token，这些 token 大多都是唯一的。 这会增加字段的整体基数并且带来更大的内存压力。</p>
</div>
<div class="paragraph">
<p>有些类型的分析对于内存来说 <em>极度</em> 不友好，想想 n-gram 的分析过程， New York 会被 n-gram 分析成以下 token：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>ne</code></p> </li>
<li> <p><code>ew</code></p> </li>
<li> <p>w{nbsp}</p> </li>
<li> <p>{nbsp}y</p> </li>
<li> <p><code>yo</code></p> </li>
<li> <p><code>or</code></p> </li>
<li> <p><code>rk</code></p> </li>
</ul>
</div>
<div class="paragraph">
<p>可以想象 n-gram 的过程是如何生成大量唯一 token 的，特别是在分析成段文本的时候。当这些数据加载到内存中，会轻而易举的将我们堆空间消耗殆尽。</p>
</div>
<div class="paragraph">
<p>因此，在聚合字符串字段之前，请评估情况：</p>
</div>
<div class="ulist">
<ul>
<li> <p>这是一个 <code>not_analyzed</code> 字段吗？如果是，可以通过 doc values 节省内存 。</p> </li>
<li> <p>否则，这是一个 <code>analyzed</code> 字段，它将使用 fielddata 并加载到内存中。这个字段因为 ngrams 有一个非常大的基数？如果是，这对于内存来说极度不友好。</p> </li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_limiting_memory_usage">限制内存使用</h3>
<div class="paragraph">
<p>一旦分析字符串被加载到 fielddata ，他们会一直在那里，直到被驱逐（或者节点崩溃）。由于这个原因，留意内存的使用情况，了解它是如何以及何时加载的，怎样限制对集群的影响是很重要的。</p>
</div>
<div class="paragraph">
<p>Fielddata 是 <em>延迟</em> 加载。如果你从来没有聚合一个分析字符串，就不会加载 fielddata 到内存中。此外，fielddata 是基于字段加载的， 这意味着只有很活跃地使用字段才会增加 fielddata 的负担。</p>
</div>
<div class="paragraph">
<p>然而，这里有一个令人惊讶的地方。假设你的查询是高度选择性和只返回命中的 100 个结果。大多数人认为 fielddata 只加载 100 个文档。</p>
</div>
<div class="paragraph">
<p>实际情况是，fielddata 会加载索引中（针对该特定字段的） <strong>所有的</strong> 文档，而不管查询的特异性。逻辑是这样：如果查询会访问文档 X、Y 和 Z，那很有可能会在下一个查询中访问其他文档。</p>
</div>
<div class="paragraph">
<p>与 doc values 不同，fielddata 结构不会在索引时创建。相反，它是在查询运行时，动态填充。这可能是一个比较复杂的操作，可能需要一些时间。 将所有的信息一次加载，再将其维持在内存中的方式要比反复只加载一个 fielddata 的部分代价要低。</p>
</div>
<div class="paragraph">
<p>JVM 堆 是有限资源的，应该被合理利用。 限制 fielddata 对堆使用的影响有多套机制，这些限制方式非常重要，因为堆栈的乱用会导致节点不稳定（感谢缓慢的垃圾回收机制），甚至导致节点宕机（通常伴随 OutOfMemory 异常）。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
选择堆大小（Choosing a Heap Size）
</div>
<div class="paragraph">
<p>在设置 Elasticsearch 堆大小时需要通过 <code>$ES_HEAP_SIZE</code> 环境变量应用两个规则：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
不要超过可用 RAM 的 50%
</dt>
<dd>
<p>Lucene 能很好利用文件系统的缓存，它是通过系统内核管理的。如果没有足够的文件系统缓存空间，性能会受到影响。 此外，专用于堆的内存越多意味着其他所有使用 doc values 的字段内存越少。</p>
</dd>
<dt class="hdlist1">
不要超过 32 GB
</dt>
<dd>
<p>如果堆大小小于 32 GB，JVM 可以利用指针压缩，这可以大大降低内存的使用：每个指针 4 字节而不是 8 字节。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>更详细和更完整的堆大小讨论，请参阅 <a href="#heap-sizing">堆内存:大小和交换</a></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fielddata-size">Fielddata的大小</h4>
<div class="paragraph">
<p><code>indices.fielddata.cache.size</code> 控制为 fielddata 分配的堆空间大小。 当你发起一个查询，分析字符串的聚合将会被加载到 fielddata，如果这些字符串之前没有被加载过。如果结果中 fielddata 大小超过了指定 <code>大小</code> ，其他的值将会被回收从而获得空间。</p>
</div>
<div class="paragraph">
<p>默认情况下，设置都是 <em>unbounded</em> ，Elasticsearch 永远都不会从 fielddata 中回收数据。</p>
</div>
<div class="paragraph">
<p>这个默认设置是刻意选择的：fielddata 不是临时缓存。它是驻留内存里的数据结构，必须可以快速执行访问，而且构建它的代价十分高昂。如果每个请求都重载数据，性能会十分糟糕。</p>
</div>
<div class="paragraph">
<p>一个有界的大小会强制数据结构回收数据。我们会看何时应该设置这个值，但请首先阅读以下警告：</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Warning
</div> </td>
<td class="content">
<div class="paragraph">
<p>这个设置是一个安全卫士，而非内存不足的解决方案。</p>
</div>
<div class="paragraph">
<p>如果没有足够空间可以将 fielddata 保留在内存中，Elasticsearch 就会时刻从磁盘重载数据，并回收其他数据以获得更多空间。内存的回收机制会导致重度磁盘I/O，并且在内存中生成很多垃圾，这些垃圾必须在晚些时候被回收掉。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>设想我们正在对日志进行索引，每天使用一个新的索引。通常我们只对过去一两天的数据感兴趣，尽管我们会保留老的索引，但我们很少需要查询它们。不过如果采用默认设置，旧索引的 fielddata 永远不会从缓存中回收！ fieldata 会保持增长直到 fielddata 发生断熔（请参阅 <a href="#circuit-breaker">断路器</a>），这样我们就无法载入更多的 fielddata。</p>
</div>
<div class="paragraph">
<p>这个时候，我们被困在了死胡同。但我们仍然可以访问旧索引中的 fielddata，也无法加载任何新的值。相反，我们应该回收旧的数据，并为新值获得更多空间。</p>
</div>
<div class="paragraph">
<p>为了防止发生这样的事情，可以通过在 <code>config/elasticsearch.yml</code> 文件中增加配置为 fielddata 设置一个上限：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">indices.fielddata.cache.size:  20% <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>可以设置堆大小的百分比，也可以是某个值，例如： <code>5gb</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>有了这个设置，最久未使用（LRU）的 fielddata 会被回收为新数据腾出空间。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Warning
</div> </td>
<td class="content">
<div class="paragraph">
<p>可能发现在线文档有另外一个设置： <code>indices.fielddata.cache.expire</code> 。</p>
</div>
<div class="paragraph">
<p>这个设置 <em>永远都不会</em> 被使用！它很有可能在不久的将来被弃用。</p>
</div>
<div class="paragraph">
<p>这个设置要求 Elasticsearch 回收那些 <code>过期</code> 的 fielddata，不管这些值有没有被用到。</p>
</div>
<div class="paragraph">
<p>这对性能是件 <em>很糟糕</em> 的事情。回收会有消耗性能，它刻意的安排回收方式，而没能获得任何回报。</p>
</div>
<div class="paragraph">
<p>没有理由使用这个设置：我们不能从理论上假设一个有用的情形。目前，它的存在只是为了向前兼容。我们只在很有以前提到过这个设置，但不幸的是网上各种文章都将其作为一种性能调优的小窍门来推荐。</p>
</div>
<div class="paragraph">
<p>它不是。永远不要使用！</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="monitoring-fielddata">监控 fielddata（Monitoring fielddata）</h4>
<div class="paragraph">
<p>无论是仔细监控 fielddata 的内存使用情况， 还是看有无数据被回收都十分重要。高的回收数可以预示严重的资源问题以及性能不佳的原因。</p>
</div>
<div class="paragraph">
<p>Fielddata 的使用可以被监控：</p>
</div>
<div class="ulist">
<ul>
<li> <p>按索引使用 <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-stats.html"><code>indices-stats</code> API</a> ：</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /_stats/fielddata?fields=*</code></pre>
</div>
</div> </li>
<li> <p>按节点使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/cluster-nodes-stats.html"><code>nodes-stats</code> API</a> ：</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /_nodes/stats/indices/fielddata?fields=*</code></pre>
</div>
</div> </li>
<li> <p>按索引节点：</p> </li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">GET /_nodes/stats/indices/fielddata?level=indices&amp;fields=*</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用设置 <code>?fields=*</code> ，可以将内存使用分配到每个字段。</p>
</div>
</div>
<div class="sect3">
<h4 id="circuit-breaker">断路器</h4>
<div class="paragraph">
<p>机敏的读者可能已经发现 fielddata 大小设置的一个问题。fielddata 大小是在数据加载 <em>之后</em> 检查的。 如果一个查询试图加载比可用内存更多的信息到 fielddata 中会发生什么？答案很丑陋：我们会碰到 OutOfMemoryException 。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 包括一个 <em>fielddata 断熔器</em> ，这个设计就是为了处理上述情况。 断熔器通过内部检查（字段的类型、基数、大小等等）来估算一个查询需要的内存。它然后检查要求加载的 fielddata 是否会导致 fielddata 的总量超过堆的配置比例。</p>
</div>
<div class="paragraph">
<p>如果估算查询的大小超出限制，就会 <em>触发</em> 断路器，查询会被中止并返回异常。这都发生在数据加载 <em>之前</em> ，也就意味着不会引起 OutOfMemoryException 。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
可用的断路器（Available Circuit Breakers）
</div>
<div class="paragraph">
<p>Elasticsearch 有一系列的断路器，它们都能保证内存不会超出限制：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>indices.breaker.fielddata.limit</code>
</dt>
<dd>
<p><code>fielddata</code> 断路器默认设置堆的 60% 作为 fielddata 大小的上限。</p>
</dd>
<dt class="hdlist1">
<code>indices.breaker.request.limit</code>
</dt>
<dd>
<p><code>request</code> 断路器估算需要完成其他请求部分的结构大小，例如创建一个聚合桶，默认限制是堆内存的 40%。</p>
</dd>
<dt class="hdlist1">
<code>indices.breaker.total.limit</code>
</dt>
<dd>
<p><code>total</code> 揉合 <code>request</code> 和 <code>fielddata</code> 断路器保证两者组合起来不会使用超过堆内存的 70%。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>断路器的限制可以在文件 <code>config/elasticsearch.yml</code> 中指定，可以动态更新一个正在运行的集群：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /_cluster/settings
{
  "persistent" : {
    "indices.breaker.fielddata.limit" : "40%" <b class="conum">(1)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>这个限制是按对内存的百分比设置的。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>最好为断路器设置一个相对保守点的值。 记住 fielddata 需要与 <code>request</code> 断路器共享堆内存、索引缓冲内存和过滤器缓存。Lucene 的数据被用来构造索引，以及各种其他临时的数据结构。 正因如此，它默认值非常保守，只有 60% 。过于乐观的设置可能会引起潜在的堆栈溢出（OOM）异常，这会使整个节点宕掉。</p>
</div>
<div class="paragraph">
<p>另一方面，过度保守的值只会返回查询异常，应用程序可以对异常做相应处理。异常比服务器崩溃要好。这些异常应该也能促进我们对查询进行重新评估：为什么单个查询需要超过堆内存的 60% 之多？</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>在 <a href="#fielddata-size">Fielddata的大小</a> 中，我们提过关于给 fielddata 的大小加一个限制，从而确保旧的无用 fielddata 被回收的方法。 <code>indices.fielddata.cache.size</code> 和 <code>indices.breaker.fielddata.limit</code> 之间的关系非常重要。 如果断路器的限制低于缓存大小，没有数据会被回收。为了能正常工作，断路器的限制 <em>必须</em> 要比缓存大小要高。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>值得注意的是：断路器是根据总堆内存大小估算查询大小的，而 <em>非</em> 根据实际堆内存的使用情况。 这是由于各种技术原因造成的（例如，堆可能看上去是满的但实际上可能只是在等待垃圾回收，这使我们难以进行合理的估算）。但作为终端用户，这意味着设置需要保守，因为它是根据总堆内存必要的，而 <em>不是</em> 可用堆内存。 </p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fielddata_filtering">Fielddata 的过滤</h3>
<div class="paragraph">
<p>设想我们正在运行一个网站允许用户收听他们喜欢的歌曲。 为了让他们可以更容易的管理自己的音乐库，用户可以为歌曲设置任何他们喜欢的标签，这样我们就会有很多歌曲被附上 <code>rock（摇滚）</code> 、 <code>hiphop（嘻哈）</code> 和 <code>electronica（电音）</code> ，但也会有些歌曲被附上 <code>my_16th_birthday_favorite_anthem</code> 这样的标签。</p>
</div>
<div class="paragraph">
<p>现在设想我们想要为用户展示每首歌曲最受欢迎的三个标签，很有可能 <code>rock</code> 这样的标签会排在三个中的最前面，而 <code>my_16th_birthday_favorite_anthem</code> 则不太可能得到评级。 尽管如此，为了计算最受欢迎的标签，我们必须强制将这些一次性使用的项加载到内存中。</p>
</div>
<div class="paragraph">
<p>感谢 fielddata 过滤，我们可以控制这种状况。我们 <em>知道</em> 自己只对最流行的项感兴趣，所以我们可以简单地避免加载那些不太有意思的长尾项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /music/_mapping/song
{
  "properties": {
    "tag": {
      "type": "string",
      "fielddata": { <b class="conum">(1)</b>
        "filter": {
          "frequency": { <b class="conum">(2)</b>
            "min":              0.01, <b class="conum">(3)</b>
            "min_segment_size": 500  <b class="conum">(4)</b>
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>fielddata</code> 关键字允许我们配置 fielddata 处理该字段的方式。</p> </li>
<li> <p><code>frequency</code> 过滤器允许我们基于项频率过滤加载 fielddata。</p> </li>
<li> <p>只加载那些至少在本段文档中出现 1% 的项。</p> </li>
<li> <p>忽略任何文档个数小于 500 的段。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>有了这个映射，只有那些至少在 <em>本段</em> 文档中出现超过 1% 的项才会被加载到内存中。我们也可以指定一个 <code>最大</code> 词频，它可以被用来排除 <em>常用</em> 项，比如 <a href="#stopwords">停用词</a> 。</p>
</div>
<div class="paragraph">
<p>这种情况下，词频是按照段来计算的。这是实现的一个限制：fielddata 是按段来加载的，所以可见的词频只是该段内的频率。但是，这个限制也有些有趣的特性：它可以让受欢迎的新项迅速提升到顶部。</p>
</div>
<div class="paragraph">
<p>比如一个新风格的歌曲在一夜之间受大众欢迎，我们可能想要将这种新风格的歌曲标签包括在最受欢迎列表中，但如果我们倚赖对索引做完整的计算获取词频，我们就必须等到新标签变得像 <code>rock</code> 和 <code>electronica</code> ）一样流行。 由于频度过滤的实现方式，新加的标签会很快作为高频标签出现在新段内，也当然会迅速上升到顶部。</p>
</div>
<div class="paragraph">
<p><code>min_segment_size</code> 参数要求 Elasticsearch 忽略某个大小以下的段。 如果一个段内只有少量文档，它的词频会非常粗略没有任何意义。 小的分段会很快被合并到更大的分段中，某一刻超过这个限制，将会被纳入计算。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>通过频次来过滤项并不是唯一的选择，我们也可以使用正则式来决定只加载那些匹配的项。例如，我们可以用 <code>regex</code> 过滤器 处理 twitte 上的消息只将以 <code>#</code> 号开始的标签加载到内存中。 这假设我们使用的分析器会保留标点符号，像 <code>whitespace</code> 分析器。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>Fielddata 过滤对内存使用有 <em>巨大的</em> 影响，权衡也是显而易见的：我们实际上是在忽略数据。但对于很多应用，这种权衡是合理的，因为这些数据根本就没有被使用到。内存的节省通常要比包括一个大量而无用的长尾项更为重要。</p>
</div>
</div>
<div class="sect2">
<h3 id="preload-fielddata">预加载 fielddata</h3>
<div class="paragraph">
<p>Elasticsearch 加载内存 fielddata 的默认行为是 <em>延迟</em> 加载 。 当 Elasticsearch 第一次查询某个字段时，它将会完整加载这个字段所有 Segment 中的倒排索引到内存中，以便于以后的查询能够获取更好的性能。</p>
</div>
<div class="paragraph">
<p>对于小索引段来说，这个过程的需要的时间可以忽略。但如果我们有一些 5 GB 的索引段，并希望加载 10 GB 的 fielddata 到内存中，这个过程可能会要数十秒。 已经习惯亚秒响应的用户很难会接受停顿数秒卡着没反应的网站。</p>
</div>
<div class="paragraph">
<p>有三种方式可以解决这个延时高峰：</p>
</div>
<div class="ulist">
<ul>
<li> <p>预加载 fielddata</p> </li>
<li> <p>预加载全局序号</p> </li>
<li> <p>缓存预热</p> </li>
</ul>
</div>
<div class="paragraph">
<p>所有的变化都基于同一概念：预加载 fielddata ，这样在用户进行搜索时就不会碰到延迟高峰。</p>
</div>
<div class="sect3">
<h4 id="eager-fielddata">预加载 fielddata（Eagerly Loading Fielddata）</h4>
<div class="paragraph">
<p>第一个工具称为 <em>预加载</em> （与默认的 延迟加载相对）。随着新分段的创建（通过刷新、写入或合并等方式）， 启动字段预加载可以使那些对搜索不可见的分段里的 fielddata <em>提前</em> 加载。</p>
</div>
<div class="paragraph">
<p>这就意味着首次命中分段的查询不需要促发 fielddata 的加载，因为 fielddata 已经被载入到内存。避免了用户遇到搜索卡顿的情形。</p>
</div>
<div class="paragraph">
<p>预加载是按字段启用的，所以我们可以控制具体哪个字段可以预先加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /music/_mapping/_song
{
  "tags": {
    "type": "string",
    "fielddata": {
      "loading" : "eager" <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>设置 <code>fielddata.loading: eager</code> 可以告诉 Elasticsearch 预先将此字段的内容载入内存中。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>Fielddata 的载入可以使用 <code>update-mapping</code> API 对已有字段设置 <code>lazy</code> 或 <code>eager</code> 两种模式。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Warning
</div> </td>
<td class="content">
<div class="paragraph">
<p>预加载只是简单的将载入 fielddata 的代价转移到索引刷新的时候，而不是查询时，从而大大提高了搜索体验。</p>
</div>
<div class="paragraph">
<p>体积大的索引段会比体积小的索引段需要更长的刷新时间。通常，体积大的索引段是由那些已经对查询可见的小分段合并而成的，所以较慢的刷新时间也不是很重要。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="global-ordinals">全局序号（Global Ordinals）</h4>
<div class="paragraph">
<p>有种可以用来降低字符串 fielddata 内存使用的技术叫做 <em>序号</em> 。</p>
</div>
<div class="paragraph">
<p>设想我们有十亿文档，每个文档都有自己的 <code>status</code> 状态字段，状态总共有三种： <code>status_pending</code> 、 <code>status_published</code> 、 <code>status_deleted</code> 。如果我们为每个文档都保留其状态的完整字符串形式，那么每个文档就需要使用 14 到 16 字节，或总共 15 GB。</p>
</div>
<div class="paragraph">
<p>取而代之的是我们可以指定三个不同的字符串，对其排序、编号：0，1，2。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ordinal | Term
-------------------
0       | status_deleted
1       | status_pending
2       | status_published</pre>
</div>
</div>
<div class="paragraph">
<p>序号字符串在序号列表中只存储一次，每个文档只要使用数值编号的序号来替代它原始的值。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Doc     | Ordinal
-------------------------
0       | 1  # pending
1       | 1  # pending
2       | 2  # published
3       | 0  # deleted</pre>
</div>
</div>
<div class="paragraph">
<p>这样可以将内存使用从 15 GB 降到 1 GB 以下！</p>
</div>
<div class="paragraph">
<p>但这里有个问题，记得 fielddata 是按分 <em>段</em> 来缓存的。如果一个分段只包含两个状态（ <code>status_deleted</code> 和 <code>status_published</code> ）。那么结果中的序号（0 和 1）就会与包含所有三个状态的分段不一样。</p>
</div>
<div class="paragraph">
<p>如果我们尝试对 <code>status</code> 字段运行 <code>terms</code> 聚合，我们需要对实际字符串的值进行聚合，也就是说我们需要识别所有分段中相同的值。一个简单粗暴的方式就是对每个分段执行聚合操作，返回每个分段的字符串值，再将它们归纳得出完整的结果。 尽管这样做可行，但会很慢而且大量消耗 CPU。</p>
</div>
<div class="paragraph">
<p>取而代之的是使用一个被称为 <em>全局序号</em> 的结构。 全局序号是一个构建在 fielddata 之上的数据结构，它只占用少量内存。唯一值是 <em>跨所有分段</em> 识别的，然后将它们存入一个序号列表中，正如我们描述过的那样。</p>
</div>
<div class="paragraph">
<p>现在， <code>terms</code> 聚合可以对全局序号进行聚合操作，将序号转换成真实字符串值的过程只会在聚合结束时发生一次。这会将聚合（和排序）的性能提高三到四倍。</p>
</div>
<div class="sect4">
<h5 id="_构建全局序号_building_global_ordinals">构建全局序号（Building global ordinals）</h5>
<div class="paragraph">
<p>当然，天下没有免费的晚餐。 全局序号分布在索引的所有段中，所以如果新增或删除一个分段时，需要对全局序号进行重建。 重建需要读取每个分段的每个唯一项，基数越高（即存在更多的唯一项）这个过程会越长。</p>
</div>
<div class="paragraph">
<p>全局序号是构建在内存 fielddata 和 doc values 之上的。实际上，它们正是 doc values 性能表现不错的一个主要原因。</p>
</div>
<div class="paragraph">
<p>和 fielddata 加载一样，全局序号默认也是延迟构建的。首个需要访问索引内 fielddata 的请求会促发全局序号的构建。由于字段的基数不同，这会导致给用户带来显著延迟这一糟糕结果。一旦全局序号发生重建，仍会使用旧的全局序号，直到索引中的分段产生变化：在刷新、写入或合并之后。</p>
</div>
</div>
<div class="sect4">
<h5 id="eager-global-ordinals">预构建全局序号（Eager global ordinals）</h5>
<div class="paragraph">
<p>单个字符串字段 可以通过配置预先构建全局序号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /music/_mapping/_song
{
  "song_title": {
    "type": "string",
    "fielddata": {
      "loading" : "eager_global_ordinals" <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>设置 <code>eager_global_ordinals</code> 也暗示着 fielddata 是预加载的。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>正如 fielddata 的预加载一样，预构建全局序号发生在新分段对于搜索可见之前。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>序号的构建只被应用于字符串。数值信息（integers（整数）、geopoints（地理经纬度）、dates（日期）等等）不需要使用序号映射，因为这些值自己本质上就是序号映射。</p>
</div>
<div class="paragraph">
<p>因此，我们只能为字符串字段预构建其全局序号。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>也可以对 Doc values 进行全局序号预构建：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /music/_mapping/_song
{
  "song_title": {
    "type":       "string",
    "doc_values": true,
    "fielddata": {
      "loading" : "eager_global_ordinals" <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>这种情况下，fielddata 没有载入到内存中，而是 doc values 被载入到文件系统缓存中。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>与 fielddata 预加载不一样，预建全局序号会对数据的 <em>实时性</em> 产生影响，构建一个高基数的全局序号会使一个刷新延时数秒。 选择在于是每次刷新时付出代价，还是在刷新后的第一次查询时。如果经常索引而查询较少，那么在查询时付出代价要比每次刷新时要好。如果写大于读，那么在选择在查询时重建全局序号将会是一个更好的选择。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>针对实际场景优化全局序号的重建频次。如果我们有高基数字段需要花数秒钟重建，增加 <code>refresh_interval</code> 的刷新的时间从而可以使我们的全局序号保留更长的有效期，这也会节省 CPU 资源，因为我们重建的频次下降了。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="index-warmers">索引预热器（Index Warmers）</h4>
<div class="paragraph">
<p>最后我们谈谈 <em>索引预热器</em> 。预热器早于 fielddata 预加载和全局序号预加载之前出现，它们仍然有其存在的理由。一个索引预热器允许我们指定一个查询和聚合须要在新分片对于搜索可见之前执行。 这个想法是通过预先填充或 <em>预热缓存</em> 让用户永远无法遇到延迟的波峰。</p>
</div>
<div class="paragraph">
<p>原来，预热器最重要的用法是确保 fielddata 被预先加载，因为这通常是最耗时的一步。现在可以通过前面讨论的那些技术来更好的控制它，但是预热器还是可以用来预建过滤器缓存，当然我们也还是能选择用它来预加载 fielddata。</p>
</div>
<div class="paragraph">
<p>让我们注册一个预热器然后解释发生了什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /music/_warmer/warmer_1 <b class="conum">(1)</b>
{
  "query" : {
    "bool" : {
      "filter" : {
        "bool": {
          "should": [ <b class="conum">(2)</b>
            { "term": { "tag": "rock"        }},
            { "term": { "tag": "hiphop"      }},
            { "term": { "tag": "electronics" }}
          ]
        }
      }
    }
  },
  "aggs" : {
    "price" : {
      "histogram" : {
        "field" : "price", <b class="conum">(3)</b>
        "interval" : 10
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>预热器被关联到索引（ <code>music</code> ）上，使用接入口 <code>_warmer</code> 以及 ID （ <code>warmer_1</code> ）。</p> </li>
<li> <p>为三种最受欢迎的曲风预建过滤器缓存。</p> </li>
<li> <p>字段 price 的 fielddata 和全局序号会被预加载。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>预热器是根据具体索引注册的， 每个预热器都有唯一的 ID ，因为每个索引可能有多个预热器。</p>
</div>
<div class="paragraph">
<p>然后我们可以指定查询，任何查询。它可以包括查询、过滤器、聚合、排序值、脚本，任何有效的查询表达式都毫不夸张。 这里的目的是想注册那些可以代表用户产生流量压力的查询，从而将合适的内容载入缓存。</p>
</div>
<div class="paragraph">
<p>当新建一个分段时，Elasticsearch 将会执行注册在预热器中的查询。执行这些查询会强制加载缓存，只有在所有预热器执行完，这个分段才会对搜索可见。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Warning
</div> </td>
<td class="content">
<div class="paragraph">
<p>与预加载类似，预热器只是将冷缓存的代价转移到刷新的时候。当注册预热器时，做出明智的决定十分重要。 为了确保每个缓存都被读入，我们 <em>可以</em> 加入上千的预热器，但这也会使新分段对于搜索可见的时间急剧上升。</p>
</div>
<div class="paragraph">
<p>实际中，我们会选择少量代表大多数用户的查询，然后注册它们。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>有些管理的细节（比如获得已有预热器和删除预热器）没有在本小节提到，剩下的详细内容可以参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/indices-warmers.html">预热器文档（warmers documentation）</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_preventing_combinatorial_explosions">优化聚合查询</h3>
<div class="paragraph">
<p>“elasticsearch 里面桶的叫法和 SQL 里面分组的概念是类似的，一个桶就类似 SQL 里面的一个 group，多级嵌套的 aggregation， 类似 SQL 里面的多字段分组（group by field1,field2, …​..），注意这里仅仅是概念类似，底层的实现原理是不一样的。 －译者注”</p>
</div>
<div class="paragraph">
<p><code>terms</code> 桶基于我们的数据动态构建桶；它并不知道到底生成了多少桶。 大多数时候对单个字段的聚合查询还是非常快的， 但是当需要同时聚合多个字段时，就可能会产生大量的分组，最终结果就是占用 es 大量内存，从而导致 OOM 的情况发生。</p>
</div>
<div class="paragraph">
<p>假设我们现在有一些关于电影的数据集，每条数据里面会有一个数组类型的字段存储表演该电影的所有演员的名字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "actors" : [
    "Fred Jones",
    "Mary Jane",
    "Elizabeth Worthing"
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想要查询出演影片最多的十个演员以及与他们合作最多的演员，使用聚合是非常简单的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "aggs" : {
    "actors" : {
      "terms" : {
         "field" : "actors",
         "size" :  10
      },
      "aggs" : {
        "costars" : {
          "terms" : {
            "field" : "actors",
            "size" :  5
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会返回前十位出演最多的演员，以及与他们合作最多的五位演员。这看起来是一个简单的聚合查询，最终只返回 50 条数据！</p>
</div>
<div class="paragraph">
<p>但是， 这个看上去简单的查询可以轻而易举地消耗大量内存，我们可以通过在内存中构建一个树来查看这个 <code>terms</code> 聚合。 <code>actors</code> 聚合会构建树的第一层，每个演员都有一个桶。然后，内套在第一层的每个节点之下， <code>costar</code> 聚合会构建第二层，每个联合出演一个桶，请参见 <a href="#depth-first-1">Build full depth tree</a> 所示。这意味着每部影片会生成 n2 个桶！</p>
</div>
<div id="depth-first-1" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_depth_first_1.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_depth_first_1.svg" alt="Build full depth tree"></a>
</div>
<div class="title">
Figure 42. Build full depth tree
</div>
</div>
<div class="paragraph">
<p>用真实点的数据，设想平均每部影片有 10 名演员，每部影片就会生成 102 == 100 个桶。如果总共有 20，000 部影片，粗率计算就会生成 2，000，000 个桶。</p>
</div>
<div class="paragraph">
<p>现在，记住，聚合只是简单的希望得到前十位演员和与他们联合出演者，总共 50 条数据。为了得到最终的结果，我们创建了一个有 2，000，000 桶的树，然后对其排序，取 top10。 图 <a href="#depth-first-2">Sort tree</a> 和图 <a href="#depth-first-3">Prune tree</a> 对这个过程进行了阐述。</p>
</div>
<div id="depth-first-2" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_depth_first_2.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_depth_first_2.svg" alt="Sort tree"></a>
</div>
<div class="title">
Figure 43. Sort tree
</div>
</div>
<div id="depth-first-3" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_depth_first_3.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_depth_first_3.svg" alt="Prune tree"></a>
</div>
<div class="title">
Figure 44. Prune tree
</div>
</div>
<div class="paragraph">
<p>这时我们一定非常抓狂，在 2 万条数据下执行任何聚合查询都是毫无压力的。如果我们有 2 亿文档，想要得到前 100 位演员以及与他们合作最多的 20 位演员，作为查询的最终结果会出现什么情况呢？</p>
</div>
<div class="paragraph">
<p>可以推测聚合出来的分组数非常大，会使这种策略难以维持。世界上并不存在足够的内存来支持这种不受控制的聚合查询。</p>
</div>
<div class="sect3">
<h4 id="_深度优先与广度优先_depth_first_versus_breadth_first">深度优先与广度优先（Depth-First Versus Breadth-First）</h4>
<div class="paragraph">
<p>Elasticsearch 允许我们改变聚合的 <em>集合模式</em> ，就是为了应对这种状况。 我们之前展示的策略叫做 <em>深度优先</em> ，它是默认设置， 先构建完整的树，然后修剪无用节点。 <em>深度优先</em> 的方式对于大多数聚合都能正常工作，但对于如我们演员和联合演员这样例子的情形就不太适用。</p>
</div>
<div class="paragraph">
<p>为了应对这些特殊的应用场景，我们应该使用另一种集合策略叫做 <em>广度优先</em> 。这种策略的工作方式有些不同，它先执行第一层聚合， <em>再</em> 继续下一层聚合之前会先做修剪。 图 <a href="#breadth-first-1">Build first level</a> 和图 <a href="#breadth-first-3">Prune first level</a> 对这个过程进行了阐述。</p>
</div>
<div class="paragraph">
<p>在我们的示例中， <code>actors</code> 聚合会首先执行，在这个时候，我们的树只有一层，但我们已经知道了前 10 位的演员！这就没有必要保留其他的演员信息，因为它们无论如何都不会出现在前十位中。</p>
</div>
<div id="breadth-first-1" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_1.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_1.svg" alt="Build first level"></a>
</div>
<div class="title">
Figure 45. Build first level
</div>
</div>
<div id="breadth-first-2" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_2.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_2.svg" alt="Sort first level"></a>
</div>
<div class="title">
Figure 46. Sort first level
</div>
</div>
<div id="breadth-first-3" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_3.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_3.svg" alt="Prune first level"></a>
</div>
<div class="title">
Figure 47. Prune first level
</div>
</div>
<div class="paragraph">
<p>因为我们已经知道了前十名演员，我们可以安全的修剪其他节点。修剪后，下一层是基于 <em>它的</em> 执行模式读入的，重复执行这个过程直到聚合完成，如图 <a href="#breadth-first-4">Populate full depth for remaining nodes</a> 所示。 这种场景下，广度优先可以大幅度节省内存。</p>
</div>
<div id="breadth-first-4" class="imageblock">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_4.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/300_120_breadth_first_4.svg" alt="Step 4: populate full depth for remaining nodes"></a>
</div>
<div class="title">
Figure 48. Populate full depth for remaining nodes
</div>
</div>
<div class="paragraph">
<p>要使用广度优先，只需简单 的通过参数 <code>collect</code> 开启：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "aggs" : {
    "actors" : {
      "terms" : {
         "field" :        "actors",
         "size" :         10,
         "collect_mode" : "breadth_first" <b class="conum">(1)</b>
      },
      "aggs" : {
        "costars" : {
          "terms" : {
            "field" : "actors",
            "size" :  5
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>按聚合来开启 <code>breadth_first</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>广度优先仅仅适用于每个组的聚合数量远远小于当前总组数的情况下，因为广度优先会在内存中缓存裁剪后的仅仅需要缓存的每个组的所有数据，以便于它的子聚合分组查询可以复用上级聚合的数据。</p>
</div>
<div class="paragraph">
<p>广度优先的内存使用情况与裁剪后的缓存分组数据量是成线性的。对于很多聚合来说，每个桶内的文档数量是相当大的。 想象一种按月分组的直方图，总组数肯定是固定的，因为每年只有12个月，这个时候每个月下的数据量可能非常大。这使广度优先不是一个好的选择，这也是为什么深度优先作为默认策略的原因。</p>
</div>
<div class="paragraph">
<p>针对上面演员的例子，如果数据量越大，那么默认的使用深度优先的聚合模式生成的总分组数就会非常多，但是预估二级的聚合字段分组后的数据量相比总的分组数会小很多所以这种情况下使用广度优先的模式能大大节省内存，从而通过优化聚合模式来大大提高了在某些特定场景下聚合查询的成功率。</p>
</div>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/183/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/183/index.html">一起来学算法吧！</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/100.html">MisterBooo</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 97个">97</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/59/index.html">
<img class="uk-book-cover" src="../../static/icons/48/tensorflow_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/59/index.html">TensorFlow 官方文档中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/35.html">jikexueyuanwiki</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="tensorflow">tensorflow</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">33页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8767个">8767</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/38/index.html">
<img class="uk-book-cover" src="../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/38/index.html">Java资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">61页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月23日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7938个">7938</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/142/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/142/index.html">免费开发书籍中文版清单</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/75.html">Free Ebook Foundation</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">78页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 117980个">117980</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/131/index.html">
<img class="uk-book-cover" src="../../static/icons/48/visualstudio_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/131/index.html">Office 365 开发入门指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/70.html">chenxizhang</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="visualstudio">visualstudio</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">51页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 98个">98</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/111/index.html">
<img class="uk-book-cover" src="../../static/icons/48/kubernetes_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/111/index.html">和我一步步部署 kubernetes 集群</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="kubernetes">kubernetes</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">17页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9290;var bookPageRelUrl ='docvalues-and-fielddata.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>