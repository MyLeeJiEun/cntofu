
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>数据输入和输出-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='数据输入和输出,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='数据输入和输出,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/distributed-cluster.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">集群内的原理</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/distributed-docs.html">
<span class="">分布式文档存储</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="data-in-data-out">数据输入和输出</h2>
<div class="paragraph">
<p>无论我们写什么样的程序，目的都是一样的：以某种方式组织数据服务我们的目的。 但是数据不仅仅由随机位和字节组成。我们建立数据元素之间的关系以便于表示实体，或者现实世界中存在的 <em>事物</em> 。 如果我们知道一个名字和电子邮件地址属于同一个人，那么它们将会更有意义。</p>
</div>
<div class="paragraph">
<p>尽管在现实世界中，不是所有的类型相同的实体看起来都是一样的。 一个人可能有一个家庭电话号码，而另一个人只有一个手机号码，再一个人可能两者兼有。 一个人可能有三个电子邮件地址，而另一个人却一个都没有。一位西班牙人可能有两个姓，而讲英语的人可能只有一个姓。</p>
</div>
<div class="paragraph">
<p>面向对象编程语言如此流行的原因之一是对象帮我们表示和处理现实世界具有潜在的复杂的数据结构的实体，到目前为止，一切都很完美！</p>
</div>
<div class="paragraph">
<p>但是当我们需要存储这些实体时问题来了，传统上，我们以行和列的形式存储数据到关系型数据库中，相当于使用电子表格。 正因为我们使用了这种不灵活的存储媒介导致所有我们使用对象的灵活性都丢失了。</p>
</div>
<div class="paragraph">
<p>但是否我们可以将我们的对象按对象的方式来存储？这样我们就能更加专注于 <em>使用</em> 数据，而不是在电子表格的局限性下对我们的应用建模。 我们可以重新利用对象的灵活性。</p>
</div>
<div class="paragraph">
<p>一个 <em>对象</em> 是基于特定语言的内存的数据结构。为了通过网络发送或者存储它，我们需要将它表示成某种标准的格式。 <a href="http://en.wikipedia.org/wiki/Json">JSON</a> 是一种以人可读的文本表示对象的方法。 它已经变成 NoSQL 世界交换数据的事实标准。当一个对象被序列化成为 JSON，它被称为一个 <em>JSON 文档</em> 。</p>
</div>
<div class="paragraph">
<p>Elastcisearch 是分布式的 <em>文档</em> 存储。它能存储和检索复杂的数据结构—​序列化成为JSON文档—​以 <em>实时</em> 的方式。 换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。</p>
</div>
<div class="paragraph">
<p>当然，我们不仅要存储数据，我们一定还需要查询它，成批且快速的查询它们。 尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。</p>
</div>
<div class="paragraph">
<p>在 Elasticsearch 中， <em>每个字段的所有数据</em> 都是 <em>默认被索引的</em> 。 即每个字段都有为了快速检索设置的专用倒排索引。而且，不像其他多数的数据库，它能在 <em>相同的查询中</em> 使用所有这些倒排索引，并以惊人的速度返回结果。</p>
</div>
<div class="paragraph">
<p>在本章中，我们展示了用来创建，检索，更新和删除文档的 API。就目前而言，我们不关心文档中的数据或者怎样查询它们。 所有我们关心的就是在 Elasticsearch 中怎样安全的存储文档，以及如何将文档再次返回。</p>
</div>
<div class="sect2">
<h3 id="document">什么是文档?</h3>
<div class="paragraph">
<p>在大多数应用中，多数实体或对象可以被序列化为包含键值对的 JSON 对象。 一个 <em>键</em> 可以是一个字段或字段的名称，一个 <em>值</em> 可以是一个字符串，一个数字，一个布尔值， 另一个对象，一些数组值，或一些其它特殊类型诸如表示日期的字符串，或代表一个地理位置的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "name":         "John Smith",
    "age":          42,
    "confirmed":    true,
    "join_date":    "2014-06-01",
    "home": {
        "lat":      51.5,
        "lon":      0.1
    },
    "accounts": [
        {
            "type": "facebook",
            "id":   "johnsmith"
        },
        {
            "type": "twitter",
            "id":   "johnsmith"
        }
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常情况下，我们使用的术语 <em>对象</em> 和 <em>文档</em> 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。在 Elasticsearch 中，术语 <em>文档</em> 有着特定的含义。它是指最顶层或者根对象, 这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Warning
</div> </td>
<td class="content"> 字段的名字可以是任何合法的字符串，但不可以包含时间段。 </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_Document_Metadata">文档元数据</h3>
<div class="paragraph">
<p>一个文档不仅仅包含它的数据 ，也包含 <em>元数据</em> —— <em>有关</em> 文档的信息。 三个必须的元数据元素如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>_index</code>
</dt>
<dd>
<p>文档在哪存放</p>
</dd>
<dt class="hdlist1">
<code>_type</code>
</dt>
<dd>
<p>文档表示的对象类别</p>
</dd>
<dt class="hdlist1">
<code>_id</code>
</dt>
<dd>
<p>文档唯一标识</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_index">_index</h4>
<div class="paragraph">
<p>一个 <em>索引</em> 应该是因共同的特性被分组到一起的文档集合。 例如，你可能存储所有的产品在索引 <code>products</code> 中，而存储所有销售的交易到索引 <code>sales</code> 中。 虽然也允许存储不相关的数据到一个索引中，但这通常看作是一个反模式的做法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content">
<div class="paragraph">
<p>实际上，在 Elasticsearch 中，我们的数据是被存储和索引在 <em>分片</em> 中，而一个索引仅仅是逻辑上的命名空间， 这个命名空间由一个或者多个分片组合在一起。 然而，这是一个内部细节，我们的应用程序根本不应该关心分片，对于应用程序而言，只需知道文档位于一个 <em>索引</em> 内。 Elasticsearch 会处理所有的细节。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>我们将在 <a href="#index-management">索引管理</a> 介绍如何自行创建和管理索引，但现在我们将让 Elasticsearch 帮我们创建索引。 所有需要我们做的就是选择一个索引名，这个名字必须小写，不能以下划线开头，不能包含逗号。我们用 <code>website</code> 作为索引名举例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_type">_type</h4>
<div class="paragraph">
<p>数据可能在索引中只是松散的组合在一起，但是通常明确定义一些数据中的子分区是很有用的。 例如，所有的产品都放在一个索引中，但是你有许多不同的产品类别，比如 "electronics" 、 "kitchen" 和 "lawn-care"。</p>
</div>
<div class="paragraph">
<p>这些文档共享一种相同的（或非常相似）的模式：他们有一个标题、描述、产品代码和价格。他们只是正好属于“产品”下的一些子类。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 公开了一个称为 <em>types</em> （类型）的特性，它允许您在索引中对数据进行逻辑分区。不同 types 的文档可能有不同的字段，但最好能够非常相似。 我们将在 <a href="#mapping">类型和映射</a> 中更多的讨论关于 types 的一些应用和限制。</p>
</div>
<div class="paragraph">
<p>一个 <code>_type</code> 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号， 并且长度限制为256个字符. 我们使用 <code>blog</code> 作为类型名举例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_id">_id</h4>
<div class="paragraph">
<p><em>ID</em> 是一个字符串，当它和 <code>_index</code> 以及 <code>_type</code> 组合就可以唯一确定 Elasticsearch 中的一个文档。 当你创建一个新的文档，要么提供自己的 <code>_id</code> ，要么让 Elasticsearch 帮你生成。</p>
</div>
</div>
<div class="sect3">
<h4 id="_Other_Metadata">其他元数据</h4>
<div class="paragraph">
<p>还有一些其他的元数据元素，他们在 <a href="#mapping">类型和映射</a> 进行了介绍。通过前面已经列出的元数据元素， 我们已经能存储文档到 Elasticsearch 中并通过 ID 检索它—​换句话说，使用 Elasticsearch 作为文档的存储介质。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="index-doc">索引文档</h3>
<div class="paragraph">
<p>通过使用 <code>index</code> API ，文档可以被 <em>索引</em> —— 存储和使文档可被搜索。 但是首先，我们要确定文档的位置。正如我们刚刚讨论的，一个文档的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 唯一标识一个文档。 我们可以提供自定义的 <code>_id</code> 值，或者让 <code>index</code> API 自动生成。</p>
</div>
<div class="sect3">
<h4 id="_Using_Our_Own_ID">使用自定义的 ID</h4>
<div class="paragraph">
<p>如果你的文档有一个自然的标识符 （例如，一个 <code>user_account</code> 字段或其他标识文档的值），你应该使用如下方式的 <code>index</code> API 并提供你自己 <code>_id</code> ：</p>
</div>
<div class="listingblock pagebreak-before">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /{index}/{type}/{id}
{
  "field": "value",
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>举个例子，如果我们的索引称为 <code>website</code> ，类型称为 <code>blog</code> ，并且选择 <code>123</code> 作为 ID ，那么索引请求应该是下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "Just trying this out...",
  "date":  "2014/01/01"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elasticsearch 响应体如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "123",
   "_version":  1,
   "created":   true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该响应表明文档已经成功创建，该索引包括 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 元数据， 以及一个新元素： <code>_version</code> 。</p>
</div>
<div class="paragraph">
<p>在 Elasticsearch 中每个文档都有一个版本号。当每次对文档进行修改时（包括删除）， <code>_version</code> 的值会递增。 在 <a href="#version-control">处理冲突</a> 中，我们讨论了怎样使用 <code>_version</code> 号码确保你的应用程序中的一部分修改不会覆盖另一部分所做的修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="_autogenerating_ids">Autogenerating IDs</h4>
<div class="paragraph">
<p>如果你的数据没有自然的 ID， Elasticsearch 可以帮我们自动生成 ID 。 请求的结构调整为： 不再使用 <code>PUT</code> 谓词(“使用这个 URL 存储这个文档”)， 而是使用 <code>POST</code> 谓词(“存储文档在这个 URL 命名空间下”)。</p>
</div>
<div class="paragraph">
<p>现在该 URL 只需包含 <code>_index</code> 和 <code>_type</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/
{
  "title": "My second blog entry",
  "text":  "Still trying this out...",
  "date":  "2014/01/01"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了 <code>_id</code> 是 Elasticsearch 自动生成的，响应的其他部分和前面的类似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "AVFgSgVHUP18jI2wRx0w",
   "_version":  1,
   "created":   true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串。 这些 GUID 字符串由可修改的 FlakeID 模式生成，这种模式允许多个节点并行生成唯一 ID ，且互相之间的冲突概率几乎为零。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="get-doc">取回一个文档</h3>
<div class="paragraph">
<p>为了从 Elasticsearch 中检索出文档，我们仍然使用相同的 <code>_index</code> , <code>_type</code> , 和 <code>_id</code> ，但是 HTTP 谓词更改为 <code>GET</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /website/blog/123?pretty</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应体包括目前已经熟悉了的元数据元素，再加上 <code>_source</code> 字段，这个字段包含我们索引数据时发送给 Elasticsearch 的原始 JSON 文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "title": "My first blog entry",
      "text":  "Just trying this out...",
      "date":  "2014/01/01"
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>在请求的查询串参数中加上 <code>pretty</code> 参数，正如前面的例子中看到的，这将会调用 Elasticsearch 的 <em>pretty-print</em> 功能，该功能 使得 JSON 响应体更加可读。但是， <code>_source</code> 字段不能被格式化打印出来。相反，我们得到的 <code>_source</code> 字段中的 JSON 串，刚好是和我们传给它的一样。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>GET 请求的响应体包括 <code>{"found": true}</code> ，这证实了文档已经被找到。 如果我们请求一个不存在的文档，我们仍旧会得到一个 JSON 响应体，但是 <code>found</code> 将会是 <code>false</code> 。 此外， HTTP 响应码将会是 <code>404 Not Found</code> ，而不是 <code>200 OK</code> 。</p>
</div>
<div class="paragraph">
<p>我们可以通过传递 <code>-i</code> 参数给 <code>curl</code> 命令，该参数能够显示响应的头部：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">curl -i -XGET http://localhost:9200/website/blog/124?pretty</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示响应头部的响应体现在类似这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">HTTP/1.1 404 Not Found
Content-Type: application/json; charset=UTF-8
Content-Length: 83

{
  "_index" : "website",
  "_type" :  "blog",
  "_id" :    "124",
  "found" :  false
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_返回文档的一部分">返回文档的一部分</h4>
<div class="paragraph">
<p>默认情况下， <code>GET</code> 请求会返回整个文档，这个文档正如存储在 <code>_source</code> 字段中的一样。但是也许你只对其中的 <code>title</code> 字段感兴趣。单个字段能用 <code>_source</code> 参数请求得到，多个字段也能使用逗号分隔的列表来指定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /website/blog/123?_source=title,text</code></pre>
</div>
</div>
<div class="paragraph">
<p>该 <code>_source</code> 字段现在包含的只是我们请求的那些字段，并且已经将 <code>date</code> 字段过滤掉了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 1,
  "found" :   true,
  "_source" : {
      "title": "My first blog entry" ,
      "text":  "Just trying this out..."
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果你只想得到 <code>_source</code> 字段，不需要任何元数据，你能使用 <code>_source</code> 端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /website/blog/123/_source</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么返回的的内容如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "title": "My first blog entry",
   "text":  "Just trying this out...",
   "date":  "2014/01/01"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="doc-exists">检查文档是否存在</h3>
<div class="paragraph">
<p>如果只想检查一个文档是否存在--根本不想关心内容—​那么用 <code>HEAD</code> 方法来代替 <code>GET</code> 方法。 <code>HEAD</code> 请求没有返回体，只返回一个 HTTP 请求报头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -i -XHEAD http://localhost:9200/website/blog/123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文档存在， Elasticsearch 将返回一个 <code>200 ok</code> 的状态码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>若文档不存在， Elasticsearch 将返回一个 <code>404 Not Found</code> 的状态码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -i -XHEAD http://localhost:9200/website/blog/124</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=UTF-8
Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，一个文档仅仅是在检查的时候不存在，并不意味着一毫秒之后它也不存在：也许同时正好另一个进程就创建了该文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="update-doc">更新整个文档</h3>
<div class="paragraph">
<p>在 Elasticsearch 中文档是 <em>不可改变</em> 的，不能修改它们。相反，如果想要更新现有的文档，需要 <em>重建索引</em> 或者进行替换， 我们可以使用相同的 <code>index</code> API 进行实现，在 <a href="#index-doc">索引文档</a> 中已经进行了讨论。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在响应体中，我们能看到 Elasticsearch 已经增加了 <code>_version</code> 字段值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 2,
  "created":   false <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>created</code> 标志设置成 <code>false</code> ，是因为相同的索引、类型和 ID 的文档已经存在。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。</p>
</div>
<div class="paragraph">
<p>在本章的后面部分，我们会介绍 <code>update</code> API, 这个 API 可以用于 <a href="#partial-updates">partial updates to a document</a> 。 虽然它似乎对文档直接进行了修改，但实际上 Elasticsearch 按前述完全相同方式执行以下过程：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>从旧文档构建 JSON</p> </li>
<li> <p>更改该 JSON</p> </li>
<li> <p>删除旧文档</p> </li>
<li> <p>索引一个新文档</p> </li>
</ol>
</div>
<div class="paragraph">
<p>唯一的区别在于, <code>update</code> API 仅仅通过一个客户端请求来实现这些步骤，而不需要单独的 <code>get</code> 和 <code>index</code> 请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="create-doc">创建新文档</h3>
<div class="paragraph">
<p>当我们索引一个文档，怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？</p>
</div>
<div class="paragraph">
<p>请记住， <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 的组合可以唯一标识一个文档。所以，确保创建一个新文档的最简单办法是，使用索引请求的 <code>POST</code> 形式让 Elasticsearch 自动生成唯一 <code>_id</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/
{ ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，如果已经有自己的 <code>_id</code> ，那么我们必须告诉 Elasticsearch ，只有在相同的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 不存在时才接受我们的索引请求。这里有两种方式，他们做的实际是相同的事情。使用哪种，取决于哪种使用起来更方便。</p>
</div>
<div class="paragraph">
<p>第一种方法使用 <code>op_type</code> 查询-字符串参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123?op_type=create
{ ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二种方法是在 URL 末端使用 <code>/_create</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123/_create
{ ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 <code>201 Created</code> 的 HTTP 响应码。</p>
</div>
<div class="paragraph">
<p>另一方面，如果具有相同的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 的文档已经存在，Elasticsearch 将会返回 <code>409 Conflict</code> 响应码，以及如下的错误信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "error": {
      "root_cause": [
         {
            "type": "document_already_exists_exception",
            "reason": "[blog][123]: document already exists",
            "shard": "0",
            "index": "website"
         }
      ],
      "type": "document_already_exists_exception",
      "reason": "[blog][123]: document already exists",
      "shard": "0",
      "index": "website"
   },
   "status": 409
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="delete-doc">删除文档</h3>
<div class="paragraph">
<p>删除文档的语法和我们所知道的规则相同，只是使用 <code>DELETE</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /website/blog/123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果找到该文档，Elasticsearch 将要返回一个 <code>200 ok</code> 的 HTTP 响应码，和一个类似以下结构的响应体。注意，字段 <code>_version</code> 值已经增加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "found" :    true,
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 3
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文档没有找到，我们将得到 <code>404 Not Found</code> 的响应码和类似这样的响应体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "found" :    false,
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 4
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使文档不存在（ <code>Found</code> 是 <code>false</code> ）， <code>_version</code> 值仍然会增加。这是 Elasticsearch 内部记录本的一部分，用来确保这些改变在跨多节点时以正确的顺序执行。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content"> 正如已经在<a href="#update-doc">更新整个文档</a>中提到的，删除文档不会立即将文档从磁盘中删除，只是将文档标记为已删除状态。随着你不断的索引更多的数据，Elasticsearch 将会在后台清理标记为已删除的文档。 </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="version-control">处理冲突</h3>
<div class="paragraph">
<p>当我们使用 <code>index</code> API 更新文档 ，可以一次性读取原始文档，做我们的修改，然后重新索引 <em>整个文档</em> 。 最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。</p>
</div>
<div class="paragraph">
<p>很多时候这是没有问题的。也许我们的主数据存储是一个关系型数据库，我们只是将数据复制到 Elasticsearch 中并使其可被搜索。 也许两个人同时更改相同的文档的几率很小。或者对于我们的业务来说偶尔丢失更改并不是很严重的问题。</p>
</div>
<div class="paragraph">
<p>但有时丢失了一个变更就是 <em>非常严重的</em> 。试想我们使用 Elasticsearch 存储我们网上商城商品库存的数量， 每次我们卖一个商品的时候，我们在 Elasticsearch 中将库存数量减少。</p>
</div>
<div class="paragraph">
<p>有一天，管理层决定做一次促销。突然地，我们一秒要卖好几个商品。 假设有两个 web 程序并行运行，每一个都同时处理所有商品的销售，如图 <a href="#img-data-lww">Consequence of no concurrency control</a> 所示。</p>
</div>
<div id="img-data-lww" class="imageblock" style="text-align: center">
<div class="content">
<a href="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_0301.png" data-uk-lightbox><img src="https://img.cntofu.com/book/elasticsearch-definitive-guide/images/elas_0301.png" alt="Consequence of no concurrency control" width="50%"></a>
</div>
<div class="title">
Figure 7. Consequence of no concurrency control
</div>
</div>
<div class="paragraph">
<p><code>web_1</code> 对 <code>stock_count</code> 所做的更改已经丢失，因为 <code>web_2</code> 不知道它的 <code>stock_count</code> 的拷贝已经过期。 结果我们会认为有超过商品的实际数量的库存，因为卖给顾客的库存商品并不存在，我们将让他们非常失望。</p>
</div>
<div class="paragraph">
<p>变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。</p>
</div>
<div class="paragraph">
<p>在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<em>悲观并发控制</em>
</dt>
<dd>
<p>这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</p>
</dd>
<dt class="hdlist1">
<em>乐观并发控制</em>
</dt>
<dd>
<p>Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="optimistic-concurrency-control">乐观并发控制</h3>
<div class="paragraph">
<p>Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 <em>顺序是乱的</em> 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p>
</div>
<div class="paragraph">
<p>当我们之前讨论 <code>index</code> ， <code>GET</code> 和 <code>delete</code> 请求时，我们指出每个文档都有一个 <code>_version</code> （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 <code>_version</code> 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p>
</div>
<div class="paragraph">
<p>我们可以利用 <code>_version</code> 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 <code>version</code> 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。</p>
</div>
<div class="paragraph">
<p>让我们创建一个新的博客文章：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/1/_create
{
  "title": "My first blog entry",
  "text":  "Just trying this out..."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应体告诉我们，这个新创建的文档 <code>_version</code> 版本号是 <code>1</code> 。现在假设我们想编辑这个文档：我们加载其数据到 web 表单中， 做一些修改，然后保存新的版本。</p>
</div>
<div class="paragraph">
<p>首先我们检索文档:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /website/blog/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应体包含相同的 <code>_version</code> 版本号 <code>1</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "1",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "title": "My first blog entry",
      "text":  "Just trying this out..."
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，当我们尝试通过重建文档的索引来保存修改，我们指定 <code>version</code> 为我们的修改会被应用的版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/1?version=1 <b class="conum">(1)</b>
{
  "title": "My first blog entry",
  "text":  "Starting to get the hang of this..."
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>我们想这个在我们索引中的文档只有现在的 <code>_version</code> 为 <code>1</code> 时，本次更新才能成功。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>此请求成功，并且响应体告诉我们 <code>_version</code> 已经递增到 <code>2</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "1",
  "_version": 2
  "created":  false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，如果我们重新运行相同的索引请求，仍然指定 <code>version=1</code> ， Elasticsearch 返回 <code>409 Conflict</code> HTTP 响应码，和一个如下所示的响应体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "error": {
      "root_cause": [
         {
            "type": "version_conflict_engine_exception",
            "reason": "[blog][1]: version conflict, current [2], provided [1]",
            "index": "website",
            "shard": "3"
         }
      ],
      "type": "version_conflict_engine_exception",
      "reason": "[blog][1]: version conflict, current [2], provided [1]",
      "index": "website",
      "shard": "3"
   },
   "status": 409
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉我们在 Elasticsearch 中这个文档的当前 <code>_version</code> 号是 <code>2</code> ，但我们指定的更新版本号为 <code>1</code> 。</p>
</div>
<div class="paragraph">
<p>我们现在怎么做取决于我们的应用需求。我们可以告诉用户说其他人已经修改了文档，并且在再次保存之前检查这些修改内容。 或者，在之前的商品 <code>stock_count</code> 场景，我们可以获取到最新的文档并尝试重新应用这些修改。</p>
</div>
<div class="paragraph">
<p>所有文档的更新或删除 API，都可以接受 <code>version</code> 参数，这允许你在代码中使用乐观的并发控制，这是一种明智的做法。</p>
</div>
<div class="sect3">
<h4 id="_Using_Versions_from_an_External_System">通过外部系统使用版本控制</h4>
<div class="paragraph">
<p>一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。</p>
</div>
<div class="paragraph">
<p>如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 <code>timestamp</code> — 那么你就可以在 Elasticsearch 中通过增加 <code>version_type=external</code> 到查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 <code>9.2E+18</code> — 一个 Java 中 <code>long</code> 类型的正值。</p>
</div>
<div class="paragraph">
<p>外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 <code><em>version</em></code><em> 和请求中指定的版本号是否相同， 而是检查当前 <code>_version</code> 是否 _小于</em> 指定的版本号。 如果请求成功，外部的版本号作为文档的新 <code>_version</code> 进行存储。</p>
</div>
<div class="paragraph">
<p>外部版本号不仅在索引和删除请求是可以指定，而且在 <em>创建</em> 新文档时也可以指定。</p>
</div>
<div class="paragraph">
<p>例如，要创建一个新的具有外部版本号 <code>5</code> 的博客文章，我们可以按以下方法进行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/2?version=5&amp;version_type=external
{
  "title": "My first external blog entry",
  "text":  "Starting to get the hang of this..."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在响应中，我们能看到当前的 <code>_version</code> 版本号是 <code>5</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 5,
  "created":  true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们更新这个文档，指定一个新的 <code>version</code> 号是 <code>10</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/2?version=10&amp;version_type=external
{
  "title": "My first external blog entry",
  "text":  "This is a piece of cake..."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请求成功并将当前 <code>_version</code> 设为 <code>10</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 10,
  "created":  false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你要重新运行此请求时，它将会失败，并返回像我们之前看到的同样的冲突错误， 因为指定的外部版本号不大于 Elasticsearch 的当前版本号。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="partial-updates">文档的部分更新</h3>
<div class="paragraph">
<p>在 <a href="#update-doc">更新整个文档</a> , 我们已经介绍过 更新一个文档的方法是检索并修改它，然后重新索引整个文档，这的确如此。然而，使用 <code>update</code> API 我们还可以部分更新文档，例如在某个请求时对计数器进行累加。</p>
</div>
<div class="paragraph">
<p>我们也介绍过文档是不可变的：他们不能被修改，只能被替换。 <code>update</code> API 必须遵循同样的规则。 从外部来看，我们在一个文档的某个位置进行部分更新。然而在内部， <code>update</code> API 简单使用与之前描述相同的 <em>检索-修改-重建索引</em> 的处理过程。 区别在于这个过程发生在分片内部，这样就避免了多次请求的网络开销。通过减少检索和重建索引步骤之间的时间，我们也减少了其他进程的变更带来冲突的可能性。</p>
</div>
<div class="paragraph">
<p><code>update</code> 请求最简单的一种形式是接收文档的一部分作为 <code>doc</code> 的参数， 它只是与现有的文档进行合并。对象被合并到一起，覆盖现有的字段，增加新的字段。 例如，我们增加字段 <code>tags</code> 和 <code>views</code> 到我们的博客文章，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "doc" : {
      "tags" : [ "testing" ],
      "views": 0
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求成功，我们看到类似于 <code>index</code> 请求的响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index" :   "website",
   "_id" :      "1",
   "_type" :    "blog",
   "_version" : 3
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>检索文档显示了更新后的 <code>_source</code> 字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  3,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags": [ "testing" ], <b class="conum">(1)</b>
      "views":  0 <b class="conum">(1)</b>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>新的字段已被添加到 <code>_source</code> 中。</p> </li>
</ol>
</div>
<div class="sect3">
<h4 id="_Using_Scripts_to_Make_Partial_Updates">使用脚本部分更新文档</h4>
<div class="paragraph">
<p>脚本可以在 <code>update</code> API中用来改变 <code>_source</code> 的字段内容， 它在更新脚本中称为 <code>ctx._source</code> 。 例如，我们可以使用脚本来增加博客文章中 <code>views</code> 的数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "script" : "ctx._source.views+=1"
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
用 Groovy 脚本编程
</div>
<div class="paragraph">
<p>对于那些 API 不能满足需求的情况，Elasticsearch 允许你使用脚本编写自定义的逻辑。 许多API都支持脚本的使用，包括搜索、排序、聚合和文档更新。 脚本可以作为请求的一部分被传递，从特殊的 .scripts 索引中检索，或者从磁盘加载脚本。</p>
</div>
<div class="paragraph">
<p>默认的脚本语言 是 <a href="http://groovy.codehaus.org/">Groovy</a>，一种快速表达的脚本语言，在语法上与 JavaScript 类似。 它在 Elasticsearch V1.3.0 版本首次引入并运行在 <em>沙盒</em> 中，然而 Groovy 脚本引擎存在漏洞， 允许攻击者通过构建 Groovy 脚本，在 Elasticsearch Java VM 运行时脱离沙盒并执行 shell 命令。</p>
</div>
<div class="paragraph">
<p>因此，在版本 v1.3.8 、 1.4.3 和 V1.5.0 及更高的版本中，它已经被默认禁用。 此外，您可以通过设置集群中的所有节点的 <code>config/elasticsearch.yml</code> 文件来禁用动态 Groovy 脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">script.groovy.sandbox.enabled: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将关闭 Groovy 沙盒，从而防止动态 Groovy 脚本作为请求的一部分被接受， 或者从特殊的 <code>.scripts</code> 索引中被检索。当然，你仍然可以使用存储在每个节点的 <code>config/scripts/</code> 目录下的 Groovy 脚本。</p>
</div>
<div class="paragraph">
<p>如果你的架构和安全性不需要担心漏洞攻击，例如你的 Elasticsearch 终端仅暴露和提供给可信赖的应用， 当它是你的应用需要的特性时，你可以选择重新启用动态脚本。</p>
</div>
<div class="paragraph">
<p>你可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-scripting.html">scripting reference documentation</a> 获取更多关于脚本的资料。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>我们也可以通过使用脚本给 <code>tags</code> 数组添加一个新的标签。在这个例子中，我们指定新的标签作为参数，而不是硬编码到脚本内部。 这使得 Elasticsearch 可以重用这个脚本，而不是每次我们想添加标签时都要对新脚本重新编译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "script" : "ctx._source.tags+=new_tag",
   "params" : {
      "new_tag" : "search"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>获取文档并显示最后两次请求的效果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  5,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags":  ["testing", "search"], <b class="conum">(1)</b>
      "views":  1 <b class="conum">(2)</b>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p><code>search</code> 标签已追加到 <code>tags</code> 数组中。</p> </li>
<li> <p><code>views</code> 字段已递增。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>我们甚至可以选择通过设置 <code>ctx.op</code> 为 <code>delete</code> 来删除基于其内容的文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "script" : "ctx.op = ctx._source.views == count ? 'delete' : 'none'",
    "params" : {
        "count": 1
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_Updating_a_Document_That_May_Not_Yet_Exist">更新的文档可能尚不存在</h4>
<div class="paragraph">
<p>假设我们需要在 Elasticsearch 中存储一个页面访问量计数器。 每当有用户浏览网页，我们对该页面的计数器进行累加。但是，如果它是一个新网页，我们不能确定计数器已经存在。 如果我们尝试更新一个不存在的文档，那么更新操作将会失败。</p>
</div>
<div class="paragraph">
<p>在这样的情况下，我们可以使用 <code>upsert</code> 参数，指定如果文档不存在就应该先创建它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/pageviews/1/_update
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 1
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们第一次运行这个请求时， <code>upsert</code> 值作为新文档被索引，初始化 <code>views</code> 字段为 <code>1</code> 。 在后续的运行中，由于文档已经存在， <code>script</code> 更新操作将替代 <code>upsert</code> 进行应用，对 <code>views</code> 计数器进行累加。</p>
</div>
</div>
<div class="sect3">
<h4 id="_Updates_and_Conflicts">更新和冲突</h4>
<div class="paragraph">
<p>在本节的介绍中，我们说明 <em>检索</em> 和 <em>重建索引</em> 步骤的间隔越小，变更冲突的机会越小。 但是它并不能完全消除冲突的可能性。 还是有可能在 <code>update</code> 设法重新索引之前，来自另一进程的请求修改了文档。</p>
</div>
<div class="paragraph">
<p>为了避免数据丢失， <code>update</code> API 在 <em>检索</em> 步骤时检索得到文档当前的 <code><em>version</em></code><em> 号，并传递版本号到 _重建索引</em> 步骤的 <code>index</code> 请求。 如果另一个进程修改了处于检索和重新索引步骤之间的文档，那么 <code>_version</code> 号将不匹配，更新请求将会失败。</p>
</div>
<div class="paragraph">
<p>对于部分更新的很多使用场景，文档已经被改变也没有关系。 例如，如果两个进程都对页面访问量计数器进行递增操作，它们发生的先后顺序其实不太重要； 如果冲突发生了，我们唯一需要做的就是尝试再次更新。</p>
</div>
<div class="paragraph">
<p>这可以通过设置参数 <code>retry_on_conflict</code> 来自动完成， 这个参数规定了失败之前 <code>update</code> 应该重试的次数，它的默认值为 <code>0</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/pageviews/1/_update?retry_on_conflict=5 <b class="conum">(1)</b>
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 0
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>失败之前重试该更新5次。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>在增量操作无关顺序的场景，例如递增计数器等这个方法十分有效，但是在其他情况下变更的顺序 <em>是</em> 非常重要的。 类似 <a href="#index-doc"><code>index</code> API</a> ， <code>update</code> API 默认采用 <em>最终写入生效</em> 的方案，但它也接受一个 <code>version</code> 参数来允许你使用 <a href="#optimistic-concurrency-control">optimistic concurrency control</a> 指定想要更新文档的版本。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Retrieving_Multiple_Documents">取回多个文档</h3>
<div class="paragraph">
<p>Elasticsearch 的速度已经很快了，但甚至能更快。 将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。 如果你需要从 Elasticsearch 检索很多文档，那么使用 <em>multi-get</em> 或者 <code>mget</code> API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p>
</div>
<div class="paragraph">
<p><code>mget</code> API 要求有一个 <code>docs</code> 数组作为参数，每个元素包含需要检索文档的元数据， 包括 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 。如果你想检索一个或者多个特定的字段，那么你可以通过 <code>_source</code> 参数来指定这些字段的名字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该响应体也包含一个 <code>docs</code> 数组， 对于每一个在请求中指定的文档，这个数组中都包含有一个对应的响应，且顺序与请求中的顺序相同。 其中的每一个响应都和使用单个 <a href="#get-doc"><code>get</code> request</a> 请求所得到的响应体相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "docs" : [
      {
         "_index" :   "website",
         "_id" :      "2",
         "_type" :    "blog",
         "found" :    true,
         "_source" : {
            "text" :  "This is a piece of cake...",
            "title" : "My first external blog entry"
         },
         "_version" : 10
      },
      {
         "_index" :   "website",
         "_id" :      "1",
         "_type" :    "pageviews",
         "found" :    true,
         "_version" : 2,
         "_source" : {
            "views" : 2
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果想检索的数据都在相同的 <code>_index</code> 中（甚至相同的 <code>_type</code> 中），则可以在 URL 中指定默认的 <code>/_index</code> 或者默认的 <code>/_index/_type</code> 。</p>
</div>
<div class="paragraph">
<p>你仍然可以通过单独请求覆盖这些值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /website/blog/_mget
{
   "docs" : [
      { "_id" : 2 },
      { "_type" : "pageviews", "_id" :   1 }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，如果所有文档的 <code>_index</code> 和 <code>_type</code> 都是相同的，你可以只传一个 <code>ids</code> 数组，而不是整个 <code>docs</code> 数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，我们请求的第二个文档是不存在的。我们指定类型为 <code>blog</code> ，但是文档 ID <code>1</code> 的类型是 <code>pageviews</code> ，这个不存在的情况将在响应体中被报告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "docs" : [
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "2",
      "_version" : 10,
      "found" :    true,
      "_source" : {
        "title":   "My first external blog entry",
        "text":    "This is a piece of cake..."
      }
    },
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "1",
      "found" :    false  <b class="conum">(1)</b>
    }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>未找到该文档。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>事实上第二个文档未能找到并不妨碍第一个文档被检索到。每个文档都是单独检索和报告的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Note
</div> </td>
<td class="content">
<div class="paragraph">
<p>即使有某个文档没有找到，上述请求的 HTTP 状态码仍然是 <code>200</code> 。事实上，即使请求 <em>没有</em> 找到任何文档，它的状态码依然是 <code>200</code> --因为 <code>mget</code> 请求本身已经成功执行。 为了确定某个文档查找是成功或者失败，你需要检查 <code>found</code> 标记。</p>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="bulk">代价较小的批量操作</h3>
<div class="paragraph">
<p>与 <code>mget</code> 可以使我们一次取回多个文档同样的方式， <code>bulk</code> API 允许在单个步骤中进行多次 <code>create</code> 、 <code>index</code> 、 <code>update</code> 或 <code>delete</code> 请求。 如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。</p>
</div>
<div class="paragraph">
<p><code>bulk</code> 与其他的请求体格式稍有不同，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ action: { metadata }}\n
{ request body        }\n
{ action: { metadata }}\n
{ request body        }\n
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种格式类似一个有效的单行 JSON 文档 <em>流</em> ，它通过换行符(<code>\n</code>)连接到一起。注意两个要点：</p>
</div>
<div class="ulist">
<ul>
<li> <p>每行一定要以换行符(<code>\n</code>)结尾， <em>包括最后一行</em> 。这些换行符被用作一个标记，可以有效分隔行。</p> </li>
<li> <p>这些行不能包含未转义的换行符，因为他们将会对解析造成干扰。这意味着这个 JSON <em>不</em> 能使用 pretty 参数打印。</p> </li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">
Tip
</div> </td>
<td class="content"> 在 <a href="#bulk-format">为什么是有趣的格式？</a> 中， 我们解释为什么 <code>bulk</code> API 使用这种格式。 </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>action/metadata 行指定 <em>哪一个文档</em> 做 <em>什么操作</em> 。</p>
</div>
<div class="paragraph">
<p>action 必须是以下选项之一:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>create</code>
</dt>
<dd>
<p>如果文档不存在，那么就创建它。详情请见 <a href="#create-doc">创建新文档</a>。</p>
</dd>
<dt class="hdlist1">
<code>index</code>
</dt>
<dd>
<p>创建一个新文档或者替换一个现有的文档。详情请见 <a href="#index-doc">索引文档</a> 和 <a href="#update-doc">更新整个文档</a>。</p>
</dd>
<dt class="hdlist1">
<code>update</code>
</dt>
<dd>
<p>部分更新一个文档。详情请见 <a href="#partial-updates">文档的部分更新</a>。</p>
</dd>
<dt class="hdlist1">
<code>delete</code>
</dt>
<dd>
<p>删除一个文档。详情请见 <a href="#delete-doc">删除文档</a>。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>metadata 应该指定被索引、创建、更新或者删除的文档的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 。</p>
</div>
<div class="paragraph">
<p>例如，一个 <code>delete</code> 请求看起来是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>request body 行由文档的 <code>_source</code> 本身组成—​文档包含的字段和值。它是 <code>index</code> 和 <code>create</code> 操作所必需的，这是有道理的：你必须提供文档以索引。</p>
</div>
<div class="paragraph">
<p>它也是 <code>update</code> 操作所必需的，并且应该包含你传递给 <code>update</code> API 的相同请求体： <code>doc</code> 、 <code>upsert</code> 、 <code>script</code> 等等。 删除操作不需要 request body 行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "create":  { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "My first blog post" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不指定 <code>_id</code> ，将会自动生成一个 ID ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "index": { "_index": "website", "_type": "blog" }}
{ "title":    "My second blog post" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了把所有的操作组合在一起，一个完整的 <code>bulk</code> 请求 有以下形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /_bulk
{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }} <b class="conum">(1)</b>
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "My first blog post" }
{ "index":  { "_index": "website", "_type": "blog" }}
{ "title":    "My second blog post" }
{ "update": { "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3} }
{ "doc" : {"title" : "My updated blog post"} } <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>请注意 <code>delete</code> 动作不能有请求体,它后面跟着的是另外一个操作。</p> </li>
<li> <p>谨记最后一个换行符不要落下。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>这个 Elasticsearch 响应包含 <code>items</code> 数组，这个数组的内容是以请求的顺序列出来的每个请求的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "took": 4,
   "errors": false, <b class="conum">(1)</b>
   "items": [
      {  "delete": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 2,
            "status":   200,
            "found":    true
      }},
      {  "create": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 3,
            "status":   201
      }},
      {  "create": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "EiwfApScQiiy7TIKFxRCTw",
            "_version": 1,
            "status":   201
      }},
      {  "update": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 4,
            "status":   200
      }}
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>所有的子请求都成功完成。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。 如果其中任何子请求失败，最顶层的 <code>error</code> 标志被设置为 <code>true</code> ，并且在相应的请求报告出错误明细：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /_bulk
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "Cannot create - it already exists" }
{ "index":  { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "But we can update it" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在响应中，我们看到 <code>create</code> 文档 <code>123</code> 失败，因为它已经存在。但是随后的 <code>index</code> 请求，也是对文档 <code>123</code> 操作，就成功了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "took": 3,
   "errors": true, <b class="conum">(1)</b>
   "items": [
      {  "create": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "status":   409, <b class="conum">(2)</b>
            "error":    "DocumentAlreadyExistsException <b class="conum">(3)</b>
                        [[website][4] [blog][123]:
                        document already exists]"
      }},
      {  "index": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 5,
            "status":   200 <b class="conum">(4)</b>
      }}
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>一个或者多个请求失败。</p> </li>
<li> <p>这个请求的HTTP状态码报告为 <code>409 CONFLICT</code> 。</p> </li>
<li> <p>解释为什么请求失败的错误信息。</p> </li>
<li> <p>第二个请求成功，返回 HTTP 状态码 <code>200 OK</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>这也意味着 <code>bulk</code> 请求不是原子的： 不能用它来实现事务控制。每个请求是单独处理的，因此一个请求的成功或失败不会影响其他的请求。</p>
</div>
<div class="sect3">
<h4 id="_Dont_Repeat_Yourself">不要重复指定Index和Type</h4>
<div class="paragraph">
<p>也许你正在批量索引日志数据到相同的 <code>index</code> 和 <code>type</code> 中。 但为每一个文档指定相同的元数据是一种浪费。相反，可以像 <code>mget</code> API 一样，在 <code>bulk</code> 请求的 URL 中接收默认的 <code>/_index</code> 或者 <code>/_index/_type</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/_bulk
{ "index": { "_type": "log" }}
{ "event": "User logged in" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你仍然可以覆盖元数据行中的 <code>_index</code> 和 <code>_type</code> , 但是它将使用 URL 中的这些元数据值作为默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/log/_bulk
{ "index": {}}
{ "event": "User logged in" }
{ "index": { "_type": "blog" }}
{ "title": "Overriding the default type" }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_How_Big_Is_Too_Big">多大是太大了？</h4>
<div class="paragraph">
<p>整个批量请求都需要由接收到请求的节点加载到内存中，因此该请求越大，其他请求所能获得的内存就越少。 批量请求的大小有一个最佳值，大于这个值，性能将不再提升，甚至会下降。 但是最佳值不是一个固定的值。它完全取决于硬件、文档的大小和复杂度、索引和搜索的负载的整体情况。</p>
</div>
<div class="paragraph">
<p>幸运的是，很容易找到这个 <em>最佳点</em> ：通过批量索引典型文档，并不断增加批量大小进行尝试。 当性能开始下降，那么你的批量大小就太大了。一个好的办法是开始时将 1,000 到 5,000 个文档作为一个批次, 如果你的文档非常大，那么就减少批量的文档个数。</p>
</div>
<div class="paragraph">
<p>密切关注你的批量请求的物理大小往往非常有用，一千个 1KB 的文档是完全不同于一千个 1MB 文档所占的物理大小。 一个好的批量大小在开始处理后所占用的物理大小约为 5-15 MB。</p>
</div>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/35/index.html">
<img class="uk-book-cover" src="../../static/icons/48/django_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/35/index.html">Django 1.8 中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="django">django</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">172页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 16个">16</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/156/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/156/index.html">pyspider中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/88.html">aaronhua123</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">18页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月12日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/34/index.html">
<img class="uk-book-cover" src="../../static/icons/48/markdown_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/34/index.html">Markdown - 简单的世界</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="markdown">markdown</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">16页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 159个">159</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/138/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/138/index.html">开发经验总结</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 641个">641</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/102/index.html">
<img class="uk-book-cover" src="../../static/icons/48/c_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/102/index.html">C 语言进阶</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="c">c</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">32页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/48/index.html">
<img class="uk-book-cover" src="../../static/icons/48/tensorflow_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/48/index.html">机器学习基础笔记</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/25.html">zhjunqin</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="tensorflow">tensorflow</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">43页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月2日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9256;var bookPageRelUrl ='data-in-data-out.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>