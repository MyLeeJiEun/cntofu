
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>监控-Elasticsearch权威指南(Elasticsearch Definitive Guide)</title>
<meta content='监控,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='keywords'>
<meta content='监控,Elasticsearch权威指南,Elasticsearch Definitive Guide' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/asciidoc.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/40/administration.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">管理、监控和部署</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/40/deploy.html">
<span class="">部署</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/40/index.html">Elasticsearch权威指南 (Elasticsearch Definitive Guide)</a>
<a target="_blank" rel="nofollow" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  asc-content-section  uk-margin-bottom">
<h2 id="cluster-admin">监控</h2>
<div class="paragraph">
<p>Elasticsearch 经常以多节点集群的方式部署。有多种 API 让你可以管理和监控集群本身，而不用和集群里存储的数据打交道。</p>
</div>
<div class="paragraph">
<p>和 Elasticsearch 里绝大多数功能一样，我们有一个总体的设计目标，即任务应该通过 API 执行，而不是通过修改静态的配置文件。这一点在你的集群扩容时尤为重要。即便通过配置管理系统（比如 Puppet，Chef 或者 Ansible），一个简单的 HTTP API 调用，也比往上百台物理设备上推送新配置文件简单多了。</p>
</div>
<div class="paragraph">
<p>因此，本章将介绍各种可以让你动态调整、调优和调配集群的 API。同时，还会介绍一系列提供集群自身统计数据的 API，你可以用这些接口来监控集群健康状态和性能。</p>
</div>
<div class="sect2">
<h3 id="marvel">Marvel 监控</h3>
<div class="paragraph">
<p><a href="https://www.elastic.co/guide/en/marvel/current/index.html">Marvel</a> 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。</p>
</div>
<div class="paragraph">
<p>虽然你可以通过本章介绍的 API 查看大量的指标数据，但是它们展示的都是当前时间点的即时情况。了解这个瞬间的内存占用比当然很有用，但是了解内存占用比 <em>随时间轴的趋势</em> 更加有用。Marvel 会查询并聚合这些数据，你可以通过可视化效果看到自己集群随时间的变化，这样可以很容易的发现发展的趋势。</p>
</div>
<div class="paragraph">
<p>随着你集群规模的发展，统计 API 的输出内容会复杂得让人完全没法看。当你有一大把节点，比如说一百个，再阅读这个输出的 JSON 就非常乏味了。而 Marvel 可以让你交互式的探索这些数据，更容易于集中关注特定节点或者索引上发生了什么。</p>
</div>
<div class="paragraph">
<p>Marvel 使用公开的 API，和你自己能找到的一样 — 它没有暴露任何你通过 API 访问不到的统计信息。但是，Marvel 极大的简化了这些统计信息的采集和可视化工作。</p>
</div>
<div class="paragraph">
<p>Marvel 可以免费使用（包括生产环境上！），所以你现在就开始用起来吧！安装介绍，参阅 <a href="https://www.elastic.co/guide/en/marvel/current/getting-started.html">Marvel 入门</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_health">集群健康</h3>
<div class="paragraph">
<p>一个 Elasticsearch 集群至少包括一个节点和一个索引。或者它可能有一百个数据节点、三个单独的主节点，以及一小打客户端节点——这些共同操作一千个索引（以及上万个分片）。</p>
</div>
<div class="paragraph">
<p>不管集群扩展到多大规模，你都会想要一个快速获取集群状态的途径。<code>Cluster Health</code> API 充当的就是这个角色。你可以把它想象成是在一万英尺的高度鸟瞰集群。它可以告诉你安心吧一切都好，或者警告你集群某个地方有问题。</p>
</div>
<div class="paragraph">
<p>让我们执行一下 <code>cluster-health</code> API 然后看看响应体是什么样子的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET _cluster/health</code></pre>
</div>
</div>
<div class="paragraph">
<p>和 Elasticsearch 里其他 API 一样，<code>cluster-health</code> 会返回一个 JSON 响应。这对自动化和告警系统来说，非常便于解析。响应中包含了和你集群有关的一些关键信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "cluster_name": "elasticsearch_zach",
   "status": "green",
   "timed_out": false,
   "number_of_nodes": 1,
   "number_of_data_nodes": 1,
   "active_primary_shards": 10,
   "active_shards": 10,
   "relocating_shards": 0,
   "initializing_shards": 0,
   "unassigned_shards": 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应信息中最重要的一块就是 <code>status</code> 字段。状态可能是下列三个值之一：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>green</code>
</dt>
<dd>
<p>所有的主分片和副本分片都已分配。你的集群是 100% 可用的。</p>
</dd>
<dt class="hdlist1">
<code>yellow</code>
</dt>
<dd>
<p>所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。不过，你的高可用性在某种程度上被弱化。如果 <em>更多的</em> 分片消失，你就会丢数据了。把 <code>yellow</code> 想象成一个需要及时调查的警告。</p>
</dd>
<dt class="hdlist1">
<code>red</code>
</dt>
<dd>
<p>至少一个主分片（以及它的全部副本）都在缺失中。这意味着你在缺少数据：搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>green</code>/<code>yellow</code>/<code>red</code> 状态是一个概览你的集群并了解眼下正在发生什么的好办法。剩下来的指标给你列出来集群的状态概要：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>number_of_nodes</code> 和 <code>number_of_data_nodes</code> 这个命名完全是自描述的。</p> </li>
<li> <p><code>active_primary_shards</code> 指出你集群中的主分片数量。这是涵盖了所有索引的汇总值。</p> </li>
<li> <p><code>active_shards</code> 是涵盖了所有索引的_所有_分片的汇总值，即包括副本分片。</p> </li>
<li> <p><code>relocating_shards</code> 显示当前正在从一个节点迁往其他节点的分片的数量。通常来说应该是 0，不过在 Elasticsearch 发现集群不太均衡时，该值会上涨。比如说：添加了一个新节点，或者下线了一个节点。</p> </li>
<li> <p><code>initializing_shards</code> 是刚刚创建的分片的个数。比如，当你刚创建第一个索引，分片都会短暂的处于 <code>initializing</code> 状态。这通常会是一个临时事件，分片不应该长期停留在 <code>initializing</code> 状态。你还可能在节点刚重启的时候看到 <code>initializing</code> 分片：当分片从磁盘上加载后，它们会从 <code>initializing</code> 状态开始。</p> </li>
<li> <p><code>unassigned_shards</code> 是已经在集群状态中存在的分片，但是实际在集群里又找不着。通常未分配分片的来源是未分配的副本。比如，一个有 5 分片和 1 副本的索引，在单节点集群上，就会有 5 个未分配副本分片。如果你的集群是 <code>red</code> 状态，也会长期保有未分配分片（因为缺少主分片）。</p> </li>
</ul>
</div>
<div class="sect3">
<h4 id="_钻更深点_找到问题索引">钻更深点：找到问题索引</h4>
<div class="paragraph">
<p>想象一下某天碰到问题了， 而你发现你的集群健康状态看起来像是这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "cluster_name": "elasticsearch_zach",
   "status": "red",
   "timed_out": false,
   "number_of_nodes": 8,
   "number_of_data_nodes": 8,
   "active_primary_shards": 90,
   "active_shards": 180,
   "relocating_shards": 0,
   "initializing_shards": 0,
   "unassigned_shards": 20
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好了，从这个健康状态里我们能推断出什么来？嗯，我们集群是 <code>red</code> ，意味着我们缺数据（主分片 + 副本分片）了。我们知道我们集群原先有 10 个节点，但是在这个健康状态里列出来的只有 8 个数据节点。有两个数据节点不见了。我们看到有 20 个未分配分片。</p>
</div>
<div class="paragraph">
<p>这就是我们能收集到的全部信息。那些缺失分片的情况依然是个谜。我们是缺了 20 个索引，每个索引里少 1 个主分片？还是缺 1 个索引里的 20 个主分片？还是 10 个索引里的各 1 主 1 副本分片？具体是哪个索引？</p>
</div>
<div class="paragraph">
<p>要回答这个问题，我们需要使用 <code>level</code> 参数让 <code>cluster-health</code> 答出更多一点的信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET _cluster/health?level=indices</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个参数会让 <code>cluster-health</code> API 在我们的集群信息里添加一个索引清单，以及有关每个索引的细节（状态、分片数、未分配分片数等等）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "cluster_name": "elasticsearch_zach",
   "status": "red",
   "timed_out": false,
   "number_of_nodes": 8,
   "number_of_data_nodes": 8,
   "active_primary_shards": 90,
   "active_shards": 180,
   "relocating_shards": 0,
   "initializing_shards": 0,
   "unassigned_shards": 20
   "indices": {
      "v1": {
         "status": "green",
         "number_of_shards": 10,
         "number_of_replicas": 1,
         "active_primary_shards": 10,
         "active_shards": 20,
         "relocating_shards": 0,
         "initializing_shards": 0,
         "unassigned_shards": 0
      },
      "v2": {
         "status": "red", <b class="conum">(1)</b>
         "number_of_shards": 10,
         "number_of_replicas": 1,
         "active_primary_shards": 0,
         "active_shards": 0,
         "relocating_shards": 0,
         "initializing_shards": 0,
         "unassigned_shards": 20 <b class="conum">(2)</b>
      },
      "v3": {
         "status": "green",
         "number_of_shards": 10,
         "number_of_replicas": 1,
         "active_primary_shards": 10,
         "active_shards": 20,
         "relocating_shards": 0,
         "initializing_shards": 0,
         "unassigned_shards": 0
      },
      ....
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>我们可以看到 <code>v2</code> 索引就是让集群变 <code>red</code> 的那个索引。</p> </li>
<li> <p>由此明确了，20 个缺失分片全部来自这个索引。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>一旦我们询问要索引的输出，哪个索引有问题立马就很清楚了：<code>v2</code> 索引。我们还可以看到这个索引曾经有 10 个主分片和一个副本，而现在这 20 个分片全不见了。可以推测，这 20 个索引就是位于从我们集群里不见了的那两个节点上。</p>
</div>
<div class="paragraph">
<p><code>level</code> 参数还可以接受其他更多选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET _cluster/health?level=shards</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shards</code> 选项会提供一个详细得多的输出，列出每个索引里每个分片的状态和位置。这个输出有时候很有用，但是由于太过详细会比较难用。如果你知道哪个索引有问题了，本章讨论的其他 API 显得更加有用一点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_阻塞等待状态变化">阻塞等待状态变化</h4>
<div class="paragraph">
<p>当构建单元和集成测试时，或者实现和 Elasticsearch 相关的自动化脚本时，<code>cluster-health</code> API 还有另一个小技巧非常有用。你可以指定一个 <code>wait_for_status</code> 参数，它只有在状态达标之后才会返回。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET _cluster/health?wait_for_status=green</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个调用会 <em>阻塞</em> （不给你的程序返回控制权）住直到 <code>cluster-health</code> 变成 <code>green</code> ，也就是说所有主分片和副本分片都分配下去了。这对自动化脚本和测试非常重要。</p>
</div>
<div class="paragraph">
<p>如果你创建一个索引，Elasticsearch 必须在集群状态中向所有节点广播这个变更。那些节点必须初始化这些新分片，然后响应给主节点说这些分片已经 <code>Started</code> 。这个过程很快，但是因为网络延迟，可能要花 10–20ms。</p>
</div>
<div class="paragraph">
<p>如果你有个自动化脚本是 (a) 创建一个索引然后 (b) 立刻写入一个文档，这个操作会失败。因为索引还没完全初始化完成。在 (a) 和 (b) 两步之间的时间可能不到 1ms —— 对网络延迟来说这可不够。</p>
</div>
<div class="paragraph">
<p>比起使用 <code>sleep</code> 命令，直接让你的脚本或者测试使用 <code>wait_for_status</code> 参数调用 <code>cluster-health</code> 更好。当索引完全创建好，<code>cluster-health</code> 就会变成 <code>green</code> ，然后这个调用就会把控制权交还给你的脚本，然后你就可以开始写入了。</p>
</div>
<div class="paragraph">
<p>有效的选项是： <code>green</code> 、 <code>yellow</code> 和 <code>red</code> 。这个调回会在达到你要求（或者『更高』）的状态时返回。比如，如果你要求的是 <code>yellow</code> ，状态变成 <code>yellow</code> 或者 <code>green</code> 都会打开调用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_monitoring_individual_nodes">监控单个节点</h3>
<div class="paragraph">
<p><code>集群健康</code> 就像是光谱的一端——对集群的所有信息进行高度概述。而 <code>节点统计值</code> API 则是在另一端。它提供一个让人眼花缭乱的统计数据的数组，包含集群的每一个节点统计值。</p>
</div>
<div class="paragraph">
<p><code>节点统计值</code> 提供的统计值如此之多，在完全熟悉它之前，你可能都搞不清楚哪些指标是最值得关注的。我们将会高亮那些最重要的监控指标（但是我们鼓励你记录接口提供的所有指标——或者用 Marvel ——因为你永远不知道何时需要某个或者另一个值）。</p>
</div>
<div class="paragraph">
<p><code>节点统计值</code> API 可以通过如下命令执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET _nodes/stats</code></pre>
</div>
</div>
<div class="paragraph">
<p>在输出内容的开头，我们可以看到集群名称和我们的第一个节点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "cluster_name": "elasticsearch_zach",
   "nodes": {
      "UNr6ZMf5Qk-YCPA_L18BOQ": {
         "timestamp": 1408474151742,
         "name": "Zach",
         "transport_address": "inet[zacharys-air/192.168.1.131:9300]",
         "host": "zacharys-air",
         "ip": [
            "inet[zacharys-air/192.168.1.131:9300]",
            "NONE"
         ],
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>节点是排列在一个哈希里，以节点的 UUID 作为键名。还显示了节点网络属性的一些信息（比如传输层地址和主机名）。这些值对调试诸如节点未加入集群这类自动发现问题很有用。通常你会发现是端口用错了，或者节点绑定在错误的 IP 地址/网络接口上了。</p>
</div>
<div class="sect3">
<h4 id="_索引部分">索引部分</h4>
<div class="paragraph">
<p><code>索引(indices)</code> 部分列出了这个节点上所有索引的聚合过的统计值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">    "indices": {
        "docs": {
           "count": 6163666,
           "deleted": 0
        },
        "store": {
           "size_in_bytes": 2301398179,
           "throttle_time_in_millis": 122850
        },</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的统计值被归入以下部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>docs</code> 展示节点内存有多少文档，包括还没有从段里清除的已删除文档数量。</p> </li>
<li> <p><code>store</code> 部分显示节点耗用了多少物理存储。这个指标包括主分片和副本分片在内。如果限流时间很大，那可能表明你的磁盘限流设置得过低（在<a href="#segments-and-merging">段和合并</a>里讨论过）。</p> </li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">        "indexing": {
           "index_total": 803441,
           "index_time_in_millis": 367654,
           "index_current": 99,
           "delete_total": 0,
           "delete_time_in_millis": 0,
           "delete_current": 0
        },
        "get": {
           "total": 6,
           "time_in_millis": 2,
           "exists_total": 5,
           "exists_time_in_millis": 2,
           "missing_total": 1,
           "missing_time_in_millis": 0,
           "current": 0
        },
        "search": {
           "open_contexts": 0,
           "query_total": 123,
           "query_time_in_millis": 531,
           "query_current": 0,
           "fetch_total": 3,
           "fetch_time_in_millis": 55,
           "fetch_current": 0
        },
        "merges": {
           "current": 0,
           "current_docs": 0,
           "current_size_in_bytes": 0,
           "total": 1128,
           "total_time_in_millis": 21338523,
           "total_docs": 7241313,
           "total_size_in_bytes": 5724869463
        },</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>indexing</code> 显示已经索引了多少文档。这个值是一个累加计数器。在文档被删除的时候，数值不会下降。还要注意的是，在发生内部 <em>索引</em> 操作的时候，这个值也会增加，比如说文档更新。</p>
<div class="paragraph">
<p>还列出了索引操作耗费的时间，正在索引的文档数量，以及删除操作的类似统计值。</p>
</div> </li>
<li> <p><code>get</code> 显示通过 ID 获取文档的接口相关的统计值。包括对单个文档的 <code>GET</code> 和 <code>HEAD</code> 请求。</p> </li>
<li> <p><code>search</code> 描述在活跃中的搜索（ <code>open_contexts</code> ）数量、查询的总数量、以及自节点启动以来在查询上消耗的总时间。用 <code>query_time_in_millis / query_total</code> 计算的比值，可以用来粗略的评价你的查询有多高效。比值越大，每个查询花费的时间越多，你应该要考虑调优了。</p>
<div class="paragraph">
<p>fetch 统计值展示了查询处理的后一半流程（query-then-fetch 里的 <em>fetch</em> ）。如果 fetch 耗时比 query 还多，说明磁盘较慢，或者获取了太多文档，或者可能搜索请求设置了太大的分页（比如， <code>size: 10000</code> ）。</p>
</div> </li>
<li> <p><code>merges</code> 包括了 Lucene 段合并相关的信息。它会告诉你目前在运行几个合并，合并涉及的文档数量，正在合并的段的总大小，以及在合并操作上消耗的总时间。</p>
<div class="paragraph">
<p>在你的集群写入压力很大时，合并统计值非常重要。合并要消耗大量的磁盘 I/O 和 CPU 资源。如果你的索引有大量的写入，同时又发现大量的合并数，一定要去阅读<a href="#indexing-performance">索引性能技巧</a>。</p>
</div>
<div class="paragraph">
<p>注意：文档更新和删除也会导致大量的合并数，因为它们会产生最终需要被合并的段 <em>碎片</em> 。</p>
</div> </li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">        "filter_cache": {
           "memory_size_in_bytes": 48,
           "evictions": 0
        },
        "fielddata": {
           "memory_size_in_bytes": 0,
           "evictions": 0
        },
        "segments": {
           "count": 319,
           "memory_in_bytes": 65812120
        },
        ...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>filter_cache</code> 展示了已缓存的过滤器位集合所用的内存数量，以及过滤器被驱逐出内存的次数。过多的驱逐数 <em>可能</em> 说明你需要加大过滤器缓存的大小，或者你的过滤器不太适合缓存（比如它们因为高基数而在大量产生，就像是缓存一个 <code>now</code> 时间表达式）。</p>
<div class="paragraph">
<p>不过，驱逐数是一个很难评定的指标。过滤器是在每个段的基础上缓存的，而从一个小的段里驱逐过滤器，代价比从一个大的段里要廉价的多。有可能你有很大的驱逐数，但是它们都发生在小段上，也就意味着这些对查询性能只有很小的影响。</p>
</div>
<div class="paragraph">
<p>把驱逐数指标作为一个粗略的参考。如果你看到数字很大，检查一下你的过滤器，确保他们都是正常缓存的。不断驱逐着的过滤器，哪怕都发生在很小的段上，效果也比正确缓存住了的过滤器差很多。</p>
</div> </li>
<li> <p><code>field_data</code> 显示 fielddata 使用的内存，用以聚合、排序等等。这里也有一个驱逐计数。和 <code>filter_cache</code> 不同的是，这里的驱逐计数是很有用的：这个数应该或者至少是接近于 0。因为 fielddata 不是缓存，任何驱逐都消耗巨大，应该避免掉。如果你在这里看到驱逐数，你需要重新评估你的内存情况，fielddata 限制，请求语句，或者这三者。</p> </li>
<li> <p><code>segments</code> 会展示这个节点目前正在服务中的 Lucene 段的数量。这是一个重要的数字。大多数索引会有大概 50–150 个段，哪怕它们存有 TB 级别的数十亿条文档。段数量过大表明合并出现了问题（比如，合并速度跟不上段的创建）。注意这个统计值是节点上所有索引的汇聚总数。记住这点。</p>
<div class="paragraph">
<p><code>memory</code> 统计值展示了 Lucene 段自己用掉的内存大小。这里包括底层数据结构，比如倒排表，字典，和布隆过滤器等。太大的段数量会增加这些数据结构带来的开销，这个内存使用量就是一个方便用来衡量开销的度量值。</p>
</div> </li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_操作系统和进程部分">操作系统和进程部分</h4>
<div class="paragraph">
<p><code>OS</code> 和 <code>Process</code> 部分基本是自描述的，不会在细节中展开讲解。它们列出来基础的资源统计值，比如 CPU 和负载。<code>OS</code> 部分描述了整个操作系统，而 <code>Process</code> 部分只显示 Elasticsearch 的 JVM 进程使用的资源情况。</p>
</div>
<div class="paragraph">
<p>这些都是非常有用的指标，不过通常在你的监控技术栈里已经都测量好了。统计值包括下面这些：</p>
</div>
<div class="ulist">
<ul>
<li> <p>CPU</p> </li>
<li> <p>负载</p> </li>
<li> <p>内存使用率</p> </li>
<li> <p>Swap 使用率</p> </li>
<li> <p>打开的文件描述符</p> </li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_jvm_部分">JVM 部分</h4>
<div class="paragraph">
<p><code>jvm</code> 部分包括了运行 Elasticsearch 的 JVM 进程一些很关键的信息。最重要的，它包括了垃圾回收的细节，这对你的 Elasticsearch 集群的稳定性有着重大影响。</p>
</div>
<div id="garbage_collector_primer" class="sidebarblock">
<div class="content">
<div class="title">
垃圾回收入门
</div>
<div class="paragraph">
<p>在我们描述统计值之前，先上一门速成课程讲解垃圾回收以及它对 Elasticsearch 的影响是非常有用的。如果你对 JVM 的垃圾回收很熟悉，请跳过这段。</p>
</div>
<div class="paragraph">
<p>Java 是一门 <em>垃圾回收</em> 语言，也就是说程序员不用手动管理内存分配和回收。程序员只管写代码，然后 Java 虚拟机（JVM）按需分配内存，然后在稍后不再需要的时候清理这部分内存。</p>
</div>
<div class="paragraph">
<p>当内存分配给一个 JVM 进程，它是分配到一个大块里，这个块叫做 <em>堆</em> 。JVM 把堆分成两组，用 <em>代</em> 来表示：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
新生代（或者伊甸园）
</dt>
<dd>
<p>新实例化的对象分配的空间。新生代空间通常都非常小，一般在 100 MB&amp;#x2013;500 MB。新生代也包含两个 <em>幸存</em> 空间。</p>
</dd>
<dt class="hdlist1">
老生代
</dt>
<dd>
<p>较老的对象存储的空间。这些对象预计将长期留存并持续上很长一段时间。老生代通常比新生代大很多。Elasticsearch 节点可以给老生代用到 30 GB。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>当一个对象实例化的时候，它被放在新生代里。当新生代空间满了，就会发生一次新生代垃圾回收（GC）。依然是"存活"状态的对象就被转移到一个幸存区内，而"死掉"的对象被移除。如果一个对象在多次新生代 GC 中都幸存了，它就会被"终身"置于老生代了。</p>
</div>
<div class="paragraph">
<p>类似的过程在老生代里同样发生：空间满的时候，发生一次垃圾回收，死掉的对象被移除。</p>
</div>
<div class="paragraph">
<p>不过，天下没有免费的午餐。新生代、老生代的垃圾回收都有一个阶段会“停止时间”。在这段时间里，JVM 字面意义上的停止了程序运行，以便跟踪对象图，收集死亡对象。在这个时间停止阶段，一切都不会发生。请求不被服务，ping 不被回应，分片不被分配。整个世界都真的停止了。</p>
</div>
<div class="paragraph">
<p>对于新生代，这不是什么大问题；那么小的空间意味着 GC 会很快执行完。但是老生代大很多，而这里面一个慢 GC 可能就意味着 1 秒乃至 15 秒的暂停——对于服务器软件来说这是不可接受的。</p>
</div>
<div class="paragraph">
<p>JVM 的垃圾回收采用了 <em>非常</em> 精密的算法，在减少暂停方面做得很棒。而且 Elasticsearch 非常努力的变成对 <em>垃圾回收友好</em> 的程序，比如内部智能的重用对象，重用网络缓冲，以及默认启用 <a href="#docvalues">Doc Values</a> 功能。但最终，GC 的频率和时长依然是你需要去观察的指标。因为它是集群不稳定的头号嫌疑人。</p>
</div>
<div class="paragraph">
<p>一个经常发生长 GC 的集群就会因为内存不足而处于高负载压力下。这些长 GC 会导致节点短时间内从集群里掉线。这种不稳定会导致分片频繁重定位，因为 Elasticsearch 会尝试保持集群均衡，保证有足够的副本在线。这接着就导致网络流量和磁盘 I/O 的增加。而所有这些都是在你的集群努力服务于正常的索引和查询的同时发生的。</p>
</div>
<div class="paragraph">
<p>总而言之，长时间 GC 总是不好的，需要尽可能的减少。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>因为垃圾回收对 Elasticsearch 是如此重要，你应该非常熟悉 <code>node-stats</code> API 里的这部分内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">        "jvm": {
            "timestamp": 1408556438203,
            "uptime_in_millis": 14457,
            "mem": {
               "heap_used_in_bytes": 457252160,
               "heap_used_percent": 44,
               "heap_committed_in_bytes": 1038876672,
               "heap_max_in_bytes": 1038876672,
               "non_heap_used_in_bytes": 38680680,
               "non_heap_committed_in_bytes": 38993920,</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>jvm</code> 部分首先列出一些和 heap 内存使用有关的常见统计值。你可以看到有多少 heap 被使用了，多少被指派了（当前被分配给进程的），以及 heap 被允许分配的最大值。理想情况下，<code>heap_committed_in_bytes</code> 应该等于 <code>heap_max_in_bytes</code> 。如果指派的大小更小，JVM 最终会被迫调整 heap 大小——这是一个非常昂贵的操作。如果你的数字不相等，阅读 <a href="#heap-sizing">堆内存:大小和交换</a> 学习如何正确的配置它。</p>
<div class="paragraph">
<p><code>heap_used_percent</code> 指标是值得关注的一个数字。Elasticsearch 被配置为当 heap 达到 75% 的时候开始 GC。如果你的节点一直 &gt;= 75%，你的节点正处于 <em>内存压力</em> 状态。这是个危险信号，不远的未来可能就有慢 GC 要出现了。</p>
</div>
<div class="paragraph">
<p>如果 heap 使用率一直 &gt;=85%，你就麻烦了。Heap 在 90–95% 之间，则面临可怕的性能风险，此时最好的情况是长达 10–30s 的 GC，最差的情况就是内存溢出（OOM）异常。</p>
</div> </li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">   "pools": {
      "young": {
         "used_in_bytes": 138467752,
         "max_in_bytes": 279183360,
         "peak_used_in_bytes": 279183360,
         "peak_max_in_bytes": 279183360
      },
      "survivor": {
         "used_in_bytes": 34865152,
         "max_in_bytes": 34865152,
         "peak_used_in_bytes": 34865152,
         "peak_max_in_bytes": 34865152
      },
      "old": {
         "used_in_bytes": 283919256,
         "max_in_bytes": 724828160,
         "peak_used_in_bytes": 283919256,
         "peak_max_in_bytes": 724828160
      }
   }
},</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>新生代(young)</code> 、 <code>幸存区(survivor)</code> 和 <code>老生代(old)</code> 部分分别展示 GC 中每一个代的内存使用情况。这些统计值很方便观察其相对大小，但是在调试问题的时候，通常并不怎么重要。</p> </li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"gc": {
   "collectors": {
      "young": {
         "collection_count": 13,
         "collection_time_in_millis": 923
      },
      "old": {
         "collection_count": 0,
         "collection_time_in_millis": 0
      }
   }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>gc</code> 部分显示新生代和老生代的垃圾回收次数和累积时间。大多数时候你可以忽略掉新生代的次数：这个数字通常都很大。这是正常的。</p>
<div class="paragraph">
<p>与之相反，老生代的次数应该很小，而且 <code>collection_time_in_millis</code> 也应该很小。这些是累积值，所以很难给出一个阈值表示你要开始操心了（比如，一个跑了一整年的节点，即使很健康，也会有一个比较大的计数）。这就是像 Marvel 这类工具很有用的一个原因。GC 计数的 <em>时间趋势</em> 是个重要的考虑因素。</p>
</div>
<div class="paragraph">
<p>GC 花费的时间也很重要。比如，在索引文档时，一系列垃圾生成了。这是很常见的情况，每时每刻都会导致 GC。这些 GC 绝大多数时候都很快，对节点影响很小：新生代一般就花一两毫秒，老生代花一百多毫秒。这些跟 10 秒级别的 GC 是很不一样的。</p>
</div>
<div class="paragraph">
<p>我们的最佳建议是定期收集 GC 计数和时长（或者使用 Marvel）然后观察 GC 频率。你也可以开启慢 GC 日志记录，在 <a href="#logging">日志记录</a> 小节已经讨论过。</p>
</div> </li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_线程池部分">线程池部分</h4>
<div class="paragraph">
<p>Elasticsearch 在内部维护了线程池。这些线程池相互协作完成任务，有必要的话相互间还会传递任务。通常来说，你不需要配置或者调优线程池，不过查看它们的统计值有时候还是有用的，可以洞察你的集群表现如何。</p>
</div>
<div class="paragraph">
<p>这有一系列的线程池，但以相同的格式输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">  "index": {
     "threads": 1,
     "queue": 0,
     "active": 0,
     "rejected": 0,
     "largest": 1,
     "completed": 1
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个线程池会列出已配置的线程数量（ <code>threads</code> ），当前在处理任务的线程数量（ <code>active</code> ），以及在队列中等待处理的任务单元数量（ <code>queue</code> ）。</p>
</div>
<div class="paragraph">
<p>如果队列中任务单元数达到了极限，新的任务单元会开始被拒绝，你会在 <code>rejected</code> 统计值上看到它反映出来。这通常是你的集群在某些资源上碰到瓶颈的信号。因为队列满意味着你的节点或集群在用最高速度运行，但依然跟不上工作的蜂拥而入。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
批量操作的被拒绝数
</div>
<div class="paragraph">
<p>如果你碰到了队列被拒，一般来说都是批量索引请求导致的。通过并发导入程序发送大量批量请求非常简单。越多越好嘛，对不？</p>
</div>
<div class="paragraph">
<p>事实上，每个集群都有它能处理的请求上限。一旦这个阈值被超过，队列会很快塞满，然后新的批量请求就被拒绝了。</p>
</div>
<div class="paragraph">
<p>这是一件 <em>好事情</em> 。队列的拒绝在回压方面是有用的。它们让你知道你的集群已经在最大容量了。这比把数据塞进内存队列要来得好。增加队列大小并不能增加性能，它只是隐藏了问题。当你的集群只能每秒钟处理 10000 个文档的时候，无论队列是 100 还是 10000000 都没关系——你的集群还是只能每秒处理 10000 个文档。</p>
</div>
<div class="paragraph">
<p>队列只是隐藏了性能问题，而且带来的是真实的数据丢失的风险。在队列里的数据都是还没处理的，如果节点挂掉，这些请求都会永久的丢失。此外，队列还要消耗大量内存，这也是不理想的。</p>
</div>
<div class="paragraph">
<p>在你的应用中，优雅的处理来自满载队列的回压，才是更好的选择。当你收到拒绝响应的时候，你应该采取如下几步：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>暂停导入线程 3&amp;#x2013;5 秒。</p> </li>
<li> <p>从批量操作的响应里提取出来被拒绝的操作。因为可能很多操作还是成功的。响应会告诉你哪些成功，哪些被拒绝了。</p> </li>
<li> <p>发送一个新的批量请求，只包含这些被拒绝过的操作。</p> </li>
<li> <p>如果依然碰到拒绝，再次从步骤 1 开始。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>通过这个流程，你的代码可以很自然的适应你集群的负载，做到自动回压。</p>
</div>
<div class="paragraph">
<p>拒绝不是错误：它们只是意味着你要稍后重试。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>这里的一系列的线程池，大多数你可以忽略，但是有一小部分还是值得关注的：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">
<code>indexing</code>
</dt>
<dd>
<p>普通的索引请求的线程池</p>
</dd>
<dt class="hdlist1">
<code>bulk</code>
</dt>
<dd>
<p>批量请求，和单条的索引请求不同的线程池</p>
</dd>
<dt class="hdlist1">
<code>get</code>
</dt>
<dd>
<p>Get-by-ID 操作</p>
</dd>
<dt class="hdlist1">
<code>search</code>
</dt>
<dd>
<p>所有的搜索和查询请求</p>
</dd>
<dt class="hdlist1">
<code>merging</code>
</dt>
<dd>
<p>专用于管理 Lucene 合并的线程池</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_文件系统和网络部分">文件系统和网络部分</h4>
<div class="paragraph">
<p>继续向下阅读 <code>node-stats</code> API，你会看到一串和你的文件系统相关的统计值：可用空间，数据目录路径，磁盘 I/O 统计值，等等。如果你没有监控磁盘可用空间的话，可以从这里获取这些统计值。磁盘 I/O 统计值也很方便，不过通常那些更专门的命令行工具（比如 <code>iostat</code> ）会更有用些。</p>
</div>
<div class="paragraph">
<p>显然，Elasticsearch 在磁盘空间满的时候很难运行——所以请确保不会这样。</p>
</div>
<div class="paragraph">
<p>还有两个跟网络统计值相关的部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">        "transport": {
            "server_open": 13,
            "rx_count": 11696,
            "rx_size_in_bytes": 1525774,
            "tx_count": 10282,
            "tx_size_in_bytes": 1440101928
         },
         "http": {
            "current_open": 4,
            "total_opened": 23
         },</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>transport</code> 显示和 <em>传输地址</em> 相关的一些基础统计值。包括节点间的通信（通常是 9300 端口）以及任意传输客户端或者节点客户端的连接。如果看到这里有很多连接数不要担心；Elasticsearch 在节点之间维护了大量的连接。</p> </li>
<li> <p><code>http</code> 显示 HTTP 端口（通常是 9200）的统计值。如果你看到 <code>total_opened</code> 数很大而且还在一直上涨，这是一个明确信号，说明你的 HTTP 客户端里有没启用 keep-alive 长连接的。持续的 keep-alive 长连接对性能很重要，因为连接、断开套接字是很昂贵的（而且浪费文件描述符）。请确认你的客户端都配置正确。</p> </li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_断路器">断路器</h4>
<div class="paragraph">
<p>终于，我们到了最后一段：跟 fielddata 断路器（在 <a href="#circuit-breaker">断路器</a> 介绍过）相关的统计值：</p>
</div>
<div class="listingblock pagebreak-before">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">         "fielddata_breaker": {
            "maximum_size_in_bytes": 623326003,
            "maximum_size": "594.4mb",
            "estimated_size_in_bytes": 0,
            "estimated_size": "0b",
            "overhead": 1.03,
            "tripped": 0
         }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里你可以看到断路器的最大值（比如，一个请求申请更多的内存时会触发断路器）。这个部分还会让你知道断路器被触发了多少次，以及当前配置的间接开销。间接开销用来铺垫评估，因为有些请求比其他请求更难评估。</p>
</div>
<div class="paragraph">
<p>主要需要关注的是 <code>tripped</code> 指标。如果这个数字很大或者持续上涨，这是一个信号，说明你的请求需要优化，或者你需要添加更多内存（单机上添加，或者通过添加新节点的方式）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_stats">集群统计</h3>
<div class="paragraph">
<p><code>集群统计</code> API 提供了和 <code>节点统计</code> 相似的输出。 但有一个重要的区别：节点统计显示的是每个节点上的统计值，而 <code>集群统计</code> 展示的是对于单个指标，所有节点的总和值。</p>
</div>
<div class="paragraph">
<p>这里面提供一些很值得一看的统计值。比如说你可以看到，整个集群用了 50% 的堆内存，或者说过滤器缓存的驱逐情况不严重。这个接口主要用途是提供一个比 <code>集群健康</code> 更详细、但又没有 <code>节点统计</code> 那么详细的快速概览。对于非常大的集群来说也很有用，因为那时候 <code>节点统计</code> 的输出已经非常难于阅读了。</p>
</div>
<div class="paragraph">
<p>这个 API 可以像下面这样调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET _cluster/stats</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_index_stats">索引统计</h3>
<div class="paragraph">
<p>到目前为止，我们看到的都是以 <em>节点为中心</em> 的统计值： 节点有多少内存？用了多少 CPU ？正在服务多少个搜索？</p>
</div>
<div class="paragraph">
<p>有时候从 <em>索引为中心</em> 的角度看统计值也很有用：<em>这个索引</em> 收到了多少个搜索请求？<em>那个索引</em> 获取文档耗费了多少时间？</p>
</div>
<div class="paragraph">
<p>要做到这点，选择你感兴趣的索引 （ 或者多个索引 ）然后执行一个索引级别的 <code>统计</code> API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET my_index/_stats <b class="conum">(1)</b>

GET my_index,another_index/_stats <b class="conum">(2)</b>

GET _all/_stats <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li> <p>统计 <code>my_index</code> 索引。</p> </li>
<li> <p>使用逗号分隔索引名可以请求多个索引统计值。</p> </li>
<li> <p>使用特定的 <code>_all</code> 可以请求全部索引的统计值</p> </li>
</ol>
</div>
<div class="paragraph">
<p>返回的统计信息和 <code>节点统计</code> 的输出很相似：<code>search</code> 、 <code>fetch</code> 、 <code>get</code> 、 <code>index</code> 、 <code>bulk</code> 、 <code>segment counts</code> 等等。</p>
</div>
<div class="paragraph">
<p>索引为中心的统计在有些时候很有用，比如辨别或验证集群中的 <em>热门</em> 索引，或者试图找出某些索引比其他索引更快或者更慢的原因。</p>
</div>
<div class="paragraph">
<p>实践中，节点为中心的统计还是显得更有用些。瓶颈往往是针对整个节点而言，而不是对于单个索引。因为索引一般是分布在多个节点上的，这导致以索引为中心的统计值通常不是很有用，因为它们是从不同环境的物理机器上汇聚的数据。</p>
</div>
<div class="paragraph">
<p>索引为中心的统计作为一个有用的工具可以保留在你的技能表里，但是通常它不会是第一个用的上的工具。</p>
</div>
</div>
<div class="sect2">
<h3 id="_pending_tasks">等待中的任务</h3>
<div class="paragraph">
<p>有一些任务只能由主节点去处理，比如创建一个新的索引或者在集群中移动分片。由于一个集群中只能有一个主节点，所以只有这一节点可以处理集群级别的元数据变动。在 99.9999% 的时间里，这不会有什么问题。元数据变动的队列基本上保持为零。</p>
</div>
<div class="paragraph">
<p>在一些 <code>罕见</code> 的集群里，元数据变动的次数比主节点能处理的还快。这会导致等待中的操作会累积成队列。</p>
</div>
<div class="paragraph">
<p><code>等待中的任务</code> API 会给你展示队列中（如果有的话）等待的集群级别的元数据变更操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET _cluster/pending_tasks</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，响应都是像这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "tasks": []
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着没有等待中的任务。如果你有一个罕见的集群在主节点出现瓶颈了，等待中的任务列表可能会像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "tasks": [
      {
         "insert_order": 101,
         "priority": "URGENT",
         "source": "create-index [foo_9], cause [api]",
         "time_in_queue_millis": 86,
         "time_in_queue": "86ms"
      },
      {
         "insert_order": 46,
         "priority": "HIGH",
         "source": "shard-started ([foo_2][1], node[tMTocMvQQgGCkj7QDHl3OA], [P],
         s[INITIALIZING]), reason [after recovery from gateway]",
         "time_in_queue_millis": 842,
         "time_in_queue": "842ms"
      },
      {
         "insert_order": 45,
         "priority": "HIGH",
         "source": "shard-started ([foo_2][0], node[tMTocMvQQgGCkj7QDHl3OA], [P],
         s[INITIALIZING]), reason [after recovery from gateway]",
         "time_in_queue_millis": 858,
         "time_in_queue": "858ms"
      }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以看到任务都被指派了优先级（ 比如说 <code>URGENT</code> 要比 <code>HIGH</code> 更早的处理 ），任务插入的次序、操作进入队列多久，以及打算处理什么。在上面的列表中，有一个 <code>创建索引(create-index)</code> 和两个 <code>启动分片(shard-started)</code> 的操作在等待。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">
什么时候应该担心等待中的任务？
</div>
<div class="paragraph">
<p>就像曾经提到过的，主节点很少会成为集群的瓶颈。唯一可能成为瓶颈的是集群状态非常大 <em>而且</em> 更新频繁。</p>
</div>
<div class="paragraph">
<p>例如，如果你允许客户按照他们的意愿创建任意的动态字段，而且每个客户每天都有一个独立索引，那么你的集群状态会变得非常大。集群状态包括 ( 但不限于 ) 所有索引及其类型，以及每个索引的全部字段。</p>
</div>
<div class="paragraph">
<p>所以如果你有 100000 客户，然后每个客户平均有 1000 个字段，而且数据有 90 天的保留期—这就有九十亿个字段需要保存在集群状态中。不管它何时发生变更，所有的节点都需要被通知。</p>
</div>
<div class="paragraph">
<p>主节点必须处理这些变动，这需要不小的 CPU 开销，加上推送更新的集群状态到所有节点的网络开销。</p>
</div>
<div class="paragraph">
<p>这就是那些可以看到集群状态操作队列上涨的集群。没有简单的办法可以解决这个问题，不过你有三个选择：</p>
</div>
<div class="ulist">
<ul>
<li> <p>使用一个更强大的主节点。不幸的是，这种垂直扩展只是延迟这种必然结果出现而已。</p> </li>
<li> <p>通过某些方式限定文档的动态性质来限制集群状态的大小。</p> </li>
<li> <p>到达某个阈值后组建另外一个集群。</p> </li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cat_api">cat API</h3>
<div class="paragraph">
<p>如果经常在命令行环境下工作，<code>cat</code> API 对你会非常有用。用 Linux 的 <code>cat</code> 命令命名，这些 API 也就设计成像 *nix 命令行工具一样工作了。</p>
</div>
<div class="paragraph">
<p>他们提供的统计和前面已经讨论过的 API ( 健康、<code>节点统计</code> 等等 ) 是一样的。但是输出以表格的形式提供，而不是 JSON。对于系统管理员来说这是 <em>非常</em> 方便的，你仅仅想浏览一遍集群或者找出内存使用偏高的节点而已。</p>
</div>
<div class="paragraph">
<p>通过 <code>GET</code> 请求发送 <code>cat</code> 命名可以列出所有可用的 API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET /_cat

=^.^=
/_cat/allocation
/_cat/shards
/_cat/shards/{index}
/_cat/master
/_cat/nodes
/_cat/indices
/_cat/indices/{index}
/_cat/segments
/_cat/segments/{index}
/_cat/count
/_cat/count/{index}
/_cat/recovery
/_cat/recovery/{index}
/_cat/health
/_cat/pending_tasks
/_cat/aliases
/_cat/aliases/{alias}
/_cat/thread_pool
/_cat/plugins
/_cat/fielddata
/_cat/fielddata/{fields}</code></pre>
</div>
</div>
<div class="paragraph">
<p>许多 API 看起来很熟悉了 ( 是的，顶上还有一只猫:) )。让我们看看 <code>cat</code> 的健康检查 API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET /_cat/health

1408723713 12:08:33 elasticsearch_zach yellow 1 1 114 114 0 0 114</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先你会注意到的是响应是表格样式的纯文本，而不是 JSON。其次你会注意到各列默认是没有表头的。这都是模仿 *nix 工具设计的，因为它假设一旦你对输出熟悉了，你就再也不想看见表头了。</p>
</div>
<div class="paragraph">
<p>要启用表头，添加 <code>?v</code> 参数即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET /_cat/health?v

epoch   time    cluster status node.total node.data shards pri relo init
1408[..] 12[..] el[..]  1         1         114 114    0    0     114
unassign</code></pre>
</div>
</div>
<div class="paragraph">
<p>嗯，好多了。我们现在看到 时间戳、集群名称、状态、集群中节点的数量等等—所有信息和 <code>集群健康</code> API 返回的都一样。</p>
</div>
<div class="paragraph">
<p>让我们再看看 <code>cat</code> API 里面的 <code>节点统计</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET /_cat/nodes?v

host         ip            heap.percent ram.percent load node.role master name
zacharys-air 192.168.1.131           45          72 1.85 d         *      Zach</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们看到集群里节点的一些统计，不过和完整的 <code>节点统计</code> 输出相比而言是非常基础的。你可以包含更多的指标，但是比起查阅文档，让我们直接问 <code>cat</code> API 有哪些可用的吧。</p>
</div>
<div class="paragraph">
<p>你可以过对任意 API 添加 <code>?help</code> 参数来做到这点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET /_cat/nodes?help

id               | id,nodeId               | unique node id
pid              | p                       | process id
host             | h                       | host name
ip               | i                       | ip address
port             | po                      | bound transport port
version          | v                       | es version
build            | b                       | es build hash
jdk              | j                       | jdk version
disk.avail       | d,disk,diskAvail        | available disk space
heap.percent     | hp,heapPercent          | used heap ratio
heap.max         | hm,heapMax              | max configured heap
ram.percent      | rp,ramPercent           | used machine memory ratio
ram.max          | rm,ramMax               | total machine memory
load             | l                       | most recent load avg
uptime           | u                       | node uptime
node.role        | r,role,dc,nodeRole      | d:data node, c:client node
master           | m                       | m:master-eligible, *:current master
...
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>( 注意这个输出为了页面简洁而被截断了 )。</p>
</div>
<div class="paragraph">
<p>第一列显示完整的名称，第二列显示缩写，第三列提供了关于这个参数的简介。现在我们知道了一些列名了，我们可以用 <code>?h</code> 参数来明确指定显示这些指标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">GET /_cat/nodes?v&amp;h=ip,port,heapPercent,heapMax

ip            port heapPercent heapMax
192.168.1.131 9300          53 990.7mb</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 <code>cat</code> API 试图像 *nix 工具一样工作，你可以使用管道命令将结果传递给其他工具，比如 <code>sort</code> 、 <code>grep</code> 或者 <code>awk</code> 。例如，通过以下方式可以找到集群中最大的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">% curl 'localhost:9200/_cat/indices?bytes=b' | sort -rnk8

yellow test_names         5 1 3476004 0 376324705 376324705
yellow .marvel-2014.08.19 1 1  263878 0 160777194 160777194
yellow .marvel-2014.08.15 1 1  234482 0 143020770 143020770
yellow .marvel-2014.08.09 1 1  222532 0 138177271 138177271
yellow .marvel-2014.08.18 1 1  225921 0 138116185 138116185
yellow .marvel-2014.07.26 1 1  173423 0 132031505 132031505
yellow .marvel-2014.08.21 1 1  219857 0 128414798 128414798
yellow .marvel-2014.07.27 1 1   75202 0  56320862  56320862
yellow wavelet            5 1    5979 0  54815185  54815185
yellow .marvel-2014.07.28 1 1   57483 0  43006141  43006141
yellow .marvel-2014.07.21 1 1   31134 0  27558507  27558507
yellow .marvel-2014.08.01 1 1   41100 0  27000476  27000476
yellow kibana-int         5 1       2 0     17791     17791
yellow t                  5 1       7 0     15280     15280
yellow website            5 1      12 0     12631     12631
yellow agg_analysis       5 1       5 0      5804      5804
yellow v2                 5 1       2 0      5410      5410
yellow v1                 5 1       2 0      5367      5367
yellow bank               1 1      16 0      4303      4303
yellow v                  5 1       1 0      2954      2954
yellow p                  5 1       2 0      2939      2939
yellow b0001_072320141238 5 1       1 0      2923      2923
yellow ipaddr             5 1       1 0      2917      2917
yellow v2a                5 1       1 0      2895      2895
yellow movies             5 1       1 0      2738      2738
yellow cars               5 1       0 0      1249      1249
yellow wavelet2           5 1       0 0       615       615</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过添加 <code>?bytes=b</code> ，我们关闭了人类可读的数字格式化，强制它们以字节数输出。随后通过管道命令将输出传递给 <code>sort</code> 让索引按大小（ 第八列 ）排序</p>
</div>
<div class="paragraph">
<p>不幸的是，你会注意到 Marval 索引也出现在结果中，但是我们目前并不真正在意这些索引。让我们把结果传递给 <code>grep</code> 命令来移除提到 Marval 的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">% curl 'localhost:9200/_cat/indices?bytes=b' | sort -rnk8 | grep -v marvel

yellow test_names         5 1 3476004 0 376324705 376324705
yellow wavelet            5 1    5979 0  54815185  54815185
yellow kibana-int         5 1       2 0     17791     17791
yellow t                  5 1       7 0     15280     15280
yellow website            5 1      12 0     12631     12631
yellow agg_analysis       5 1       5 0      5804      5804
yellow v2                 5 1       2 0      5410      5410
yellow v1                 5 1       2 0      5367      5367
yellow bank               1 1      16 0      4303      4303
yellow v                  5 1       1 0      2954      2954
yellow p                  5 1       2 0      2939      2939
yellow b0001_072320141238 5 1       1 0      2923      2923
yellow ipaddr             5 1       1 0      2917      2917
yellow v2a                5 1       1 0      2895      2895
yellow movies             5 1       1 0      2738      2738
yellow cars               5 1       0 0      1249      1249
yellow wavelet2           5 1       0 0       615       615</code></pre>
</div>
</div>
<div class="paragraph">
<p>瞧！在传递给 <code>grep</code> ( 通过 <code>-v</code> 来过滤掉不需要匹配的数据 ) 之后，我们得到了一个没有 Marval 混杂的索引排序列表了。</p>
</div>
<div class="paragraph">
<p>这只是命令行上 <code>cat</code> 的灵活性的一个简单示例。一旦你习惯了使用 <code>cat</code> ，你会发现它和其他所有 *nix 工具一样并且开始疯狂的使用管道、排序和过滤。如果你是一个系统管理员并且永远都是 SSH 登录到设备上，那么当然要花些时间来熟悉 <code>cat</code> API 了。</p>
</div>
</div>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/116/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/116/index.html">Protocol Buffer 3学习笔记</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">37页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/110/index.html">
<img class="uk-book-cover" src="../../static/icons/48/react_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/110/index.html">React 学习之道</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="react">react</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">11页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/84/index.html">
<img class="uk-book-cover" src="../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/84/index.html">Java后端开发笔记</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/54.html">shunliz</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">18页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/5/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/5/index.html">超级棒的"派神"书</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/5.html">zhaoolee</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/28/index.html">
<img class="uk-book-cover" src="../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/28/index.html">笨办法学 Linux</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 326个">326</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/186/index.html">
<img class="uk-book-cover" src="../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/186/index.html">leetcode题解，记录自己的leetcode解题之路</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8204个">8204</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/40/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/40/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/40/foreword_id.html" title="序言" data-book-page-rel-url="foreword_id.html" data-book-page-id="9242">序言</a>
</li>
<li>
<a class="pjax" href="../../book/40/preface.html" title="前言" data-book-page-rel-url="preface.html" data-book-page-id="9243">前言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/_who_should_read_this_book.html" title="谁应该读这本书" data-book-page-rel-url="_who_should_read_this_book.html" data-book-page-id="9244">谁应该读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_why_we_wrote_this_book.html" title="为什么我们要写这本书" data-book-page-rel-url="_why_we_wrote_this_book.html" data-book-page-id="9245">为什么我们要写这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_elasticsearch_version.html" title="Elasticsearch 版本" data-book-page-rel-url="_elasticsearch_version.html" data-book-page-id="9246">Elasticsearch 版本</a>
</li>
<li>
<a class="pjax" href="../../book/40/_how_to_read_this_book.html" title="如何读这本书" data-book-page-rel-url="_how_to_read_this_book.html" data-book-page-id="9247">如何读这本书</a>
</li>
<li>
<a class="pjax" href="../../book/40/_navigating_this_book.html" title="本书导航" data-book-page-rel-url="_navigating_this_book.html" data-book-page-id="9248">本书导航</a>
</li>
<li>
<a class="pjax" href="../../book/40/_online_resources.html" title="在线资源" data-book-page-rel-url="_online_resources.html" data-book-page-id="9249">在线资源</a>
</li>
<li>
<a class="pjax" href="../../book/40/_conventions_used_in_this_book.html" title="本书协议约定" data-book-page-rel-url="_conventions_used_in_this_book.html" data-book-page-id="9250">本书协议约定</a>
</li>
<li>
<a class="pjax" href="../../book/40/_using_code_examples.html" title="使用代码示例" data-book-page-rel-url="_using_code_examples.html" data-book-page-id="9251">使用代码示例</a>
</li>
<li>
<a class="pjax" href="../../book/40/_acknowledgments.html" title="鸣谢" data-book-page-rel-url="_acknowledgments.html" data-book-page-id="9252">鸣谢</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/getting-started.html" title="基础入门" data-book-page-rel-url="getting-started.html" data-book-page-id="9253">基础入门</a>
<ul>
<li>
<a class="pjax" href="../../book/40/intro.html" title="你知道的, 为了搜索&#8230;&#8203;" data-book-page-rel-url="intro.html" data-book-page-id="9254">你知道的, 为了搜索&#8230;&#8203;</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-cluster.html" title="集群内的原理" data-book-page-rel-url="distributed-cluster.html" data-book-page-id="9255">集群内的原理</a>
</li>
<li>
<a class="pjax" href="../../book/40/data-in-data-out.html" title="数据输入和输出" data-book-page-rel-url="data-in-data-out.html" data-book-page-id="9256">数据输入和输出</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-docs.html" title="分布式文档存储" data-book-page-rel-url="distributed-docs.html" data-book-page-id="9257">分布式文档存储</a>
</li>
<li>
<a class="pjax" href="../../book/40/search.html" title="搜索——最基本的工具" data-book-page-rel-url="search.html" data-book-page-id="9258">搜索——最基本的工具</a>
</li>
<li>
<a class="pjax" href="../../book/40/mapping-analysis.html" title="映射和分析" data-book-page-rel-url="mapping-analysis.html" data-book-page-id="9259">映射和分析</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-body-search.html" title="请求体查询" data-book-page-rel-url="full-body-search.html" data-book-page-id="9260">请求体查询</a>
</li>
<li>
<a class="pjax" href="../../book/40/sorting.html" title="排序与相关性" data-book-page-rel-url="sorting.html" data-book-page-id="9261">排序与相关性</a>
</li>
<li>
<a class="pjax" href="../../book/40/distributed-search.html" title="执行分布式检索" data-book-page-rel-url="distributed-search.html" data-book-page-id="9262">执行分布式检索</a>
</li>
<li>
<a class="pjax" href="../../book/40/index-management.html" title="索引管理" data-book-page-rel-url="index-management.html" data-book-page-id="9263">索引管理</a>
</li>
<li>
<a class="pjax" href="../../book/40/inside-a-shard.html" title="分片内部原理" data-book-page-rel-url="inside-a-shard.html" data-book-page-id="9264">分片内部原理</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/search-in-depth.html" title="深入搜索" data-book-page-rel-url="search-in-depth.html" data-book-page-id="9265">深入搜索</a>
<ul>
<li>
<a class="pjax" href="../../book/40/structured-search.html" title="结构化搜索" data-book-page-rel-url="structured-search.html" data-book-page-id="9266">结构化搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/full-text-search.html" title="全文搜索" data-book-page-rel-url="full-text-search.html" data-book-page-id="9267">全文搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/multi-field-search.html" title="多字段搜索" data-book-page-rel-url="multi-field-search.html" data-book-page-id="9268">多字段搜索</a>
</li>
<li>
<a class="pjax" href="../../book/40/proximity-matching.html" title="近似匹配" data-book-page-rel-url="proximity-matching.html" data-book-page-id="9269">近似匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/partial-matching.html" title="部分匹配" data-book-page-rel-url="partial-matching.html" data-book-page-id="9270">部分匹配</a>
</li>
<li>
<a class="pjax" href="../../book/40/controlling-relevance.html" title="控制相关度" data-book-page-rel-url="controlling-relevance.html" data-book-page-id="9271">控制相关度</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/languages.html" title="处理人类语言" data-book-page-rel-url="languages.html" data-book-page-id="9272">处理人类语言</a>
<ul>
<li>
<a class="pjax" href="../../book/40/language-intro.html" title="开始处理各种语言" data-book-page-rel-url="language-intro.html" data-book-page-id="9273">开始处理各种语言</a>
</li>
<li>
<a class="pjax" href="../../book/40/identifying-words.html" title="词汇识别" data-book-page-rel-url="identifying-words.html" data-book-page-id="9274">词汇识别</a>
</li>
<li>
<a class="pjax" href="../../book/40/token-normalization.html" title="归一化词元" data-book-page-rel-url="token-normalization.html" data-book-page-id="9275">归一化词元</a>
</li>
<li>
<a class="pjax" href="../../book/40/stemming.html" title="将单词还原为词根" data-book-page-rel-url="stemming.html" data-book-page-id="9276">将单词还原为词根</a>
</li>
<li>
<a class="pjax" href="../../book/40/stopwords.html" title="停用词: 性能与精度" data-book-page-rel-url="stopwords.html" data-book-page-id="9277">停用词: 性能与精度</a>
</li>
<li>
<a class="pjax" href="../../book/40/synonyms.html" title="同义词" data-book-page-rel-url="synonyms.html" data-book-page-id="9278">同义词</a>
</li>
<li>
<a class="pjax" href="../../book/40/fuzzy-matching.html" title="拼写错误" data-book-page-rel-url="fuzzy-matching.html" data-book-page-id="9279">拼写错误</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/aggregations.html" title="聚合" data-book-page-rel-url="aggregations.html" data-book-page-id="9280">聚合</a>
<ul>
<li>
<a class="pjax" href="../../book/40/aggs-high-level.html" title="高阶概念" data-book-page-rel-url="aggs-high-level.html" data-book-page-id="9281">高阶概念</a>
</li>
<li>
<a class="pjax" href="../../book/40/_aggregation_test_drive.html" title="尝试聚合" data-book-page-rel-url="_aggregation_test_drive.html" data-book-page-id="9282">尝试聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_building_bar_charts.html" title="条形图" data-book-page-rel-url="_building_bar_charts.html" data-book-page-id="9283">条形图</a>
</li>
<li>
<a class="pjax" href="../../book/40/_looking_at_time.html" title="按时间统计" data-book-page-rel-url="_looking_at_time.html" data-book-page-id="9284">按时间统计</a>
</li>
<li>
<a class="pjax" href="../../book/40/_scoping_aggregations.html" title="范围限定的聚合" data-book-page-rel-url="_scoping_aggregations.html" data-book-page-id="9285">范围限定的聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_filtering_queries_and_aggregations.html" title="过滤和聚合" data-book-page-rel-url="_filtering_queries_and_aggregations.html" data-book-page-id="9286">过滤和聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/_sorting_multivalue_buckets.html" title="多桶排序" data-book-page-rel-url="_sorting_multivalue_buckets.html" data-book-page-id="9287">多桶排序</a>
</li>
<li>
<a class="pjax" href="../../book/40/_approximate_aggregations.html" title="近似聚合" data-book-page-rel-url="_approximate_aggregations.html" data-book-page-id="9288">近似聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/significant-terms.html" title="通过聚合发现异常指标" data-book-page-rel-url="significant-terms.html" data-book-page-id="9289">通过聚合发现异常指标</a>
</li>
<li>
<a class="pjax" href="../../book/40/docvalues-and-fielddata.html" title="Doc Values and Fielddata" data-book-page-rel-url="docvalues-and-fielddata.html" data-book-page-id="9290">Doc Values and Fielddata</a>
</li>
<li>
<a class="pjax" href="../../book/40/_closing_thoughts.html" title="总结" data-book-page-rel-url="_closing_thoughts.html" data-book-page-id="9291">总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/geoloc.html" title="地理位置" data-book-page-rel-url="geoloc.html" data-book-page-id="9292">地理位置</a>
<ul>
<li>
<a class="pjax" href="../../book/40/geopoints.html" title="地理坐标点" data-book-page-rel-url="geopoints.html" data-book-page-id="9293">地理坐标点</a>
</li>
<li>
<a class="pjax" href="../../book/40/geohashes.html" title="Geohashes" data-book-page-rel-url="geohashes.html" data-book-page-id="9294">Geohashes</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-aggs.html" title="地理位置聚合" data-book-page-rel-url="geo-aggs.html" data-book-page-id="9295">地理位置聚合</a>
</li>
<li>
<a class="pjax" href="../../book/40/geo-shapes.html" title="地理形状" data-book-page-rel-url="geo-shapes.html" data-book-page-id="9296">地理形状</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/modeling-your-data.html" title="数据建模" data-book-page-rel-url="modeling-your-data.html" data-book-page-id="9297">数据建模</a>
<ul>
<li>
<a class="pjax" href="../../book/40/relations.html" title="关联关系处理" data-book-page-rel-url="relations.html" data-book-page-id="9298">关联关系处理</a>
</li>
<li>
<a class="pjax" href="../../book/40/nested-objects.html" title="嵌套对象" data-book-page-rel-url="nested-objects.html" data-book-page-id="9299">嵌套对象</a>
</li>
<li>
<a class="pjax" href="../../book/40/parent-child.html" title="父-子关系文档" data-book-page-rel-url="parent-child.html" data-book-page-id="9300">父-子关系文档</a>
</li>
<li>
<a class="pjax" href="../../book/40/scale.html" title="扩容设计" data-book-page-rel-url="scale.html" data-book-page-id="9301">扩容设计</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../book/40/administration.html" title="管理、监控和部署" data-book-page-rel-url="administration.html" data-book-page-id="9302">管理、监控和部署</a>
<ul>
<li>
<a class="pjax" href="../../book/40/cluster-admin.html" title="监控" data-book-page-rel-url="cluster-admin.html" data-book-page-id="9303">监控</a>
</li>
<li>
<a class="pjax" href="../../book/40/deploy.html" title="部署" data-book-page-rel-url="deploy.html" data-book-page-id="9304">部署</a>
</li>
<li>
<a class="pjax" href="../../book/40/post_deploy.html" title="部署后" data-book-page-rel-url="post_deploy.html" data-book-page-id="9305">部署后</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =40;var bookPageId =9303;var bookPageRelUrl ='cluster-admin.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>