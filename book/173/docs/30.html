
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Appendix-HBase中文参考指南 3.0</title>
<meta content='Appendix,HBase中文参考指南 3.0' name='keywords'>
<meta content='Appendix,HBase中文参考指南 3.0' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/173/docs/29.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">Community</span>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/173/index.html">HBase中文参考指南 3.0</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/hbase-doc-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="附录">附录</h1>
<h2 id="附录-a贡献文档">附录 A：贡献文档</h2>
<p>Apache HBase 项目欢迎对项目的所有方面做出贡献，包括文档。</p>
<p>在 HBase 中，文档包括以下几个方面，可能还包括其他方面：</p>
<ul>
<li> <p><a href="https://hbase.apache.org/book.html">HBase 参考指南</a>（本书）</p> </li>
<li> <p><a href="https://hbase.apache.org/">HBase 网站</a></p> </li>
<li> <p>API 文档</p> </li>
<li> <p>命令行实用程序输出和帮助文本</p> </li>
<li> <p>Web UI 字符串，显式帮助文本，上下文相关字符串等</p> </li>
<li> <p>记录消息</p> </li>
<li> <p>源文件，配置文件和其他内容中的注释</p> </li>
<li> <p>将上述任何一种语言本地化为英语以外的目标语言</p> </li>
</ul>
<p>无论您想要帮助哪个区域，第一步几乎总是下载（通常通过克隆 Git 存储库）并熟悉 HBase 源代码。有关下载和构建源的信息，请参阅<a href="#developer">开发人员</a>。</p>
<h3 id="a1有助于文档或其他字符串">A.1。有助于文档或其他字符串</h3>
<p>如果您在 UI，实用程序，脚本，日志消息或其他地方的字符串中发现错误，或者您认为某些内容可以更清晰，或者您认为文本需要添加到当前不存在的位置，那么第一个步骤是提交 JIRA。除了任何其他相关组件外，务必将组件设置为<code>Documentation</code>。大多数组件都有一个或多个默认所有者，他们监视进入这些队列的新问题。无论您是否能够修复该错误，您仍应该在看到错误的地方提交错误。</p>
<p>如果您想尝试修复新提交的错误，请将其分配给自己。您需要将 HBase Git 存储库克隆到本地系统并在那里解决问题。当您开发出潜在的修复程序时，请将其提交以供审核。如果它解决了这个问题并被视为一种改进，那么其中一个 HBase 提交者将根据需要将其提交给一个或多个分支。</p>
<p>过程：提交补丁的建议工作流程</p>
<p>这个程序比 Git 专业人员需要的更详细，但是包含在本附录中，以便不熟悉 Git 的人在学习时能够对 HBase 有信心。</p>
<ol>
<li> <p>如果您还没有这样做，请在本地克隆 Git 存储库。你只需要这样做一次。</p> </li>
<li> <p>通常，在检出跟踪分支时，使用<code>git pull</code>命令将远程更改拉入本地存储库。</p> </li>
<li> <p>对于您处理的每个问题，请创建一个新分支。一个适用于命名分支的约定是将给定分支命名为与其相关的 JIRA：</p> <pre><code>$ git checkout -b HBASE-123456 
</code></pre> </li>
<li> <p>在您的分支上进行建议的更改，经常将更改提交到本地存储库。如果您需要切换到处理其他问题，请记得检查相应的分支。</p> </li>
<li> <p>当您准备好提交补丁时，首先要确保 HBase 构建干净，并在修改的分支中按预期运行。</p> </li>
<li> <p>如果您更改了文档，请确保通过运行<code>mvn clean site</code>来构建文档和网站。</p> </li>
<li> <p>如果您需要几天或几周的时间来实施修复，或者您知道您正在使用的代码区域最近有很多更改，请确保将分支重新绑定到远程主服务器并处理任何冲突在提交补丁之前。</p> <pre><code>$ git checkout HBASE-123456
$ git rebase origin/master 
</code></pre> </li>
<li> <p>针对远程主服务器生成补丁。从 git 存储库的顶层运行以下命令（通常称为<code>hbase</code>）：</p> <pre><code>$ git format-patch --stdout origin/master &amp;gt; HBASE-123456.patch 
</code></pre> <p>补丁的名称应包含 JIRA ID。</p> </li>
<li> <p>查看补丁文件，确保您没有意外更改任何其他文件，并且没有其他意外。</p> </li>
<li> <p>如果您满意，请将补丁附加到 JIRA 并单击 <strong>Patch Available</strong> 按钮。审核人员将审核您的补丁。</p> </li>
<li> <p>如果您需要提交新版本的补丁，请将旧版本保留在 JIRA 上，并在新补丁的名称中添加版本号。</p> </li>
<li> <p>提交更改后，无需保留本地分支。</p> </li>
</ol>
<h3 id="a2编辑-hbase-网站">A2。编辑 HBase 网站</h3>
<p>HBase 网站的源代码位于 HBase 源代码的 <em>src / site /</em> 目录中。在此目录中，各个页面的源位于 <em>xdocs /</em> 目录中，这些页面中引用的图像位于 <em>resources / <a href="https://hbase.apache.org/images/">https://hbase.apache.org/images 中/</a></em> 目录。此目录还存储 HBase 参考指南中使用的图像。</p>
<p>该网站的页面是用类似 HTML 的 XML 方言编写的，名为 xdoc，在 <a href="https://maven.apache.org/archives/maven-1.x/plugins/xdoc/reference/xdocs.html">https://maven.apache.org/archives/maven-1.x/plugins/xdoc/reference/xdocs 上有参考指南。 html</a> 。您可以在纯文本编辑器，IDE 或 XML 编辑器（如 XML Mind XML Editor（XXE）或 Oxygen XML Author）中编辑这些文件。</p>
<p>要预览更改，请使用<code>mvn clean site -DskipTests</code>命令构建网站。 HTML 输出位于 _ 目标/站点/_ 目录中。如果对更改感到满意，请按照<a href="#submit_doc_patch_procedure">提交文档修补程序</a>中的步骤提交补丁。</p>
<h3 id="a3发布-hbase-网站和文档">A.3。发布 HBase 网站和文档</h3>
<p>HBase 使用 ASF 的<code>gitpubsub</code>机制。 Jenkins 作业运行<code>dev-support/jenkins-scripts/generate-hbase-website.sh</code>脚本，该脚本针对<code>hbase</code>存储库的<code>master</code>分支运行<code>mvn clean site site:stage</code>，并将构建的工件提交到<code>hbase-site</code>存储库的<code>asf-site</code>分支。按下提交后，将自动重新部署网站。如果脚本遇到错误，则会向开发人员邮件列表发送一封电子邮件。您可以手动运行脚本或检查脚本以查看所涉及的步骤。</p>
<h3 id="a4检查-hbase-网站的断开链接">A.4。检查 HBase 网站的断开链接</h3>
<p>Jenkins 作业定期运行，使用<code>dev-support/jenkins-scripts/check-website-links.sh</code>脚本检查 HBase 网站是否有损坏的链接。此脚本使用名为<code>linklint</code>的工具检查错误链接并创建报告。如果找到损坏的链接，则会向开发人员邮件列表发送一封电子邮件。您可以手动运行脚本或检查脚本以查看所涉及的步骤。</p>
<h3 id="a5-hbase-参考指南样式指南和备忘单">A.5。 HBase 参考指南样式指南和备忘单</h3>
<p>HBase 参考指南用 Asciidoc 编写，使用 <a href="http://asciidoctor.org">AsciiDoctor</a> 构建。以下备忘单供您参考。更多细微而全面的文档可在 <a href="http://asciidoctor.org/docs/user-manual/">http://asciidoctor.org/docs/user-manual/</a> 上找到。</p>
<table>
<thead>
<tr>
<th>元素类型</th>
<th>期望的渲染</th>
<th>怎么做</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个段落</td>
<td>一个段落</td>
</tr>
</tbody>
</table>
<p>只需键入一些顶部和底部带有空行的文本。</p>
<p>| |在段落中添加换行符而不添加空行|手动换行|</p>
<p>这将在加号处打破+。或者在整个段落前面加上包含'[％hardbreaks]'的行</p>
<p>| |给任何东西一个标题彩色斜体粗体不同大小的文字| | |内联代码或命令| monospace |</p>
<p><code>text</code></p>
<p>| |内联文字内容（完全按照所示输入的内容）|大胆的单声道|</p>
<p><em><code>typethis</code></em></p>
<p>| |内联可替换内容（用您自己的值替换的东西）|粗斜体单声道|</p>
<p>__ 类型的东西 __</p>
<p>| |突出显示的代码块|等宽，突出，保留空间|</p>
<pre><code>[source,java]
----
  myAwesomeCode() {
}
---- 
</code></pre>
<p>| |代码块包含在单独的文件中包括就好像它是主文件的一部分|</p>
<pre><code>[source,ruby]
----
include\::path/to/app.rb[]
---- 
</code></pre>
<p>| |仅包含单独文件的一部分|与 Javadoc 相似|</p>
<p>见 <a href="http://asciidoctor.org/docs/user-manual/#by-tagged-regions">http://asciidoctor.org/docs/user-manual/#by-tagged-regions</a></p>
<p>| |文件名，目录名，新术语|斜体|</p>
<p><em>hbase-default.xml</em></p>
<p>| |外部裸 URL |链接 URL 作为链接文本|</p>
<pre><code>link:http://www.google.com 
</code></pre>
<p>| |带文字的外部网址|带有任意链接文本的链接|</p>
<pre><code>link:http://www.google.com[Google] 
</code></pre>
<p>| |创建内部锚点以交叉引用|没有呈现|</p>
<pre><code>[[anchor_name]] 
</code></pre>
<p>| |使用其默认标题|交叉引用现有锚点使用元素标题的内部超链接（如果可用），否则使用锚名称|</p>
<pre><code>&lt;&lt;anchor_name&gt;&gt; 
</code></pre>
<p>| |使用自定义文本交叉引用现有锚点使用任意文本的内部超链接</p>
<pre><code>&lt;&lt;anchor_name,Anchor Text&gt;&gt; 
</code></pre>
<p>| |块图像|替代文字的图像|</p>
<pre><code>image::sunset.jpg[Alt Text] 
</code></pre>
<p>（将图像放在 src / site / resources / images 目录中）</p>
<p>| |内嵌图像|带有 alt 文本的图像，作为文本流程的一部分</p>
<pre><code>image:sunset.jpg [Alt Text] 
</code></pre>
<p>（只有一个冒号）</p>
<p>| |链接到远程图像|显示在别处托管的图像|</p>
<pre><code>image::http://inkscape.org/doc/examples/tux.svg[Tux,250,350] 
</code></pre>
<p>（或<code>image:</code>）</p>
<p>| |向图像添加尺寸或 URL |取决于|</p>
<p>在 alt 文本后的括号内，指定 width，height 和/或 link =“ <a href="http://my_link.com">http://my_link.com</a> ”</p>
<p>| |脚注|下标链接带你到脚注|</p>
<pre><code>Some text.footnote:[The footnote text.] 
</code></pre>
<p>| |没有标题的注释或警告|告诫图像后面跟着警告|</p>
<pre><code>NOTE:My note here 
</code></pre>
<pre><code>WARNING:My warning here 
</code></pre>
<p>| |复杂的笔记|该笔记有一个标题和/或多个段落和/或代码块或列表等</p>
<pre><code>.The Title
[NOTE]
====
Here is the note text. Everything until the second set of four equals signs is part of the note.
----
some source code
----
==== 
</code></pre>
<p>| |子弹列表|子弹列表|</p>
<pre><code>* list item 1 
</code></pre>
<p>（见 <a href="http://asciidoctor.org/docs/user-manual/#unordered-lists">http://asciidoctor.org/docs/user-manual/#unordered-lists</a> ）</p>
<p>| |编号列表|编号列表|</p>
<pre><code>. list item 2 
</code></pre>
<p>（见 <a href="http://asciidoctor.org/docs/user-manual/#ordered-lists">http://asciidoctor.org/docs/user-manual/#ordered-lists</a> ）</p>
<p>| |清单|选中或未选中的复选框|</p>
<p>经过：</p>
<pre><code>- [*] 
</code></pre>
<p>未选中：</p>
<pre><code>- [ ] 
</code></pre>
<p>| |多级列表|项目符号或编号或组合|</p>
<pre><code>. Numbered (1), at top level
* Bullet (2), nested under 1
* Bullet (3), nested under 1
. Numbered (4), at top level
* Bullet (5), nested under 4
** Bullet (6), nested under 5
- [x] Checked (7), at top level 
</code></pre>
<p>| |标记列表/变量列表|列表项标题或摘要后跟内容|</p>
<pre><code>Title:: content

Title::
  content 
</code></pre>
<p>| |侧栏，引号或其他文本块|一个文本块，格式与默认值不同</p>
<p>使用不同的分隔符分隔，请参阅 <a href="http://asciidoctor.org/docs/user-manual/#built-in-blocks-summary">http://asciidoctor.org/docs/user-manual/#built-in-blocks-summary</a> 。上面的一些例子使用分隔符，如....，----，====。</p>
<pre><code>[example]
====
This is an example block.
====

[source]
----
This is a source block.
----

[note]
====
This is a note block.
====

[quote]
____
This is a quote block.
____ 
</code></pre>
<p>如果要插入一直保持被解释的文字 Asciidoc 内容，如果有疑问，请在顶部和底部使用八个点作为分隔符。</p>
<p>| |嵌套部分|章节，节，小节等|</p>
<pre><code>= Book (or chapter if the chapter can be built alone, see the leveloffset info below)

== Chapter (or section if the chapter is standalone)

=== Section (or subsection, etc)

==== Subsection 
</code></pre>
<p>等等多达 6 个级别（仔细考虑深入 4 级以上，也许你可以选择标题段落或列表）。请注意，您可以通过在 include 之前直接添加<code>:leveloffset:+1</code>宏指令将一本书包含在另一本书中，然后将其重置为 0。有关示例，请参阅 <em>book.adoc</em> 源代码，因为这是本指南处理章节的方式。 <strong>不要为前言，术语表，附录或其他特殊类型的章节做这些。</strong></p>
<p>| |包含另一个文件|内容包含在内，就像它是内联的一样</p>
<pre><code>include::[/path/to/file.adoc] 
</code></pre>
<p>有很多例子。见 <em>book.adoc</em> 。</p>
<p>| |一张桌子|一张桌子|</p>
<p>见 <a href="http://asciidoctor.org/docs/user-manual/#tables">http://asciidoctor.org/docs/user-manual/#tables</a> 。通常，行由换行符和换行符按管道分隔</p>
<p>| |注释掉一行|渲染时跳过一行|</p>
<p><code>// This line won’t show up</code></p>
<p>| |注释掉一个块|在渲染过程中会跳过文件的一部分</p>
<pre><code>////
Nothing between the slashes will show up.
//// 
</code></pre>
<p>| |突出显示要审阅的文本|文本显示黄色背景|</p>
<pre><code>Test between #hash marks# is highlighted yellow. 
</code></pre>
<p>|</p>
<h3 id="a6自动生成的内容">A.6。自动生成的内容</h3>
<p>HBase 参考指南的某些部分，特别是 <a href="#config.files">config.files</a> ，是自动生成的，因此文档的这个区域与代码保持同步。这是通过 XSLT 转换完成的，您可以在 _src / main / xslt / configuration_to_asciidoc <em>chapter.xsl</em> 的源代码中查看。这会将 <em>hbase-common / src / main / resources / hbase-default.xml</em> 文件转换为 Asciidoc 输出，该输出可以包含在参考指南中。</p>
<p>有时，需要添加配置参数或修改其描述。对源文件进行修改，重建后它们将包含在“参考指南”中。</p>
<p>将来可能并且将从 HBase 源文件自动生成其他类型的内容。</p>
<h3 id="a7-hbase-参考指南中的图像">A.7。 HBase 参考指南中的图像</h3>
<p>您可以在 HBase 参考指南中包含图像。如果可能，重要的是包括图像标题，并始终包括替代文本。这允许屏幕阅读器导航到图像并且还为图像提供替代文本。以下是带有标题和替代文本的图像示例。注意双冒号。</p>
<pre><code>.My Image Title
image::sunset.jpg[Alt Text] 
</code></pre>
<p>以下是带有替换文本的内嵌图像的示例。注意单个冒号。内嵌图像不能有标题。它们通常是像 GUI 按钮这样的小图像。</p>
<pre><code>image:sunset.jpg[Alt Text] 
</code></pre>
<p>进行本地构建时，将图像保存到 <em>src / site / resources / <a href="https://hbase.apache.org/images/">https://hbase.apache.org/images/</a></em> 目录。链接到图像时，请不要包含路径的目录部分。在构建输出期间，图像将被复制到适当的目标位置。</p>
<p>当您提交包含将图像添加到 HBase 参考指南的修补程序时，请将图像附加到 JIRA。如果提交者询问应该提交映像的位置，它应该进入上面的目录。</p>
<h3 id="a8在-hbase-参考指南中添加新章节">A.8。在 HBase 参考指南中添加新章节</h3>
<p>如果要在 HBase 参考指南中添加新章节，最简单的方法是复制现有的章节文件，重命名它，并更改 ID（在双括号中）和标题。章节位于 <em>src / main / asciidoc / _ 章节/</em> 目录中。</p>
<p>删除现有内容并创建新内容。然后打开 <em>src / main / asciidoc / book.adoc</em> 文件，该文件是 HBase 参考指南的主文件，并复制现有的<code>include</code>元素以将新章节包含在适当的位置。在创建补丁之前，请务必将新文件添加到 Git 存储库。</p>
<p>如有疑问，请检查其他文件是如何包含的。</p>
<h3 id="a9常见文档问题">A.9。常见文档问题</h3>
<p>经常出现以下文档问题。其中一些是偏好，但其他人可能会产生神秘的构建错误或其他问题。</p>
<ol>
<li> <p>_ 隔离更改以便进行简易差异检查。_</p> <p>小心漂亮打印或重新格式化整个 XML 文件，即使格式随着时间的推移而降级。如果您需要重新格式化文件，请在不更改任何内容的单独 JIRA 中执行此操作。请注意，因为某些 XML 编辑器在您打开新文件时会进行批量重新格式化，尤其是在编辑器中使用 GUI 模式时。</p> </li>
<li> <p>_ 语法突出显示 _</p> <p>HBase 参考指南使用<code>coderay</code>进行语法高亮显示。要为给定代码清单启用语法突出显示，请使用以下类型的语法：</p> <pre><code>[source,xml]
----
&amp;lt;name&amp;gt;My Name&amp;lt;/name&amp;gt;
---- 
</code></pre> <p>支持几种语法类型。 HBase 参考指南中最有趣的是<code>java</code>，<code>xml</code>，<code>sql</code>和<code>bash</code>。</p> </li>
</ol>
<h2 id="附录-b常见问题">附录 B：常见问题</h2>
<h3 id="b1一般">B.1。一般</h3>
<p>我什么时候应该使用 HBase？</p>
<p>请参阅架构章节中的<a href="#arch.overview">概述</a>。</p>
<p>还有其他 HBase 常见问题吗？</p>
<p>请参阅维基上的常见问题解答， <a href="https://wiki.apache.org/hadoop/Hbase/FAQ">HBase Wiki 常见问题解答</a>。</p>
<p>HBase 是否支持 SQL？</p>
<p>并不是的。通过 <a href="https://hive.apache.org/">Hive</a> 对 HBase 的 SQL-ish 支持正在开发中，但是 Hive 基于 MapReduce，它通常不适用于低延迟请求。有关 HBase 客户端的示例，请参见<a href="#datamodel">数据模型</a>部分。</p>
<p>如何找到 NoSQL / HBase 的示例？</p>
<p>请参阅<a href="#other.info">关于 HBase</a> 的其他信息以及其他文章中 BigTable 论文的链接。</p>
<p>HBase 的历史是什么？</p>
<p>见 <a href="#hbase.history">hbase.history</a> 。</p>
<p>为什么 HBase 不建议使用 10MB 以上的电池？</p>
<p>大细胞不适合 HBase 缓冲数据的方法。首先，大单元在写入时绕过 MemStoreLAB。然后，在读取操作期间，它们不能缓存在 L2 块缓存中。相反，HBase 每次都必须为它们分配堆内存。这可能会对 RegionServer 进程中的垃圾收集器产生重大影响。</p>
<h3 id="b2升级">B.2。升级</h3>
<p>如何将 Maven 管理的项目从 HBase 0.94 升级到 HBase 0.96+？</p>
<p>在 HBase 0.96 中，项目转移到模块化结构。调整项目的依赖关系以依赖<code>hbase-client</code>模块或其他模块，而不是单个 JAR。您可以根据您的目标 HBase 版本，在以下之一之后为 Maven 依赖建模。有关更多信息，请参见第 3.5 节“从 0.94.x 升级到 0.96.x”或第 3.3 节“从 0.96.x 升级到 0.98.x”。</p>
<p>Maven 对 HBase 的依赖性为 0.98</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;
  &lt;artifactId&gt;hbase-client&lt;/artifactId&gt;
  &lt;version&gt;0.98.5-hadoop2&lt;/version&gt;
&lt;/dependency&gt; 
</code></pre>
<p>Maven 对 HBase 的依赖性为 0.96</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;
  &lt;artifactId&gt;hbase-client&lt;/artifactId&gt;
  &lt;version&gt;0.96.2-hadoop2&lt;/version&gt;
&lt;/dependency&gt; 
</code></pre>
<p>Maven 对 HBase 的依赖性为 0.94</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;
  &lt;artifactId&gt;hbase&lt;/artifactId&gt;
  &lt;version&gt;0.94.3&lt;/version&gt;
&lt;/dependency&gt; 
</code></pre>
<h3 id="b3建筑">B.3。建筑</h3>
<p>HBase 如何处理 Region-RegionServer 分配和位置？</p>
<p>见<a href="#regions.arch">区域</a>。</p>
<h3 id="b4组态">B.4。组态</h3>
<p>我怎样才能开始使用我的第一个集群？</p>
<p>参见<a href="#quickstart">快速入门 - 独立 HBase</a> 。</p>
<p>我在哪里可以了解其他配置选项？</p>
<p>请参见 <a href="#configuration">Apache HBase 配置</a>。</p>
<h3 id="b5架构设计数据访问">B.5。架构设计/数据访问</h3>
<p>我应该如何在 HBase 中设计我的架构？</p>
<p>参见<a href="#datamodel">数据模型</a>和 <a href="#schema">HBase 和模式设计</a>。</p>
<p>如何在 HBase 中存储（填空）？</p>
<p>请参见<a href="#supported.datatypes">支持的数据类型</a>。</p>
<p>如何处理 HBase 中的二级索引？</p>
<p>请参见<a href="#secondary.indexes">辅助索引和备用查询路径</a>。</p>
<p>我可以更改表的 rowkeys 吗？</p>
<p>这是一个非常常见的问题。你不能。参见 <a href="#changing.rowkeys">Rowkeys</a> 的不变性。</p>
<p>HBase 支持哪些 API？</p>
<p>参见<a href="#datamodel">数据模型</a>，<a href="#architecture.client">客户端</a>和 <a href="#external_apis">Apache HBase 外部 API</a> 。</p>
<h3 id="b6-mapreduce-的">B.6。 MapReduce 的</h3>
<p>如何将 MapReduce 与 HBase 一起使用？</p>
<p>参见 <a href="#mapreduce">HBase 和 MapReduce</a> 。</p>
<h3 id="b7性能和故障排除">B.7。性能和故障排除</h3>
<p>如何提高 HBase 集群性能？</p>
<p>参见 <a href="#performance">Apache HBase 性能调优</a>。</p>
<p>如何解决 HBase 群集问题？</p>
<p>请参阅<a href="#trouble">疑难解答和调试 Apache HBase</a> 。</p>
<h3 id="b8亚马逊-ec2">B.8。亚马逊 EC2</h3>
<p>我在 Amazon EC2 上运行 HBase 并且......</p>
<p>EC2 问题是一个特例。参见 <a href="#trouble.ec2">Amazon EC2</a> 和 <a href="#perf.ec2">Amazon EC2</a> 。</p>
<h3 id="b9操作">B.9。操作</h3>
<p>如何管理 HBase 群集？</p>
<p>参见 <a href="#ops_mgt">Apache HBase 运营管理</a>。</p>
<p>如何备份 HBase 群集？</p>
<p>参见 <a href="#ops.backup">HBase Backup</a> 。</p>
<h3 id="b10-hbase-在行动">B.10。 HBase 在行动</h3>
<p>我在哪里可以找到有关 HBase 的有趣视频和演示文稿？</p>
<p>参见<a href="#other.info">关于 HBase</a> 的其他信息。</p>
<h2 id="附录-c访问控制矩阵">附录 C：访问控制矩阵</h2>
<p>以下矩阵显示了在 HBase 中执行操作所需的权限集。在使用该表之前，请阅读有关如何解释它的信息。</p>
<p>解释 ACL 矩阵表</p>
<p>ACL Matrix 表中使用以下约定：</p>
<h3 id="c1领域">C.1。领域</h3>
<p>从最广泛的范围开始评估权限，并在最窄的范围内进行评估。</p>
<p>范围对应于数据模型的级别。从最广泛到最窄，范围如下：</p>
<p>领域</p>
<ul>
<li> <p>全球</p> </li>
<li> <p>命名空间（NS）</p> </li>
<li> <p>表</p> </li>
<li> <p>柱族（CF）</p> </li>
<li> <p>列限定符（CQ）</p> </li>
<li> <p>细胞</p> </li>
</ul>
<p>例如，在表级别授予的权限支配在列族，列限定符或单元级别完成的任何授权。用户可以在表中的任何位置执行授权所暗示的内容。在全局范围内授予的权限支配所有权限：始终允许用户在任何地方执行该操作。</p>
<h3 id="c2权限">C.2。权限</h3>
<p>可能的权限包括以下内容：</p>
<p>权限</p>
<ul>
<li> <p>超级用户 - 属于“超级组”组的特殊用户，具有无限制访问权限</p> </li>
<li> <p>管理员（A）</p> </li>
<li> <p>创建（C）</p> </li>
<li> <p>写（W）</p> </li>
<li> <p>阅读（R）</p> </li>
<li> <p>执行（X）</p> </li>
</ul>
<p>在大多数情况下，权限以预期的方式工作，具有以下警告：</p>
<p>拥有写入权限并不意味着具有读取权限。</p>
<p>用户能够并且有时希望能够写入相同用户无法读取的数据。一个这样的例子是日志写入过程。</p>
<p>无论用户的其他授权或限制如何，每个用户都可以读取 hbase：meta 表。</p>
<p>这是 HBase 正常运行的要求。</p>
<p>如果用户没有写入和读取权限，则<code>CheckAndPut</code>和<code>CheckAndDelete</code>操作将失败。</p>
<p><code>Increment</code>和<code>Append</code>操作不需要读访问权限。</p>
<p>顾名思义，<code>superuser</code>具有执行所有可能操作的权限。</p>
<p>对于标有*的操作，检查在后挂钩中完成，只有满足访问检查的结果子集才会返回给用户。</p>
<p>下表按提供每个操作的接口排序。如果表格过时，可以在 <em>hbase-server / src / test / java / org / apache / hadoop / hbase / security / access / TestAccessController.java 中找到检查权限准确性的单元。</em> ，访问控制本身可以在 <em>hbase-server / src / main / java / org / apache / hadoop / hbase / security / access / AccessController.java</em> 中查看。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>手术</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>主</td>
<td>CREATETABLE</td>
<td>超级用户|全球（C）| NS（C）</td>
</tr>
<tr>
<td></td>
<td>modifyTable</td>
<td>超级用户|全球（A）|全球（C）| NS（A）| NS（C）|表所有者|表（A）|表（C）</td>
</tr>
<tr>
<td></td>
<td>deleteTable</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>truncateTable</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>addColumn</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>modifyColumn</td>
<td>超级用户|全球（A）|全球（C）| NS（A）| NS（C）|表所有者|表（A）|表（C）|柱（A）|柱（C）</td>
</tr>
<tr>
<td></td>
<td>deleteColumn</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)|column(A)|column(C)</td>
</tr>
<tr>
<td></td>
<td>enableTable</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>disableTable</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>disableAclTable</td>
<td>不允许</td>
</tr>
<tr>
<td></td>
<td>移动</td>
<td>超级用户|全球（A）| NS（A）|表所有者|表（A）</td>
</tr>
<tr>
<td></td>
<td>分配</td>
<td>superuser|global(A)|NS(A)|TableOwner|table(A)</td>
</tr>
<tr>
<td></td>
<td>取消分配</td>
<td>superuser|global(A)|NS(A)|TableOwner|table(A)</td>
</tr>
<tr>
<td></td>
<td>regionOffline</td>
<td>superuser|global(A)|NS(A)|TableOwner|table(A)</td>
</tr>
<tr>
<td></td>
<td>平衡</td>
<td>超级用户|全球（A）</td>
</tr>
<tr>
<td></td>
<td>balanceSwitch</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>关掉</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>stopMaster</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>快照</td>
<td>superuser|global(A)|NS(A)|TableOwner|table(A)</td>
</tr>
<tr>
<td></td>
<td>listSnapshot</td>
<td>超级用户|全球（A）| SnapshotOwner</td>
</tr>
<tr>
<td></td>
<td>cloneSnapshot</td>
<td>超级用户|全局（A）|（SnapshotOwner＆amp; TableName 匹配）</td>
</tr>
<tr>
<td></td>
<td>restoreSnapshot</td>
<td>超级用户|全球（A）| SnapshotOwner＆amp; （NS（A）|表所有者|表（A））</td>
</tr>
<tr>
<td></td>
<td>deleteSnapshot</td>
<td>superuser|global(A)|SnapshotOwner</td>
</tr>
<tr>
<td></td>
<td>createNamespace</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>deleteNamespace</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>modifyNamespace</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>getNamespaceDescriptor</td>
<td>超级用户|全球（A）| NS（A）</td>
</tr>
<tr>
<td></td>
<td>listNamespaceDescriptors *</td>
<td>superuser|global(A)|NS(A)</td>
</tr>
<tr>
<td></td>
<td>flushTable</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>getTableDescriptors *</td>
<td>superuser|global(A)|global(C)|NS(A)|NS(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>getTableNames *</td>
<td>超级用户| TableOwner |任何全局或表 perm</td>
</tr>
<tr>
<td></td>
<td>setUserQuota（全局级别）</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>setUserQuota（名称空间级别）</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>setUserQuota（表级）</td>
<td>superuser|global(A)|NS(A)|TableOwner|table(A)</td>
</tr>
<tr>
<td></td>
<td>setTableQuota</td>
<td>superuser|global(A)|NS(A)|TableOwner|table(A)</td>
</tr>
<tr>
<td></td>
<td>setNamespaceQuota</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>addReplicationPeer</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>removeReplicationPeer</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>enableReplicationPeer</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>disableReplicationPeer</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>getReplicationPeerConfig</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>updateReplicationPeerConfig</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>listReplicationPeers</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>getClusterStatus</td>
<td>任何用户</td>
</tr>
<tr>
<td>区域</td>
<td>openRegion</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>closeRegion</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>红晕</td>
<td>超级用户|全球（A）|全球（C）|表所有者|表（A）|表（C）</td>
</tr>
<tr>
<td></td>
<td>分裂</td>
<td>超级用户|全球（A）|表所有者|表所有者|表（A）</td>
</tr>
<tr>
<td></td>
<td>紧凑</td>
<td>superuser|global(A)|global(C)|TableOwner|table(A)|table(C)</td>
</tr>
<tr>
<td></td>
<td>getClosestRowBefore</td>
<td>超级用户|全球（R）| NS（R）|表所有者|表（R）| CF（R）| CQ（R）</td>
</tr>
<tr>
<td></td>
<td>getOp</td>
<td>superuser|global(R)|NS(R)|TableOwner|table(R)|CF(R)|CQ(R)</td>
</tr>
<tr>
<td></td>
<td>存在</td>
<td>superuser|global(R)|NS(R)|TableOwner|table(R)|CF(R)|CQ(R)</td>
</tr>
<tr>
<td></td>
<td>放</td>
<td>超级用户|全球（W）| NS（W）|表（W）|表所有者| CF（W）| CQ（W）</td>
</tr>
<tr>
<td></td>
<td>删除</td>
<td>superuser|global(W)|NS(W)|table(W)|TableOwner|CF(W)|CQ(W)</td>
</tr>
<tr>
<td></td>
<td>batchMutate</td>
<td>超级用户|全球（W）| NS（W）|表所有者|表（W）| CF（W）| CQ（W）</td>
</tr>
<tr>
<td></td>
<td>checkAndPut</td>
<td>超级用户|全球（RW）| NS（RW）|表所有者|表（RW）| CF（RW）| CQ（RW）</td>
</tr>
<tr>
<td></td>
<td>checkAndPutAfterRowLock</td>
<td>超级用户|全球（R）| NS（R）|表所有者|表（R）| CF（R）| CQ（R）</td>
</tr>
<tr>
<td></td>
<td>checkAndDelete</td>
<td>superuser|global(RW)|NS(RW)|TableOwner|table(RW)|CF(RW)|CQ(RW)</td>
</tr>
<tr>
<td></td>
<td>checkAndDeleteAfterRowLock</td>
<td>superuser|global(R)|NS(R)|TableOwner|table(R)|CF(R)|CQ(R)</td>
</tr>
<tr>
<td></td>
<td>incrementColumnValue</td>
<td>superuser|global(W)|NS(W)|TableOwner|table(W)|CF(W)|CQ(W)</td>
</tr>
<tr>
<td></td>
<td>附加</td>
<td>superuser|global(W)|NS(W)|TableOwner|table(W)|CF(W)|CQ(W)</td>
</tr>
<tr>
<td></td>
<td>appendAfterRowLock</td>
<td>superuser|global(W)|NS(W)|TableOwner|table(W)|CF(W)|CQ(W)</td>
</tr>
<tr>
<td></td>
<td>增量</td>
<td>superuser|global(W)|NS(W)|TableOwner|table(W)|CF(W)|CQ(W)</td>
</tr>
<tr>
<td></td>
<td>incrementAfterRowLock</td>
<td>superuser|global(W)|NS(W)|TableOwner|table(W)|CF(W)|CQ(W)</td>
</tr>
<tr>
<td></td>
<td>scannerOpen</td>
<td>superuser|global(R)|NS(R)|TableOwner|table(R)|CF(R)|CQ(R)</td>
</tr>
<tr>
<td></td>
<td>scannerNext</td>
<td>superuser|global(R)|NS(R)|TableOwner|table(R)|CF(R)|CQ(R)</td>
</tr>
<tr>
<td></td>
<td>scannerClose</td>
<td>superuser|global(R)|NS(R)|TableOwner|table(R)|CF(R)|CQ(R)</td>
</tr>
<tr>
<td></td>
<td>bulkLoadHFile</td>
<td>超级用户|全球（C）|表所有者|表（C）| CF（C）</td>
</tr>
<tr>
<td></td>
<td>prepareBulkLoad</td>
<td>superuser|global(C)|TableOwner|table(C)|CF(C)</td>
</tr>
<tr>
<td></td>
<td>cleanupBulkLoad</td>
<td>superuser|global(C)|TableOwner|table(C)|CF(C)</td>
</tr>
<tr>
<td>端点</td>
<td>调用</td>
<td>超级用户|全球（X）| NS（X）|表所有者|表（X）</td>
</tr>
<tr>
<td>AccessController 的</td>
<td>补助金（全球一级）</td>
<td>全球（A）</td>
</tr>
<tr>
<td></td>
<td>grant（名称空间级别）</td>
<td>全球（A）| NS（A）</td>
</tr>
<tr>
<td></td>
<td>授权（表级）</td>
<td>全球（A）| NS（A）|表所有者|表（A）| CF（A）| CQ（A）</td>
</tr>
<tr>
<td></td>
<td>撤销（全球一级）</td>
<td>global(A)</td>
</tr>
<tr>
<td></td>
<td>revoke（名称空间级别）</td>
<td>global(A)|NS(A)</td>
</tr>
<tr>
<td></td>
<td>撤销（表级）</td>
<td>global(A)|NS(A)|TableOwner|table(A)|CF(A)|CQ(A)</td>
</tr>
<tr>
<td></td>
<td>getUserPermissions（全局级别）</td>
<td>global(A)</td>
</tr>
<tr>
<td></td>
<td>getUserPermissions（名称空间级别）</td>
<td>global(A)|NS(A)</td>
</tr>
<tr>
<td></td>
<td>getUserPermissions（表级）</td>
<td>global(A)|NS(A)|TableOwner|table(A)|CF(A)|CQ(A)</td>
</tr>
<tr>
<td></td>
<td>hasPermission（表级）</td>
<td>全球（A）| SelfUserCheck</td>
</tr>
<tr>
<td>RegionServer 的</td>
<td>stopRegionServer</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>mergeRegions</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>rollWALWriterRequest</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>replicateLogEntries</td>
<td>超级用户|全球（W）</td>
</tr>
<tr>
<td>RSGroup</td>
<td>addRSGroup</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>balanceRSGroup</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>getRSGroupInfo</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>getRSGroupInfoOfTable</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>getRSGroupOfServer</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>listRSGroups</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>moveServers</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>moveServersAndTables</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>moveTables</td>
<td>superuser|global(A)</td>
</tr>
<tr>
<td></td>
<td>removeRSGroup</td>
<td>superuser|global(A)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>removeServers |超级用户|全球（A）</p>
</blockquote>
<h2 id="附录-dhbase-中的压缩和数据块编码">附录 D：HBase 中的压缩和数据块编码</h2>
<blockquote>
<p>本节中提到的编解码器用于编码和解码数据块或行键。有关复制编解码器的信息，请参见 <a href="#cluster.replication.preserving.tags">cluster.replication.preserving.tags</a> 。</p>
</blockquote>
<p>本节中的一些信息来自 HBase Development 邮件列表中的<a href="http://search-hadoop.com/m/lL12B1PFVhp1/v=threaded">讨论</a>。</p>
<p>HBase 支持几种不同的压缩算法，可以在 ColumnFamily 上启用。数据块编码试图限制密钥中信息的重复，利用 HBase 的一些基本设计和模式，例如排序的行键和给定表的模式。压缩器减少了单元中大型不透明字节数组的大小，并且可以显着减少存储未压缩数据所需的存储空间。</p>
<p>压缩器和数据块编码可以在同一 ColumnFamily 上一起使用。</p>
<p>压缩后的变化生效</p>
<p>如果更改 ColumnFamily 的压缩或编码，则更改将在压缩期间生效。</p>
<p>一些编解码器利用 Java 内置的功能，例如 GZip 压缩。其他人依赖本地图书馆。本机库可以作为 Hadoop 的一部分提供，例如 LZ4。在这种情况下，HBase 只需要访问适当的共享库。</p>
<p>其他编解码器，例如 Google Snappy，需要先安装。某些编解码器的许可方式与 HBase 的许可证相冲突，不能作为 HBase 的一部分提供。</p>
<p>本节讨论使用 HBase 进行测试的常用编解码器。无论您使用何种编解码器，请确保测试它是否已正确安装并且可在群集中的所有节点上使用。可能需要额外的操作步骤以确保编解码器在新部署的节点上可用。您可以使用 <a href="#compression.test">compression.test</a> 实用程序检查给定的编解码器是否已正确安装。</p>
<p>要将 HBase 配置为使用压缩器，请参见 <a href="#compressor.install">compressor.install</a> 。要为 ColumnFamily 启用压缩器，请参阅 <a href="#changing.compression">changing.compression</a> 。要为 ColumnFamily 启用数据块编码，请参见 <a href="#data.block.encoding.enable">data.block.encoding.enable</a> 。</p>
<p>块压缩机</p>
<ul>
<li> <p>没有</p> </li>
<li> <p>瞬间</p> </li>
<li> <p>LZO</p> </li>
<li> <p>LZ4</p> </li>
<li> <p>GZ</p> </li>
</ul>
<p>数据块编码类型</p>
<p>字首</p>
<p>通常，键非常相似。具体来说，密钥通常共享一个共同的前缀，并且只在末尾附近不同。例如，一个键可能是<code>RowKey:Family:Qualifier0</code>，下一个键可能是<code>RowKey:Family:Qualifier1</code>。在前缀编码中，添加了一个额外的列，其中包含当前键和前一个键之间共享的前缀长度。假设此处的第一个密钥与之前的密钥完全不同，则其前缀长度为 0。</p>
<p>第二个密钥的前缀长度为<code>23</code>，因为它们共有前 23 个字符。</p>
<p>显然，如果密钥往往没有任何共同点，Prefix 将不会提供太多好处。</p>
<p>下图显示了一个没有数据块编码的假设 ColumnFamily。</p>
<p><a href="https://img.cntofu.com/book/hbase-doc-zh/docs/img/1f44983638a4ac51880dbbea2f7f876b.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/hbase-doc-zh/docs/img/1f44983638a4ac51880dbbea2f7f876b.jpg" alt="data block no encoding"></a>图 18.没有编码的 ColumnFamily</p>
<p>这是与前缀数据编码相同的数据。</p>
<p><a href="https://img.cntofu.com/book/hbase-doc-zh/docs/img/963f30d82e977ef545d807d7b2c4ddd9.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/hbase-doc-zh/docs/img/963f30d82e977ef545d807d7b2c4ddd9.jpg" alt="data block prefix encoding"></a>图 19.带有前缀编码的 ColumnFamily</p>
<p>DIFF</p>
<p>差异编码扩展了前缀编码。不是将密钥顺序地视为单个字节序列，而是分割每个密钥字段，以便可以更有效地压缩密钥的每个部分。</p>
<p>添加了两个新字段：时间戳和类型。</p>
<p>如果 ColumnFamily 与上一行相同，则从当前行中省略它。</p>
<p>如果密钥长度，值长度或类型与前一行相同，则省略该字段。</p>
<p>此外，为了增加压缩，时间戳存储为前一行时间戳的 Diff，而不是完整存储。给定前缀示例中的两个行键，并给出时间戳和相同类型的精确匹配，第二行的值长度或类型都不需要存储，第二行的时间戳值只有 0，而不是一个完整的时间戳。</p>
<p>默认情况下禁用 Diff 编码，因为写入和扫描速度较慢但缓存了更多数据。</p>
<p>此图像显示与之前图像相同的 ColumnFamily，具有 Diff 编码。</p>
<p><a href="https://img.cntofu.com/book/hbase-doc-zh/docs/img/effffee77541617c3a2622f509064aff.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/hbase-doc-zh/docs/img/effffee77541617c3a2622f509064aff.jpg" alt="data block diff encoding"></a>图 20.带有 Diff 编码的 ColumnFamily</p>
<p>快速差异</p>
<p>Fast Diff 与 Diff 类似，但使用更快的实现。它还添加了另一个字段，用于存储单个位以跟踪数据本身是否与前一行相同。如果是，则不再存储数据。</p>
<p>如果您有长键或多列，建议使用快速差异。</p>
<p>数据格式几乎与 Diff 编码相同，因此没有图像来说明它。</p>
<p>前缀树</p>
<p>在 HBase 0.96 中引入了前缀树编码作为实验特征。它为 Prefix，Diff 和 Fast Diff 编码器提供了类似的内存节省，但以较慢的编码速度为代价提供了更快的随机访问。它已在 hbase-2.0.0 中删除。这是一个好主意，但很少采用。如果有兴趣重振这项工作，请编写 hbase 开发列表。</p>
<h3 id="d1使用哪种压缩器或数据块编码器">D.1。使用哪种压缩器或数据块编码器</h3>
<p>要使用的压缩或编解码器类型取决于数据的特征。选择错误的类型可能会导致数据占用更多空间而不是更少，并且可能会影响性能。</p>
<p>通常，您需要在较小尺寸和较快压缩/解压缩之间权衡您的选择。以下是一些一般性指南，从<a href="http://search-hadoop.com/m/lL12B1PFVhp1">关于压缩和编解码器的文档指南</a>的讨论中进行了扩展。</p>
<ul>
<li> <p>如果您有长键（与值相比）或许多列，请使用前缀编码器。建议使用 FAST_DIFF。</p> </li>
<li> <p>如果值很大（而不是预压缩，例如图像），请使用数据块压缩器。</p> </li>
<li> <p>将 GZIP 用于 _ 冷数据 _，不经常访问。 GZIP 压缩比 Snappy 或 LZO 使用更多的 CPU 资源，但提供更高的压缩比。</p> </li>
<li> <p>对于经常访问的 _ 热数据 _ 使用 Snappy 或 LZO。 Snappy 和 LZO 比 GZIP 使用更少的 CPU 资源，但不提供高压缩比。</p> </li>
<li> <p>在大多数情况下，默认情况下启用 Snappy 或 LZO 是一个不错的选择，因为它们具有较低的性能开销并节省空间。</p> </li>
<li> <p>在 2011 年 Snappy 成为谷歌之前，LZO 是默认的。 Snappy 具有与 LZO 相似的品质，但已被证明表现更好。</p> </li>
</ul>
<h3 id="d2在-hbase-中使用-hadoop-本机库">D.2。在 HBase 中使用 Hadoop 本机库</h3>
<p>Hadoop 共享库有许多功能，包括压缩库和快速 crc'ing - 硬件 crc'ing，如果您的芯片组支持它。要使此工具可用于 HBase，请执行以下操作。如果找不到本机库版本，HBase / Hadoop 将回退使用替代品 - 或者如果你要求显式压缩器并且没有替代可用，则彻底失败。</p>
<p>首先确保你的 Hadoop。如果您看到它启动 Hadoop 进程，请修复此消息：</p>
<pre><code>16/02/09 22:40:24 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 
</code></pre>
<p>这意味着没有正确指向其本机库，或者本地库是为另一个平台编译的。先解决这个问题。</p>
<p>然后，如果您在 HBase 日志中看到以下内容，则表示 HBase 无法找到 Hadoop 本机库：</p>
<pre><code>2014-08-07 09:26:20,139 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 
</code></pre>
<p>如果库已成功加载，则不会显示 WARN 消息。通常这意味着你很高兴去阅读。</p>
<p>让我们假设您的 Hadoop 附带了一个适合您正在运行 HBase 的平台的本机库。要检查 Hadoop 本机库是否可用于 HBase，请运行以下工具（可在 Hadoop 2.1 及更高版本中使用）：</p>
<pre><code>$ ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker
2014-08-26 13:15:38,717 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
Native library checking:
hadoop: false
zlib:   false
snappy: false
lz4:    false
bzip2:  false
2014-08-26 13:15:38,863 INFO  [main] util.ExitUtil: Exiting with status 1 
</code></pre>
<p>上图显示本地 hadoop 库在 HBase 上下文中不可用。</p>
<p>上面的 NativeLibraryChecker 工具可能会回来说所有的文件都是 hunky-dory - 即所有的库都显示'true'，它们是可用的 - 但是无论如何都要按照下面的说明来确保本机库在 HBase 上下文中可用，当它们使用它们时。</p>
<p>要解决上述问题，如果 Hadoop 和 HBase 停顿在文件系统中相邻，则将 Hadoop 本机库本地或符号链接复制到它们。您还可以通过在 hbase-env.sh 中设置<code>LD_LIBRARY_PATH</code>环境变量来指向其位置。</p>
<p>JVM 寻找本机库的位置是“系统相关的”（参见<code>java.lang.System#loadLibrary(name)</code>）。在 linux 上，默认情况下，将查看 <em>lib / native / PLATFORM</em> ，其中<code>PLATFORM</code>是安装 HBase 的平台的标签。在本地 linux 机器上，它似乎是 java 属性<code>os.name</code>和<code>os.arch</code>的串联，后跟是 32 位还是 64 位。启动时 HBase 打印出所有 java 系统属性，因此在日志中找到 os.name 和 os.arch。例如：</p>
<pre><code>...
2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.name=Linux
2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.arch=amd64
... 
</code></pre>
<p>所以在这种情况下，PLATFORM 字符串是<code>Linux-amd64-64</code>。在 <em>lib / native / Linux-amd64-64</em> 复制 Hadoop 本机库或符号链接将确保找到它们。完成此更改后滚动重新启动。</p>
<p>以下是如何设置符号链接的示例。让 hadoop 和 hbase 安装在您的主目录中。假设您的 hadoop 本机库位于〜/ hadoop / lib / native。假设您使用的是 Linux-amd64-64 平台。在这种情况下，您将执行以下操作来链接 hadoop 本机库，以便 hbase 可以找到它们。</p>
<pre><code>...
$ mkdir -p ~/hbaseLinux-amd64-64 -&gt; /home/stack/hadoop/lib/native/lib/native/
$ cd ~/hbase/lib/native/
$ ln -s ~/hadoop/lib/native Linux-amd64-64
$ ls -la
# Linux-amd64-64 -&gt; /home/USER/hadoop/lib/native
... 
</code></pre>
<p>如果您在堆栈轨道中看到 PureJavaCrc32C，或者如果在 perf 跟踪中看到类似下面的内容，则本机不起作用;您使用的是 java CRC 函数而不是 native 函数：</p>
<pre><code> 5.02%  perf-53601.map      [.] Lorg/apache/hadoop/util/PureJavaCrc32C;.update 
</code></pre>
<p>请参阅 <a href="https://issues.apache.org/jira/browse/HBASE-11927">HBASE-11927 使用 Native Hadoop Library 进行 HFile 校验和（并将默认值从 CRC32 转换为 CRC32C）</a>，有关本机校验和支持的更多信息。请特别参阅发行说明，了解如何检查硬件是否支持处理器是否支持硬件 CRC。或者查看 HBase 博客文章中的 Apache <a href="https://blogs.apache.org/hbase/entry/saving_cpu_using_native_hadoop">Checksums。</a></p>
<p>以下是如何使用<code>LD_LIBRARY_PATH</code>环境变量指向 Hadoop 库的示例：</p>
<pre><code>$ LD_LIBRARY_PATH=~/hadoop-2.5.0-SNAPSHOT/lib/native ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker
2014-08-26 13:42:49,332 INFO  [main] bzip2.Bzip2Factory: Successfully loaded &amp; initialized native-bzip2 library system-native
2014-08-26 13:42:49,337 INFO  [main] zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library
Native library checking:
hadoop: true /home/stack/hadoop-2.5.0-SNAPSHOT/lib/native/libhadoop.so.1.0.0
zlib:   true /lib64/libz.so.1
snappy: true /usr/lib64/libsnappy.so.1
lz4:    true revision:99
bzip2:  true /lib64/libbz2.so.1 
</code></pre>
<p>在启动 HBase 时在 <em>hbase-env.sh</em> 中设置 LD_LIBRARY_PATH 环境变量。</p>
<h3 id="d3压缩器配置安装和使用">D.3。压缩器配置，安装和使用</h3>
<h4 id="d31为压缩器配置-hbase">D.3.1。为压缩器配置 HBase</h4>
<p>在 HBase 可以使用给定的压缩器之前，它的库需要可用。由于许可问题，默认安装中只有 Gase 压缩可用于 HBase（通过本机 Java 库）。其他压缩库可通过与 hadoop 捆绑在一起的共享库提供。当 HBase 启动时，需要找到 hadoop 本机库。看到</p>
<p>主机上的压缩器支持</p>
<p>在 HBase 0.95 中引入了新的配置设置，以检查主服务器以确定在其上安装和配置了哪些数据块编码器，并假设整个群集配置相同。此选项<code>hbase.master.check.compression</code>默认为<code>true</code>。这可以防止 <a href="https://issues.apache.org/jira/browse/HBASE-6370">HBASE-6370</a> 中描述的情况，其中创建或修改表以支持区域服务器不支持的编解码器，从而导致需要很长时间才能发生的故障并且难以调试。</p>
<p>如果启用了<code>hbase.master.check.compression</code>，则需要在主服务器上安装和配置所有所需压缩程序的库，即使主服务器未运行区域服务器也是如此。</p>
<p>通过本机库安装 GZ 支持</p>
<p>HBase 使用 Java 的内置 GZip 支持，除非 CLASSPATH 上有本机 Hadoop 库。将库添加到 CLASSPATH 的推荐方法是为运行 HBase 的用户设置环境变量<code>HBASE_LIBRARY_PATH</code>。如果本机库不可用且使用 Java 的 GZIP，则<code>Got brand-new compressor</code>报告将出现在日志中。见 <a href="#brand.new.compressor">brand.new.compressor</a> ）。</p>
<p>安装 LZO 支持</p>
<p>由于 HBase 使用 Apache 软件许可证（ASL）和使用 GPL 许可证的 LZO 之间不兼容，因此 HBase 无法附带 LZO。有关配置 HBase 的 LZO 支持的信息，请参阅 Twitter 上的 <a href="https://github.com/twitter/hadoop-lzo/blob/master/README.html">Hadoop-LZO。</a></p>
<p>如果您依赖于 LZO 压缩，请考虑在 LZO 不可用时将 RegionServers 配置为无法启动。参见 <a href="#hbase.regionserver.codecs">hbase.regionserver.codecs</a> 。</p>
<p>配置 LZ4 支持</p>
<p>LZ4 支持与 Hadoop 捆绑在一起。启动 HBase 时，确保可以访问 hadoop 共享库（libhadoop.so）。配置完平台后（参见 <a href="#hadoop.native.lib">hadoop.native.lib</a> ），您可以建立从 HBase 到本机 Hadoop 库的符号链接。这假定两个软件安装是共同的。例如，如果我的'平台'是 Linux-amd64-64：</p>
<pre><code>$ cd $HBASE_HOME
$ mkdir lib/native
$ ln -s $HADOOP_HOME/lib/native lib/native/Linux-amd64-64 
</code></pre>
<p>使用压缩工具检查所有节点上是否安装了 LZ4。启动（或重启）HBase。之后，您可以创建和更改表以使 LZ4 成为压缩编解码器：</p>
<pre><code>hbase(main):003:0&gt; alter 'TestTable', {NAME =&gt; 'info', COMPRESSION =&gt; 'LZ4'} 
</code></pre>
<p>安装 Snappy 支持</p>
<p>由于许可问题，HBase 不附带 Snappy 支持。您可以安装 Snappy 二进制文件（例如，在 CentOS 上使用 yum install snappy）或从源代码构建 Snappy。安装 Snappy 后，搜索共享库，它将被称为 <em>libsnappy.so.X</em> ，其中 X 是一个数字。如果您是从源构建的，请将共享库复制到系统上的已知位置，例如 <em>/ opt / snappy / lib /</em> 。</p>
<p>除了 Snappy 库之外，HBase 还需要访问 Hadoop 共享库，它将被称为 <em>libhadoop.so.X.Y</em> ，其中 X 和 Y 都是数字。记下 Hadoop 库的位置，或将其复制到与 Snappy 库相同的位置。</p>
<p>| |</p>
<p>需要在群集的每个节点上提供 Snappy 和 Hadoop 库。请参阅 <a href="#compression.test">compression.test</a> 以了解如何测试这种情况。</p>
<p>如果给定的压缩器不可用，请参见 <a href="#hbase.regionserver.codecs">hbase.regionserver.codecs</a> 以配置 RegionServers 无法启动。</p>
<p>|</p>
<p>需要将每个库位置添加到运行 HBase 的操作系统用户的环境变量<code>HBASE_LIBRARY_PATH</code>中。您需要重新启动 RegionServer 才能使更改生效。</p>
<p>压缩测试</p>
<p>您可以使用 CompressionTest 工具验证您的压缩器是否可用于 HBase：</p>
<pre><code> $ hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://host/path/to/hbase snappy 
</code></pre>
<p>在 RegionServer 上强制执行压缩设置</p>
<p>您可以通过将选项 hbase.regionserver.codecs 添加到 <em>hbase-site.xml</em> 并将其值设置为逗号分隔来配置 RegionServer，以便在压缩配置不正确时无法重新启动需要可用的编解码器列表。例如，如果将此属性设置为<code>lzo,gz</code>，则如果两个压缩程序都不可用，则 RegionServer 将无法启动。这样可以防止在没有正确配置编解码器的情况下将新服务器添加到群集中。</p>
<h4 id="d32在-columnfamily-上启用压缩">D.3.2。在 ColumnFamily 上启用压缩</h4>
<p>要为 ColumnFamily 启用压缩，请使用<code>alter</code>命令。您无需重新创建表或复制数据。如果要更改编解码器，请确保旧的编解码器仍然可用，直到所有旧的 StoreFiles 都已压缩为止。</p>
<p>使用 HBase Shell 在现有表的列族上启用压缩</p>
<pre><code>hbase&gt; disable 'test'
hbase&gt; alter 'test', {NAME =&gt; 'cf', COMPRESSION =&gt; 'GZ'}
hbase&gt; enable 'test' 
</code></pre>
<p>在 ColumnFamily 上使用压缩创建新表</p>
<pre><code>hbase&gt; create 'test2', { NAME =&gt; 'cf2', COMPRESSION =&gt; 'SNAPPY' } 
</code></pre>
<p>验证 ColumnFamily 的压缩设置</p>
<pre><code>hbase&gt; describe 'test'
DESCRIPTION                                          ENABLED
 'test', {NAME =&gt; 'cf', DATA_BLOCK_ENCODING =&gt; 'NONE false
 ', BLOOMFILTER =&gt; 'ROW', REPLICATION_SCOPE =&gt; '0',
 VERSIONS =&gt; '1', COMPRESSION =&gt; 'GZ', MIN_VERSIONS
 =&gt; '0', TTL =&gt; 'FOREVER', KEEP_DELETED_CELLS =&gt; 'fa
 lse', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'false', B
 LOCKCACHE =&gt; 'true'}
1 row(s) in 0.1070 seconds 
</code></pre>
<h4 id="d33测试压缩性能">D.3.3。测试压缩性能</h4>
<p>HBase 包含一个名为 LoadTestTool 的工具，它提供了测试压缩性能的机制。必须指定<code>-write</code>或<code>-update-read</code>作为第一个参数，如果未指定其他参数，则为每个选项打印使用建议。</p>
<p>LoadTestTool 用法</p>
<pre><code>$ bin/hbase org.apache.hadoop.hbase.util.LoadTestTool -h
usage: bin/hbase org.apache.hadoop.hbase.util.LoadTestTool &lt;options&gt;
Options:
 -batchupdate                 Whether to use batch as opposed to separate
                              updates for every column in a row
 -bloom &lt;arg&gt;                 Bloom filter type, one of [NONE, ROW, ROWCOL]
 -compression &lt;arg&gt;           Compression type, one of [LZO, GZ, NONE, SNAPPY,
                              LZ4]
 -data_block_encoding &lt;arg&gt;   Encoding algorithm (e.g. prefix compression) to
                              use for data blocks in the test column family, one
                              of [NONE, PREFIX, DIFF, FAST_DIFF, ROW_INDEX_V1].
 -encryption &lt;arg&gt;            Enables transparent encryption on the test table,
                              one of [AES]
 -generator &lt;arg&gt;             The class which generates load for the tool. Any
                              args for this class can be passed as colon
                              separated after class name
 -h,--help                    Show usage
 -in_memory                   Tries to keep the HFiles of the CF inmemory as far
                              as possible.  Not guaranteed that reads are always
                              served from inmemory
 -init_only                   Initialize the test table only, don't do any
                              loading
 -key_window &lt;arg&gt;            The 'key window' to maintain between reads and
                              writes for concurrent write/read workload. The
                              default is 0.
 -max_read_errors &lt;arg&gt;       The maximum number of read errors to tolerate
                              before terminating all reader threads. The default
                              is 10.
 -multiput                    Whether to use multi-puts as opposed to separate
                              puts for every column in a row
 -num_keys &lt;arg&gt;              The number of keys to read/write
 -num_tables &lt;arg&gt;            A positive integer number. When a number n is
                              speicfied, load test tool  will load n table
                              parallely. -tn parameter value becomes table name
                              prefix. Each table name is in format
                              &lt;tn&gt;_1...&lt;tn&gt;_n
 -read &lt;arg&gt;                  &lt;verify_percent&gt;[:&lt;#threads=20&gt;]
 -regions_per_server &lt;arg&gt;    A positive integer number. When a number n is
                              specified, load test tool will create the test
                              table with n regions per server
 -skip_init                   Skip the initialization; assume test table already
                              exists
 -start_key &lt;arg&gt;             The first key to read/write (a 0-based index). The
                              default value is 0.
 -tn &lt;arg&gt;                    The name of the table to read or write
 -update &lt;arg&gt;                &lt;update_percent&gt;[:&lt;#threads=20&gt;][:&lt;#whether to
                              ignore nonce collisions=0&gt;]
 -write &lt;arg&gt;                 &lt;avg_cols_per_key&gt;:&lt;avg_data_size&gt;[:&lt;#threads=20&gt;]
 -zk &lt;arg&gt;                    ZK quorum as comma-separated host names without
                              port numbers
 -zk_root &lt;arg&gt;               name of parent znode in zookeeper 
</code></pre>
<p>LoadTestTool 的示例用法</p>
<pre><code>$ hbase org.apache.hadoop.hbase.util.LoadTestTool -write 1:10:100 -num_keys 1000000
          -read 100:30 -num_tables 1 -data_block_encoding NONE -tn load_test_tool_NONE 
</code></pre>
<h3 id="d4启用数据块编码">D.4。启用数据块编码</h3>
<p>编解码器内置于 HBase 中，因此无需额外配置。通过设置<code>DATA_BLOCK_ENCODING</code>属性在表上启用编解码器。在更改其 DATA_BLOCK_ENCODING 设置之前禁用该表。以下是使用 HBase Shell 的示例：</p>
<p>在表上启用数据块编码</p>
<pre><code>hbase&gt;  disable 'test'
hbase&gt; alter 'test', { NAME =&gt; 'cf', DATA_BLOCK_ENCODING =&gt; 'FAST_DIFF' }
Updating all regions with the new schema...
0/1 regions updated.
1/1 regions updated.
Done.
0 row(s) in 2.2820 seconds
hbase&gt; enable 'test'
0 row(s) in 0.1580 seconds 
</code></pre>
<p>验证 ColumnFamily 的数据块编码</p>
<pre><code>hbase&gt; describe 'test'
DESCRIPTION                                          ENABLED
 'test', {NAME =&gt; 'cf', DATA_BLOCK_ENCODING =&gt; 'FAST true
 _DIFF', BLOOMFILTER =&gt; 'ROW', REPLICATION_SCOPE =&gt;
 '0', VERSIONS =&gt; '1', COMPRESSION =&gt; 'GZ', MIN_VERS
 IONS =&gt; '0', TTL =&gt; 'FOREVER', KEEP_DELETED_CELLS =
 &gt; 'false', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'fals
 e', BLOCKCACHE =&gt; 'true'}
1 row(s) in 0.0650 seconds 
</code></pre>
<h2 id="附录-esql-over-hbase">附录 E：SQL over HBase</h2>
<p>以下项目为 SQL over HBase 提供了一些支持。</p>
<h3 id="e1-apache-phoenix">E.1。 Apache Phoenix</h3>
<p><a href="https://phoenix.apache.org">Apache Phoenix</a></p>
<h3 id="e2-trafodion">E.2。 Trafodion</h3>
<p><a href="https://trafodion.incubator.apache.org/">Trafodion：事务性 SQL-on-HBase</a></p>
<h2 id="附录-fycsb">附录 F：YCSB</h2>
<p><a href="https://github.com/brianfrankcooper/YCSB/">YCSB：雅虎！云服务基准测试</a>和 HBase</p>
<p>TODO：描述 YCSB 如何通过提供合适的集群负载而变穷。</p>
<p>TODO：描述 YCSB for HBase 的设置。特别是，在开始运行之前预先对你的表进行预分解。请参阅 <a href="https://issues.apache.org/jira/browse/HBASE-4163">HBASE-4163 为 YCSB 基准创建拆分策略</a>了解为什么以及如何执行此操作的一些 shell 命令。</p>
<p>Ted Dunning 重新编写了 YCSB，因此它已经进行了专业化，并添加了用于验证工作负载的工具。见 <a href="https://github.com/tdunning/YCSB">Ted Dunning 的 YCSB</a> 。</p>
<h2 id="附录-ghfile-格式">附录 G：HFile 格式</h2>
<p>本附录描述了 HFile 格式的演变。</p>
<h3 id="g1-hbase-文件格式版本-1">G.1。 HBase 文件格式（版本 1）</h3>
<p>由于我们将讨论对 HFile 格式的更改，因此简要概述原始（HFile 版本 1）格式。</p>
<h4 id="g11版本-1-概述">G.1.1。版本 1 概述</h4>
<p>版本 1 格式的 HFile 结构如下：</p>
<p><a href="https://img.cntofu.com/book/hbase-doc-zh/docs/img/e96f9080ab2dd672c557134f21cec3b2.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/hbase-doc-zh/docs/img/e96f9080ab2dd672c557134f21cec3b2.jpg" alt="HFile Version 1"></a>图 21. HFile V1 格式</p>
<h4 id="g12版本-1-中的块索引格式">G.1.2。版本 1 中的块索引格式</h4>
<p>版本 1 中的块索引非常简单。对于每个条目，它包含：</p>
<ol>
<li> <p>偏移（长）</p> </li>
<li> <p>未压缩的大小（int）</p> </li>
<li> <p>键（使用 Bytes.writeByteArray 编写的序列化字节数组）</p>
<ol>
<li> <p>密钥长度为可变长度整数（VInt）</p> </li>
<li> <p>关键字节</p> </li>
</ol> </li>
</ol>
<p>块索引中的条目数存储在固定文件尾部中，并且必须传递给读取块索引的方法。版本 1 中块索引的一个限制是它不提供块的压缩大小，这对于解压缩来说是必要的。因此，HFile 读取器必须从块之间的偏移差异推断出该压缩大小。我们在版本 2 中修复了这个限制，我们存储了磁盘块大小而不是未压缩的大小，并从块头获得未压缩的大小。</p>
<h3 id="g2带内联块的-hbase-文件格式版本-2">G.2。带内联块的 HBase 文件格式（版本 2）</h3>
<p>注意：此功能是在 HBase 0.92 中引入的</p>
<h4 id="g21动机">G.2.1。动机</h4>
<p>我们发现有必要在遇到高内存使用率和由区域服务器中的大 Bloom 过滤器和块索引引起的慢启动时间后修改 HFile 格式。 Bloom 过滤器每个 HFile 可以达到 100 MB，在 20 个区域聚合时可以增加 2 GB。在同一组区域中，块索引的总大小可以增加到 6 GB。在加载所有块索引数据之前，不会将区域视为已打开。 Large Bloom 过滤器会产生不同的性能问题：第一个需要 Bloom 过滤器查找的 get 请求将导致加载整个 Bloom 过滤器位阵列的延迟。</p>
<p>为了加速区域服务器启动，我们打破 Bloom 过滤器并将索引阻塞到多个块中，并在它们填满时写出这些块，这也减少了 HFile writer 的内存占用。在 Bloom 过滤器的情况下，“填充块”意味着累积足够的密钥以有效地利用固定大小的位阵列，并且在块索引的情况下，我们累积所需大小的“索引块”。布隆过滤器块和索引块（我们称之为“内联块”）散布在数据块中，作为副作用，我们不再依赖块偏移之间的差异来确定数据块长度，就像在版本 1 中完成的那样。</p>
<p>HFile 是一种低级文件格式，它不应该处理特定于应用程序的细节，例如在 StoreFile 级别处理的 Bloom 过滤器。因此，我们在 HFile“内联”块中调用 Bloom 过滤器块。我们还为 HFile 提供了一个用于编写这些内联块的接口。</p>
<p>旨在减少区域服务器启动时间的另一种格式修改是使用连续的“加载打开”部分，该部分必须在打开 HFile 时加载到存储器中。目前，当 HFile 打开时，会有单独的搜索操作来读取预告片，数据/元索引和文件信息。要读取布隆过滤器，对其“数据”和“元”部分还有两个搜索操作。在版本 2 中，我们寻求一次阅读预告片并再次寻找从连续块中打开文件所需的其他内容。</p>
<h4 id="g22版本-2-概述">G.2.2。版本 2 概述</h4>
<p>引入上述功能的 HBase 版本同时读取版本 1 和 2 HFiles，但仅写入版本 2 HFiles。版本 2 HFile 的结构如下：</p>
<p><a href="https://img.cntofu.com/book/hbase-doc-zh/docs/img/237a6f0fd380aa5fdbc8dc30fe58ee74.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/hbase-doc-zh/docs/img/237a6f0fd380aa5fdbc8dc30fe58ee74.jpg" alt="HFile Version 2"></a>图 22. HFile 版本 2 结构</p>
<h4 id="g23统一版本-2-块格式">G.2.3。统一版本 2 块格式</h4>
<p>在版本 2 中，数据部分中的每个块都包含以下字段：</p>
<ol>
<li> <p>8 字节：块类型，相当于版本 1 的“魔术记录”的字节序列。支持的块类型是：</p>
<ol>
<li> <p>数据 - 数据块</p> </li>
<li> <p>LEAF_INDEX - 多级块索引中的叶级索引块</p> </li>
<li> <p>BLOOM_CHUNK - Bloom 过滤器块</p> </li>
<li> <p>META - 元块（不再用于版本 2 中的 Bloom 过滤器）</p> </li>
<li> <p>INTERMEDIATE_INDEX - 多级块索引中的中间级索引块</p> </li>
<li> <p>ROOT_INDEX - 多级块索引中的根级索引块</p> </li>
<li> <p>FILE_INFO - “文件信息”块，元数据的小键值映射</p> </li>
<li> <p>BLOOM_META - 加载时打开部分中​​的 Bloom 过滤器元数据块</p> </li>
<li> <p>TRAILER - 固定大小的文件预告片。与上述相反，这不是 HFile v2 块，而是固定大小（对于每个 HFile 版本）数据结构</p> </li>
<li> <p>INDEX_V1 - 此块类型仅用于传统的 HFile v1 块</p> </li>
</ol> </li>
<li> <p>块数据的压缩大小，不包括头（int）。</p> <p>扫描 HFile 数据时可用于跳过当前数据块。</p> </li>
<li> <p>块的数据未压缩大小，不包括头（int）</p> <p>如果压缩算法为 NONE，则等于压缩大小</p> </li>
<li> <p>相同类型的前一个块的文件偏移量（长）</p> <p>可用于寻找以前的数据/索引块</p> </li>
<li> <p>压缩数据（如果压缩算法为 NONE，则为未压缩数据）。</p> </li>
</ol>
<p>以上格式的块用于以下 HFile 部分：</p>
<p>扫描块部分</p>
<p>该部分之所以如此命名是因为它包含了顺序扫描 HFile 时需要读取的所有数据块。还包含 Leaf 索引块和 Bloom 块块。</p>
<p>非扫描块部分</p>
<p>此部分仍包含统一格式的 v2 块，但在执行顺序扫描时不必读取它。本节包含“元”块和中级索引块。</p>
<p>我们在版本 2 中支持“meta”块的方式与版本 1 中支持的方式相同，即使我们不再将 Bloom 过滤器数据存储在这些块中。</p>
<h4 id="g24阻止版本-2-中的索引">G.2.4。阻止版本 2 中的索引</h4>
<p>HFile 版本 2 中有三种类型的块索引，以两种不同的格式（root 和 non-root）存储：</p>
<ol>
<li> <p>数据索引 - 版本 2 多级块索引，包括：</p>
<ol>
<li> <p>版本 2 根索引，存储在文件的数据块索引部分</p> </li>
<li> <p>（可选）版本 2 中间级别，以非根格式存储在文件的数据索引部分中。如果存在叶级块，则只能存在中间级别</p> </li>
<li> <p>（可选）版本 2 叶级别，以非根格式存储，与数据块内联</p> </li>
</ol> </li>
<li> <p>元索引 - 仅版本 2 根索引格式，存储在文件的元索引部分中</p> </li>
<li> <p>Bloom 索引 - 仅版本 2 根索引格式，作为 Bloom 过滤器元数据的一部分存储在''load-on-open'部分中。</p> </li>
</ol>
<h4 id="g25版本-2-中的根块索引格式">G.2.5。版本 2 中的根块索引格式</h4>
<p>此格式适用于：</p>
<ol>
<li> <p>版本 2 数据索引的根级别</p> </li>
<li> <p>版本 2 中的整个 meta 和 Bloom 索引始终是单级的。</p> </li>
</ol>
<p>版本 2 根索引块是以下格式的条目序列，类似于版本 1 块索引的条目，但存储磁盘大小而不是未压缩大小。</p>
<ol>
<li> <p>Offset (long)</p> <p>该偏移可以指向数据块或更深层索引块。</p> </li>
<li> <p>磁盘大小（int）</p> </li>
<li> <p>键（使用 Bytes.writeByteArray 存储的序列化字节数组）</p> </li>
<li> <p>钥匙（VInt）</p> </li>
<li> <p>Key bytes</p> </li>
</ol>
<p>单级版本 2 块索引仅包含单个根索引块。要读取版本 2 的根索引块，需要知道条目数。对于数据索引和元索引，条目数存储在预告片中，对于 Bloom 索引，它存储在复合布隆过滤器元数据中。</p>
<p>对于多级块索引，除了上面描述的数据结构之外，我们还将以下字段存储在 HFile 的 load-on-open 部分的根索引块中：</p>
<ol>
<li> <p>中叶索引块偏移</p> </li>
<li> <p>中间叶块磁盘大小（表示包含对文件“中间”数据块的引用的叶索引块）</p> </li>
<li> <p>中间叶级块中的中间键（在下面定义）的索引。</p> </li>
</ol>
<p>这些附加字段用于有效地检索 HFile 分裂中使用的 HFile 的中间密钥，我们将其定义为具有零基索引（n-1）/ 2 的块的第一个密钥，如果总数为 HFile 中的块是 n。此定义与 HFile 版本 1 中确定中间密钥的方式一致，并且通常是合理的，因为块的平均大小可能相同，但我们没有对单个键/值对大小的任何估计。</p>
<p>在编写版本 2 HFile 时，每个叶级索引块指向的数据块总数将被跟踪。当我们完成写入并确定叶级块的总数时，很清楚哪个叶级块包含中键，并且计算上面列出的字段。当读取 HFile 并请求中键时，我们检索中间叶索引块（可能来自块缓存）并从该叶块内的适当位置获取中键值。</p>
<h4 id="g26版本-2-中的非-root-块索引格式">G.2.6。版本 2 中的非 root 块索引格式</h4>
<p>此格式适用于版本 2 多级数据块索引的中间级别和叶索引块。每个非根索引块的结构如下。</p>
<ol>
<li> <p>numEntries：条目数（int）。</p> </li>
<li> <p>entryOffsets：块中条目偏移的“二级索引”，便于快速二进制搜索键（<code>numEntries + 1</code> int 值）。最后一个值是此索引块中所有条目的总长度。例如，在条目大小为 60,80,50 的非根索引块中，“二级索引”将包含以下 int 数组：<code>{0, 60, 140, 190}</code>。</p> </li>
<li> <p>参赛作品。每个条目包含：</p>
<ol>
<li> <p>文件中此条目引用的块的偏移量（长整数）</p> </li>
<li> <p>引用块的磁盘大小（int）</p> </li>
<li> <p>键。长度可以从 entryOffsets 计算。</p> </li>
</ol> </li>
</ol>
<h4 id="g27版本-2-中的-bloom-过滤器">G.2.7。版本 2 中的 Bloom 过滤器</h4>
<p>与版本 1 相比，在版本 2 中，HFile Bloom 过滤器元数据存储在 HFile 的 open-on-open 部分中，以便快速启动。</p>
<ol>
<li> <p>复合布隆过滤器。</p> </li>
<li> <p>Bloom 过滤器版本= 3（int）。曾经有一个 DynamicByteBloomFilter 类，其 Bloom 过滤器版本号为 2</p> </li>
<li> <p>所有复合 Bloom 过滤器块的总字节大小（长）</p> </li>
<li> <p>散列函数数（int）</p> </li>
<li> <p>哈希函数的类型（int）</p> </li>
<li> <p>插入 Bloom 过滤器的总密钥数（长）</p> </li>
<li> <p>布隆过滤器中的最大键数（长）</p> </li>
<li> <p>块数（int）</p> </li>
<li> <p>用于 Bloom 过滤器键的比较器类，使用 Bytes.writeByteArray 存储的 UTF＆gt; 8 编码字符串</p> </li>
<li> <p>版本 2 根块索引格式中的 Bloom 块索引</p> </li>
</ol>
<h4 id="g28版本-1-和-2-中的文件信息格式">G.2.8。版本 1 和 2 中的文件信息格式</h4>
<p>文件信息块是从字节数组到字节数组的序列化映射，包括以下键。 StoreFile 级逻辑为此添加了更多密钥。</p>
<p>| hfile.LASTKEY |文件的最后一个键（字节数组）| | hfile.AVG_KEY_LEN |文件中的平均密钥长度（int）| | hfile.AVG_VALUE_LEN |文件（int）|中的平均值长度</p>
<p>在版本 2 中，我们没有更改文件格式，但是我们将文件信息移动到文件的最后一部分，可以在打开 HFile 时将其作为一个块加载。</p>
<p>此外，我们不再将比较器存储在版本 2 文件信息中。相反，我们将其存储在固定文件预告片中。这是因为我们需要在解析 HFile 的 open-on-open 部分时知道比较器。</p>
<h4 id="g29修复了版本-1-和版本-2-之间的文件尾部格式差异">G.2.9。修复了版本 1 和版本 2 之间的文件尾部格式差异</h4>
<p>下表显示了版本 1 和版本 2 中固定文件预告片之间的常见字段和不同字段。请注意，预告片的大小因版本而异，因此仅在一个版本中“固定”。但是，版本始终存储为文件中的最后四个字节整数。</p>
<table>
<thead>
<tr>
<th>版本 1</th>
<th>版本 2</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>文件信息偏移（长）</td>
</tr>
<tr>
<td>数据索引偏移量（长）</td>
<td>loadOnOpenOffset（long）/打开文件时需要加载的部分的偏移量./</td>
</tr>
<tr>
<td></td>
<td>数据索引条目数（int）</td>
</tr>
<tr>
<td>metaIndexOffset（long）/版本 1 读者不使用此字段，因此我们将其从版本 2 中删除。</td>
<td>uncompressedDataIndexSize（long）/整个数据块索引的未压缩总大小，包括根级别，中级别和叶级别块./</td>
</tr>
<tr>
<td></td>
<td>元索引条目数（int）</td>
</tr>
<tr>
<td></td>
<td>未压缩字节总数（长）</td>
</tr>
<tr>
<td>numEntries（int）</td>
<td>numEntries（长）</td>
</tr>
<tr>
<td>压缩编解码器：0 = LZO，1 = GZ，2 = NONE（int）</td>
<td>Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int)</td>
</tr>
<tr>
<td></td>
<td>数据块索引中的级别数（int）</td>
</tr>
<tr>
<td></td>
<td>firstDataBlockOffset（long）/第一个数据块的偏移量。扫描时使用./</td>
</tr>
<tr>
<td></td>
<td>lastDataBlockEnd（long）/最后一个键/值数据块之后的第一个字节的偏移量。扫描时我们不需要超出此偏移量./</td>
</tr>
<tr>
<td>版本：1（int）</td>
<td>版本：2（int）</td>
</tr>
</tbody>
</table>
<h4 id="g210-getshortmidpointkey数据索引块的优化">G.2.10。 getShortMidpointKey（数据索引块的优化）</h4>
<p>注意：此优化是在 HBase 0.95+中引入的</p>
<p>HFiles 包含许多包含一系列已排序单元格的块。每个单元都有一个键。为了在读取 Cells 时保存 IO，HFile 还有一个索引，它将 Cell 的开始键映射到特定块开头的偏移量。在此优化之前，HBase 将使用每个数据块中第一个单元的键作为索引键。</p>
<p>在 HBASE-7845 中，我们生成一个新的键，其按字典顺序大于前一个块的最后一个键，并按字典顺序等于或小于当前块的起始键。虽然实际的密钥可能很长，但这个“假密钥”或“虚拟密钥”可以短得多。例如，如果前一个块的停止键是“快速棕色狐狸”，则当前块的开始键是“谁”，我们可以在我们的 hfile 索引中使用“r”作为我们的虚拟键。</p>
<p>这有两个好处：</p>
<ul>
<li> <p>拥有较短的密钥会减少 hfile 索引的大小，（允许我们在内存中保留更多的索引），以及</p> </li>
<li> <p>当目标密钥位于“虚拟密钥”和目标块中第一个元素的密钥之间时，使用更靠近前一个块的结束键的东西允许我们避免可能的额外 IO。</p> </li>
</ul>
<p>此优化（由 getShortMidpointKey 方法实现）的灵感来自 LevelDB 的 ByteWiseComparatorImpl :: FindShortestSeparator（）和 FindShortSuccessor（）。</p>
<h3 id="g3具有安全增强功能的-hbase-文件格式版本-3">G.3。具有安全增强功能的 HBase 文件格式（版本 3）</h3>
<p>注意：此功能是在 HBase 0.98 中引入的</p>
<h4 id="g31动机">G.3.1。动机</h4>
<p>HFile 的第 3 版进行了更改，以简化静态加密和单元级元数据的加密管理（这又是单元级 ACL 和单元级可见性标签所必需的）。有关更多信息，请参阅 <a href="#hbase.encryption.server">hbase.encryption.server</a> ， <a href="#hbase.tags">hbase.tags</a> ， <a href="#hbase.accesscontrol.configuration">hbase.accesscontrol.configuration</a> 和 <a href="#hbase.visibility.labels">hbase.visibility.labels</a> 。</p>
<h4 id="g32概观">G.3.2。概观</h4>
<p>引入上述功能的 HBase 版本在版本 1,2 和 3 中读取 HFile，但仅写入版本 3 HFile。版本 3 HFile 的结构与版本 2 HFile 相同。有关更多信息，请参阅 <a href="#hfilev2.overview">hfilev2.overview</a> 。</p>
<h4 id="g33版本-3-中的文件信息块">G.3.3。版本 3 中的文件信息块</h4>
<p>版本 3 将另外两条信息添加到文件信息块中的保留键。</p>
<p>| hfile.MAX_TAGS_LEN |存储此 hfile（int）中任何单个单元格的序列化标记所需的最大字节数| hfile.TAGS_COMPRESSED |该 hfile 的块编码器是否压缩标签？ （布尔）。仅当 hfile.MAX_TAGS_LEN 也存在时才应存在。 |</p>
<p>在读取版本 3 HFile 时，<code>MAX_TAGS_LEN</code>的存在用于确定如何对数据块内的单元进行反序列化。因此，消费者必须在读取任何数据块之前读取文件的信息块。</p>
<p>在编写版本 3 HFile 时，HBase 在将 memstore 刷新到底层文件系统时将始终包含[​​COD0]。</p>
<p>压缩现有文件时，如果所选的所有文件本身不包含任何带标记的单元格，则默认编写器将省略<code>MAX_TAGS_LEN</code>。</p>
<p>有关压缩文件选择算法的详细信息，请参见<a href="#compaction">压缩</a>。</p>
<h4 id="g34版本-3-中的数据块">G.3.4。版本 3 中的数据块</h4>
<p>内的 HFILE，HBase 的细胞被存储在数据块作为键值来的序列（见 <a href="#hfilev1.overview">hfilev1.overview</a> 或<a href="http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html">拉斯乔治的很好的介绍 HBase 的寄存</a>）。在版本 3 中，这些 KeyValue 可选地包含一组 0 个或更多标记：</p>
<table>
<thead>
<tr>
<th>版本 1＆amp; 2，版本 3 没有 MAX_TAGS_LEN</th>
<th>版本 3，MAX_TAGS_LEN</th>
</tr>
</thead>
<tbody>
<tr>
<td>密钥长度（4 个字节）</td>
</tr>
<tr>
<td>值长度（4 个字节）</td>
</tr>
<tr>
<td>关键字节（变量）</td>
</tr>
<tr>
<td>值字节（变量）</td>
</tr>
<tr>
<td></td>
<td>标签长度（2 个字节）</td>
</tr>
<tr>
<td></td>
<td>标签字节（变量）</td>
</tr>
</tbody>
</table>
<p>如果给定 HFile 的 info 块包含<code>MAX_TAGS_LEN</code>的条目，则每个单元格将包含该单元格标签的长度，即使该长度为零。实际标签存储为标签长度（2 个字节），标签类型（1 个字节），标签字节（变量）的序列。单个标记的字节格式取决于标记类型。</p>
<p>请注意，对 info 块内容的依赖意味着在读取任何数据块之前，必须首先处理文件的 info 块。它还意味着在写入数据块之前，您必须知道文件的信息块是否包含<code>MAX_TAGS_LEN</code>。</p>
<h4 id="g35修复了版本-3-中的文件预告片">G.3.5。修复了版本 3 中的文件预告片</h4>
<p>使用 HFile 版本 3 编写的固定文件预告片始终使用协议缓冲区进行序列化。此外，它还为名为 encryption_key 的版本 2 协议缓冲区添加了一个可选字段。如果 HBase 配置为加密 HFile，则此字段将存储此特定 HFile 的数据加密密钥，使用 AES 使用当前群集主密钥加密。有关更多信息，请参阅 <a href="#hbase.encryption.server">hbase.encryption.server</a> 。</p>
<h2 id="附录-h关于-hbase-的其他信息">附录 H：关于 HBase 的其他信息</h2>
<h3 id="h1-hbase-视频">H.1。 HBase 视频</h3>
<p>HBase 简介</p>
<ul>
<li> <p><a href="https://vimeo.com/23400732">Todd Lipcon 介绍 HBase</a> （2011 年芝加哥数据峰会）。</p> </li>
<li> <p><a href="https://vimeo.com/26804675">使用 HBase</a> 在 Facebook 上建立实时服务作者：Jonathan Gray（柏林流行语 2011）</p> </li>
<li> <p><a href="http://www.cloudera.com/videos/hw10_video_how_stumbleupon_built_and_advertising_platform_using_hbase_and_hadoop">Jean-Daniel Cryans 的 HBase</a> 的多重用途（柏林流行语 2011）。</p> </li>
</ul>
<h3 id="h2-hbase-演示文稿幻灯片">H.2。 HBase 演示文稿（幻灯片）</h3>
<p><a href="https://www.slideshare.net/cloudera/hadoop-world-2011-advanced-hbase-schema-design-lars-george-cloudera">高级 HBase 架构设计</a>作者：Lars George（Hadoop World 2011）。</p>
<p><a href="http://www.slideshare.net/cloudera/chicago-data-summit-apache-hbase-an-introduction">Todd Lipcon 介绍 HBase</a> （2011 年芝加哥数据峰会）。</p>
<p><a href="http://www.slideshare.net/cloudera/hw09-practical-h-base-getting-the-most-from-your-h-base-install">通过 Ryan Rawson，Jonathan Gray（Hadoop World 2009）从 HBase 安装</a>中获得最大收益。</p>
<h3 id="h3-hbase-论文">H.3。 HBase 论文</h3>
<p><a href="http://research.google.com/archive/bigtable.html">BigTable</a> 由谷歌（2006）。</p>
<p><a href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html">HBase 和 HDFS Locality</a> 作者：Lars George（2010）。</p>
<p><a href="http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf">无关系：非关系型数据库的混合祝福</a>，Ian Varley（2009）。</p>
<h3 id="h4-hbase-网站">H.4。 HBase 网站</h3>
<p><a href="https://blog.cloudera.com/blog/category/hbase/">Cloudera 的 HBase 博客</a>有很多链接到有用的 HBase 信息。</p>
<p><a href="https://blog.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/">CAP Confusion</a> 是分布式存储系统背景信息的相关条目。</p>
<p>来自 DZone 的 <a href="http://refcardz.dzone.com/refcardz/hbase">HBase RefCard</a> 。</p>
<h3 id="h5-hbase-书籍">H.5。 HBase 书籍</h3>
<p><a href="http://shop.oreilly.com/product/0636920014348.do">HBase：Lars George 的权威指南</a>。</p>
<h3 id="h6-hadoop-书籍">H.6。 Hadoop 书籍</h3>
<p><a href="http://shop.oreilly.com/product/9780596521981.do">Hadoop：Tom White 的权威指南</a>。</p>
<h2 id="附录-ihbase-历史">附录 I：HBase 历史</h2>
<ul>
<li> <p>2006 年： <a href="http://research.google.com/archive/bigtable.html">BigTable</a> 论文由 Google 发布。</p> </li>
<li> <p>2006 年（年底）：HBase 开发。</p> </li>
<li> <p>2008 年：HBase 成为 Hadoop 子项目。</p> </li>
<li> <p>2010 年：HBase 成为 Apache 顶级项目。</p> </li>
</ul>
<h2 id="附录-jhbase-和-apache-软件基金会">附录 J：HBase 和 Apache 软件基金会</h2>
<p>HBase 是 Apache Software Foundation 中的一个项目，因此 ASF 有责任确保项目健康。</p>
<h3 id="j1-asf-开发流程">J.1。 ASF 开发流程</h3>
<p>有关 ASF 结构的各种信息（例如，PMC，提交者，贡献者），有关贡献和参与的提示以及开源在 ASF 中的工作原理，请参见 <a href="https://www.apache.org/dev/#committers">Apache 开发流程页面</a>。</p>
<h3 id="j2-asf-董事会报告">J.2。 ASF 董事会报告</h3>
<p>每季度一次，ASF 投资组合中的每个项目都会向 ASF 董事会提交报告。这是由 HBase 项目负责人和提交者完成的。有关详细信息，请参阅 <a href="https://www.apache.org/foundation/board/reporting">ASF 板报告</a>。</p>
<h2 id="附录-kapache-hbase-orca">附录 K：Apache HBase Orca</h2>
<p><a href="https://img.cntofu.com/book/hbase-doc-zh/docs/img/7cc0026a6a9851c1d14acb215e146d7c.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/hbase-doc-zh/docs/img/7cc0026a6a9851c1d14acb215e146d7c.jpg" alt="jumping orca rotated 25percent"></a>图 23. Apache HBase Orca，HBase 颜色，＆amp;字形</p>
<p><a href="https://issues.apache.org/jira/browse/HBASE-4920">Orca 是 Apache HBase 的吉祥物。</a> 见 NOTICES.txt。我们在这里得到的 Orca 徽标： <a href="http://www.vectorfree.com/jumping-orca">http://www.vectorfree.com/jumping-orca</a> 它是 Creative Commons Attribution 3.0 的许可。参见 <a href="https://creativecommons.org/licenses/by/3.0/us/">https://creativecommons.org/licenses/by/3.0/us/</a> 我们通过剥离彩色背景，反转它然后旋转一些来改变徽标。</p>
<p>“官方”HBase 颜色是“国际橙色（工程）”，旧金山<a href="https://en.wikipedia.org/wiki/International_orange">金门大桥</a>的颜色和 NASA 使用的太空服。</p>
<p>我们的'字体'是 <a href="http://www.dafont.com/bitsumishi.font">Bitsumishi</a> 。</p>
<h2 id="附录-l在-hbase-中启用类似-dapper-的跟踪">附录 L：在 HBase 中启用类似 Dapper 的跟踪</h2>
<p>HBase 包括使用开源跟踪库 <a href="https://htrace.incubator.apache.org/">Apache HTrace</a> 跟踪请求的工具。设置跟踪非常简单，但是它目前需要对客户端代码进行一些非常小的更改（将来可能会删除此要求）。</p>
<p>在 <a href="https://issues.apache.org/jira/browse/HBASE-6449">HBASE-6449</a> 中添加了在 HBase 中使用 HTrace 3 支持此功能。从 HBase 2.0 开始，通过 <a href="https://issues.apache.org/jira/browse/HBASE-18601">HBASE-18601</a> 对 HTrace 4 进行了不兼容的更新。本节提供的示例将使用 HTrace 4 包名称，语法和约定。有关较旧的示例，请参阅本指南的早期版本。</p>
<h3 id="l1-spanreceivers">L.1。 SpanReceivers</h3>
<p>跟踪系统通过在称为“Spans”的结构中收集信息来工作。您可以通过实现<code>SpanReceiver</code>接口来选择接收此信息的方式，该接口定义了一种方法：</p>
<pre><code>public void receiveSpan(Span span); 
</code></pre>
<p>每当跨度完成时，此方法用作回调。 HTrace 允许您根据需要使用尽可能多的 SpanReceivers，因此您可以轻松地将跟踪信息发送到多个目的地。</p>
<p>通过在 <em>hbase-site.xml</em> 属性中实现<code>SpanReceiver</code>的类的完全限定类名称的逗号分隔列表来配置您希望我们使用的 SpanReceivers：<code>hbase.trace.spanreceiver.classes</code>。</p>
<p>HTrace 包含<code>LocalFileSpanReceiver</code>，它以基于 JSON 的格式将所有跨度信息写入本地文件。 <code>LocalFileSpanReceiver</code>在 <em>hbase-site.xml</em> 中查找<code>hbase.local-file-span-receiver.path</code>属性，其值描述节点应写入其跨度信息的文件的名称。</p>
<pre><code>&lt;property&gt;
  &lt;name&gt;hbase.trace.spanreceiver.classes&lt;/name&gt;
  &lt;value&gt;org.apache.htrace.core.LocalFileSpanReceiver&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.htrace.local-file-span-receiver.path&lt;/name&gt;
  &lt;value&gt;/var/log/hbase/htrace.out&lt;/value&gt;
&lt;/property&gt; 
</code></pre>
<p>HTrace 还提供<code>ZipkinSpanReceiver</code>，它将跨度转换为 <a href="http://github.com/twitter/zipkin">Zipkin</a> span 格式并将它们发送到 Zipkin 服务器。要使用此 span 接收器，您需要将 htrace-zipkin jar 安装到群集中所有节点上的 HBase 类路径中。</p>
<p><em>htrace-zipkin</em> 发布到 <a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.htrace%22 AND a%3A%22htrace-zipkin%22">Maven 中央存储库</a>。您可以从那里获得最新版本或只是在本地构建它（请参阅 <a href="https://htrace.incubator.apache.org/">HTrace</a> 主页以获取有关如何执行此操作的信息），然后将其复制到所有节点。</p>
<p><code>ZipkinSpanReceiver</code>用于 <em>hbase-site.xml</em> 中名为<code>hbase.htrace.zipkin.collector-hostname</code>和<code>hbase.htrace.zipkin.collector-port</code>的属性，其值描述了发送范围信息的 Zipkin 收集器服务器。</p>
<pre><code>&lt;property&gt;
  &lt;name&gt;hbase.trace.spanreceiver.classes&lt;/name&gt;
  &lt;value&gt;org.apache.htrace.core.ZipkinSpanReceiver&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.htrace.zipkin.collector-hostname&lt;/name&gt;
  &lt;value&gt;localhost&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.htrace.zipkin.collector-port&lt;/name&gt;
  &lt;value&gt;9410&lt;/value&gt;
&lt;/property&gt; 
</code></pre>
<p>如果您不想使用附带的跨接收发器，建议您编写自己的接收器（以<code>LocalFileSpanReceiver</code>为例）。如果您认为其他人会从您的接收器中受益，请向 HTrace 项目提交 JIRA。</p>
<h2 id="201客户修改">201.客户修改</h2>
<p>为了在客户端代码中启用跟踪，您必须初始化每个客户端进程一次向接收器发送跨度的模块。</p>
<pre><code>private SpanReceiverHost spanReceiverHost;

...

  Configuration conf = HBaseConfiguration.create();
  SpanReceiverHost spanReceiverHost = SpanReceiverHost.getInstance(conf); 
</code></pre>
<p>然后，您只需在您认为有趣的请求之前开始跟踪跨度，并在请求完成时关闭它。例如，如果要跟踪所有获取操作，请更改此设置：</p>
<pre><code>Configuration config = HBaseConfiguration.create();
Connection connection = ConnectionFactory.createConnection(config);
Table table = connection.getTable(TableName.valueOf("t1"));
Get get = new Get(Bytes.toBytes("r1"));
Result res = table.get(get); 
</code></pre>
<p>成：</p>
<pre><code>TraceScope ts = Trace.startSpan("Gets", Sampler.ALWAYS);
try {
  Table table = connection.getTable(TableName.valueOf("t1"));
  Get get = new Get(Bytes.toBytes("r1"));
  Result res = table.get(get);
} finally {
  ts.close();
} 
</code></pre>
<p>如果你想跟踪一半的“获取”操作，你会传入：</p>
<pre><code>new ProbabilitySampler(0.5) 
</code></pre>
<p>代替<code>Sampler.ALWAYS</code>至<code>Trace.startSpan()</code>。有关采样器的更多信息，请参见 HTrace <em>README</em> 。</p>
<h2 id="202追踪-hbase-shell">202.追踪 HBase Shell</h2>
<p>您可以使用<code>trace</code>命令跟踪来自 HBase Shell 的请求。 <code>trace 'start'</code>命令打开跟踪，<code>trace 'stop'</code>命令关闭跟踪。</p>
<pre><code>hbase(main):001:0&gt; trace 'start'
hbase(main):002:0&gt; put 'test', 'row1', 'f:', 'val1'   # traced commands
hbase(main):003:0&gt; trace 'stop' 
</code></pre>
<p><code>trace 'start'</code>和<code>trace 'stop'</code>始终返回表示是否存在正在进行的跟踪的布尔值。结果，<code>trace 'stop'</code>成功返回 false。如果打开跟踪，<code>trace 'status'</code>只会返回。</p>
<pre><code>hbase(main):001:0&gt; trace 'start'
=&gt; true

hbase(main):002:0&gt; trace 'status'
=&gt; true

hbase(main):003:0&gt; trace 'stop'
=&gt; false

hbase(main):004:0&gt; trace 'status'
=&gt; false 
</code></pre>
<h2 id="附录-m095-rpc-规范">附录 M：0.95 RPC 规范</h2>
<p>在 0.95 中，所有客户端/服务器通信都是使用 <a href="https://developers.google.com/protocol-buffers/">protobuf'ed</a> 消息而不是 <a href="https://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html">Hadoop Writables</a> 完成的。因此我们的 RPC 线格式会发生变化本文档描述了客户端/服务器请求/响应协议以及我们新的 RPC 线路格式。</p>
<p>对于 0.94 及之前的 RPC，请参阅 Benoît/ Tsuna 的<a href="https://github.com/OpenTSDB/asynchbase/blob/master/src/HBaseRpc.java#L164">非官方 Hadoop / HBase RPC 协议文档</a>。有关我们如何达到此规范的更多背景信息，请参阅 <a href="https://docs.google.com/document/d/1WCKwgaLDqBw2vpux0jPsAu2WPTRISob7HGCO8YhfDTA/edit#">HBase RPC：WIP</a></p>
<h3 id="m1目标">M.1。目标</h3>
<ol>
<li> <p>我们可以发展一种线形式</p> </li>
<li> <p>一种格式，不需要我们的重写服务器核心或从根本上改变其当前架构（以后）。</p> </li>
</ol>
<h3 id="m2去做">M.2。去做</h3>
<ol>
<li> <p>当前指定格式的问题列表以及我们希望在版本 2 中的位置等。例如，如果要移动服务器异步或支持流/分块，我们必须更改什么？</p> </li>
<li> <p>关于它如何工作的图表</p> </li>
<li> <p>简洁地描述线格式的语法。目前我们有这些单词和 rpc protobuf idl 的内容，但来回的语法将有助于 groking rpc。此外，客户端/服务器上的一个小型状态机交互将有助于理解（并确保正确实现）。</p> </li>
</ol>
<h3 id="m3-rpc">M.3。 RPC</h3>
<p>客户端将发送有关连接建立的设置信息。此后，客户端调用针对远程服务器的方法发送 protobuf 消息并接收 protobuf 消息作为响应。沟通是同步的。所有来回前面都有一个 int，它具有请求/响应的总长度。可选地，Cells（KeyValues）可以在后续 Cell 块中的 protobufs 之外传递（因为<a href="https://docs.google.com/document/d/1WEtrq-JTIUhlnlnvA0oYRLp0F8MKpEBeBSCFcQiacdw/edit#">我们不能 protobuf 兆字节的 KeyValues</a> 或 Cells）。这些 CellBlock 被编码并可选地压缩。</p>
<p>有关所涉及的 protobufs 的更多详细信息，请参阅 master 中的 <a href="https://github.com/apache/hbase/blob/master/hbase-protocol/src/main/protobuf/RPC.proto">RPC.proto</a> 文件。</p>
<h4 id="m31连接设置">M.3.1。连接设置</h4>
<p>客户端启动连接。</p>
<h5 id="客户">客户</h5>
<p>在连接设置上，客户端发送前导码，后跟连接头。</p>
<preamble>
<pre><code>&lt;MAGIC 4 byte integer&gt; &lt;1 byte RPC Format Version&gt; &lt;1 byte auth type&gt; 
</code></pre>
<p>我们需要 auth 方法规范。这里，如果启用 auth，则编码连接头。</p>
<p>例如：HBas0x000x50 - 4 个字节的 MAGIC - “HBas” - 加上一个字节的版本，在这种情况下为 0，还有一个字节，0x50（SIMPLE）。一个身份验证类型。</p>
<protobuf connectionheader="" message="">
<p>有用户信息和``protocol''，以及客户端将使用发送 CellBlocks 的编码器和压缩。 CellBlock 编码器和压缩器用于连接的生命周期。 CellBlock 编码器实现 org.apache.hadoop.hbase.codec.Codec。然后也可以压缩 CellBlock。压缩器实现 org.apache.hadoop.io.compress.CompressionCodec。这个 protobuf 是使用 writeDelimited 编写的，所以它是以带有序列化长度的 pb varint 开头的</p>
<h5 id="服务器">服务器</h5>
<p>客户端发送前导码和连接头后，如果连接设置成功，服务器不响应。没有响应意味着服务器准备好接受请求并给出响应。如果前导中的版本或身份验证不合适或服务器在解析前导码时遇到问题，则会抛出 org.apache.hadoop.hbase.ipc.FatalConnectionException 来解释错误，然后断开连接。如果连接头中的客户端 - 即连接前导码后面的 protobuf'd 消息 - 要求服务器不支持服务器或服务器没有的编解码器，我们再次抛出 FatalConnectionException 并附带说明。</p>
<h4 id="m32请求">M.3.2。请求</h4>
<p>建立连接后，客户端发出请求。服务器响应。</p>
<p>请求由 protobuf RequestHeader 和 protobuf Message 参数组成。标头包括方法名称和可选的 CellBlock 上可能跟随的元数据。参数类型适合被调用的方法：即，如果我们正在执行 getRegionInfo 请求，则 protobuf Message param 将是 GetRegionInfoRequest 的实例。响应将是 GetRegionInfoResponse。 CellBlock 可选地用于传送大量 RPC 数据：即 Cells / KeyValues。</p>
<h5 id="索取零件">索取零件</h5>
<total length="">
<p>该请求以一个 int 开头，该 int 保存后面的总长度。</p>
<protobuf message="" requestheader="">
<p>将包含 call.id，trace.id 和方法名称等，包括 IFF 上的 Cell 块上的可选元数据。数据在此 pb 消息中是内联的，或者可选地包含在以下 CellBlock 中</p>
<protobuf message="" param="">
<p>如果调用的方法是 getRegionInfo，如果您研究客户端的服务描述符到 regionserver 协议，您会发现请求在此位置发送 GetRegionInfoRequest protobuf 消息参数。</p>
<cellblock>
<p>经编码且可选地压缩的 Cell 块。</p>
<h4 id="m33响应">M.3.3。响应</h4>
<p>与 Request 相同，它是一个 protobuf ResponseHeader，后跟一个 protobuf Message 响应，其中 Message 响应类型适合调用的方法。大量数据可能会出现在以下 CellBlock 中。</p>
<h5 id="响应部分">响应部分</h5>
<total length="">
<p>响应以一个 int 开头，该 int 保存了后面的总长度。</p>
<protobuf message="" responseheader="">
<p>将有 call.id 等。如果处理失败将包括异常。可选地包括关于可选的元数据，IFF 下面有一个 CellBlock。</p>
<protobuf message="" response="">
<p>如果例外，则返回或可能无效。如果调用的方法是 getRegionInfo，如果您研究客户端的服务描述符到 regionserver 协议，您会发现响应在此位置发送 GetRegionInfoResponse protobuf 消息参数。</p>
<cellblock>
<p>An encoded and optionally compressed Cell block.</p>
<h4 id="m34例外">M.3.4。例外</h4>
<p>有两种不同的类型。请求失败，它封装在响应的响应头内。连接保持打开状态以接收新请求。第二种类型 FatalConnectionException 会终止连接。</p>
<p>例外可以携带额外的信息。请参阅 ExceptionResponse protobuf 类型。它有一个标志，表示不重试以及其他杂项有效负载，以帮助提高客户响应能力。</p>
<h4 id="m35牢房">M.3.5。牢房</h4>
<p>这些都没有版本。服务器可以执行编解码器，也可以不执行。如果编解码器的新版本说更严格的编码，那么给它一个新的类名。编解码器将一直存在于服务器上，以便老客户端可以连接。</p>
<h3 id="m4笔记">M.4。笔记</h3>
<p>约束</p>
<p>在某些部分，当前的线路格式 - 即所有请求和响应前面都有一个长度 - 由当前的服务器非异步架构决定。</p>
<p>一个胖 pb 请求或标题+参数</p>
<p>我们用 pb 标题跟随 pb param 发出请求和 pb 标题然后是 pb 响应。执行 header + param 而不是一个包含 header 和 param 内容的 protobuf 消息：</p>
<ol>
<li> <p>更接近我们现在拥有的</p> </li>
<li> <p>有一个单一的脂肪 pb 需要额外的复制将已经 pb'd 的参数放入脂肪请求 pb 的主体（并且相同的结果）</p> </li>
<li> <p>在我们阅读参数之前，我们可以决定是否接受请求;例如，请求可能是低优先级。当然，我们一次性读取 header + param，因为服务器当前已实现，因此这是一个 TODO。</p> </li>
</ol>
<p>优点很小。如果以后，胖请求有明显的优势，以后可以推出 v2。</p>
<h4 id="m41-rpc-配置">M.4.1。 RPC 配置</h4>
<p>CellBlock 编解码器</p>
<p>要启用默认<code>KeyValueCodec</code>以外的编解码器，请将<code>hbase.client.rpc.codec</code>设置为要使用的 Codec 类的名称。编解码器必须实现 hbase 的<code>Codec</code>接口。连接建立后，所有传递的单元块将与此编解码器一起发送。只要编解码器在服务器的 CLASSPATH 上，服务器就会使用相同的编解码器返回单元块（否则你将获得<code>UnsupportedCellCodecException</code>）。</p>
<p>要更改默认编解码器，请设置<code>hbase.client.default.rpc.codec</code>。</p>
<p>要完全禁用单元块并转到纯 protobuf，请将默认值设置为空 String，并且不要在 Configuration 中指定编解码器。因此，将<code>hbase.client.default.rpc.codec</code>设置为空字符串，不要设置<code>hbase.client.rpc.codec</code>。这将导致客户端连接到没有指定编解码器的服务器。如果服务器没有看到编解码器，它将返回纯 protobuf 中的所有响应。一直运行纯 protobuf 比使用 cellblocks 运行要慢。</p>
<p>压缩</p>
<p>使用 hadoop 的压缩编解码器。要启用压缩传递的 CellBlock，请将<code>hbase.client.rpc.compressor</code>设置为要使用的 Compressor 的名称。 Compressor 必须实现 Hadoop 的 CompressionCodec 接口。连接建立后，所有传递的单元块将被压缩发送。只要压缩器在 CLASSPATH 上，服务器就会返回使用同一压缩器压缩的单元块（否则你将获得<code>UnsupportedCompressionCodecException</code>）。</p>
<h2 id="附录-nhbase-版本中已知的不兼容性">附录 N：HBase 版本中已知的不兼容性</h2>
<h2 id="203-hbase-20-不兼容的变化">203. HBase 2.0 不兼容的变化</h2>
<p>本附录描述了早期版本的 HBase 与 HBase 2.0 的不兼容更改。此列表并不意味着完全包含所有可能的不兼容性。相反，这些内容旨在深入了解大多数用户将从 HBase 1.x 版本中遇到的一些明显的不兼容性。</p>
<h3 id="2031-hbase-20-的主要变更清单">203.1。 HBase 2.0 的主要变更清单</h3>
<ul>
<li> <p>HBASE-1912-HBCK 是用于捕获不一致性的 HBase 数据库检查工具。作为 HBase 管理员，您不应使用 HBase 1.0 版 hbck 工具来检查 HBase 2.0 数据库。这样做会破坏数据库并引发异常错误。</p> </li>
<li> <p>HBASE-16189 和 HBASE-18945-您无法通过 HBase 1.0 版本打开 HBase 2.0 hfiles。如果您是使用 HBase 版本 1.x 的管理员或 HBase 用户，则必须先滚动升级到最新版本的 HBase 1.x，然后再升级到 HBase 2.0。</p> </li>
<li> <p>HBASE-18240 - 更改了 ReplicationEndpoint 接口。它还引入了一个新的 hbase-third party 1.0，它打包了所有第三方实用程序，这些实用程序预计将在 hbase 集群中运行。</p> </li>
</ul>
<h3 id="2032协处理器-api-更改">203.2。协处理器 API 更改</h3>
<ul>
<li> <p>HBASE-16769 - 来自 MasterObserver 和 RegionServerObserver 的不推荐的 PB 引用。</p> </li>
<li> <p>HBASE-17312 - [JDK8]使用 Observer 协处理器的默认方法。 BaseMasterAndRegionObserver，BaseMasterObserver，BaseRegionObserver，BaseRegionServerObserver 和 BaseWALObserver 的接口类使用 JDK8 的'default'关键字来提供空的和无操作的实现。</p> </li>
<li> <p>接口 HTableInterface HBase 2.0 对下面列出的方法进行了以下更改：</p> </li>
</ul>
<h4 id="20321----接口协处理器环境变化2">203.2.1。 [ - ]接口协处理器环境变化（2）</h4>
<table>
<thead>
<tr>
<th>更改</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象方法 getTable（TableName）已被删除。</td>
<td>NoSuchMethodError 异常可能会中断客户端程序。</td>
</tr>
<tr>
<td>抽象方法 getTable（TableName，ExecutorService）已被删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li>公众观众</li>
</ul>
<p>下表描述了协处理器的更改。</p>
<h5 id="--类-coprocessorrpcchannel1">[ - ]类 CoprocessorRpcChannel（1）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个类已成为界面。</td>
<td>IncompatibleClassChangeError 或 InstantiationError 异常可能会中断客户端程序，具体取决于此类的用法。</td>
</tr>
</tbody>
</table>
<h5 id="类-coprocessorhost">类 CoprocessorHost</h5>
<p>Audience Private 但已删除的类。</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>字段协处理器的类型已从 java.util.SortedSet &lt;e&gt;更改为 org.apache.hadoop.hbase.util.SortedList &lt;e&gt;。&lt;/e&gt;&lt;/e&gt;</td>
<td>NoSuchFieldError 异常可能会中断客户端程序。</td>
</tr>
</tbody>
</table>
<h4 id="20322-masterobserver">203.2.2。 MasterObserver</h4>
<p>HBase 2.0 引入了对 MasterObserver 接口的以下更改。</p>
<h5 id="--界面-masterobserver14">[ - ]界面 MasterObserver（14）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此界面中删除抽象方法 voidpostCloneSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostCreateTable（ObserverContext &lt;mastercoprocessorenvironment&gt;，HTableDescriptor，HRegionInfo []）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>NoSuchMethodErrorexception 可能会中断客户端程序。</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostDeleteSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpostGetTableDescriptors（ObserverContext &lt;mastercoprocessorenvironment&gt;，List &lt;htabledescriptor&gt;）。&lt;/htabledescriptor&gt;&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpostModifyTable（ObserverContext &lt;mastercoprocessorenvironment&gt;，TableName，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostRestoreSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpreCloneSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpreCreateTable（ObserverContext &lt;mastercoprocessorenvironment&gt;，HTableDescriptor，HRegionInfo []）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpreDeleteSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpreGetTableDescriptors（ObserverContext &lt;mastercoprocessorenvironment&gt;，List &lt;tablename&gt;，List &lt;htabledescriptor&gt;）。&lt;/htabledescriptor&gt;&lt;/tablename&gt;&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpreModifyTable（ObserverContext &lt;mastercoprocessorenvironment&gt;，TableName，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpreRestoreSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpreSnapshot（ObserverContext &lt;mastercoprocessorenvironment&gt;，HBaseProtos.SnapshotDescription，HTableDescriptor）。&lt;/mastercoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodErrorexception.</td>
</tr>
</tbody>
</table>
<h4 id="20323-regionobserver">203.2.3。 RegionObserver</h4>
<p>HBase 2.0 引入了对 RegionObserver 接口的以下更改。</p>
<h5 id="---interface-regionobserver13">[ - ] interface RegionObserver（13）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此界面中删除抽象方法 voidpostCloseRegionOperation（ObserverContext &lt;regioncoprocessorenvironment&gt;，HRegion.Operation）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpostCompactSelection（ObserverContext &lt;regioncoprocessorenvironment&gt;，Store，ImmutableList &lt;storefile&gt;）。&lt;/storefile&gt;&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostCompactSelection（ObserverContext &lt;regioncoprocessorenvironment&gt;，Store，ImmutableList &lt;storefile&gt;，CompactionRequest）。&lt;/storefile&gt;&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpostGetClosestRowBefore（ObserverContext &lt;regioncoprocessorenvironment&gt;，byte []，byte []，Result）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除了抽象方法 DeleteTrackerpostInstantiateDeleteTracker（ObserverContext &lt;regioncoprocessorenvironment&gt;，DeleteTracker）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostSplit（ObserverContext &lt;regioncoprocessorenvironment&gt;，HRegion，HRegion）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostStartRegionOperation（ObserverContext &lt;regioncoprocessorenvironment&gt;，HRegion.Operation）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 StoreFile.ReaderpostStoreFileReaderOpen（ObserverContext &lt;regioncoprocessorenvironment&gt;，FileSystem，Path，FSDataInputStreamWrapper，long，CacheConfig，Reference，StoreFile.Reader）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpostWALRestore（ObserverContext &lt;regioncoprocessorenvironment&gt;，HRegionInfo，HLogKey，WALEdit）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除了抽象方法 InternalScannerpreFlushScannerOpen（ObserverContext &lt;regioncoprocessorenvironment&gt;，Store，KeyValueScanner，InternalScanner）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 voidpreGetClosestRowBefore（ObserverContext &lt;regioncoprocessorenvironment&gt;，byte []，byte []，Result）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 StoreFile.ReaderpreStoreFileReaderOpen（ObserverContext &lt;regioncoprocessorenvironment&gt;，FileSystem，Path，FSDataInputStreamWrapper，long，CacheConfig，Reference，StoreFile.Reader）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 voidpreWALRestore（ObserverContext &lt;regioncoprocessorenvironment&gt;，HRegionInfo，HLogKey，WALEdit）。&lt;/regioncoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="20324-walobserver">203.2.4。 WALObserver</h4>
<p>HBase 2.0 引入了对 WALObserver 接口的以下更改。</p>
<h6 id="--界面-walobserver">[ - ]界面 WALObserver</h6>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此界面中删除抽象方法 voidpostWALWrite（ObserverContext &lt;walcoprocessorenvironment&gt;，HRegionInfo，HLogKey，WALEdit）。&lt;/walcoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 booleanpreWALWrite（ObserverContext &lt;walcoprocessorenvironment&gt;，HRegionInfo，HLogKey，WALEdit）。&lt;/walcoprocessorenvironment&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="20325杂">203.2.5。杂</h4>
<p>HBase 2.0 引入了以下类的更改：</p>
<p>hbase-server-1.0.0.jar，OnlineRegions.class 包 org.apache.hadoop.hbase.regionserver</p>
<h5 id="---onlineregionsgetfromonlineregionsstring-p1abstracthregion">[ - ] OnlineRegions.getFromOnlineRegions（String p1）[abstract]：HRegion</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/ OnlineRegions.getFromOnlineRegions：（Ljava /郎/字符串;）Lorg /阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/ HRegion;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 Region 更改为 Region。</td>
<td>此方法已被删除，因为返回类型是方法签名的一部分。 NoSuchMethodError 异常可能会中断客户端程序。</td>
</tr>
</tbody>
</table>
<p>hbase-server-1.0.0.jar，RegionCoprocessorEnvironment.class 包 org.apache.hadoop.hbase.coprocessor</p>
<h5 id="---regioncoprocessorenvironmentgetregionabstracthregion">[ - ] RegionCoprocessorEnvironment.getRegion（）[abstract]：HRegion</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/协处理器/ RegionCoprocessorEnvironment.getRegion :(）Lorg /阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/ HRegion;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.regionserver.HRegion 更改为 org.apache.hadoop.hbase.regionserver.Region。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<p>hbase-server-1.0.0.jar，RegionCoprocessorHost.class 包 org.apache.hadoop.hbase.regionserver</p>
<h5 id="---regioncoprocessorhostpostappend追加追加结果结果void">[ - ] RegionCoprocessorHost.postAppend（追加追加，结果结果）：void</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/ RegionCoprocessorHost.postAppend：（Lorg /阿帕奇/ hadoop 的/ HBase 的/客户端/追加; Lorg /阿帕奇/ hadoop 的/ HBase 的/客户/结果;）V</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 void 更改为 org.apache.hadoop.hbase.client.Result。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---regioncoprocessorhostprestorefilereaderopenfilesystem-fspath-pfsdatainputstreamwrapper-inlong-sizecacheconfig-cacheconfreference-rstorefilereader">[ - ] RegionCoprocessorHost.preStoreFileReaderOpen（FileSystem fs，Path p，FSDataInputStreamWrapper in，long size，CacheConfig cacheConf，Reference r）：StoreFile.Reader</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/ RegionCoprocessorHost.preStoreFileReaderOpen：（Lorg /阿帕奇/ hadoop 的/ FS /文件系统; Lorg /阿帕奇/ hadoop 的/ FS /路径; Lorg /阿帕奇/ hadoop 的/ HBase 的/ IO / FSDataInputStreamWrapper; JLorg /阿帕奇/ hadoop 的/ HBase 的/ IO / HFILE / CacheConfig; Lorg /阿帕奇/ hadoop 的/ HBase 的/ IO /参考）Lorg /阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/ StoreFile $阅读器;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 StoreFile.Reader 更改为 StoreFileReader。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="20326-ipc">203.2.6。 IPC</h4>
<h4 id="20327调度程序更改">203.2.7。调度程序更改：</h4>
<ol>
<li>以下方法变得抽象：</li>
</ol>
<p>包 org.apache.hadoop.hbase.ipc</p>
<h5 id="---class-rpcscheduler1">[ - ] class RpcScheduler（1）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象方法 void dispatch（CallRunner）已从此类中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<p>hbase-server-1.0.0.jar，RpcScheduler.class 包 org.apache.hadoop.hbase.ipc</p>
<h5 id="---rpcschedulerdispatchcallrunner-p1abstractvoid-1">[ - ] RpcScheduler.dispatch（CallRunner p1）[abstract]：void 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ IPC / RpcScheduler.dispatch：（Lorg /阿帕奇/ hadoop 的/ HBase 的/ IPC / CallRunner;）V</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 void 更改为 boolean。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ol>
<li>以下摘要方法已被删除：</li>
</ol>
<h5 id="---interface-priorityfunction2">[ - ] interface PriorityFunction（2）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此接口中删除了抽象方法 longgetDeadline（RPCProtos.RequestHeader，Message）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>抽象方法 int getPriority（RPCProtos.RequestHeader，Message）已从此接口中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="20328服务器-api-更改">203.2.8。服务器 API 更改：</h4>
<h5 id="--类-rpcserver12">[ - ]类 RpcServer（12）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>字段类型 CurCall 已从 java.lang.ThreadLocal &lt;rpcserver.call&gt;更改为 java.lang.ThreadLocal &lt;rpccall&gt;。&lt;/rpccall&gt;&lt;/rpcserver.call&gt;</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>这堂课变得抽象了。</td>
<td>InstantiationError 异常可能会中断客户端程序。</td>
</tr>
<tr>
<td>抽象方法 int getNumOpenConnections（）已添加到此类中。</td>
<td>此类变为抽象，客户端程序可能会被 InstantiationError 异常中断。</td>
</tr>
<tr>
<td>已从此类中删除 org.apache.hadoop.hbase.util.Counter 类型的字段 callQueueSize。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除了类型为 java.util.List &lt;rpcserver.connection&gt;的字段 connectionList。&lt;/rpcserver.connection&gt;</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除 int 类型的字段 maxIdleTime。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除 int 类型的字段 numConnections。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>int 类型的字段端口已从此类中删除。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除了 long 类型的字段 purgeTimeout。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>RpcServer.Responder 类型的字段响应程序已从此类中删除。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除 int 类型的字段 socketSendBufferSize。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除 int 类型的字段 thresholdIdleConnections。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
</tbody>
</table>
<p>以下摘要方法已被删除：</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象方法 Pair &lt;message&gt;调用（BlockingService，Descriptors.MethodDescriptor，Message，CellScanner，long，MonitoredRPCHandler）已从此界面中删除。&lt;/message&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="20329复制和-wal-更改">203.2.9。复制和 WAL 更改：</h4>
<p>HBASE-18733：WALKey 已在 HBase 2.0 中完全清除。以下是 WALKey 的更改：</p>
<h5 id="---classwalkey8">[ - ] classWALKey（8）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>字段 clusterIds 的访问级别已从 protected 更改为 private。</td>
<td>IllegalAccessError 异常可能会中断客户端程序。</td>
</tr>
<tr>
<td>字段 compressionContext 的访问级别已从 protected 更改为 private。</td>
<td>A client program may be interrupted by IllegalAccessError exception.</td>
</tr>
<tr>
<td>字段 encodedRegionName 的访问级别已从 protected 更改为 private。</td>
<td>A client program may be interrupted by IllegalAccessError exception.</td>
</tr>
<tr>
<td>字段表名的访问级别已从 protected 更改为 private。</td>
<td>A client program may be interrupted by IllegalAccessError exception.</td>
</tr>
<tr>
<td>字段 writeTime 的访问级别已从 protected 更改为 private。</td>
<td>A client program may be interrupted by IllegalAccessError exception.</td>
</tr>
</tbody>
</table>
<p>以下字段已被删除：</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此类中删除 org.apache.commons.logging.Log 类型的字段日志。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>WALKey.Version 类型的字段 VERSION 已从此类中删除。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除了 long 类型的字段 logSeqNum。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
</tbody>
</table>
<p>以下是对 WALEdit.class 的更改：hbase-server-1.0.0.jar，WALEdit.class 包 org.apache.hadoop.hbase.regionserver.wal</p>
<h5 id="waleditgetcompactioncell-kv静态walprotoscompactiondescriptor1">WALEdit.getCompaction（Cell kv）[静态]：WALProtos.CompactionDescriptor（1）</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/沃尔玛/ WALEdit.getCompaction：（Lorg /阿帕奇/ hadoop 的/ HBase 的/细胞）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ WALProtos $ CompactionDescriptor;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.protobuf.generated.WALProtos.CompactionDescriptor 更改为 org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.CompactionDescriptor。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="waleditgetflushdescriptorcell-cell静态walprotosflushdescriptor1">WALEdit.getFlushDescriptor（Cell cell）[静态]：WALProtos.FlushDescriptor（1）</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/沃尔玛/ WALEdit.getFlushDescriptor：（Lorg /阿帕奇/ hadoop 的/ HBase 的/细胞）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ WALProtos $ FlushDescriptor;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.protobuf.generated.WALProtos.FlushDescriptor 更改为 org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.FlushDescriptor。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="waleditgetregioneventdescriptorcell-cell静态walprotosregioneventdescriptor1">WALEdit.getRegionEventDescriptor（Cell cell）[静态]：WALProtos.RegionEventDescriptor（1）</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/沃尔玛/ WALEdit.getRegionEventDescriptor：（Lorg /阿帕奇/ hadoop 的/ HBase 的/细胞）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ WALProtos $ RegionEventDescriptor;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.protobuf.generated.WALProtos.RegionEventDescriptor 更改为 org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.RegionEventDescriptor。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<p>以下是对 WALKey.class：package org.apache.hadoop.hbase.wal 的更改</p>
<h5 id="walkeygetbuilderwalcellcodecbytestringcompressor-压缩器walprotoswalkeybuilder-1">WALKey.getBuilder（WALCellCodec.ByteStringCompressor 压缩器）：WALProtos.WALKey.Builder 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/沃尔玛/ WALKey.getBuilder：（Lorg /阿帕奇/ hadoop 的/ HBase 的/ RegionServer 的/沃尔/ WALCellCodec $ ByteStringCompressor）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ WALProtos $ $ WALKey 助洗剂;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.protobuf.generated.WALProtos.WALKey.Builder 更改为 org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.WALKey.Builder。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="203210不推荐使用的-api-或协处理器">203.2.10。不推荐使用的 API 或协处理器：</h4>
<p>HBASE-16769 - 已删除 MasterObserver 和 RegionServerObserver 中的 PB 引用。</p>
<h4 id="203211管理界面-api-更改">203.2.11。管理界面 API 更改：</h4>
<p>您无法管理 HBase 2.0 群集与 HBase 1.0 客户端，其中包括 Admin ops 的 RelicationAdmin，ACC，Thrift 和 REST 使用。返回 protobufs 的方法已更改为返回 POJO。 pb 不再用于 API 中。异步方法的返回值已从 void 更改为 Future。 HBASE-18106 - Admin.listProcedures 和 Admin.listLocks 重命名为 getProcedures 和 getLocks。 MapReduce 使用 Admin 执行以下 admin.getClusterStatus（）来计算 Splits。</p>
<ul>
<li> <p>管理 API 的节约使用：compact（ByteBuffer）createTable（ByteBuffer，List &lt;columndescriptor&gt;）deleteTable（ByteBuffer）disableTable（ByteBuffer）enableTable（ByteBuffer）getTableNames（）majorCompact（ByteBuffer）&lt;/columndescriptor&gt;</p> </li>
<li> <p>Admin API 的 REST 用法：hbase-rest org.apache.hadoop.hbase.rest RootResource getTableList（）TableName [] tableNames = servlet.getAdmin（）。listTableNames（）; SchemaResource delete（UriInfo）Admin admin = servlet.getAdmin（）; update（TableSchemaModel，boolean，UriInfo）Admin admin = servlet.getAdmin（）; StorageClusterStatusResource get（UriInfo）ClusterStatus status = servlet.getAdmin（）。getClusterStatus（）; StorageClusterVersionResource get（UriInfo）model.setVersion（servlet.getAdmin（）。getClusterStatus（）。getHBaseVersion（））; TableResource exists（）返回 servlet.getAdmin（）。tableExists（TableName.valueOf（table））;</p> </li>
</ul>
<p>以下是对 Admin 界面的更改：</p>
<h5 id="--界面管理员9">[ - ]界面管理员（9）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此接口中删除抽象方法 createTableAsync（HTableDescriptor，byte [] []）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 disableTableAsync（TableName）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 enableTableAsync（TableName）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 getCompactionState（TableName）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 getCompactionStateForRegion（byte []）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>抽象方法 isSnapshotFinished（HBaseProtos.SnapshotDescription）已从此界面中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 snapshot（String，TableName，HBaseProtos.SnapshotDescription.Type）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法快照（HBaseProtos.SnapshotDescription）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 takeSnapshotAsync（HBaseProtos.SnapshotDescription）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<p>以下是对 Admin.class 的更改：hbase-client-1.0.0.jar，Admin.class 包 org.apache.hadoop.hbase.client</p>
<h5 id="---admincreatetableasynchtabledescriptor-p1byte---p2abstractvoid-1">[ - ] Admin.createTableAsync（HTableDescriptor p1，byte [] [] p2）[abstract]：void 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/客户端/ Admin.createTableAsync：（Lorg /阿帕奇/ hadoop 的/ HBase 的/ HTableDescriptor; [[B）V</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 void 更改为 java.util.concurrent.Future &lt;java.lang.void&gt;。&lt;/java.lang.void&gt;</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---admindisabletableasynctablename-p1abstractvoid-1">[ - ] Admin.disableTableAsync（TableName p1）[abstract]：void 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/客户端/ Admin.disableTableAsync：（Lorg /阿帕奇/ hadoop 的/ HBase 的/表名;）V</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return value type has been changed from void to java.util.concurrent.Future&lt;java.lang.void&gt;.&lt;/java.lang.void&gt;</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="adminenabletableasynctablename-p1abstractvoid-1">Admin.enableTableAsync（TableName p1）[abstract]：void 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/客户端/ Admin.enableTableAsync：（Lorg /阿帕奇/ hadoop 的/ HBase 的/表名;）V</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return value type has been changed from void to java.util.concurrent.Future&lt;java.lang.void&gt;.&lt;/java.lang.void&gt;</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---admingetcompactionstatetablename-p1abstractadminprotosgetregioninforesponsecompactionstate-1">[ - ] Admin.getCompactionState（TableName p1）[abstract]：AdminProtos.GetRegionInfoResponse.CompactionState 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/客户端/ Admin.getCompactionState：（Lorg /阿帕奇/ hadoop 的/ HBase 的/表名）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ AdminProtos $ $ GetRegionInfoResponse CompactionState;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.protobuf.generated.AdminProtos.GetRegionInfoResponse.CompactionState 更改为 CompactionState。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---admingetcompactionstateforregionbyte--p1abstractadminprotosgetregioninforesponsecompactionstate-1">[ - ] Admin.getCompactionStateForRegion（byte [] p1）[abstract]：AdminProtos.GetRegionInfoResponse.CompactionState 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/客户端/ Admin.getCompactionStateForRegion：（[B）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ AdminProtos $ $ GetRegionInfoResponse CompactionState;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return value type has been changed from org.apache.hadoop.hbase.protobuf.generated.AdminProtos.GetRegionInfoResponse.CompactionState to CompactionState.</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="203212-htabledescriptor-和-hcolumndescriptor-发生了变化">203.2.12。 HTableDescriptor 和 HColumnDescriptor 发生了变化</h4>
<p>HTableDescriptor 和 HColumnDescriptor 已成为接口，您可以通过 Builders 创建它。 HCD 已成为 CFD。它不再实现可写接口。包 org.apache.hadoop.hbase</p>
<h5 id="--类-hcolumndescriptor1">[ - ]类 HColumnDescriptor（1）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>删除了超级接口 org.apache.hadoop.io.WritableComparable &lt;hcolumndescriptor&gt;。&lt;/hcolumndescriptor&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<p>HColumnDescriptor in 1.0.0 {code} @ InterfaceAudience.Public @ InterfaceStability.Evolving public class HColumnDescriptor 实现 WritableComparable &lt;hcolumndescriptor&gt;{{code}&lt;/hcolumndescriptor&gt;</p>
<p>HColumnDescriptor in 2.0 {code} @ InterfaceAudience.Public <a href="https://github.com/Deprecated"><strong>@Deprecated</strong></a> //在 3.0 公共类中删除它 HColumnDescriptor 实现 ColumnFamilyDescriptor，Comparable &lt;hcolumndescriptor&gt;{{code}&lt;/hcolumndescriptor&gt;</p>
<p>对于 META_TABLEDESC，制造商方法已在 1.0.0 中的 HTD 中弃用。 OWNER_KEY 仍处于 HTD 状态。</p>
<h5 id="类-htabledescriptor3">类 HTableDescriptor（3）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>删除了超级接口 org.apache.hadoop.io.WritableComparable &lt;htabledescriptor&gt;。&lt;/htabledescriptor&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此类中删除了类型为 HTableDescriptor 的字段 META_TABLEDESC。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
</tbody>
</table>
<p>hbase-client-1.0.0.jar，HTableDescriptor.class 包 org.apache.hadoop.hbase</p>
<h5 id="---htabledescriptorgetcolumnfamilieshcolumndescriptor-1">[ - ] HTableDescriptor.getColumnFamilies（）：HColumnDescriptor []（1）</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ HTableDescriptor.getColumnFamilies：（）[Lorg /阿帕奇/ hadoop 的/ HBase 的/ HColumnDescriptor;</p>
<h5 id="-class-hcolumndescriptor-1">[−] class HColumnDescriptor (1)</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 HColumnDescriptor []更改为 client.ColumnFamilyDescriptor []。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---htabledescriptorgetcoprocessorslist-string1string">[ - ] HTableDescriptor.getCoprocessors（）：List &lt;string&gt;（1）&lt;/string&gt;</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ HTableDescriptor.getCoprocessors :(）Ljava / util 的/列表;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 java.util.List &lt;java.lang.string&gt;更改为 java.util.Collection。&lt;/java.lang.string&gt;</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li>HBASE-12990 删除了 MetaScanner，它被 MetaTableAccessor 取代。</li>
</ul>
<h5 id="htablewrapper-更改">HTableWrapper 更改：</h5>
<p>hbase-server-1.0.0.jar，HTableWrapper.class 包 org.apache.hadoop.hbase.client</p>
<h5 id="---htablewrappercreatewrapperlist-htableinterfaceopentablestablename-tablenamecoprocessorhostenvironment-envexecutorservice-pool静态htableinterface-1htableinterface">[ - ] HTableWrapper.createWrapper（List &lt;htableinterface&gt;openTables，TableName tableName，CoprocessorHost.Environment env，ExecutorService pool）[静态]：HTableInterface 1&lt;/htableinterface&gt;</h5>
<p>组织/阿帕奇/的 Hadoop / HBase 的/客户/ HTableWrapper.createWrapper：（Ljava / UTIL /列表; Lorg /阿帕奇/的 Hadoop / HBase 的/表名; Lorg /阿帕奇/的 Hadoop / HBase 的/协/ CoprocessorHost $环境; Ljava / UTIL /并发/ ExecutorService 的;）Lorg /阿帕奇/ hadoop 的/ HBase 的/客户/ HTableInterface;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 HTableInterface 更改为 Table。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li> <p>HBASE-12586：删除所有公共 HTable 构造函数并删除 ConnectionManager＃{delete，get} Connection。</p> </li>
<li> <p>HBASE-9117：删除 HTablePool 和所有与 HConnection 池相关的 API。</p> </li>
<li> <p>HBASE-13214：从 HTable 类中删除不推荐使用和未使用的方法以下是对 Table 接口的更改：</p> </li>
</ul>
<h5 id="--界面表4">[ - ]界面表（4）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此界面中删除抽象方法批处理（List＆lt;？＆gt;）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此界面中删除抽象方法 batchCallback（List＆lt;？＆gt;，Batch.Callback &lt;r&gt;）。&lt;/r&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 getWriteBufferSize（）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此接口中删除抽象方法 setWriteBufferSize（long）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="203213表在-101-中中不推荐使用缓冲区方法在-200-中删除">203.2.13。表（在 1.0.1 中）中不推荐使用缓冲区方法，在 2.0.0 中删除</h4>
<ul>
<li> <p>HBASE-13298-澄清表。{set | get} WriteBufferSize（）是否已弃用。</p> </li>
<li> <p>LockTimeoutException 和 OperationConflictException 类已被删除。</p> </li>
</ul>
<h4 id="203214-class-operationconflictexception1">203.2.14。 class OperationConflictException（1）</h4>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>此课程已被删除。</td>
<td>NoClassDefFoundErrorexception 可能会中断客户端程序。</td>
</tr>
</tbody>
</table>
<h4 id="203215-class-class-locktimeoutexception1">203.2.15。 class class LockTimeoutException（1）</h4>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>This class has been removed.</td>
<td>A client program may be interrupted by NoClassDefFoundErrorexception.</td>
</tr>
</tbody>
</table>
<h4 id="203216过滤-api-更改">203.2.16。过滤 API 更改：</h4>
<p>已删除以下方法：package org.apache.hadoop.hbase.filter</p>
<h5 id="--类过滤器2">[ - ]类过滤器（2）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此类中删除抽象方法 getNextKeyHint（KeyValue）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>已从此类中删除抽象方法 transform（KeyValue）。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li> <p>HBASE-12296 过滤器应该与 ByteBufferedCell 一起使用。</p> </li>
<li> <p>HBase 2.0 中删除了 HConnection。</p> </li>
<li> <p>RegionLoad 和 ServerLoad 在内部移动到着色的 PB。</p> </li>
</ul>
<h5 id="---class-regionload1">[ - ] class RegionLoad（1）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>字段 regionLoadPB 的类型已从 protobuf.generated.ClusterStatusProtos.RegionLoad 更改为 shaded.protobuf.generated.ClusterStatusProtos.RegionLoad。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li>HBASE-15783：AccessControlConstants＃OP_ATTRIBUTE_ACL_STRATEGY_CELL_FIRST 不再使用。包 org.apache.hadoop.hbase.security.access</li>
</ul>
<h5 id="--接口-accesscontrolconstants3">[ - ]接口 AccessControlConstants（3）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此接口中删除了类型为 java.lang.String 的字段 OP_ATTRIBUTE_ACL_STRATEGY。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此接口中删除 byte []类型的字段 OP_ATTRIBUTE_ACL_STRATEGY_CELL_FIRST。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此接口中删除 byte []类型的字段 OP_ATTRIBUTE_ACL_STRATEGY_DEFAULT。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
</tbody>
</table>
<h5 id="serverload-返回-long-而不是-int-1">ServerLoad 返回 long 而不是 int 1</h5>
<p>hbase-client-1.0.0.jar，ServerLoad.class 包 org.apache.hadoop.hbase</p>
<h5 id="---serverloadgetnumberofrequestsint-1">[ - ] ServerLoad.getNumberOfRequests（）：int 1</h5>
<p>组织/阿帕奇/的 Hadoop / HBase 的/ ServerLoad.getNumberOfRequests :(）我</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 int 更改为 long。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---serverloadgetreadrequestscountint-1">[ - ] ServerLoad.getReadRequestsCount（）：int 1</h5>
<p>组织/阿帕奇/的 Hadoop / HBase 的/ ServerLoad.getReadRequestsCount :(）我</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return value type has been changed from int to long.</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---serverloadgettotalnumberofrequestsint-1">[ - ] ServerLoad.getTotalNumberOfRequests（）：int 1</h5>
<p>组织/阿帕奇/的 Hadoop / HBase 的/ ServerLoad.getTotalNumberOfRequests :(）我</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return value type has been changed from int to long.</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h5 id="---serverloadgetwriterequestscountint-1">[ - ] ServerLoad.getWriteRequestsCount（）：int 1</h5>
<p>组织/阿帕奇/的 Hadoop / HBase 的/ ServerLoad.getWriteRequestsCount :(）我</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return value type has been changed from int to long.</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li> <p>HBASE-13636 删除 HBASE-4072 的弃用（阅读 zoo.cfg）</p> </li>
<li> <p>HConstants 被删除。 HBASE-16040 删除配置“hbase.replication”</p> </li>
</ul>
<h5 id="--班级-hconstants6">[ - ]班级 HConstants（6）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此类中删除类型为 boolean 的字段 DEFAULT_HBASE_CONFIG_READ_ZOOKEEPER_CONFIG。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除了类型为 java.lang.String 的字段 HBASE_CONFIG_READ_ZOOKEEPER_CONFIG。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除类型为 boolean 的字段 REPLICATION_ENABLE_DEFAULT。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除 java.lang.String 类型的字段 REPLICATION_ENABLE_KEY。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除了类型为 java.lang.String 的字段 ZOOKEEPER_CONFIG_NAME。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
<tr>
<td>已从此类中删除了类型为 java.lang.String 的字段 ZOOKEEPER_USEMULTI。</td>
<td>A client program may be interrupted by NoSuchFieldError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li>HBASE-18732：[compat 1-2] HBASE-14047 删除了 Cell 方法而没有弃用周期。</li>
</ul>
<h5 id="--界面单元格-5">[ - ]界面单元格 5</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象方法 getFamily（）已从此接口中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>抽象方法 getMvccVersion（）已从此接口中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>抽象方法 getQualifier（）已从此接口中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>抽象方法 getRow（）已从此接口中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
<tr>
<td>抽象方法 getValue（）已从此接口中删除。</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li>HBASE-18795：仅为测试公开 KeyValue.getBuffer（）。仅在以前不推荐使用的测试中允许 KV＃getBuffer。</li>
</ul>
<h4 id="203217区域扫描仪更改">203.2.17。区域扫描仪更改：</h4>
<h5 id="--界面-regionscanner1">[ - ]界面 RegionScanner（1）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>已从此接口中删除抽象方法 boolean nextRaw（List &lt;cell&gt;，int）。&lt;/cell&gt;</td>
<td>A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="203218-storefile-更改">203.2.18。 StoreFile 更改：</h4>
<h5 id="--类-storefile1">[ - ]类 StoreFile（1）</h5>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个类成了界面。</td>
<td>客户端程序可能会因 IncompatibleClassChangeError 或 InstantiationError 异常而中断，具体取决于此类的用法。</td>
</tr>
</tbody>
</table>
<h4 id="203219-mapreduce-更改">203.2.19。 Mapreduce 更改：</h4>
<p>HFile *格式已在 HBase 2.0 中删除。</p>
<h4 id="203220-clusterstatus-更改">203.2.20。 ClusterStatus 更改：</h4>
<p>HBASE-15843：用 Set hbase-client-1.0.0.jar，ClusterStatus.class 包 org.apache.hadoop.hbase 替换 RegionState.getRegionInTransition（）Map</p>
<h5 id="---clusterstatusgetregionsintransitionmap-string1string">[ - ] ClusterStatus.getRegionsInTransition（）：Map &lt;string&gt;1&lt;/string&gt;</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ ClusterStatus.getRegionsInTransition :(）Ljava / util 的/地图;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 java.util.Map &lt;java.lang.string&gt;更改为 java.util.List &lt;master.regionstate&gt;。&lt;/master.regionstate&gt;&lt;/java.lang.string&gt;</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<p>ClusterStatus 中的其他更改包括删除从 API 中清除 PB 后不再需要的转换方法。</p>
<h4 id="203221从-api-中清除-pb">203.2.21。从 API 中清除 PB</h4>
<p>PBase 已在 HBase 2.0 中的 API 中弃用。</p>
<h5 id="---hbasesnapshotexceptiongetsnapshotdescriptionhbaseprotossnapshotdescription-1">[ - ] HBaseSnapshotException.getSnapshotDescription（）：HBaseProtos.SnapshotDescription 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/快照/ HBaseSnapshotException.getSnapshotDescription :(）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ HBaseProtos $ SnapshotDescription;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.protobuf.generated.HBaseProtos.SnapshotDescription 更改为 org.apache.hadoop.hbase.client.SnapshotDescription。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<ul>
<li>HBASE-15609：从 Result，DoubleColumnInterpreter 和 2.0 的任何此类面向公共的类中删除 PB 引用。 hbase-client-1.0.0.jar，Result.class 包 org.apache.hadoop.hbase.client</li>
</ul>
<h5 id="---resultgetstatsclientprotosregionloadstats-1">[ - ] Result.getStats（）：ClientProtos.RegionLoadStats 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/客户端/ Result.getStats :(）Lorg /阿帕奇/ hadoop 的/ HBase 的/ protobuf 的/生成/ ClientProtos $ RegionLoadStats;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.hadoop.hbase.protobuf.generated.ClientProtos.RegionLoadStats 更改为 RegionLoadStats。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="203222-rest-更改">203.2.22。 REST 更改：</h4>
<p>hbase-rest-1.0.0.jar，Client.class 包 org.apache.hadoop.hbase.rest.client</p>
<h5 id="---clientgethttpclienthttpclient-1">[ - ] Client.getHttpClient（）：HttpClient 1</h5>
<p>组织/阿帕奇/的 Hadoop / HBase 的/ REST /客户/ Client.getHttpClient :(）Lorg /阿帕奇/公/ HttpClient 的/ HttpClient 的</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.commons.httpclient.HttpClient 更改为 org.apache.http.client.HttpClient。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<p>hbase-rest-1.0.0.jar，Response.class 包 org.apache.hadoop.hbase.rest.client</p>
<h5 id="---responsegetheaders标题-1">[ - ] Response.getHeaders（）：标题[] 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/休息/客户端/ Response.getHeaders：（）[Lorg /阿帕奇/公地/ HttpClient 的/报头;</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 org.apache.commons.httpclient.Header []更改为 org.apache.http.Header []。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="203223-prettyprinter-更改">203.2.23。 PrettyPrinter 更改：</h4>
<p>hbase-server-1.0.0.jar，HFilePrettyPrinter.class 包 org.apache.hadoop.hbase.io.hfile</p>
<h5 id="---hfileprettyprinterprocessfilepath-filevoid-1">[ - ] HFilePrettyPrinter.processFile（Path file）：void 1</h5>
<p>组织/阿帕奇/ hadoop 的/ HBase 的/ IO / HFILE / HFilePrettyPrinter.processFile：（Lorg /阿帕奇/ hadoop 的/ FS /路径;）V</p>
<table>
<thead>
<tr>
<th>Change</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值类型已从 void 更改为 int。</td>
<td>This method has been removed because the return type is part of the method signature. A client program may be interrupted by NoSuchMethodError exception.</td>
</tr>
</tbody>
</table>
<h4 id="203224-accesscontrolclient-更改">203.2.24。 AccessControlClient 更改：</h4>
<p>HBASE-13171 更改 AccessControlClient 方法以接受连接对象以减少设置时间。参数已在以下方法中更改：</p>
<ul>
<li> <p>hbase-client-1.2.7-SNAPSHOT.jar，AccessControlClient.class 包 org.apache.hadoop.hbase.security.access AccessControlClient.getUserPermissions（Configuration conf，String tableRegex）[静态]：列表 &lt;userpermission&gt;<strong>DEPRECATED</strong> org / apache / hadoop / hbase / security / access / AccessControlClient.getUserPermissions：（Lorg / apache / hadoop / conf / Configuration; Ljava / lang / String;）Ljava / util / List;&lt;/userpermission&gt;</p> </li>
<li> <p>AccessControlClient.grant（Configuration conf，String namespace，String userName，Permission.Action ... actions）[静态]：void <strong>DEPRECATED</strong> org / apache / hadoop / hbase / security / access / AccessControlClient.grant：（Lorg /阿帕奇/ Hadoop 的/ conf 目录/配置; Ljava /朗/字符串; Ljava /朗/字符串; Lorg /阿帕奇/的 Hadoop / HBase 的/安全/访问/权限$行动;）V</p> </li>
<li> <p>AccessControlClient.grant（Configuration conf，String userName，Permission.Action ... actions）[静态]：void <strong>DEPRECATED</strong> org / apache / hadoop / hbase / security / access / AccessControlClient.grant：（Lorg / apache / Hadoop 的/ conf 目录/配置; Ljava /朗/字符串; Lorg /阿帕奇/的 Hadoop / HBase 的/安全/访问/权限$行动;）V</p> </li>
<li> <p>AccessControlClient.grant（Configuration conf，TableName tableName，String userName，byte [] family，byte [] qual，Permission.Action ... actions）[静态]：void <strong>DEPRECATED</strong> org / apache / hadoop / hbase /安全/访问/ AccessControlClient.grant：（Lorg /阿帕奇/ hadoop 的/ CONF /配置; Lorg /阿帕奇/ hadoop 的/ HBase 的/表名; Ljava /郎/字符串; [B [B [Lorg /阿帕奇/ hadoop 的/ HBase 的/安全/访问/权限$行动;）V</p> </li>
<li> <p>AccessControlClient.isAccessControllerRunning（Configuration conf）[静态]：boolean <strong>DEPRECATED</strong> org / apache / hadoop / hbase / security / access / AccessControlClient.isAccessControllerRunning：（Lorg / apache / hadoop / conf / Configuration;）Z</p> </li>
<li> <p>AccessControlClient.revoke（Configuration conf，String namespace，String userName，Permission.Action ... actions）[静态]：void <strong>DEPRECATED</strong> org / apache / hadoop / hbase / security / access / AccessControlClient.revoke：（Lorg /阿帕奇/ Hadoop 的/ conf 目录/配置; Ljava /朗/字符串; Ljava /朗/字符串; Lorg /阿帕奇/的 Hadoop / HBase 的/安全/访问/权限$行动;）V</p> </li>
<li> <p>AccessControlClient.revoke（Configuration conf，String userName，Permission.Action ... actions）[静态]：void <strong>DEPRECATED</strong> org / apache / hadoop / hbase / security / access / AccessControlClient.revoke：（Lorg / apache / Hadoop 的/ conf 目录/配置; Ljava /朗/字符串; Lorg /阿帕奇/的 Hadoop / HBase 的/安全/访问/权限$行动;）V</p> </li>
<li> <p>AccessControlClient.revoke（Configuration conf，TableName tableName，String username，byte [] family，byte []限定符，Permission.Action ... actions）[静态]：void <strong>DEPRECATED</strong> org / apache / hadoop / hbase /安全/访问/ AccessControlClient.revoke：（Lorg /阿帕奇/ hadoop 的/ CONF /配置; Lorg /阿帕奇/ hadoop 的/ HBase 的/表名; Ljava /郎/字符串; [B [B [Lorg /阿帕奇/ hadoop 的/ HBase 的/安全/访问/权限$行动;）V</p> </li>
<li> <p>HBASE-18731：[compat 1-2]标记受保护的 QuotaSettings 方法，它们将 Protobuf 内部接触为 IA.Private</p> </li>
</ul>
<p></p>
</cellblock>
</protobuf>
</protobuf>
</total>
</cellblock>
</protobuf>
</protobuf>
</total>
</protobuf>
</preamble>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/205/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/205/index.html">从0到1实战微服务架构</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/115.html">skyline75489</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="mysql">mysql</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="netty">netty</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="nginx">nginx</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">62页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/184/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/184/index.html">对开发人员有用的定律、理论、原则和模式</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/103.html">nusr</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">80页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2325个">2325</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/186/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/186/index.html">leetcode题解，记录自己的leetcode解题之路</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8204个">8204</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/34/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/markdown_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/34/index.html">Markdown - 简单的世界</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="markdown">markdown</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">16页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 159个">159</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/138/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/138/index.html">开发经验总结</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 641个">641</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/17/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/17/index.html">Go语言博客实践</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/12.html">achun</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">30页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 298个">298</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/173/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/173/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/173/README.html" title="HBase™ 中文参考指南 3.0" data-book-page-rel-url="README.html" data-book-page-id="11767">HBase™ 中文参考指南 3.0</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/0.html" title="Preface" data-book-page-rel-url="docs/0.html" data-book-page-id="11768">Preface</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/1.html" title="Getting Started" data-book-page-rel-url="docs/1.html" data-book-page-id="11769">Getting Started</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/2.html" title="Apache HBase Configuration" data-book-page-rel-url="docs/2.html" data-book-page-id="11770">Apache HBase Configuration</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/3.html" title="Upgrading" data-book-page-rel-url="docs/3.html" data-book-page-id="11771">Upgrading</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/4.html" title="The Apache HBase Shell" data-book-page-rel-url="docs/4.html" data-book-page-id="11772">The Apache HBase Shell</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/5.html" title="Data Model" data-book-page-rel-url="docs/5.html" data-book-page-id="11773">Data Model</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/6.html" title="HBase and Schema Design" data-book-page-rel-url="docs/6.html" data-book-page-id="11774">HBase and Schema Design</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/7.html" title="RegionServer Sizing Rules of Thumb" data-book-page-rel-url="docs/7.html" data-book-page-id="11775">RegionServer Sizing Rules of Thumb</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/8.html" title="HBase and MapReduce" data-book-page-rel-url="docs/8.html" data-book-page-id="11776">HBase and MapReduce</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/9.html" title="Securing Apache HBase" data-book-page-rel-url="docs/9.html" data-book-page-id="11777">Securing Apache HBase</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/10.html" title="Architecture" data-book-page-rel-url="docs/10.html" data-book-page-id="11778">Architecture</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/11.html" title="In-memory Compaction" data-book-page-rel-url="docs/11.html" data-book-page-id="11779">In-memory Compaction</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/12.html" title="Backup and Restore" data-book-page-rel-url="docs/12.html" data-book-page-id="11780">Backup and Restore</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/13.html" title="Synchronous Replication" data-book-page-rel-url="docs/13.html" data-book-page-id="11781">Synchronous Replication</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/14.html" title="Apache HBase APIs" data-book-page-rel-url="docs/14.html" data-book-page-id="11782">Apache HBase APIs</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/15.html" title="Apache HBase External APIs" data-book-page-rel-url="docs/15.html" data-book-page-id="11783">Apache HBase External APIs</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/16.html" title="Thrift API and Filter Language" data-book-page-rel-url="docs/16.html" data-book-page-id="11784">Thrift API and Filter Language</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/17.html" title="HBase and Spark" data-book-page-rel-url="docs/17.html" data-book-page-id="11785">HBase and Spark</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/18.html" title="Apache HBase Coprocessors" data-book-page-rel-url="docs/18.html" data-book-page-id="11786">Apache HBase Coprocessors</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/19.html" title="Apache HBase Performance Tuning" data-book-page-rel-url="docs/19.html" data-book-page-id="11787">Apache HBase Performance Tuning</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/20.html" title="Troubleshooting and Debugging Apache HBase" data-book-page-rel-url="docs/20.html" data-book-page-id="11788">Troubleshooting and Debugging Apache HBase</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/21.html" title="Apache HBase Case Studies" data-book-page-rel-url="docs/21.html" data-book-page-id="11789">Apache HBase Case Studies</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/22.html" title="Apache HBase Operational Management" data-book-page-rel-url="docs/22.html" data-book-page-id="11790">Apache HBase Operational Management</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/23.html" title="Building and Developing Apache HBase" data-book-page-rel-url="docs/23.html" data-book-page-id="11791">Building and Developing Apache HBase</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/24.html" title="Unit Testing HBase Applications" data-book-page-rel-url="docs/24.html" data-book-page-id="11792">Unit Testing HBase Applications</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/25.html" title="Protobuf in HBase" data-book-page-rel-url="docs/25.html" data-book-page-id="11793">Protobuf in HBase</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/26.html" title="Procedure Framework (Pv2): HBASE-12439" data-book-page-rel-url="docs/26.html" data-book-page-id="11794">Procedure Framework (Pv2): HBASE-12439</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/27.html" title="AMv2 Description for Devs" data-book-page-rel-url="docs/27.html" data-book-page-id="11795">AMv2 Description for Devs</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/28.html" title="ZooKeeper" data-book-page-rel-url="docs/28.html" data-book-page-id="11796">ZooKeeper</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/29.html" title="Community" data-book-page-rel-url="docs/29.html" data-book-page-id="11797">Community</a>
</li>
<li>
<a class="pjax" href="../../../book/173/docs/30.html" title="Appendix" data-book-page-rel-url="docs/30.html" data-book-page-id="11798">Appendix</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =173;var bookPageId =11798;var bookPageRelUrl ='docs/30.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>