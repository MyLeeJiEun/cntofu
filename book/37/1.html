
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>安卓逆向系列教程（一）Dalvik 指令集-安卓逆向系列教程</title>
<meta content='安卓逆向系列教程（一）Dalvik 指令集,安卓逆向系列教程' name='keywords'>
<meta content='安卓逆向系列教程（一）Dalvik 指令集,安卓逆向系列教程' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../static/components/css/base.css">
<link rel="stylesheet" href="../../static/components/css/reader.css">
<link rel="stylesheet" href="../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../book/37/README.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">安卓逆向系列教程</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../book/37/2.html">
<span class="">安卓逆向系列教程（二）..</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../book/37/index.html">安卓逆向系列教程</a>
<a target="_blank" rel="nofollow" href="https://github.com/wizardforcel/fl-android-re-tut" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="安卓逆向系列教程一dalvik-指令集">安卓逆向系列教程（一）Dalvik 指令集</h1>
<blockquote>
<p>作者：<a href="https://github.com/wizardforcel">飞龙</a></p>
</blockquote>
<h2 id="寄存器">寄存器</h2>
<p>Dalvik 指令集完全基于寄存器，也就是说，没有栈。</p>
<p>所有寄存器都是 32 位，无类型的。也就是说，虽然编译器会为每个局部变量分配一个寄存器，但是理论上一个寄存器中可以存放一个<code>int</code>，之后存放一个<code>String</code>（的引用），之后再存放一个别的东西。</p>
<p>如果要处理 64 位的值，需要连续的两个寄存器，但是代码中仍然只写一个寄存器。这种情况下，你在代码中看到的<code>vx</code>实际上是指<code>vx</code>和<code>vx + 1</code>。</p>
<p>寄存器有两种命名方法。<code>v</code>命名法简单直接。假设一共分配了 10 个寄存器，那么我们可以用<code>v0</code>到<code>v9</code>来命名它们。</p>
<p><a href="http://img.blog.csdn.net/20160731141440713" data-uk-lightbox><img src="http://img.blog.csdn.net/20160731141440713" alt=""></a></p>
<p>除此之外，还可以用<code>p</code>命名法来命名参数所用的寄存器，参数会占用后面的几个寄存器。假如上面那个方法是共有两个参数的静态方法，那么，我们就可以使用<code>p0</code>和<code>p1</code>取代<code>v8</code>和<code>v9</code>。如果是实例方法，那么可以用<code>p0 ~ p2</code>取代<code>v7 ~ v9</code>，其中<code>p0</code>是<code>this</code>引用。</p>
<p><a href="http://img.blog.csdn.net/20160731142057192" data-uk-lightbox><img src="http://img.blog.csdn.net/20160731142057192" alt=""></a></p>
<p>但在实际的代码中，一般不会声明所有寄存器的数量，而是直接声明局部变量所用的寄存器（后面会看到）。也就是说局部变量和参数的寄存器是分开声明的。我们无需关心<code>vx</code>是不是<code>py</code>，只需知道所有寄存器的数量是局部变量与参数数量的和。</p>
<h2 id="数据类型">数据类型</h2>
<p>Dalvik 拥有独特的数据类型表示方法，并且和 Java 类型一一对应：</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>Dalvik 表示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean</code></td>
<td>Z</td>
</tr>
<tr>
<td><code>byte</code></td>
<td>B</td>
</tr>
<tr>
<td><code>short</code></td>
<td>S</td>
</tr>
<tr>
<td><code>char</code></td>
<td>C</td>
</tr>
<tr>
<td><code>int</code></td>
<td>I</td>
</tr>
<tr>
<td><code>long</code></td>
<td>J</td>
</tr>
<tr>
<td><code>float</code></td>
<td>F</td>
</tr>
<tr>
<td><code>double</code></td>
<td>D</td>
</tr>
<tr>
<td><code>void</code></td>
<td>V</td>
</tr>
<tr>
<td>对象类型</td>
<td>L</td>
</tr>
<tr>
<td>数组类型</td>
<td>[</td>
</tr>
</tbody>
</table>
<p>其中对象类型由<code>L&lt;包名&gt;/&lt;类名&gt;;</code>（完全限定名称）表示，要注意末尾有个分号，比如<code>String</code>表示为<code>Ljava/lang/String;</code>。</p>
<p>数组类型是<code>[</code>加上元素类型，比如<code>int[]</code>表示为<code>[I</code>。左方括号的个数也就是数组的维数，比如<code>int[][]</code>表示为<code>[[I</code>。</p>
<h2 id="类定义">类定义</h2>
<p>一个 smali 文件中存放一个类，文件开头保存类的各种信息。类的定义是这样的。</p>
<pre><code>.class &lt;权限修饰符&gt; &lt;非权限修饰符&gt; &lt;完全限定名称&gt;
.super &lt;超类的完全限定名称&gt;
.source &lt;源文件名&gt;
</code></pre>
<p>比如这是某个<code>MainActivity</code>：</p>
<pre><code>.class public Lnet/flygon/myapplication/MainActivity;
.super Landroid/app/Activity;
.source "MainActivity.java"
</code></pre>
<p>我们可以看到该类是<code>public</code>的，完整名称是<code>net.flygon.myapplication.MainActivity</code>，继承了<code>android.app.Activity</code>，在源码中是<code>MainActivity.java</code>。如果类是<code>abstract</code>或者<code>final</code>的，会在<code>public/private/protected</code>后面表示。</p>
<p>类可以实现接口，如果类实现了接口，那么这三条语句下面会出现<code>.implements &lt;接口的完全限定名称&gt;</code>。比如通常用于回调的匿名类中会出现<code>.implements Landroid/view/View$OnClickListener;</code>。</p>
<p>类还可以拥有注解，同样，这三条语句下方出现这样的代码：</p>
<pre><code>.annotation &lt;完全限定名称&gt;
    键 = 值
    ...
.end annotation
</code></pre>
<p>这些语句下面就是类拥有的字段和方法。</p>
<h2 id="字段定义">字段定义</h2>
<p>字段定义如下：</p>
<pre><code>.field &lt;权限修饰符&gt; &lt;非权限修饰符&gt; &lt;名称&gt;:&lt;类型&gt;
</code></pre>
<p>其中非权限修饰符可以为<code>final</code>或者<code>abstract</code>。</p>
<p>比如我在<code>MainActivity</code>中定义一个按钮：</p>
<pre><code>.field private button1:Landroid/widget/Button;
</code></pre>
<h2 id="方法定义">方法定义</h2>
<p>方法定义如下：</p>
<pre><code>.method &lt;权限修饰符&gt; &lt;非权限修饰符&gt; &lt;名称&gt;(&lt;参数类型&gt;)&lt;返回值类型&gt;
    ...
.end method
</code></pre>
<p>要注意如果有多个参数，参数之间是紧密挨着的，没有逗号也没有空格。如果某个方法的参数是<code>int, int, String</code>，那么应该表示为<code>IILjava/lang/String;</code>。</p>
<h3 id="locals"><code>.locals</code></h3>
<p>方法里面可以包含很多很多东西，可以说是反编译的重点。首先，方法开头处可能会含有局部变量个数声明和参数声明。<code>.locals &lt;个数&gt;</code>可以用于变量个数声明，比如声明了<code>.locals 10</code>之后，我们就可以直接使用<code>v0</code>到<code>v9</code>的寄存器。</p>
<h3 id="param"><code>.param</code></h3>
<p>另外，参数虽然也占用寄存器，但是声明是不在一起的。<code>.param px,"&lt;名称&gt;"</code>用于声明参数。不知道是不是必需的。</p>
<h3 id="prologue"><code>.prologue</code></h3>
<p>之后<code>.prologue</code>的下面是方法中的代码。代码是接下来要讲的东西。</p>
<h3 id="line"><code>.line</code></h3>
<p>代码之间可能会出现<code>.line &lt;行号&gt;</code>，用来标识 Java 代码中对应的行，不过这个是非强制性的，修改之后对应不上也无所谓。</p>
<h3 id="local"><code>.local</code></h3>
<p>还可能出现局部变量声明，<code>.local vx, "&lt;名称&gt;":&lt;类型&gt;</code>。这个也是非强制性的，只是为了让你清楚哪些是具名变量，哪些是临时变量。临时变量没有这种声明，照样正常工作。甚至你把它改成不匹配的类型（<code>int</code>改成<code>Object</code>），也可以正常运行。</p>
<h2 id="数据定义">数据定义</h2>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>const/4 vx,lit4</td>
<td>将 4 位字面值<code>lit4</code>（扩展为 32 位）存入<code>vx</code></td>
</tr>
<tr>
<td>const/16 vx,lit16</td>
<td>将 16 位字面值<code>lit16</code>（扩展为 32 位）存入<code>vx</code></td>
</tr>
<tr>
<td>const vx, lit32</td>
<td>将 32 位字面值<code>lit32</code>存入<code>vx</code></td>
</tr>
<tr>
<td>const-wide/16 vx, lit16</td>
<td>将 16 位字面值<code>lit16</code>（扩展为 64 位）存入<code>vx</code>及<code>vx + 1</code></td>
</tr>
<tr>
<td>const-wide/32 vx, lit32</td>
<td>将 32 位字面值<code>lit32</code>（扩展为 64 位）存入<code>vx</code>及<code>vx + 1</code></td>
</tr>
<tr>
<td>const-wide vx, lit64</td>
<td>将 64 位字面值<code>lit64</code>存入<code>vx</code>及<code>vx + 1</code></td>
</tr>
<tr>
<td>const/high16 v0, lit16</td>
<td>将 16 位字面值<code>lit16</code>存入<code>vx</code>的高位</td>
</tr>
<tr>
<td>const-wide/high16, lit16</td>
<td>将 16 位字面值<code>lit16</code>存入<code>vx</code>和<code>vx + 1</code>的高位</td>
</tr>
<tr>
<td>const-string vx, string</td>
<td>将指字符串常量（的引用）<code>string</code>存入<code>vx</code></td>
</tr>
<tr>
<td>const-class vx, class</td>
<td>将指向类对象（的引用）<code>class</code>存入<code>vx</code></td>
</tr>
</tbody>
</table>
<p>这些指令会在我们给变量赋字面值的时候用到。下面我们来看看这些指令如何与 Java 代码对应，以下我定义了所有相关类型的变量。</p>
<pre><code class="language-java">boolean z = true;
z = false;
byte b = 1;
short s = 2;
int i = 3;
long l = 4;
float f = 0.1f;
double d = 0.2;
String str = "test";
Class c = Object.class;
</code></pre>
<p>编译之后的代码可能是这样：</p>
<pre><code>const/4 v10, 0x1
const/4 v10, 0x0
const/4 v0, 0x1
const/4 v8, 0x2
const/4 v5, 0x3
const-wide/16 v6, 0x4
const v4, 0x3dcccccd    # 0.1f
const-wide v2, 0x3fc999999999999aL    # 0.2
const-string v9, "test"
const-class v1, Ljava/lang/Object;
</code></pre>
<p>我们可以看到，<code>boolean</code>、<code>byte</code>、<code>short</code>、<code>int</code>都是使用<code>const</code>系列指令来加载的。我们在这里为其赋了比较小的值，所以它用了<code>const/4</code>。如果我们选择一个更大的值，编译器会采用<code>const/16</code>或者<code>const</code>指令。然后我们可以看到<code>const-wide/16</code>用于为<code>long</code>赋值，说明<code>const-wide</code>系列指令用于处理<code>long</code>。</p>
<p>接下来，<code>float</code>使用<code>const</code>指令处理，<code>double</code>使用<code>const-wide</code>指令处理。以<code>float</code>为例，它的<code>const</code>语句的字面值是<code>0x3dcccccd</code>，比较费解。实际上它是保持二进制数据不变，将其表示为<code>int</code>得到的。</p>
<p>我们可以用这段 c 代码来验证。</p>
<pre><code class="language-c">int main() {
    int i = 0x3dcccccd;
    float f = *(float *)&amp;i;
    printf("%f", f);
    return 0;
}
</code></pre>
<p>结果是<code>0.100000</code>，的确是我们当初赋值的 0.1。</p>
<p>最后，<code>const-string</code>用于加载字符串，<code>const-class</code>用于加载类对象。虽然文档中写着“字符串的 ID”，但实际的反编译代码中是字符串字面值，比较方便。对于类对象来说，代码中出现的是完全先定名称。</p>
<h2 id="数据移动">数据移动</h2>
<p>数据移动指令就是大名鼎鼎的<code>move</code>：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>move vx,vy</td>
<td><code>vx = vy</code></td>
</tr>
<tr>
<td>move/from16 vx,vy</td>
<td><code>vx = vy</code></td>
</tr>
<tr>
<td>move/16 vx,vy</td>
<td><code>vx = vy</code></td>
</tr>
<tr>
<td>move-wide vx,vy</td>
<td><code>vx, vx + 1 = vy, vy + 1</code></td>
</tr>
<tr>
<td>move-wide/from16 vx,vy</td>
<td><code>vx, vx + 1 = vy, vy + 1</code></td>
</tr>
<tr>
<td>move-wide/16 vx,vy</td>
<td><code>vx, vx + 1 = vy, vy + 1</code></td>
</tr>
<tr>
<td>move-object vx,vy</td>
<td><code>vx = vy</code></td>
</tr>
<tr>
<td>move-object/from16 vx,vy</td>
<td><code>vx = vy</code></td>
</tr>
<tr>
<td>move-object/16 vx,vy</td>
<td><code>vx = vy</code></td>
</tr>
<tr>
<td>move-result vx</td>
<td>将小于等于 32 位的基本类型（<code>int</code>等）的返回值赋给<code>vx</code></td>
</tr>
<tr>
<td>move-result-wide vx</td>
<td>将<code>long</code>和<code>double</code>类型的返回值赋给<code>vx</code></td>
</tr>
<tr>
<td>move-result-object vx</td>
<td>将对象类型的返回值（的引用）赋给<code>vx</code></td>
</tr>
<tr>
<td>move-exception vx</td>
<td>将异常对象（的引用）赋给<code>vx</code>，只能在<code>throw</code>之后使用</td>
</tr>
</tbody>
</table>
<p><code>move</code>系列指令以及<code>move-result</code>用于处理小于等于 32 位的基本类型。<code>move-wide</code>系列指令和<code>move-result-wide</code>用于处理<code>long</code>和<code>double</code>类型。<code>move-object</code>系列指令和<code>move-result-object</code>用于处理对象引用。</p>
<p>另外不同后缀（无、<code>/from16</code>、<code>/16</code>）只影响字节码的位数和寄存器的范围，不影响指令的逻辑。</p>
<h2 id="数据运算">数据运算</h2>
<h3 id="二元运算">二元运算</h3>
<p>二元运算指令格式为<code>&lt;运算类型&gt;-&lt;数据类型&gt; vx,vy,vz</code>。其中算术运算的<code>type</code>可以为<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>四种（<code>short</code>、<code>byte</code>按<code>int</code>处理），位运算的只支持<code>int</code>、<code>long</code>，下同。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>运算类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>add-
<type>
vx, vy, vz
</type></td>
<td>加法</td>
<td><code>vx = vy + vz</code></td>
</tr>
<tr>
<td>sub-
<type>
vx, vy, vz
</type></td>
<td>减法</td>
<td><code>vx = vy - vz</code></td>
</tr>
<tr>
<td>mul-
<type>
vx, vy, vz
</type></td>
<td>乘法</td>
<td><code>vx = vy * vz</code></td>
</tr>
<tr>
<td>div-
<type>
vx, vy, vz
</type></td>
<td>除法</td>
<td><code>vx = vy / vz</code></td>
</tr>
<tr>
<td>rem-
<type>
vx, vy, vz
</type></td>
<td>取余</td>
<td><code>vx = vy % vz</code></td>
</tr>
<tr>
<td>位运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>and-
<type>
vx, vy, vz
</type></td>
<td>与</td>
<td><code>vx = vy &amp; vz</code></td>
</tr>
<tr>
<td>or-
<type>
vx, vy, vz
</type></td>
<td>或</td>
<td><code>vx = vy | vz</code></td>
</tr>
<tr>
<td>xor-
<type>
vx, vy, vz
</type></td>
<td>异或</td>
<td><code>vx = vy ^ vz</code></td>
</tr>
<tr>
<td>shl-
<type>
vx, vy, vz
</type></td>
<td>左移</td>
<td><code>vx = vy &lt;&lt; vz</code></td>
</tr>
<tr>
<td>shr-
<type>
vx, vy, vz
</type></td>
<td>算术右移</td>
<td><code>vx = vy &gt;&gt; vz</code></td>
</tr>
<tr>
<td>ushr-
<type>
vx, vy, vz
</type></td>
<td>逻辑右移</td>
<td><code>vx = vy &gt;&gt;&gt; vz</code></td>
</tr>
</tbody>
</table>
<p>我们可以查看如下代码：</p>
<pre><code class="language-java">int a = 5,
    b = 2,
    c = a + b,
    d = a - b,
    e = a * b,
    f = a / b,
    g = a % b,
    h = a &amp; b,
    i = a | b,
    j = a ^ b,
    k = a &lt;&lt; b,
    l = a &gt;&gt; b,
    m = a &gt;&gt;&gt; b;
</code></pre>
<p>编译后的代码可能为：</p>
<pre><code>const/4 v0, 0x5
const/4 v1, 0x2
add-int v2, v0, v1
sub-int v3, v0, v1
mul-int v4, v0, v1
div-int v5, v0, v1
rem-int v6, v0, v1
and-int v7, v0, v1
or-int v8, v0, v1
xor-int v9, v0, v1
shl-int v10, v0, v1
shr-int v11, v0, v1
ushr-int v12, v0, v1
</code></pre>
<p>这里有个特例，当操作数类型是<code>int</code>，并且第二个操作数是字面值的时候，有一组特化的指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>运算类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>add-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>加法</td>
<td><code>vx = vy + &lt;litn&gt;</code></td>
</tr>
<tr>
<td>sub-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>减法</td>
<td><code>vx = vy - &lt;litn&gt;</code></td>
</tr>
<tr>
<td>mul-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>乘法</td>
<td><code>vx = vy * &lt;litn&gt;</code></td>
</tr>
<tr>
<td>div-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>除法</td>
<td><code>vx = vy / &lt;litn&gt;</code></td>
</tr>
<tr>
<td>rem-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>取余</td>
<td><code>vx = vy % &lt;litn&gt;</code></td>
</tr>
<tr>
<td>位运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>and-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>与</td>
<td><code>vx = vy &amp; &lt;litn&gt;</code></td>
</tr>
<tr>
<td>or-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>或</td>
<td><code>vx = vy | &lt;litn&gt;</code></td>
</tr>
<tr>
<td>xor-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>异或</td>
<td><code>vx = vy ^ &lt;litn&gt;</code></td>
</tr>
<tr>
<td>shl-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>左移</td>
<td><code>vx = vy &lt;&lt; &lt;litn&gt;</code></td>
</tr>
<tr>
<td>shr-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>算术右移</td>
<td><code>vx = vy &gt;&gt; &lt;litn&gt;</code></td>
</tr>
<tr>
<td>ushr-int/
<litn>
vx, vy,
<litn></litn>
</litn></td>
<td>逻辑右移</td>
<td><code>vx = vy &gt;&gt;&gt; &lt;litn&gt;</code></td>
</tr>
</tbody>
</table>
<p>其中<code>&lt;litn&gt;</code>可以为<code>lit8</code>或<code>lit16</code>，即 8 位或 16 位的整数字面值。比如<code>int a = 0; a += 2;</code>可能编译为<code>const/4 v0, 0</code>和<code>add-int/lit8 v0, v0, 0x2</code>。</p>
<h3 id="二元运算赋值">二元运算赋值</h3>
<p>二元运算赋值指令格式为<code>&lt;运算类型&gt;-&lt;数据类型&gt;/2 vx,vy,vz</code>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>运算类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>add-
<type>
/2addr vx, vy
</type></td>
<td>加法赋值</td>
<td><code>vx += vy</code></td>
</tr>
<tr>
<td>sub-
<type>
/2addr vx, vy
</type></td>
<td>减法赋值</td>
<td><code>vx -= vy</code></td>
</tr>
<tr>
<td>mul-
<type>
/2addr vx, vy
</type></td>
<td>乘法赋值</td>
<td><code>vx *= vy</code></td>
</tr>
<tr>
<td>div-
<type>
/2addr vx, vy
</type></td>
<td>除法赋值</td>
<td><code>vx /= vy</code></td>
</tr>
<tr>
<td>rem-
<type>
/2addr vx, vy
</type></td>
<td>取余赋值</td>
<td><code>vx %= vy</code></td>
</tr>
<tr>
<td>位运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>and-
<type>
/2addr vx, vy
</type></td>
<td>与赋值</td>
<td><code>vx &amp;= vy</code></td>
</tr>
<tr>
<td>or-
<type>
/2addr vx, vy
</type></td>
<td>或赋值</td>
<td><code>vx |= vy</code></td>
</tr>
<tr>
<td>xor-
<type>
/2addr vx, vy
</type></td>
<td>异或赋值</td>
<td><code>vx ^= vy</code></td>
</tr>
<tr>
<td>shl-
<type>
/2addr vx, vy
</type></td>
<td>左移赋值</td>
<td><code>vx &lt;&lt;= vy</code></td>
</tr>
<tr>
<td>shr-
<type>
/2addr vx, vy
</type></td>
<td>算术右移赋值</td>
<td><code>vx &gt;&gt;= vy</code></td>
</tr>
<tr>
<td>ushr-
<type>
/2addr vx, vy
</type></td>
<td>逻辑右移赋值</td>
<td><code>vx &gt;&gt;&gt;= vy</code></td>
</tr>
</tbody>
</table>
<p>我们可以查看这段代码：</p>
<pre><code class="language-java">int a = 5,
    b = 2;
a += b;
a -= b;
a *= b;
a /= b;
a %= b;
a &amp;= b;
a |= b;
a ^= b;
a &lt;&lt;= b;
a &gt;&gt;= b;
a &gt;&gt;&gt;= b;
</code></pre>
<p>可能会编译成：</p>
<pre><code>const/4 v0, 0x5
const/4 v1, 0x2
add-int/2addr v0, v1
sub-int/2addr v0, v1
mul-int/2addr v0, v1
div-int/2addr v0, v1
rem-int/2addr v0, v1
and-int/2addr v0, v1
or-int/2addr v0, v1
xor-int/2addr v0, v1
shl-int/2addr v0, v1
shr-int/2addr v0, v1
ushr-int/2addr v0, v1
</code></pre>
<h3 id="一元运算">一元运算</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>运算类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>neg-
<type>
vx, vy
</type></td>
<td>取负</td>
<td><code>vx = -vy</code></td>
</tr>
<tr>
<td>位运算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>not-
<type>
vx, vy
</type></td>
<td>取补</td>
<td><code>vx = ~vy</code></td>
</tr>
</tbody>
</table>
<p>简单来说，如果代码为<code>int a = 5, b = -a, c = ~a</code>，并且变量依次分配给<code>v0, v1, v2</code>的话，我们会得到<code>const/4 v0, 0x5</code>、<code>neg-int v1, v0</code>和<code>not-int v2, v0</code>。</p>
<h2 id="跳转">跳转</h2>
<h3 id="无条件">无条件</h3>
<p>Java 里面没有<code>goto</code>，但是 Smali 里面有，一般来说和<code>if</code>以及<code>for</code>配合的可能性很大，还有一个作用就是用于代码混淆。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>goto target</td>
<td>8 位无条件跳</td>
</tr>
<tr>
<td>goto/16 target</td>
<td>16 位无条件跳</td>
</tr>
<tr>
<td>goto/32 target</td>
<td>32 位无条件跳</td>
</tr>
</tbody>
</table>
<p><code>target</code>在 Smali 中是标签，以冒号开头，使用方式是这样：</p>
<pre><code>goto :label

# 一些语句

:label
</code></pre>
<p>这三个指令在使用形式上都一样，就是位数越大的语句支持的距离也越长。</p>
<h3 id="条件跳转">条件跳转</h3>
<p><code>if</code>系列指令可用于<code>int</code>（以及<code>short</code>、<code>char</code>、<code>byte</code>、<code>boolean</code>甚至是对象引用）：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>if-eq vx,vy,target</td>
<td><code>vx == vy</code>则跳到 target</td>
</tr>
<tr>
<td>if-ne vx,vy,target</td>
<td><code>vx != vy</code>则跳到 target</td>
</tr>
<tr>
<td>if-lt vx,vy,target</td>
<td><code>vx &lt; vy</code>则跳到 target</td>
</tr>
<tr>
<td>if-ge vx,vy,target</td>
<td><code>vx &gt;= vy</code>则跳到 target</td>
</tr>
<tr>
<td>if-gt vx,vy,target</td>
<td><code>vx &gt; vy</code>则跳到 target</td>
</tr>
<tr>
<td>if-le vx,vy,target</td>
<td><code>vx &lt;= vy</code>则跳到 target</td>
</tr>
<tr>
<td>if-eqz vx,target</td>
<td><code>vx == 0</code>则跳到 target</td>
</tr>
<tr>
<td>if-nez vx,target</td>
<td><code>vx != 0</code>则跳到 target</td>
</tr>
<tr>
<td>if-ltz vx,target</td>
<td><code>vx &lt; 0</code>则跳到 target</td>
</tr>
<tr>
<td>if-gez vx,target</td>
<td><code>vx &gt;= 0</code>则跳到 target</td>
</tr>
<tr>
<td>if-gtz vx,target</td>
<td><code>vx &gt; 0</code>则跳到 target</td>
</tr>
<tr>
<td>if-lez vx,target</td>
<td><code>vx &lt;= 0</code>则跳到 target</td>
</tr>
</tbody>
</table>
<p>看一下这段代码：</p>
<pre><code class="language-java">int a = 10
if(a &gt; 0) 
    a = 1;
else
    a = 0;
</code></pre>
<p>可能的编译结果是：</p>
<pre><code>const/4 v0, 0xa
if-lez v0, :cond_0 # if 块开始
const/4 v0, 0x1
goto :cond_1       # if 块结束
:cond_0            # else 块开始
const/4 v0, 0x0
:cond_1            # else 块结束
</code></pre>
<p>我们会看到用于比较逻辑是反着的，Java 里是大于，Smali 中就变成了小于等于，这个要注意。也有一些情况下，逻辑不是反着的，但是<code>if</code>块和<code>else</code>块会对调。还有，标签不一定是一样的，后面的数字会变，但是多数情况下都是两个标签，一个相对跳一个绝对跳。</p>
<p>如果只有<code>if</code>：</p>
<pre><code class="language-java">int a = 10;
if(a &gt; 0) 
    a = 1;
</code></pre>
<p>相对来说就简单一些，只需要在条件不满足时跳过<code>if</code>块即可：</p>
<pre><code>const/4 v0, 0xa
if-lez v0, :cond_0 # if 块开始
const/4 v0, 0x1
:cond_0            # if 块结束
</code></pre>
<h3 id="比较">比较</h3>
<p>对于<code>long</code>、<code>float</code>和<code>double</code>又该如何比较呢？Dalvik 提供了下面这些指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmpl-float vx, vy, vz</td>
<td><code>vx = -sgn(vy - vz)</code></td>
</tr>
<tr>
<td>cmpg-float vx, vy, vz</td>
<td><code>vx = sgn(vy - vz)</code></td>
</tr>
<tr>
<td>cmp-float vx, vy, vz</td>
<td><code>cmpg-float</code>的别名</td>
</tr>
<tr>
<td>cmpl-double vx, vy, vz</td>
<td><code>vx = -sgn(vy - vz)</code></td>
</tr>
<tr>
<td>cmpg-double vx, vy, vz</td>
<td><code>vx = sgn(vy - vz)</code></td>
</tr>
<tr>
<td>cmp-double vx, vy, vz</td>
<td><code>cmpg-double</code>的别名</td>
</tr>
<tr>
<td>cmp-long vx, vy, vz</td>
<td><code>vx = sgn(vy - vz)</code></td>
</tr>
</tbody>
</table>
<p>其中<code>sgn(x)</code>是符号函数，定义为：<code>x &gt; 0</code>时值为 1，<code>x = 0</code>时值为 0，<code>x &lt; 0</code>时值为 -1。</p>
<p>我们把之前例子中的<code>int</code>改为<code>float</code>：</p>
<pre><code class="language-java">float a = 10;
if(a &gt; 0) 
    a = 1;
else
    a = 0;
</code></pre>
<p>我们会得到：</p>
<pre><code>const v0, 0x41200000 # float 10
const v1, 0x0
cmp-float v2, v0, v1
if-lez v2, :cond_0   # if 块开始
const v0, 0x3f800000 # float 1
goto :goto_0         # if 块结束
:cond_0              # else 块开始
const/4 v0, 0x0
:goto_0              # else 块结束
</code></pre>
<p>由于<code>cmpg</code>更类似平时使用的比较器，用起来更加顺手，但是<code>cmpl</code>也需要了解。</p>
<h3 id="switch"><code>switch</code></h3>
<p>Dalvik 共支持两种<code>switch</code>，密集和稀疏。先来看密集<code>switch</code>，密集的意思是<code>case</code>的序号是挨着的：</p>
<pre><code class="language-java">int a = 10;
switch (a){
    case 0:
        a = 1;
        break;
    case 1:
        a = 5;
        break;
    case 2:
        a = 10;
        break;
    case 3:
        a = 20;
        break;
}
</code></pre>
<p>编译为：</p>
<pre><code>const/16 v0, 0xa

packed-switch v0, :pswitch_data_0 # switch 开始

:pswitch_0                        # case 0
const/4 v0, 0x1
goto :goto_0

:pswitch_1                        # case 1
const/4 v0, 0x5
goto :goto_0

:pswitch_2                        # case 2
const/16 v0, 0xa
goto :goto_0

:pswitch_3                        # case 3
const/16 v0, 0x14
goto :goto_0

:goto_0                           # switch 结束
return-void

:pswitch_data_0                   # 跳转表开始
.packed-switch 0x0                # 从 0 开始
    :pswitch_0
    :pswitch_1
    :pswitch_2
    :pswitch_3
.end packed-switch                # 跳转表结束
</code></pre>
<p>然后是稀疏<code>switch</code>：</p>
<pre><code class="language-java">int a = 10;
switch (a){
    case 0:
        a = 1;
        break;
    case 10:
        a = 5;
        break;
    case 20:
        a = 10;
        break;
    case 30:
        a = 20;
        break;
}
</code></pre>
<p>编译为：</p>
<pre><code>const/16 v0, 0xa

sparse-switch v0, :sswitch_data_0 # switch 开始

:sswitch_0                        # case 0
const/4 v0, 0x1
goto :goto_0

:sswitch_1                        # case 10
const/4 v0, 0x5

goto :goto_0

:sswitch_2                        # case 20
const/16 v0, 0xa
goto :goto_0

:sswitch_3                        # case 15
const/16 v0, 0x14
goto :goto_0

:goto_0                           # switch 结束
return-void

.line 55
:sswitch_data_0                   # 跳转表开始
.sparse-switch
    0x0 -&gt; :sswitch_0
    0xa -&gt; :sswitch_1
    0x14 -&gt; :sswitch_2
    0x1e -&gt; :sswitch_3
.end sparse-switch                # 跳转表结束
</code></pre>
<h2 id="数组操作">数组操作</h2>
<p>数组拥有一套特化的指令。</p>
<h3 id="创建">创建</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>new-array vx,vy,type</td>
<td>创建类型为<code>type</code>，大小为<code>vy</code>的数组赋给<code>vx</code></td>
</tr>
<tr>
<td>filled-new-array {params},type_id</td>
<td>从<code>params</code>创建数组，结果使用<code>move-result</code>获取</td>
</tr>
<tr>
<td>filled-new-array-range {vx..vy},type_id</td>
<td>从<code>vx</code>与<code>vy</code>之间（包含）的所有寄存器创建数组，结果使用<code>move-result</code>获取</td>
</tr>
</tbody>
</table>
<p>对于第一条指令，如果我们这样写：</p>
<pre><code class="language-java">int[] arr = new int[10];
</code></pre>
<p>就可以使用该指令编译：</p>
<pre><code>const/4 v1, 0xa
new-array v0, v1, I
</code></pre>
<p>但如果我们直接使用数组字面值给一个数组赋值：</p>
<pre><code>int[] arr = {1, 2, 3, 4, 5};
// 或者
arr = new int[]{1, 2, 3, 4, 5};
</code></pre>
<p>可以使用第二条指令编写如下：</p>
<pre><code>const/4 v1, 0x1
const/4 v2, 0x2
const/4 v3, 0x3
const/4 v4, 0x4
const/4 v5, 0x5
filled-new-array {v1, v2, v3, v4, v5}, I
move-result v0
</code></pre>
<p>我们这里的寄存器是连续的，实际上不一定是这样，如果寄存器是连续的，还可以改写为第三条指令：</p>
<pre><code>const/4 v1, 0x1
const/4 v2, 0x2
const/4 v3, 0x3
const/4 v4, 0x4
const/4 v5, 0x5
filled-new-array-range {v1..v5}, I
move-result v0
</code></pre>
<h3 id="元素操作">元素操作</h3>
<p><code>aget</code>系列指令用于读取数组元素，效果为<code>vx = vy[vz]</code>：</p>
<pre><code>aget vx,vy,vz
aget-wide vx,vy,vz
aget-object vx,vy,vz
aget-boolean vx,vy,vz
aget-byte vx,vy,vz
aget-char vx,vy,vz
aget-short vx,vy,vz
</code></pre>
<p>有两个指令需要说明，<code>aget</code>用于获取<code>int</code>和<code>float</code>，<code>aget-wide</code>用于获取<code>long</code>和<code>double</code>。</p>
<p>同样，<code>aput</code>系列指令用于写入数组元素，效果为<code>vy[vz] = vx</code>：</p>
<pre><code>aget vx,vy,vz
aget-wide vx,vy,vz
aget-object vx,vy,vz
aget-boolean vx,vy,vz
aget-byte vx,vy,vz
aget-char vx,vy,vz
aget-short vx,vy,vz
</code></pre>
<p>如果我们编写以下代码：</p>
<pre><code>int[] arr = new int[2];
int b = arr[0];
arr[1] = b;
</code></pre>
<p>可能会编译成：</p>
<pre><code>const/4 v0, 0x2
new-array v1, v0, I
const/4 v0, 0x0
aget-int v2, v1, v0
const/4 v0, 0x1
aput-int v2, v1, v0
</code></pre>
<h2 id="对象操作">对象操作</h2>
<h3 id="对象创建">对象创建</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>new-instance vx, type</td>
<td>创建<code>type</code>的新实例，并赋给<code>vx</code></td>
</tr>
</tbody>
</table>
<p><code>new-instance</code>用于创建实例，但之后还需要调用构造器<code>&lt;init&gt;</code>，比如：</p>
<pre><code>Object obj = new Object();
</code></pre>
<p>会编译成：</p>
<pre><code>new-instance v0, Ljava/lang/Object;
invoke-direct-empty {v0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V
</code></pre>
<p>方法调用后面再讲。</p>
<h3 id="字段操作">字段操作</h3>
<p><code>sget</code>系列指令用于获取静态字段，效果为<code>vx = class.field</code>：</p>
<pre><code>sget vx, type-&gt;field:field_type
sget-wide vx, type-&gt;field:field_type
sget-object vx, type-&gt;field:field_type
sget-boolean vx, type-&gt;field:field_type
sget-byte vx, type-&gt;field:field_type
sget-char vx, type-&gt;field:field_type
sget-short vx, type-&gt;field:field_type
</code></pre>
<p><code>sput</code>系列指令用于设置静态字段，效果为<code>class.field = vx</code>：</p>
<pre><code>sput vx, type-&gt;field:field_type
sput-wide vx, type-&gt;field:field_type
sput-object vx, type-&gt;field:field_type
sput-boolean vx, type-&gt;field:field_type
sput-byte vx, type-&gt;field:field_type
sput-char vx, type-&gt;field:field_type
sput-short vx, type-&gt;field:field_type
</code></pre>
<p>我们在这里创建一个类：</p>
<pre><code>public class Test 
{
    private static int staticField;
    
    public static int getStaticField() {
        return staticField;
    }
    
    public static void setStaticField(int staticField) {
        Test.staticField = staticField;
    }
}
</code></pre>
<p>编译之后，我们可以在<code>getStaticField</code>中找到：</p>
<pre><code>sget v0, Lnet/flygon/myapplication/Test;-&gt;staticField:I
return v0
</code></pre>
<p>在<code>setStaticField</code>中可以找到：</p>
<pre><code>sput p0, Lnet/flygon/myapplication/Test;-&gt;staticField:I
return-void
</code></pre>
<p><code>iget</code>系列指令用于获取实例字段，效果为<code>vx = vy.field</code>：</p>
<pre><code>iget vx, vy, type-&gt;field:field_type
iget-wide vx, vy, type-&gt;field:field_type
iget-object vx, vy, type-&gt;field:field_type
iget-boolean vx, vy, type-&gt;field:field_type
iget-byte vx, vy, type-&gt;field:field_type
iget-char vx, vy, type-&gt;field:field_type
iget-short vx, vy, type-&gt;field:field_type
</code></pre>
<p><code>iput</code>系列指令用于设置实例字段，效果为<code>vy.field = vx</code>：</p>
<pre><code>iput vx, vy, type-&gt;field:field_type
iput-wide vx, vy, type-&gt;field:field_type
iput-object vx, vy, type-&gt;field:field_type
iput-boolean vx, vy, type-&gt;field:field_type
iput-byte vx, vy, type-&gt;field:field_type
iput-char vx, vy, type-&gt;field:field_type
iput-short vx, vy, type-&gt;field:field_type
</code></pre>
<p>我们将之前的类修改一下：</p>
<pre><code>public class Test
{
    private int instanceField;

    public int getInstanceField() {
        return instanceField;
    }

    public void setInstanceField(int instanceField) {
       this.instanceField = instanceField;
    }
}
</code></pre>
<p>反编译之后，我们可以在<code>getInstanceField</code>中找到：·</p>
<pre><code>iget v0, p0, Lnet/flygon/myapplication/Test;-&gt;instanceField:I
return v0
</code></pre>
<p>在<code>setInstanceField</code>中可以找到：</p>
<pre><code>iset p1, p0, Lnet/flygon/myapplication/Test;-&gt;instanceField:I
return-void
</code></pre>
<p>在实例方法中，<code>this</code>引用永远是<code>p0</code>。第一个参数从<code>p1</code>开始。</p>
<h3 id="方法调用">方法调用</h3>
<p>有五类方法调用指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>invoke-static</td>
<td>调用静态方法</td>
</tr>
<tr>
<td>invoke-direct</td>
<td>调用直接方法</td>
</tr>
<tr>
<td>invoke-direct-empty</td>
<td>无参的<code>invoke-direct</code></td>
</tr>
<tr>
<td>invoke-virtual</td>
<td>调用虚方法</td>
</tr>
<tr>
<td>invoke-super</td>
<td>调用超类的虚方法</td>
</tr>
<tr>
<td>invoke-interface</td>
<td>调用接口方法</td>
</tr>
</tbody>
</table>
<p>这些指令的格式均为：</p>
<pre><code>invoke-* {params}, type-&gt;method(params_type)return_type
</code></pre>
<p>如果需要传递<code>this</code>引用，将其放置在<code>param</code>的第一个位置。</p>
<p>那么这些指令有什么不同呢？首先要分辨两个概念，虚方法和直接方法（JVM 里面叫特殊方法）。其实 Java 是没有虚方法这个概念的，但是 DVM 里面有，直接方法是指类的（<code>type</code>为某个类）所有实例构造器和<code>private</code>实例方法。反之<code>protected</code>或者<code>public</code>方法都叫做虚方法。</p>
<p><code>invoke-static</code>比较好分辨，当且仅当调用静态方法时，才会使用它。</p>
<p><code>invoke-direct</code>（在 JVM 中叫做<code>invokespecial</code>）用于调用直接方法，<code>invoke-virtual</code>用于调用虚方法。除了一种情况，显式使用<code>super</code>调用超类的虚方法时，使用<code>invoke-super</code>（直接方法仍然使用<code>invoke-direct</code>）。</p>
<p>就比如说，每个<code>Activity</code>的<code>onCreate</code>中要调用<code>super.onCreate</code>，该方法属于虚方法，于是我们会看到：</p>
<pre><code>invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V
</code></pre>
<p>但是呢，每个<code>Activity</code>构造器里面要调用<code>super</code>的无参构造器，它属于直接方法，那么我们会看到：</p>
<pre><code>invoke-direct {p0}, Landroid/app/Activity;-&gt;&lt;init&gt;()V
</code></pre>
<p><code>invoke-interface</code>用于调用接口方法，接口方法就是接口的方法，<code>type</code>一定为某个接口，而不是类。换句话说，类中实现的方法仍然是虚方法。比如我们在某个对象上调用<code>Map.get</code>，属于接口方法，但是调用<code>HashMap.get</code>，属于虚方法。这个指令一般在向上转型为接口类型的时候出现。</p>
<p>此外，五类指令中每一个都有对应的<code>invoke-*-range</code>指令，格式为：</p>
<pre><code>invoke-*-range {vx..vy},type-&gt;method(params_type)return_type
</code></pre>
<p>如果参数所在的寄存器的连续的，可以替换为这条指令。</p>
<h3 id="对象转换">对象转换</h3>
<p>对象转换有自己的一套检测方式，DVM 使用以下指令来实现：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>instance-of vx, vy, type</td>
<td>检验<code>vy</code>的类型是不是<code>type</code>，将结果存入<code>vx</code></td>
</tr>
<tr>
<td>check-cast vx, type</td>
<td>检验<code>vx</code>类型是不是<code>type</code>，不是的话会抛出<code>ClassCastException</code></td>
</tr>
</tbody>
</table>
<p><code>instance-of</code>指令对应 Java 的<code>instanceof</code>运算符。如果我们编写：</p>
<pre><code>String s = "test";
boolean b = s instanceof String;
</code></pre>
<p>可能会编译为：</p>
<pre><code>const-string v0, "test"
instance-of v1, v0, Ljava/lang/String;
</code></pre>
<p><code>check-cast</code>用于对象类型强制转换的情况，如果我们编写：</p>
<pre><code>String s = "test";
Object o = (Object)s;
</code></pre>
<p>那么就会：</p>
<pre><code>const-string v0, "test"
check-cast v0, Ljava/lang/Object;
move-object v1, v0
</code></pre>
<h2 id="返回">返回</h2>
<pre><code>return-void
return vx
return-wide vx
return-object vx
</code></pre>
<p>如果函数无返回值，那么使用<code>return-void</code>，注意在 Java 中，无返回值函数结尾处的<code>return</code>可以省，而 Smali 不可以。</p>
<p>如果函数需要返回对象，使用<code>return-object</code>；需要返回<code>long</code>或者<code>double</code>，使用<code>return-wide</code>；除此之外所有情况都使用<code>return</code>。</p>
<h2 id="异常指令">异常指令</h2>
<p>异常指令实际上只有一条，但是代码结构相当复杂。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>throw vx</td>
<td>抛出<code>vx</code>（所指向的对象）</td>
</tr>
</tbody>
</table>
<p>我们需要看看 Smali 如何处理异常。</p>
<h2 id="try-catch">try-catch</h2>
<p>不失一般性，我们构造以下语句：</p>
<pre><code class="language-java">int a = 10;
try {
    callSomeMethod();
} catch (Exception e) {
    a = 0;
}
callAnotherMethod();
</code></pre>
<p>可能会编译成这样，这些语句每个都不一样，可以按照特征来定位：</p>
<pre><code>const/16 v0, 0xa

:try_start_0            # try 块开始
invoke-direct {p0}, Lnet/flygon/myapplication/SubActivity;-&gt;callSomeMethod()V
:try_end_0              # try 块结束

.catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

:goto_0
invoke-direct {p0}, Lnet/flygon/myapplication/SubActivity;-&gt;callAnotherMethod()V
return-void

:catch_0                # catch 块开始
move-exception v1
const/4 v0, 0x0
goto :goto_0            # catch 块结束
</code></pre>
<p>我们可以看到，<code>:try_start_0</code>和<code>:try_end_0</code>之间的语句如果存在异常，则会向下寻找<code>.catch</code>（或者<code>.catch-all</code>）语句，符合条件时跳到标签的位置，这里是<code>:catch_0</code>，结束之后会有个<code>goto</code>跳回去。</p>
<h2 id="try-finally">try-finally</h2>
<pre><code class="language-java">int a = 10;
try {
    callSomeMethod();
} finally {
    a = 0;
}
callAnotherMethod();
</code></pre>
<p>编译之后是这样：</p>
<pre><code>const/16 v0, 0xa

:try_start_0            # try 块开始
invoke-direct {p0}, Lnet/flygon/myapplication/SubActivity;-&gt;callSomeMethod()V
:try_end_0              # try 块结束

.catchall {:try_start_0 .. :try_end_0} :catchall_0

const/4 v0, 0x0         # 复制一份到外面
invoke-direct {p0}, Lnet/flygon/myapplication/SubActivity;-&gt;callAnotherMethod()V
return-void

:catchall_0             # finally 块开始
move-exception v1
const/4 v0, 0x0
throw v1                # finally 块结束
</code></pre>
<p>我们可以看到，编译器把<code>finally</code>编译成了重新抛出的<code>.catch-all</code>，这在逻辑上也是说得通的。但是，<code>finally</code>中的逻辑在无异常情况下也会执行，所以需要复制一份到<code>finally</code>块的后面。</p>
<h3 id="try-catch-finally">try-catch-finally</h3>
<p>下面看看如果把这两个叠加起来会怎么样。</p>
<pre><code class="language-java">int a = 10;
try {
    callSomeMethod();
} catch (Exception e) {
    a = 1;
}
finally {
    a = 0;
}
callAnotherMethod();
</code></pre>
<pre><code>const/16 v0, 0xa

:try_start_0            # try 块开始
invoke-direct {p0}, Lnet/flygon/myapplication/SubActivity;-&gt;callSomeMethod()V
:try_end_0              # try 块结束

.catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0
.catchall {:try_start_0 .. :try_end_0} :catchall_0

const/4 v0, 0x0         # 复制一份到外面

:goto_0
invoke-direct {p0}, Lnet/flygon/myapplication/SubActivity;-&gt;callAnotherMethod()V
return-void

:catch_0                # catch 块开始
move-exception v1
const/4 v0, 0x1
const/4 v0, 0x0         # 复制一份到 catch 块里面
goto :goto_0            # catch 块结束

:catchall_0             # finally 块开始
move-exception v2
const/4 v0, 0x0
throw v2                # finally 块结束
</code></pre>
<p>我们可以看到，其中同时含有<code>.catch</code>块和<code>.catchall</code>块。有一些不同之处在于，<code>finally</code>块中的语句异常发生时也要执行，并且如果把<code>finally</code>编译成<code>.catchall</code>，那么和<code>.catch</code>就是互斥的，所以要复制一份到<code>catch</code>块里面。特别是<code>finally</code>块中的语句一多，就容易乱。</p>
<h2 id="锁">锁</h2>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>monitor-enter vx</td>
<td>获得<code>vx</code>所引用的对象的锁</td>
</tr>
<tr>
<td>monitor-exit vx</td>
<td>释放<code>vx</code>所引用的对象的锁</td>
</tr>
</tbody>
</table>
<p>对应 Java 的<code>synchronized</code>语句。而<code>synchronized</code>一般是被<code>try-finally</code>包起来的。</p>
<p>如果你编写：</p>
<pre><code>int a = 1;
synchronized(this) {
    a = 2;
}
</code></pre>
<p>就相当于</p>
<pre><code>int a = 1;
// monitor-enter this
try {
    a = 2;
} finally {
    // monitor-exit this
}
</code></pre>
<p>此外 Java 中没有与这两条指令相对应的方法，所以这两条指令一定成对出现。</p>
<h2 id="数据转换">数据转换</h2>
<h3 id="整数与浮点以及浮点与浮点">整数与浮点以及浮点与浮点</h3>
<pre><code>int-to-float vx, vy
int-to-double vx, vy
long-to-float vx, vy
long-to-double vx, vy
float-to-int vx, vy
float-to-long vx,vy
float-to-double vx, vy
double-to-int vx, vy
double-to-long vx, vy
double-to-float vx, vy
</code></pre>
<p>因为它们的表示方式不同，所以要保持表示的值不变，重新计算二进制位。如果不转换的话，就相当于二进制位不变，而表示的值改变，结果毫无意义。比如前面的<code>0.1f</code>如果不转换为直接使用，就会表示<code>0x3dcccccd</code>。</p>
<h3 id="整数之间的向上转换">整数之间的向上转换</h3>
<p>这种转换方式相当直接，<code>int</code>向<code>long</code>转换，<code>long</code>的第一个寄存器完全复制，第二个寄存器以<code>int</code>的最高位填充。除此之外没有其它的指令了，因为比<code>int</code>小的整数其实都是 32 位表示的，只是有效范围是 8 位或 16 位罢了（见数据定义）。</p>
<pre><code>int-to-long vx,vy
</code></pre>
<h3 id="整数之间的向下转换">整数之间的向下转换</h3>
<p>其规则是数据位截断，符号位保留。每个整数的最高位都是符号位，其余是数据位。以<code>int</code>转<code>short</code>为例，<code>int</code>的低 15 位复制给<code>short</code>，然后<code>int</code>的最高位（符号位）复制给<code>short</code>的最高位。其它同理。如果不转换而直接使用的话，会直接截断低 16 位，符号可能不能保留。</p>
<pre><code>long-to-int vx,vy
int-to-byte vx,vy
int-to-char vx,vy
int-to-short vx,vy
</code></pre>
<h2 id="nop">NOP</h2>
<p><code>nop</code>指令表示无操作。在一些场合下，不能修改二进制代码的字节数和偏移，需要用<code>nop</code>来填充，但是安卓逆向中几乎用不到。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.netmite.com/android/mydroid/dalvik/docs/dalvik-bytecode.html">Bytecode for the Dalvik VM</a></li>
<li><a href="http://blog.csdn.net/jiayanhui2877/article/details/41008985">Dalvik字节码含义查询表</a></li>
<li><a href="https://github.com/corkami/pics/blob/master/binary/DVM.png">DVM 指令集图解</a></li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/69/index.html">
<img class="uk-book-cover" src="../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/69/index.html">Android 资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1046个">1046</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/41/index.html">
<img class="uk-book-cover" src="../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/41/index.html">Android官方培訓課程中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/22.html">jasonblog</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">294页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/32/index.html">
<img class="uk-book-cover" src="../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/32/index.html">浅入浅出 Android 安全</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">9页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 59个">59</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/106/index.html">
<img class="uk-book-cover" src="../../static/icons/48/spark_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/106/index.html">Spark 编程指南简体中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/65.html">aiyanbo</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="spark">spark</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">65页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 150个">150</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/5/index.html">
<img class="uk-book-cover" src="../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/5/index.html">超级棒的"派神"书</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/5.html">zhaoolee</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">34页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../book/41/index.html">
<img class="uk-book-cover" src="../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../book/41/index.html">Android官方培訓課程中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../user/22.html">jasonblog</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">294页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../" title="返回首页"><img class="" src="../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../book/37/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../book/37/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../book/37/README.html" title="安卓逆向系列教程" data-book-page-rel-url="README.html" data-book-page-id="2232">安卓逆向系列教程</a>
</li>
<li>
<a class="pjax" href="../../book/37/1.html" title="安卓逆向系列教程（一）Dalvik 指令集" data-book-page-rel-url="1.html" data-book-page-id="2233">安卓逆向系列教程（一）Dalvik 指令集</a>
</li>
<li>
<a class="pjax" href="../../book/37/2.html" title="安卓逆向系列教程（二）APK 和 DEX" data-book-page-rel-url="2.html" data-book-page-id="2234">安卓逆向系列教程（二）APK 和 DEX</a>
</li>
<li>
<a class="pjax" href="../../book/37/3.html" title="安卓逆向系列教程（三）工具篇" data-book-page-rel-url="3.html" data-book-page-id="2235">安卓逆向系列教程（三）工具篇</a>
</li>
<li>
<a class="pjax" href="../../book/37/3.1.html" title="3.1 静态分析工具" data-book-page-rel-url="3.1.html" data-book-page-id="2236">3.1 静态分析工具</a>
</li>
<li>
<a class="pjax" href="../../book/37/3.2.html" title="3.2 抓取手机封包" data-book-page-rel-url="3.2.html" data-book-page-id="2237">3.2 抓取手机封包</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.html" title="安卓逆向系列教程（四）实战篇" data-book-page-rel-url="4.html" data-book-page-id="2238">安卓逆向系列教程（四）实战篇</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.1.html" title="4.1 字符串资源" data-book-page-rel-url="4.1.html" data-book-page-id="2239">4.1 字符串资源</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.2.html" title="4.2 分析锁机软件" data-book-page-rel-url="4.2.html" data-book-page-id="2240">4.2 分析锁机软件</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.3.html" title="4.3 登山赛车内购破解" data-book-page-rel-url="4.3.html" data-book-page-id="2241">4.3 登山赛车内购破解</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.4.html" title="4.4 逆向云播 VIP" data-book-page-rel-url="4.4.html" data-book-page-id="2242">4.4 逆向云播 VIP</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.5.html" title="4.5 糖果星星达人" data-book-page-rel-url="4.5.html" data-book-page-id="2243">4.5 糖果星星达人</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.6.html" title="4.6 去广告" data-book-page-rel-url="4.6.html" data-book-page-id="2244">4.6 去广告</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.7.html" title="4.7 修改游戏金币" data-book-page-rel-url="4.7.html" data-book-page-id="2245">4.7 修改游戏金币</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.8.html" title="4.8 去广告 II" data-book-page-rel-url="4.8.html" data-book-page-id="2246">4.8 去广告 II</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.9.html" title="4.9 破解内购 II" data-book-page-rel-url="4.9.html" data-book-page-id="2247">4.9 破解内购 II</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.10.html" title="4.10 玄奥八字" data-book-page-rel-url="4.10.html" data-book-page-id="2248">4.10 玄奥八字</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.11.html" title="4.11 优酷 APK 去广告" data-book-page-rel-url="4.11.html" data-book-page-id="2249">4.11 优酷 APK 去广告</a>
</li>
<li>
<a class="pjax" href="../../book/37/4.12.html" title="4.12 MagSearch 1.8 爆破" data-book-page-rel-url="4.12.html" data-book-page-id="2250">4.12 MagSearch 1.8 爆破</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =37;var bookPageId =2233;var bookPageRelUrl ='1.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>