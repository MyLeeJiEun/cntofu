
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Swift 初见-Swift 官方教程(The Swift Programming Language)</title>
<meta content='Swift 初见,Swift 官方教程,The Swift Programming Language' name='keywords'>
<meta content='Swift 初见,Swift 官方教程,The Swift Programming Language' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../../book/12/source/chapter1/02_version_compatibility.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">版本兼容性</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../../book/12/source/chapter1/04_revision_history.html">
<span class="">Swift 版本历史记录</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../../book/12/index.html">Swift 官方教程 (The Swift Programming Language)</a>
<a target="_blank" rel="nofollow" href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="swift-初见a-swift-tour">Swift 初见（A Swift Tour）</h1>
<hr>
<blockquote>
<p>1.0 翻译：<a href="https://github.com/numbbbbb">numbbbbb</a> 校对：<a href="https://github.com/shinyzhu">shinyzhu</a>, <a href="https://github.com/stanzhai">stanzhai</a></p>
</blockquote>
<blockquote>
<p>2.0 翻译+校对：<a href="https://github.com/xtymichael">xtymichael</a></p>
</blockquote>
<blockquote>
<p>2.2 翻译：<a href="https://github.com/Brian175">175</a>，2016-04-09 校对：<a href="https://github.com/SketchK">SketchK</a>，2016-05-11</p>
</blockquote>
<blockquote>
<p>3.0 翻译+校对：<a href="http://codebuild.me">shanks</a>，2016-10-06</p>
</blockquote>
<blockquote>
<p>3.0.1 review: 2016-11-09</p>
</blockquote>
<blockquote>
<p>3.1 校对: <a href="https://github.com/SketchK">SketchK</a> 2017-04-08</p>
</blockquote>
<blockquote>
<p>4.0 翻译+校对：<a href="https://github.com/muhlenxi">muhlenxi</a> 2017-09-26</p>
</blockquote>
<blockquote>
<p>4.1 翻译：<a href="https://github.com/mylittleswift">mylittleswift</a></p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#simple_values">简单值（Simple Values）</a></li>
<li><a href="#control_flow">控制流（Control Flow）</a></li>
<li><a href="#functions_and_closures">函数和闭包（Functions and Closures）</a></li>
<li><a href="#objects_and_classes">对象和类（Objects and Classes）</a></li>
<li><a href="#enumerations_and_structures">枚举和结构体（Enumerations and Structures）</a></li>
<li><a href="#protocols_and_extensions">协议和扩展（Protocols and Extensions）</a></li>
<li><a href="#error_handling">错误处理（Error Handling）</a></li>
<li><a href="#generics">泛型（Generics）</a></li>
</ul>
<p>通常来说，编程语言教程中的第一个程序应该在屏幕上打印 “Hello, world”。在 Swift 中，可以用一行代码实现：</p>
<pre><code class="language-swift">print("Hello, world!")
</code></pre>
<p>如果你写过 C 或者 Objective-C 代码，那你应该很熟悉这种形式——在 Swift 中，这行代码就是一个完整的程序。你不需要为了输入输出或者字符串处理导入一个单独的库。全局作用域中的代码会被自动当做程序的入口点，所以你也不需要 <code>main()</code> 函数。你同样不需要在每个语句结尾写上分号。</p>
<p>这个教程会通过一系列编程例子来让你对 Swift 有初步了解，如果你有什么不理解的地方也不用担心——任何本章介绍的内容都会在后面的章节中详细讲解到。</p>
<blockquote>
<p>注意</p>
<p>最好的体验是把这一章作为 Playground 文件在 Xcode 中打开。 Playgrounds 允许你可以编辑代码并立刻看到输出结果。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip">Download Playground</a></p>
</blockquote>
<p><a name="simple_values"></a></p>
<h2 id="简单值">简单值</h2>
<p>使用 <code>let</code> 来声明常量，使用 <code>var</code> 来声明变量。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能为它赋值一次。这说明你可以用一个常量来命名一个值，一次赋值就即可在多个地方使用。</p>
<pre><code class="language-swift">var myVariable = 42
myVariable = 50
let myConstant = 42
</code></pre>
<p>常量或者变量的类型必须和你赋给它们的值一样。然而，你不用明确地声明类型。当你通过一个值来声明变量和常量时，编译器会自动推断其类型。在上面的例子中，编译器推断出 <code>myVariable</code> 是一个整数类型，因为它的初始值是整数。</p>
<p>如果初始值没有提供足够的信息（或者没有初始值），那你需要在变量后面声明类型，用冒号分割。</p>
<pre><code class="language-swift">let implicitInteger = 70
let implicitDouble = 70.0
let explicitDouble: Double = 70
</code></pre>
<blockquote>
<p>练习</p>
<p>创建一个常量，显式指定类型为 <code>Float</code> 并指定初始值为 4。</p>
</blockquote>
<p>值永远不会被隐式转换为其他类型。如果你需要把一个值转换成其他类型，请显式转换。</p>
<pre><code class="language-swift">let label = "The width is"
let width = 94
let widthLabel = label + String(width)
</code></pre>
<blockquote>
<p>练习</p>
<p>删除最后一行中的 <code>String</code>，错误提示是什么？</p>
</blockquote>
<p>有一种更简单的把值转换成字符串的方法：把值写到括号中，并且在括号之前写一个反斜杠（\）。例如：</p>
<pre><code class="language-swift">let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fruitSummary = "I have \(apples + oranges) pieces of fruit."
</code></pre>
<blockquote>
<p>练习</p>
<p>使用 <code>\()</code> 来把一个浮点计算转换成字符串，并加上某人的名字，和他打个招呼。</p>
</blockquote>
<p>使用一对三个单引号（<code>"""</code>）来包含多行字符串内容，字符串中的内容（包括引号、空格、换行符等）都会保留下来。举个例子：</p>
<pre><code class="language-swift">let quotation = """
I said "I have \(apples) apples."
And then I said "I have \(apples + oranges) pieces of fruit."
"""
</code></pre>
<p>使用方括号 <code>[]</code> 来创建数组和字典，并使用下标或者键（key）来访问元素。最后一个元素后面允许有个逗号。</p>
<pre><code class="language-swift">var shoppingList = ["catfish", "water", "tulips", "blue paint"]
shoppingList[1] = "bottle of water"

var occupations = [
    "Malcolm": "Captain",
    "Kaylee": "Mechanic",
]
occupations["Jayne"] = "Public Relations"
</code></pre>
<p>使用初始化语法来创建一个空数组或者空字典。</p>
<pre><code class="language-swift">let emptyArray = [String]()
let emptyDictionary = [String: Float]()
</code></pre>
<p>如果类型信息可以被推断出来，你可以用 <code>[]</code> 和 <code>[:]</code> 来创建空数组和空字典——就像你声明变量或者给函数传参数的时候一样。</p>
<pre><code class="language-swift">shoppingList = []
occupations = [:]
</code></pre>
<p><a name="control_flow"></a></p>
<h2 id="控制流">控制流</h2>
<p>使用 <code>if</code> 和 <code>switch</code> 来进行条件操作，使用 <code>for-in</code>、<code>while</code> 和 <code>repeat-while</code> 来进行循环。包裹条件和循环变量的括号可以省略，但是语句体的大括号是必须的。</p>
<pre><code class="language-swift">let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score &gt; 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
print(teamScore)
</code></pre>
<p>在 <code>if</code> 语句中，条件必须是一个布尔表达式——这意味着像 <code>if score { ... }</code> 这样的代码将报错，而不会隐形地与 0 做对比。</p>
<p>你可以一起使用 <code>if</code> 和 <code>let</code> 一起来处理值缺失的情况。这些值可由可选值来代表。一个可选的值是一个具体的值或者是 <code>nil</code> 以表示值缺失。在类型后面加一个问号（<code>?</code>）来标记这个变量的值是可选的。</p>
<pre><code class="language-swift">var optionalString: String? = "Hello"
print(optionalString == nil)

var optionalName: String? = "John Appleseed"
var greeting = "Hello!"
if let name = optionalName {
    greeting = "Hello, \(name)"
}
</code></pre>
<blockquote>
<p>练习</p>
<p>把 <code>optionalName</code> 改成 <code>nil</code>，greeting 会是什么？添加一个 <code>else</code> 语句，当 <code>optionalName</code> 是 <code>nil</code> 时给 greeting 赋一个不同的值。</p>
</blockquote>
<p>如果变量的可选值是 <code>nil</code>，条件会判断为 <code>false</code>，大括号中的代码会被跳过。如果不是 <code>nil</code>，会将值解包并赋给 <code>let</code> 后面的常量，这样代码块中就可以使用这个值了。 另一种处理可选值的方法是通过使用 <code>??</code> 操作符来提供一个默认值。如果可选值缺失的话，可以使用默认值来代替。</p>
<pre><code class="language-swift">let nickName: String? = nil
let fullName: String = "John Appleseed"
let informalGreeting = "Hi \(nickName ?? fullName)"
</code></pre>
<p><code>switch</code> 支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。</p>
<pre><code class="language-swift">let vegetable = "red pepper"
switch vegetable {
case "celery":
    print("Add some raisins and make ants on a log.")
case "cucumber", "watercress":
    print("That would make a good tea sandwich.")
case let x where x.hasSuffix("pepper"):
    print("Is it a spicy \(x)?")
default:
    print("Everything tastes good in soup.")
}
</code></pre>
<blockquote>
<p>练习</p>
<p>删除 <code>default</code> 语句，看看会有什么错误？</p>
</blockquote>
<p>注意 <code>let</code> 在上述例子的等式中是如何使用的，它将匹配等式的值赋给常量 <code>x</code>。</p>
<p>运行 <code>switch</code> 中匹配到的 <code>case</code> 语句之后，程序会退出 <code>switch</code> 语句，并不会继续向下运行，所以不需要在每个子句结尾写 <code>break</code>。</p>
<p>你可以使用 <code>for-in</code> 来遍历字典，需要一对儿变量来表示每个键值对。字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。</p>
<pre><code class="language-swift">let interestingNumbers = [
    "Prime": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Square": [1, 4, 9, 16, 25],
]
var largest = 0
for (kind, numbers) in interestingNumbers {
    for number in numbers {
        if number &gt; largest {
            largest = number
        }
    }
}
print(largest)
</code></pre>
<blockquote>
<p>练习</p>
<p>添加另一个变量来记录最大数字的种类（kind），同时仍然记录这个最大数字的值。</p>
</blockquote>
<p>使用 <code>while</code> 来重复运行一段代码直到条件改变。循环条件也可以在结尾，保证能至少循环一次。</p>
<pre><code class="language-swift">var n = 2
while n &lt; 100 {
    n *= 2
}
print(n)

var m = 2
repeat {
    m *= 2
} while m &lt; 100
print(m)
</code></pre>
<p>你可以在循环中使用 <code>..&lt;</code> 来表示下标范围。</p>
<pre><code class="language-swift">var total = 0
for i in 0..&lt;4 {
	total += i
}
print(total)
</code></pre>
<p>使用 <code>..&lt;</code> 创建的范围不包含上界，如果想包含的话需要使用 <code>...</code>。</p>
<p><a name="functions_and_closures"></a></p>
<h2 id="函数和闭包">函数和闭包</h2>
<p>使用 <code>func</code> 来声明一个函数，使用名字和参数来调用函数。使用 <code>-&gt;</code> 来指定函数返回值的类型。</p>
<pre><code class="language-swift">func greet(person: String, day: String) -&gt; String {
    return "Hello \(person), today is \(day)."
}
greet(person:"Bob", day: "Tuesday")
</code></pre>
<blockquote>
<p>练习</p>
<p>删除 <code>day</code> 参数，添加一个参数来表示今天吃了什么午饭。</p>
</blockquote>
<p>默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 <code>_</code> 表示不使用参数标签。</p>
<pre><code class="language-swift">func greet(_ person: String, on day: String) -&gt; String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
</code></pre>
<p>使用元组来生成复合值，比如让一个函数返回多个值。该元组的元素可以用名称或数字来获取。</p>
<pre><code class="language-swift">func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0

    for score in scores {
        if score &gt; max {
            max = score
        } else if score &lt; min {
            min = score
        }
        sum += score
    }

    return (min, max, sum)
}
let statistics = calculateStatistics(scores:[5, 3, 100, 3, 9])
print(statistics.sum)
print(statistics.2)
</code></pre>
<p>函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。</p>
<pre><code class="language-swift">func returnFifteen() -&gt; Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
</code></pre>
<p>函数是第一等类型，这意味着函数可以作为另一个函数的返回值。</p>
<pre><code class="language-swift">func makeIncrementer() -&gt; ((Int) -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre>
<p>函数也可以当做参数传入另一个函数。</p>
<pre><code class="language-swift">func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
</code></pre>
<p>函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包作用域中的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数的例子中看过了。你可以使用 <code>{}</code> 来创建一个匿名闭包。使用 <code>in</code> 将参数和返回值类型的声明与闭包函数体进行分离。</p>
<pre><code class="language-swift">numbers.map({
    (number: Int) -&gt; Int in
    let result = 3 * number
    return result
})
</code></pre>
<blockquote>
<p>练习</p>
<p>重写闭包，对所有奇数返回 0。</p>
</blockquote>
<p>有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个代理的回调，你可以忽略参数，返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。</p>
<pre><code class="language-swift">let mappedNumbers = numbers.map({ number in 3 * number })
print(mappedNumbers)
</code></pre>
<p>你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。</p>
<pre><code class="language-swift">let sortedNumbers = numbers.sorted { $0 &gt; $1 }
print(sortedNumbers)
</code></pre>
<p><a name="objects_and_classes"></a></p>
<h2 id="对象和类">对象和类</h2>
<p>使用 <code>class</code> 和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。</p>
<pre><code class="language-swift">class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
        return "A shape with \(numberOfSides) sides."
    }
}
</code></pre>
<blockquote>
<p>练习</p>
<p>使用 <code>let</code> 添加一个常量属性，再添加一个接收一个参数的方法。</p>
</blockquote>
<p>要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。</p>
<pre><code class="language-swift">var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre>
<p>这个版本的 <code>Shape</code> 类缺少了一些重要的东西：一个构造函数来初始化类实例。使用 <code>init</code> 来创建一个构造器。</p>
<pre><code class="language-swift">class NamedShape {
    var numberOfSides: Int = 0
    var name: String

    init(name: String) {
        self.name = name
    }

    func simpleDescription() -&gt; String {
        return "A shape with \(numberOfSides) sides."
    }
}
</code></pre>
<p>注意 <code>self</code> 被用来区别实例变量 <code>name</code> 和构造器的参数 <code>name</code>。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像 <code>numberOfSides</code>）还是通过构造器（就像 <code>name</code>）。</p>
<p>如果你需要在对象释放之前进行一些清理工作，使用 <code>deinit</code> 创建一个析构函数。</p>
<p>子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以根据需要添加或者忽略父类。</p>
<p>子类如果要重写父类的方法的话，需要用 <code>override</code> 标记——如果没有添加 <code>override</code> 就重写父类方法的话编译器会报错。编译器同样会检测 <code>override</code> 标记的方法是否确实在父类中。</p>
<pre><code class="language-swift">class Square: NamedShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }

    func area() -&gt;  Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -&gt; String {
        return "A square with sides of length \(sideLength)."
    }
}
let test = Square(sideLength: 5.2, name: "my test square")
test.area()
test.simpleDescription()
</code></pre>
<blockquote>
<p>练习</p>
<p>创建 <code>NamedShape</code> 的另一个子类 <code>Circle</code>，构造器接收两个参数，一个是半径一个是名称，在子类 <code>Circle</code> 中实现 <code>area()</code> 和 <code>simpleDescription()</code> 方法。</p>
</blockquote>
<p>除了储存简单的属性之外，属性可以有 getter 和 setter 。</p>
<pre><code class="language-swift">class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }

    var perimeter: Double {
        get {
            return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }

    override func simpleDescription() -&gt; String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
print(triangle.perimeter)
triangle.perimeter = 9.9
print(triangle.sideLength)
</code></pre>
<p>在 <code>perimeter</code> 的 setter 中，新值的名字是 <code>newValue</code>。你可以在 <code>set</code> 之后显式的设置一个名字。</p>
<p>注意 <code>EquilateralTriangle</code> 类的构造器执行了三步：</p>
<ol>
<li>设置子类声明的属性值</li>
<li>调用父类的构造器</li>
<li>改变父类定义的属性值。其他的工作比如调用方法、getters 和 setters 也可以在这个阶段完成。</li>
</ol>
<p>如果你不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用 <code>willSet</code> 和 <code>didSet</code>。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况。比如，下面的类确保三角形的边长总是和正方形的边长相同。</p>
<pre><code class="language-swift">class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
print(triangleAndSquare.square.sideLength)
print(triangleAndSquare.triangle.sideLength)
triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
print(triangleAndSquare.triangle.sideLength)
</code></pre>
<p>处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加 <code>?</code>。如果 <code>?</code> 之前的值是 <code>nil</code>，<code>?</code> 后面的东西都会被忽略，并且整个表达式返回 <code>nil</code>。否则，<code>?</code> 之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。</p>
<pre><code class="language-swift">let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
let sideLength = optionalSquare?.sideLength
</code></pre>
<p><a name="enumerations_and_structure"></a></p>
<h2 id="枚举和结构体">枚举和结构体</h2>
<p>使用 <code>enum</code> 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。</p>
<pre><code class="language-swift">enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king
    func simpleDescription() -&gt; String {
        switch self {
        case .ace:
            return "ace"
        case .jack:
            return "jack"
        case .queen:
            return "queen"
        case .king:
            return "king"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
</code></pre>
<blockquote>
<p>练习</p>
<p>写一个函数，通过比较它们的原始值来比较两个 <code>Rank</code> 值。</p>
</blockquote>
<p>默认情况下，Swift 按照从 0 开始每次加 1 的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中，<code>Ace</code> 被显式赋值为 1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为枚举的原始值。使用 <code>rawValue</code> 属性来访问一个枚举成员的原始值。</p>
<p>使用 <code>init?(rawValue:)</code> 初始化构造器来创建一个带有原始值的枚举成员。如果存在与原始值相应的枚举成员就返回该枚举成员，否则就返回 <code>nil</code>。</p>
<pre><code class="language-swift">if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
</code></pre>
<p>枚举的关联值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。</p>
<pre><code class="language-swift">enum Suit {
    case spades, hearts, diamonds, clubs
    func simpleDescription() -&gt; String {
        switch self {
        case .spades:
            return "spades"
        case .hearts:
            return "hearts"
        case .diamonds:
            return "diamonds"
        case .clubs:
            return "clubs"
        }
    }
}
let hearts = Suit.hearts
let heartsDescription = hearts.simpleDescription()
</code></pre>
<blockquote>
<p>练习</p>
<p>给 <code>Suit</code> 添加一个 <code>color()</code> 方法，对 <code>spades</code> 和 <code>clubs</code> 返回 “black” ，对 <code>hearts</code> 和 <code>diamonds</code> 返回 “red” 。</p>
</blockquote>
<p>注意在上面的例子中用了两种方式引用 <code>hearts</code> 枚举成员：给 <code>hearts</code> 常量赋值时，枚举成员 <code>Suit.hearts</code> 需要用全名来引用，因为常量没有显式指定类型。在 <code>switch</code> 里，枚举成员使用缩写 <code>.hearts</code> 来引用，因为 <code>self</code> 的值已经是一个 <code>suit</code> 类型，在已知变量类型的情况下可以使用缩写。</p>
<p>如果枚举成员的实例有原始值，那么这些值是在声明的时候就已经决定了，这意味着不同枚举实例的枚举成员总会有一个相同的原始值。当然我们也可以为枚举成员设定关联值，关联值是在创建实例时决定的。这意味着不同的枚举成员的关联值都可以不同。你可以把关联值想象成枚举成员的寄存属性。例如，考虑从服务器获取日出和日落的时间的情况。服务器会返回正常结果或者错误信息。</p>
<pre><code class="language-swift">enum ServerResponse {
    case result(String, String)
    case failure(String)
}

let success = ServerResponse.result("6:00 am", "8:09 pm")
let failure = ServerResponse.failure("Out of cheese.")

switch success {
case let .result(sunrise, sunset):
    print("Sunrise is at \(sunrise) and sunset is at \(sunset)")
case let .failure(message):
    print("Failure...  \(message)")
}
</code></pre>
<blockquote>
<p>练习</p>
<p>给 <code>ServerResponse</code> 和 switch 添加第三种情况。</p>
</blockquote>
<p>注意日升和日落时间是如何从 <code>ServerResponse</code> 中提取到并与 <code>switch</code> 的 <code>case</code> 相匹配的。</p>
<p>使用 <code>struct</code> 来创建一个结构体。结构体和类有很多相同的地方，包括方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。</p>
<pre><code class="language-swift">struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -&gt; String {
        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
    }
}
let threeOfSpades = Card(rank: .three, suit: .spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
</code></pre>
<blockquote>
<p>练习</p>
<p>给 <code>Card</code> 添加一个方法，创建一副完整的扑克牌并把每张牌的 rank 和 suit 对应起来。</p>
</blockquote>
<p><a name="protocols_and_extensions"></a></p>
<h2 id="协议和扩展">协议和扩展</h2>
<p>使用 <code>protocol</code> 来声明一个协议。</p>
<pre><code class="language-swift">protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
</code></pre>
<p>类、枚举和结构体都可以遵循协议。</p>
<pre><code class="language-swift">class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
</code></pre>
<blockquote>
<p>练习</p>
<p>写一个实现这个协议的枚举。</p>
</blockquote>
<p>注意声明 <code>SimpleStructure</code> 时候 <code>mutating</code> 关键字用来标记一个会修改结构体的方法。<code>SimpleClass</code> 的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。</p>
<p>使用 <code>extension</code> 来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展让某个在别处声明的类型来遵守某个协议，这同样适用于从外部库或者框架引入的类型。</p>
<pre><code class="language-swift">extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)
</code></pre>
<blockquote>
<p>练习</p>
<p>给 <code>Double</code> 类型写一个扩展，添加 <code>absoluteValue</code> 属性。</p>
</blockquote>
<p>你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象集合。当你处理类型是协议的值时，协议外定义的方法不可用。</p>
<pre><code class="language-swift">let protocolValue: ExampleProtocol = a
print(protocolValue.simpleDescription)
// print(protocolValue.anotherProperty)  // 去掉注释可以看到错误
</code></pre>
<p>即使 <code>protocolValue</code> 变量运行时的类型是 <code>simpleClass</code> ，编译器还是会把它的类型当做 <code>ExampleProtocol</code>。这表示你不能调用在协议之外的方法或者属性。</p>
<p><a name="error_handling"></a></p>
<h2 id="错误处理">错误处理</h2>
<p>使用采用 <code>Error</code> 协议的类型来表示错误。</p>
<pre><code class="language-swift">enum PrinterError: Error {
	case outOfPaper
	case noToner
	case onFire
}
</code></pre>
<p>使用 <code>throw</code> 来抛出一个错误和使用 <code>throws</code> 来表示一个可以抛出错误的函数。如果在函数中抛出一个错误，这个函数会立刻返回并且调用该函数的代码会进行错误处理。</p>
<pre><code class="language-swift">func send(job: Int, toPrinter printerName: String) throws -&gt; String {
    if printerName == "Never Has Toner" {
        throw PrinterError.noToner
    }
    return "Job sent"
}
</code></pre>
<p>有多种方式可以用来进行错误处理。一种方式是使用 <code>do-catch</code> 。在 <code>do</code> 代码块中，使用 <code>try</code> 来标记可以抛出错误的代码。在 <code>catch</code> 代码块中，除非你另外命名，否则错误会自动命名为 <code>error</code> 。</p>
<pre><code class="language-swift">do {
    let printerResponse = try send(job: 1040, toPrinter: "Bi Sheng")
    print(printerResponse)
} catch {
    print(error)
}
</code></pre>
<blockquote>
<p>练习</p>
<p>将 printer name 改为 <code>"Never Has Toner"</code> 使 <code>send(job:toPrinter:)</code> 函数抛出错误。</p>
</blockquote>
<p>可以使用多个 <code>catch</code> 块来处理特定的错误。参照 switch 中的 <code>case</code> 风格来写 <code>catch</code>。</p>
<pre><code class="language-swift">do {
    let printerResponse = try send(job: 1440, toPrinter: "Gutenberg")
    print(printerResponse)
} catch PrinterError.onFire {
    print("I'll just put this over here, with the rest of the fire.")
} catch let printerError as PrinterError {
    print("Printer error: \(printerError).")
} catch {
    print(error)
}
</code></pre>
<blockquote>
<p>练习</p>
<p>在 <code>do</code> 代码块中添加抛出错误的代码。你需要抛出哪种错误来使第一个 <code>catch</code> 块进行接收？怎么使第二个和第三个 <code>catch</code> 进行接收呢？</p>
</blockquote>
<p>另一种处理错误的方式使用 <code>try?</code> 将结果转换为可选的。如果函数抛出错误，该错误会被抛弃并且结果为 <code>nil</code>。否则，结果会是一个包含函数返回值的可选值。</p>
<pre><code class="language-swift">let printerSuccess = try? send(job: 1884, toPrinter: "Mergenthaler")
let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner")
</code></pre>
<p>使用 <code>defer</code> 代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执行。使用 <code>defer</code>，可以把函数调用之初就要执行的代码和函数调用结束时的扫尾代码写在一起，虽然这两者的执行时机截然不同。</p>
<pre><code class="language-swift">var fridgeIsOpen = false
let fridgeContent = ["milk", "eggs", "leftovers"]

func fridgeContains(_ food: String) -&gt; Bool {
	fridgeIsOpen = true
	defer {
		fridgeIsOpen = false
	}
	
	let result = fridgeContent.contains(food)
	return result
}
fridgeContains("banana")
print(fridgeIsOpen)
</code></pre>
<p><a name="generics"></a></p>
<h2 id="泛型">泛型</h2>
<p>在尖括号里写一个名字来创建一个泛型函数或者类型。</p>
<pre><code class="language-swift">func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {
    var result = [Item]()
    for _ in 0..&lt;numberOfTimes {
        result.append(item)
    }
    return result
}
makeArray(repeating: "knock", numberOfTimes: 4)
</code></pre>
<p>你也可以创建泛型函数、方法、类、枚举和结构体。</p>
<pre><code class="language-swift">// 重新实现 Swift 标准库中的可选类型
enum OptionalValue&lt;Wrapped&gt; {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue&lt;Int&gt; = .none
possibleInteger = .some(100)
</code></pre>
<p>在类型名后面使用 <code>where</code> 来指定对类型的一系列需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类。</p>
<pre><code class="language-swift">func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool
    where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element {
        for lhsItem in lhs {
            for rhsItem in rhs {
                if lhsItem == rhsItem {
                    return true
                }
            }
        }
        return false
}
anyCommonElements([1, 2, 3], [3])
</code></pre>
<blockquote>
<p>练习</p>
<p>修改 <code>anyCommonElements(_:_:)</code> 函数来创建一个函数，返回一个数组，内容是两个序列的共有元素。</p>
</blockquote>
<p><code>&lt;T: Equatable&gt;</code> 和 <code>&lt;T&gt; ... where T: Equatable&gt;</code> 的写法是等价的。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/41/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/41/index.html">Android官方培訓課程中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/22.html">jasonblog</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">294页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/116/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/116/index.html">Protocol Buffer 3学习笔记</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">37页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/189/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/189/index.html">每日 30 秒 , 一段代码 ,一个场景</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/106.html">pushmetop</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">46页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 265个">265</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/127/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/127/index.html">aiohttp 中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/68.html">HuberTRoy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">124页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 34个">34</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/193/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/193/index.html">Pixi教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/109.html">Zainking</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">56页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2020年5月17日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/81/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/springboot_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/81/index.html">《SpringBoot参考指南》中文翻译 基于1.5.7 RELEASE</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/52.html">wangjingjing</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="springboot">springboot</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">100页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../../" title="返回首页"><img class="" src="../../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../../book/12/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/chapter1.html" title="欢迎使用 Swift" data-book-page-rel-url="source/chapter1/chapter1.html" data-book-page-id="9797">欢迎使用 Swift</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/01_about_swift.html" title="关于 Swift" data-book-page-rel-url="source/chapter1/01_about_swift.html" data-book-page-id="9798">关于 Swift</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/02_version_compatibility.html" title="版本兼容性" data-book-page-rel-url="source/chapter1/02_version_compatibility.html" data-book-page-id="9799">版本兼容性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/03_a_swift_tour.html" title="Swift 初见" data-book-page-rel-url="source/chapter1/03_a_swift_tour.html" data-book-page-id="9800">Swift 初见</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/04_revision_history.html" title="Swift 版本历史记录" data-book-page-rel-url="source/chapter1/04_revision_history.html" data-book-page-id="9801">Swift 版本历史记录</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/v1.0.html" title="Swift 1.0 发布内容" data-book-page-rel-url="source/v1.0.html" data-book-page-id="9802">Swift 1.0 发布内容</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/chapter2.html" title="Swift 教程" data-book-page-rel-url="source/chapter2/chapter2.html" data-book-page-id="9803">Swift 教程</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/01_The_Basics.html" title="基础部分" data-book-page-rel-url="source/chapter2/01_The_Basics.html" data-book-page-id="9804">基础部分</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/02_Basic_Operators.html" title="基本运算符" data-book-page-rel-url="source/chapter2/02_Basic_Operators.html" data-book-page-id="9805">基本运算符</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/03_Strings_and_Characters.html" title="字符串和字符" data-book-page-rel-url="source/chapter2/03_Strings_and_Characters.html" data-book-page-id="9806">字符串和字符</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/04_Collection_Types.html" title="集合类型" data-book-page-rel-url="source/chapter2/04_Collection_Types.html" data-book-page-id="9807">集合类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/05_Control_Flow.html" title="控制流" data-book-page-rel-url="source/chapter2/05_Control_Flow.html" data-book-page-id="9808">控制流</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/06_Functions.html" title="函数" data-book-page-rel-url="source/chapter2/06_Functions.html" data-book-page-id="9809">函数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/07_Closures.html" title="闭包" data-book-page-rel-url="source/chapter2/07_Closures.html" data-book-page-id="9810">闭包</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/08_Enumerations.html" title="枚举" data-book-page-rel-url="source/chapter2/08_Enumerations.html" data-book-page-id="9811">枚举</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/09_Classes_and_Structures.html" title="类和结构体" data-book-page-rel-url="source/chapter2/09_Classes_and_Structures.html" data-book-page-id="9812">类和结构体</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/10_Properties.html" title="属性" data-book-page-rel-url="source/chapter2/10_Properties.html" data-book-page-id="9813">属性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/11_Methods.html" title="方法" data-book-page-rel-url="source/chapter2/11_Methods.html" data-book-page-id="9814">方法</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/12_Subscripts.html" title="下标" data-book-page-rel-url="source/chapter2/12_Subscripts.html" data-book-page-id="9815">下标</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/13_Inheritance.html" title="继承" data-book-page-rel-url="source/chapter2/13_Inheritance.html" data-book-page-id="9816">继承</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/14_Initialization.html" title="构造过程" data-book-page-rel-url="source/chapter2/14_Initialization.html" data-book-page-id="9817">构造过程</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/15_Deinitialization.html" title="析构过程" data-book-page-rel-url="source/chapter2/15_Deinitialization.html" data-book-page-id="9818">析构过程</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/16_Optional_Chaining.html" title="可选链" data-book-page-rel-url="source/chapter2/16_Optional_Chaining.html" data-book-page-id="9819">可选链</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/17_Error_Handling.html" title="错误处理" data-book-page-rel-url="source/chapter2/17_Error_Handling.html" data-book-page-id="9820">错误处理</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/18_Type_Casting.html" title="类型转换" data-book-page-rel-url="source/chapter2/18_Type_Casting.html" data-book-page-id="9821">类型转换</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/19_Nested_Types.html" title="嵌套类型" data-book-page-rel-url="source/chapter2/19_Nested_Types.html" data-book-page-id="9822">嵌套类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/20_Extensions.html" title="扩展" data-book-page-rel-url="source/chapter2/20_Extensions.html" data-book-page-id="9823">扩展</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/21_Protocols.html" title="协议" data-book-page-rel-url="source/chapter2/21_Protocols.html" data-book-page-id="9824">协议</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/22_Generics.html" title="泛型" data-book-page-rel-url="source/chapter2/22_Generics.html" data-book-page-id="9825">泛型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/23_Automatic_Reference_Counting.html" title="自动引用计数" data-book-page-rel-url="source/chapter2/23_Automatic_Reference_Counting.html" data-book-page-id="9826">自动引用计数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/24_Memory_Safety.html" title="内存安全" data-book-page-rel-url="source/chapter2/24_Memory_Safety.html" data-book-page-id="9827">内存安全</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/25_Access_Control.html" title="访问控制" data-book-page-rel-url="source/chapter2/25_Access_Control.html" data-book-page-id="9828">访问控制</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/26_Advanced_Operators.html" title="高级运算符" data-book-page-rel-url="source/chapter2/26_Advanced_Operators.html" data-book-page-id="9829">高级运算符</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="语言参考" disabled data-book-page-rel-url="" data-book-page-id="9830">语言参考</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/01_About_the_Language_Reference.html" title="关于语言参考" data-book-page-rel-url="source/chapter3/01_About_the_Language_Reference.html" data-book-page-id="9831">关于语言参考</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/02_Lexical_Structure.html" title="词法结构" data-book-page-rel-url="source/chapter3/02_Lexical_Structure.html" data-book-page-id="9832">词法结构</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/03_Types.html" title="类型" data-book-page-rel-url="source/chapter3/03_Types.html" data-book-page-id="9833">类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/04_Expressions.html" title="表达式" data-book-page-rel-url="source/chapter3/04_Expressions.html" data-book-page-id="9834">表达式</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/05_Statements.html" title="语句" data-book-page-rel-url="source/chapter3/05_Statements.html" data-book-page-id="9835">语句</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/06_Declarations.html" title="声明" data-book-page-rel-url="source/chapter3/06_Declarations.html" data-book-page-id="9836">声明</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/07_Attributes.html" title="特性" data-book-page-rel-url="source/chapter3/07_Attributes.html" data-book-page-id="9837">特性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/08_Patterns.html" title="模式" data-book-page-rel-url="source/chapter3/08_Patterns.html" data-book-page-id="9838">模式</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/09_Generic_Parameters_and_Arguments.html" title="泛型参数" data-book-page-rel-url="source/chapter3/09_Generic_Parameters_and_Arguments.html" data-book-page-id="9839">泛型参数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/10_Summary_of_the_Grammar.html" title="语法总结" data-book-page-rel-url="source/chapter3/10_Summary_of_the_Grammar.html" data-book-page-id="9840">语法总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="苹果官方 Blog 官方翻译" disabled data-book-page-rel-url="" data-book-page-id="9841">苹果官方 Blog 官方翻译</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/01_Access_Control.html" title="Access Control 权限控制的黑与白" data-book-page-rel-url="source/chapter4/01_Access_Control.html" data-book-page-id="9842">Access Control 权限控制的黑与白</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/02_Type_Custom.html" title="造个类型不是梦-白话 Swift 类型创建" data-book-page-rel-url="source/chapter4/02_Type_Custom.html" data-book-page-id="9843">造个类型不是梦-白话 Swift 类型创建</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/03_Ballons.html" title="WWDC 里面的那个“大炮打气球”" data-book-page-rel-url="source/chapter4/03_Ballons.html" data-book-page-id="9844">WWDC 里面的那个“大炮打气球”</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/04_Interacting_with_C_Pointers.html" title="Swift 与 C 语言指针友好合作" data-book-page-rel-url="source/chapter4/04_Interacting_with_C_Pointers.html" data-book-page-id="9845">Swift 与 C 语言指针友好合作</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/05_Value_and_Reference_Types.html" title="引用类型和值类型的恩怨" data-book-page-rel-url="source/chapter4/05_Value_and_Reference_Types.html" data-book-page-id="9846">引用类型和值类型的恩怨</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/06_Access_Control_and_Protected.html" title="访问控制和 Protected" data-book-page-rel-url="source/chapter4/06_Access_Control_and_Protected.html" data-book-page-id="9847">访问控制和 Protected</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/07_Optional_Case_Study.html" title="可选类型完美解决占位问题" data-book-page-rel-url="source/chapter4/07_Optional_Case_Study.html" data-book-page-id="9848">可选类型完美解决占位问题</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =12;var bookPageId =9800;var bookPageRelUrl ='source/chapter1/03_a_swift_tour.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>