
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>泛型-Swift 官方教程(The Swift Programming Language)</title>
<meta content='泛型,Swift 官方教程,The Swift Programming Language' name='keywords'>
<meta content='泛型,Swift 官方教程,The Swift Programming Language' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../../book/12/source/chapter2/21_Protocols.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">协议</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../../book/12/source/chapter2/23_Automatic_Reference_Counting.html">
<span class="">自动引用计数</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../../book/12/index.html">Swift 官方教程 (The Swift Programming Language)</a>
<a target="_blank" rel="nofollow" href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="泛型">泛型</h1>
<hr>
<blockquote>
<p>1.0 翻译：<a href="https://github.com/takalard">takalard</a> 校对：<a href="https://github.com/lifedim">lifedim</a></p>
</blockquote>
<blockquote>
<p>2.0 翻译+校对： <a href="https://github.com/SergioChan">SergioChan</a></p>
</blockquote>
<blockquote>
<p>2.1 校对：<a href="http://codebuild.me">shanks</a>，2015-11-01</p>
</blockquote>
<blockquote>
<p>2.2：翻译+校对：<a href="https://github.com/LanfordCai">Lanford</a>，2016-04-08 <a href="https://github.com/SketchK">SketchK</a> 2016-05-16</p>
</blockquote>
<blockquote>
<p>3.0：翻译+校对：<a href="https://github.com/chenmingjia">chenmingjia</a>，2016-09-12 3.0.1，shanks，2016-11-13</p>
</blockquote>
<blockquote>
<p>3.1：翻译：<a href="https://github.com/qhd">qhd</a>，2017-04-10</p>
</blockquote>
<blockquote>
<p>4.0 翻译+校对：<a href="https://kemchenj.github.io/">kemchenj</a> 2017-09-21</p>
</blockquote>
<blockquote>
<p>4.1 翻译+校对：<a href="https://github.com/mylittleswift">mylittleswift</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#the_problem_that_generics_solve">泛型所解决的问题</a></li>
<li><a href="#generic_functions">泛型函数</a></li>
<li><a href="#type_parameters">类型参数</a></li>
<li><a href="#naming_type_parameters">命名类型参数</a></li>
<li><a href="#generic_types">泛型类型</a></li>
<li><a href="#extending_a_generic_type">扩展一个泛型类型</a></li>
<li><a href="#type_constraints">类型约束</a></li>
<li><a href="#associated_types">关联类型</a></li>
<li><a href="#where_clauses">泛型 Where 语句</a></li>
<li><a href="#extensions_with_a_generic_where_clause">具有泛型 where 子句的扩展</a></li>
<li><a href="#associated_types_with_a_generic_where_clause">具有泛型 Where 子句的关联类型</a></li>
<li><a href="#generic_subscripts">泛型下标</a></li>
</ul>
<p><em>泛型代码</em>让你能够根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 最强大的特性之一，许多 Swift 标准库是通过泛型代码构建的。事实上，泛型的使用贯穿了整本语言手册，只是你可能没有发现而已。例如，Swift 的 <code>Array</code> 和 <code>Dictionary</code> 都是泛型集合。你可以创建一个 <code>Int</code> 数组，也可创建一个 <code>String</code> 数组，甚至可以是任意其他 Swift 类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>
<p><a name="the_problem_that_generics_solve"></a></p>
<h2 id="泛型所解决的问题">泛型所解决的问题</h2>
<p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个 <code>Int</code> 值：</p>
<pre><code class="language-swift">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>
<p>这个函数使用输入输出参数（<code>inout</code>）来交换 <code>a</code> 和 <code>b</code> 的值，请参考<a href="./06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p><code>swapTwoInts(_:_:)</code> 函数交换 <code>b</code> 的原始值到 <code>a</code>，并交换 <code>a</code> 的原始值到 <code>b</code>。你可以调用这个函数交换两个 <code>Int</code> 变量的值：</p>
<pre><code class="language-swift">var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 打印 “someInt is now 107, and anotherInt is now 3”
</code></pre>
<p>诚然，<code>swapTwoInts(_:_:)</code> 函数挺有用，但是它只能交换 <code>Int</code> 值，如果你想要交换两个 <code>String</code> 值或者 <code>Double</code> 值，就不得不写更多的函数，例如 <code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code>，如下所示：</p>
<pre><code class="language-swift">func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>
<p>你可能注意到 <code>swapTwoInts(_:_:)</code>、<code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 <code>Int</code>、<code>String</code> 和 <code>Double</code>。</p>
<p>在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）</p>
<blockquote>
<p>注意</p>
<p>在上面三个函数中，<code>a</code> 和 <code>b</code> 类型必须相同。如果 <code>a</code> 和 <code>b</code> 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 <code>String</code> 类型的变量和一个 <code>Double</code> 类型的变量互换值。试图这样做将导致编译错误。</p>
</blockquote>
<p><a name="generic_functions"></a></p>
<h2 id="泛型函数">泛型函数</h2>
<p>泛型函数可以适用于任何类型，下面的 <code>swapTwoValues(_:_:)</code> 函数是上面三个函数的泛型版本：</p>
<pre><code class="language-swift">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>
<p><code>swapTwoValues(_:_:)</code> 的函数主体和 <code>swapTwoInts(_:_:)</code> 函数是一样的，它们只在第一行有点不同，如下所示：</p>
<pre><code class="language-swift">func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T)
</code></pre>
<p>这个函数的泛型版本使用了占位类型名（在这里用字母 <code>T</code> 来表示）来代替实际类型名（例如 <code>Int</code>、<code>String</code> 或 <code>Double</code>）。占位类型名没有指明 <code>T</code> 必须是什么类型，但是它指明了 <code>a</code> 和 <code>b</code> 必须是同一类型 <code>T</code>，无论 <code>T</code> 代表什么类型。只有 <code>swapTwoValues(_:_:)</code> 函数在调用时，才会根据所传入的实际类型决定 <code>T</code> 所代表的类型。</p>
<p>泛型函数和非泛型函数的另外一个不同之处，在于这个泛型函数名（<code>swapTwoValues(_:_:)</code>）后面跟着占位类型名（<code>T</code>），并用尖括号括起来（<code>&lt;T&gt;</code>）。这个尖括号告诉 Swift 那个 <code>T</code> 是 <code>swapTwoValues(_:_:)</code> 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 <code>T</code> 的实际类型。</p>
<p><code>swapTwoValues(_:_:)</code> 函数现在可以像 <code>swapTwoInts(_:_:)</code> 那样调用，不同的是它能接受两个任意类型的值，条件是这两个值有着相同的类型。<code>swapTwoValues(_:_:)</code> 函数被调用时，<code>T</code> 所代表的类型都会由传入的值的类型推断出来。</p>
<p>在下面的两个例子中，<code>T</code> 分别代表 <code>Int</code> 和 <code>String</code>：</p>
<pre><code class="language-swift">var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt 现在 107, and anotherInt 现在 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString 现在 "world", and anotherString 现在 "hello"
</code></pre>
<blockquote>
<p>注意</p>
<p>上面定义的 <code>swapTwoValues(_:_:)</code> 函数是受 <code>swap(_:_:)</code> 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 <code>swapTwoValues(_:_:)</code> 函数的功能，你可以使用已存在的 <code>swap(_:_:)</code> 函数。</p>
</blockquote>
<p><a name="type_parameters"></a></p>
<h2 id="类型参数">类型参数</h2>
<p>在上面的 <code>swapTwoValues(_:_:)</code> 例子中，占位类型 <code>T</code> 是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。</p>
<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 <code>swapTwoValues(_:_:)</code> 函数中的参数 <code>a</code> 和 <code>b</code>），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 <code>swapTwoValues(_:_:)</code> 例子中，当函数第一次被调用时，<code>T</code> 被 <code>Int</code> 替换，第二次调用时，被 <code>String</code> 替换。）</p>
<p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p>
<p><a name="naming_type_parameters"></a></p>
<h2 id="命名类型参数">命名类型参数</h2>
<p>在大多数情况下，类型参数具有一个描述性名字，例如 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code>，以及 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字母来命名，例如 <code>T</code>、<code>U</code>、<code>V</code>，正如上面演示的 <code>swapTwoValues(_:_:)</code> 函数中的 <code>T</code> 一样。</p>
<blockquote>
<p>注意</p>
<p>请始终使用大写字母开头的驼峰命名法（例如 <code>T</code> 和 <code>MyTypeParameter</code>）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
</blockquote>
<p><a name="generic_types"></a></p>
<h2 id="泛型类型">泛型类型</h2>
<p>除了泛型函数，Swift 还允许你定义<em>泛型</em>类型。这些自定义类、结构体和枚举可以适用于<em>任何</em>类型，类似于 <code>Array</code> 和 <code>Dictionary</code>。</p>
<p>这部分内容将向你展示如何编写一个名为 <code>Stack</code> （栈）的泛型集合类型。栈是一系列值的有序集合，和 <code>Array</code> 类似，但它相比 Swift 的 <code>Array</code> 类型有更多的操作限制。数组允许在数组的任意位置插入新元素或是删除其中任意位置的元素。而栈只允许在集合的末端添加新的元素（称之为<em>入</em>栈）。类似的，栈也只能从末端移除元素（称之为<em>出</em>栈）。</p>
<blockquote>
<p>注意</p>
<p>栈的概念已被 <code>UINavigationController</code> 类用来构造视图控制器的导航结构。你通过调用 <code>UINavigationController</code> 的 <code>pushViewController(_:animated:)</code> 方法来添加新的视图控制器到导航栈，通过 <code>popViewControllerAnimated(_:)</code> 方法来从导航栈中移除视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。</p>
</blockquote>
<p>下图展示了一个栈的入栈（push）和出栈（pop）的行为：</p>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png" data-uk-lightbox><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png" alt="此处输入图片的描述"></a></p>
<ol>
<li>现在有三个值在栈中。</li>
<li>第四个值被压入到栈的顶部。</li>
<li>现在有四个值在栈中，最近入栈的那个值在顶部。</li>
<li>栈中最顶部的那个值被移除出栈。</li>
<li>一个值移除出栈后，现在栈又只有三个值了。</li>
</ol>
<p>下面展示了如何编写一个非泛型版本的栈，以 <code>Int</code> 型的栈为例：</p>
<pre><code class="language-swift">struct IntStack {
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}
</code></pre>
<p>这个结构体在栈中使用一个名为 <code>items</code> 的 <code>Array</code> 属性来存储值。<code>Stack</code> 提供了两个方法：<code>push(_:)</code> 和 <code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为 <code>mutating</code>，因为它们需要修改结构体的 <code>items</code> 数组。</p>
<p>上面的 <code>IntStack</code> 结构体只能用于 <code>Int</code> 类型。不过，可以定义一个泛型 <code>Stack</code> 结构体，从而能够处理<em>任意</em>类型的值。</p>
<p>下面是相同代码的泛型版本：</p>
<pre><code class="language-swift">struct Stack&lt;Element&gt; {
    var items = [Element]()
 &nbsp; &nbsp;mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
}
</code></pre>
<p>注意，<code>Stack</code> 基本上和 <code>IntStack</code> 相同，只是用占位类型参数 <code>Element</code> 代替了实际的 <code>Int</code> 类型。这个类型参数包裹在紧随结构体名的一对尖括号里（<code>&lt;Element&gt;</code>）。</p>
<p><code>Element</code> 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 <code>Element</code> 来引用。在这个例子中，<code>Element</code> 在如下三个地方被用作占位符：</p>
<ul>
<li>创建 <code>items</code> 属性，使用 <code>Element</code> 类型的空数组对其进行初始化。</li>
<li>指定 <code>push(_:)</code> 方法的唯一参数 <code>item</code> 的类型必须是 <code>Element</code> 类型。</li>
<li>指定 <code>pop()</code> 方法的返回值类型必须是 <code>Element</code> 类型。</li>
</ul>
<p>由于 <code>Stack</code> 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，就像 <code>Array</code> 和 <code>Dictionary</code> 那样。</p>
<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 <code>Stack</code> 实例。例如，要创建一个 <code>String</code> 类型的栈，可以写成 <code>Stack&lt;String&gt;()</code>：</p>
<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 栈中现在有 4 个字符串
</code></pre>
<p>下图展示了 <code>stackOfStrings</code> 如何将这四个值入栈：</p>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png" data-uk-lightbox><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png" alt="此处输入图片的描述"></a></p>
<p>移除并返回栈顶部的值 <code>"cuatro"</code>，即将其出栈：</p>
<pre><code class="language-swift">let fromTheTop = stackOfStrings.pop()
// fromTheTop 的值为 "cuatro"，现在栈中还有 3 个字符串
</code></pre>
<p>下图展示了 <code>stackOfStrings</code> 如何将顶部的值出栈：</p>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png" data-uk-lightbox><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png" alt="此处输入图片的描述"></a></p>
<p><a name="extending_a_generic_type"></a></p>
<h2 id="扩展一个泛型类型">扩展一个泛型类型</h2>
<p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。<em>原始</em>类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>
<p>下面的例子扩展了泛型类型 <code>Stack</code>，为其添加了一个名为 <code>topItem</code> 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：</p>
<pre><code class="language-swift">extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>
<p><code>topItem</code> 属性会返回一个 <code>Element</code> 类型的可选值。当栈为空的时候，<code>topItem</code> 会返回 <code>nil</code>；当栈不为空的时候，<code>topItem</code> 会返回 <code>items</code> 数组中的最后一个元素。</p>
<p>注意，这个扩展并没有定义一个类型参数列表。相反的，<code>Stack</code> 类型已有的类型参数名称 <code>Element</code>，被用在扩展中来表示计算型属性 <code>topItem</code> 的可选类型。</p>
<p>计算型属性 <code>topItem</code> 现在可以用来访问任意 <code>Stack</code> 实例的顶端元素且不移除它：</p>
<pre><code class="language-swift">if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// 打印 “The top item on the stack is tres.”
</code></pre>
<p><a name="type_constraints"></a></p>
<h2 id="类型约束">类型约束</h2>
<p><code>swapTwoValues(_:_:)</code> 函数和 <code>Stack</code> 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型添加一个特定的类型约束，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
<p>例如，Swift 的 <code>Dictionary</code> 类型对字典的键的类型做了些限制。在<a href="./04_Collection_Types.html#dictionaries">字典</a>的描述中，字典的键的类型必须是可哈希（<code>hashable</code>）的。也就是说，必须有一种方法能够唯一地表示它。<code>Dictionary</code> 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，<code>Dictionary</code> 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p>
<p>为了实现这个要求，一个类型约束被强制加到 <code>Dictionary</code> 的键类型上，要求其键类型必须符合 <code>Hashable</code> 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希的。</p>
<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>
<p><a name="type_constraint_syntax"></a></p>
<h3 id="类型约束语法">类型约束语法</h3>
<p>你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）：</p>
<pre><code class="language-swift">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // 这里是泛型函数的函数体部分
}
</code></pre>
<p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code>，有一个要求 <code>T</code> 必须是 <code>SomeClass</code> 子类的类型约束；第二个类型参数 <code>U</code>，有一个要求 <code>U</code> 必须符合 <code>SomeProtocol</code> 协议的类型约束。</p>
<p><a name="type_constraints_in_action"></a></p>
<h3 id="类型约束实践">类型约束实践</h3>
<p>这里有个名为 <code>findIndex(ofString:in:)</code> 的非泛型函数，该函数的功能是在一个 <code>String</code> 数组中查找给定 <code>String</code> 值的索引。若查找到匹配的字符串，<code>findIndex(ofString:in:)</code> 函数返回该字符串在数组中的索引值，否则返回 <code>nil</code>：</p>
<pre><code class="language-swift">func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>
<p><code>findIndex(ofString:in:)</code> 函数可以用于查找字符串数组中的某个字符串：</p>
<pre><code class="language-swift">let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findIndex(ofString: "llama", in: strings) {
    print("The index of llama is \(foundIndex)")
}
// 打印 “The index of llama is 2”
</code></pre>
<p>如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以用占位类型 <code>T</code> 替换 <code>String</code> 类型来写出具有相同功能的泛型函数 <code>findIndex(_:_:)</code>。</p>
<p>下面展示了 <code>findIndex(ofString:in:)</code> 函数的泛型版本 <code>findIndex(ofString:in:)</code>。请注意这个函数返回值的类型仍然是 <code>Int?</code>，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明：</p>
<pre><code class="language-swift">func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>
<p>上面所写的函数无法通过编译。问题出在相等性检查上，即 "<code>if value == valueToFind</code>"。不是所有的 Swift 类型都可以用等式符（<code>==</code>）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 <code>T</code>，当你试图编译这部分代码时会出现相应的错误。</p>
<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何遵循该协议的类型必须实现等式符（<code>==</code>）及不等符（<code>!=</code>），从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p>
<p>任何 <code>Equatable</code> 类型都可以安全地使用在 <code>findIndex(of:in:)</code> 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 <code>Equatable</code> 类型约束作为类型参数定义的一部分：</p>
<pre><code class="language-swift">func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>
<p><code>findIndex(of:in:)</code> 唯一的类型参数写做 <code>T: Equatable</code>，也就意味着“任何符合 <code>Equatable</code> 协议的类型 <code>T</code>”。</p>
<p><code>findIndex(of:in:)</code> 函数现在可以成功编译了，并且可以作用于任何符合 <code>Equatable</code> 的类型，如 <code>Double</code> 或 <code>String</code>：</p>
<pre><code class="language-swift">let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])
// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中
let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"])
// stringIndex 类型为 Int?，其值为 2
</code></pre>
<p><a name="associated_types"></a></p>
<h2 id="关联类型">关联类型</h2>
<p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。<em>关联类型</em>为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 <code>associatedtype</code> 关键字来指定关联类型。</p>
<p><a name="associated_types_in_action"></a></p>
<h3 id="关联类型实践">关联类型实践</h3>
<p>下面例子定义了一个 <code>Container</code> 协议，该协议定义了一个关联类型 <code>Item</code>：</p>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
}
</code></pre>
<p><code>Container</code> 协议定义了三个任何采纳了该协议的类型（即容器）必须提供的功能：</p>
<ul>
<li>必须可以通过 <code>append(_:)</code> 方法添加一个新元素到容器里。</li>
<li>必须可以通过 <code>count</code> 属性获取容器中元素的数量，并返回一个 <code>Int</code> 值。</li>
<li>必须可以通过索引值类型为 <code>Int</code> 的下标检索到容器中的每一个元素。</li>
</ul>
<p>这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何遵从 <code>Container</code> 协议的类型必须提供的功能。遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>
<p>任何遵从 <code>Container</code> 协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素的类型。</p>
<p>为了定义这三个条件，<code>Container</code> 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。<code>Container</code> 协议需要指定任何通过 <code>append(_:)</code> 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>
<p>为了达到这个目的，<code>Container</code> 协议声明了一个关联类型 <code>Item</code>，写作 <code>associatedtype Item</code>。这个协议无法定义 <code>Item</code> 是什么类型的别名，这个信息将留给遵从协议的类型来提供。尽管如此，<code>Item</code> 别名提供了一种方式来引用 <code>Container</code> 中元素的类型，并将之用于 <code>append(_:)</code> 方法和下标，从而保证任何 <code>Container</code> 的行为都能够正如预期地被执行。</p>
<p>下面是先前的非泛型的 <code>IntStack</code> 类型，这一版本采纳并符合了 <code>Container</code> 协议：</p>
<pre><code class="language-swift">struct IntStack: Container {
    // IntStack 的原始实现部分
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // Container 协议的实现部分
    typealias Item = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>
<p><code>IntStack</code> 结构体实现了 <code>Container</code> 协议的三个要求，其原有功能也不会和这些要求相冲突。</p>
<p>此外，<code>IntStack</code> 在实现 <code>Container</code> 的要求时，指定 <code>Item</code> 为 <code>Int</code> 类型，即 <code>typealias Item = Int</code>，从而将 <code>Container</code> 协议中抽象的 <code>Item</code> 类型转换为具体的 <code>Int</code> 类型。</p>
<p>由于 Swift 的类型推断，你实际上不用在 <code>IntStack</code> 的定义中声明 <code>Item</code> 为 <code>Int</code>。因为 <code>IntStack</code> 符合 <code>Container</code> 协议的所有要求，Swift 只需通过 <code>append(_:)</code> 方法的 <code>item</code> 参数类型和下标返回值的类型，就可以推断出 <code>Item</code> 的具体类型。事实上，如果你在上面的代码中删除了 <code>typealias Item = Int</code> 这一行，一切仍旧可以正常工作，因为 Swift 清楚地知道 <code>Item</code> 应该是哪种类型。</p>
<p>你也可以让泛型 <code>Stack</code> 结构体遵从 <code>Container</code> 协议：</p>
<pre><code class="language-swift">struct Stack&lt;Element&gt;: Container {
    // Stack&lt;Element&gt; 的原始实现部分
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
    // Container 协议的实现部分
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Element {
        return items[i]
    }
}
</code></pre>
<p>这一次，占位类型参数 <code>Element</code> 被用作 <code>append(_:)</code> 方法的 <code>item</code> 参数和下标的返回类型。Swift 可以据此推断出 <code>Element</code> 的类型即是 <code>Item</code> 的类型。</p>
<p><a name="extending_an_existing_type_to_specify_an_associated_type"></a></p>
<h3 id="通过扩展一个存在的类型来指定关联类型">通过扩展一个存在的类型来指定关联类型</h3>
<p><a href="./21_Protocols.html#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性</a>中描述了如何利用扩展让一个已存在的类型符合一个协议，这包括使用了关联类型的协议。</p>
<p>Swift 的 <code>Array</code> 类型已经提供 <code>append(_:)</code> 方法，一个 <code>count</code> 属性，以及一个接受 <code>Int</code> 类型索引值的下标用以检索其元素。这三个功能都符合 <code>Container</code> 协议的要求，也就意味着你只需简单地声明 <code>Array</code> 采纳该协议就可以扩展 <code>Array</code>，使其遵从 <code>Container</code> 协议。你可以通过一个空扩展来实现这点，正如<a href="./21_Protocols.html#declaring_protocol_adoption_with_an_extension">通过扩展采纳协议</a>中的描述：</p>
<pre><code class="language-swift">extension Array: Container {}
</code></pre>
<p>如同上面的泛型 <code>Stack</code> 结构体一样，<code>Array</code> 的 <code>append(_:)</code> 方法和下标确保了 Swift 可以推断出 <code>Item</code> 的类型。定义了这个扩展后，你可以将任意 <code>Array</code> 当作 <code>Container</code> 来使用。</p>
<p><a name="using_type_annotations_to_constrain_an_associated_type"></a></p>
<h3 id="给关联类型添加约束">给关联类型添加约束</h3>
<p>你可以给协议里的关联类型添加类型注释，让遵守协议的类型必须遵循这个约束条件。例如，下面的代码定义了一个 <code>Item</code> 必须遵循 <code>Equatable</code> 的 <code>Container</code> 类型：</p>
<pre><code class="language-swift">protocol Container {
    associatedtype Item: Equatable
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
}
</code></pre>
<p>为了遵守了 <code>Container</code> 协议，Item 类型也必须遵守 <code>Equatable</code> 协议。</p>
<p><a name="Using_a_Protocol_in_Its_Associated_Type’s_Constraints"></a></p>
<h3 id="在关联类型约束里使用协议">在关联类型约束里使用协议</h3>
<p>协议可以作为它自身的要求出现。例如，有一个协议细化了 <code>Container</code> 协议，添加了一个 <code>suffix(_:)</code> 方法。<code>suffix(_:)</code> 方法返回容器中从后往前给定数量的元素，把它们存储在一个 <code>Suffix</code> 类型的实例里。</p>
<pre><code class="language-swift">protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -&gt; Suffix
}
</code></pre>
<p>在这个协议里，<code>Suffix</code> 是一个关联类型，就像上边例子中 <code>Container</code> 的 <code>Item</code> 类型一样。<code>Suffix</code> 拥有两个约束：它必须遵循 <code>SuffixableContainer</code> 协议（就是当前定义的协议），以及它的 <code>Item</code> 类型必须是和容器里的 <code>Item</code> 类型相同。<code>Item</code> 的约束是一个 <code>wher</code>e 分句，它在下面<a href="#extensions_with_a_generic_where_clause">带有泛型 Where 分句的扩展</a>中有讨论。</p>
<p>这里有一个来自<a href="./23_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包的循环强引用</a>的 Stack 类型的扩展，它添加了对 <code>SuffixableContainer</code> 协议的遵循：</p>
<pre><code class="language-swift">extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -&gt; Stack {
        var result = Stack()
        for index in (count-size)..&lt;count {
            result.append(self[index])
        }
        return result
    }
    // Inferred that Suffix is Stack.
}
var stackOfInts = Stack&lt;Int&gt;()
stackOfInts.append(10)
stackOfInts.append(20)
stackOfInts.append(30)
let suffix = stackOfInts.suffix(2)
// suffix contains 20 and 30
</code></pre>
<p>在上面的例子中，<code>Suffix</code> 是 <code>Stack</code> 的关联类型，也就是 <code>Stack</code> ，所以 <code>Stack</code> 的后缀运算返回另一个 <code>Stack</code> 。另外，遵循 <code>SuffixableContainer</code> 的类型可以拥有一个与它自己不同的 <code>Suffix</code> 类型——也就是说后缀运算可以返回不同的类型。比如说，这里有一个非泛型 <code>IntStack</code> 类型的扩展，它添加了 <code>SuffixableContainer</code> 遵循，使用 <code>Stack&lt;Int&gt;</code> 作为它的后缀类型而不是 <code>IntStack</code>：</p>
<pre><code class="language-swift">extension IntStack: SuffixableContainer {
    func suffix(_ size: Int) -&gt; Stack&lt;Int&gt; {
        var result = Stack&lt;Int&gt;()
        for index in (count-size)..&lt;count {
            result.append(self[index])
        }
        return result
    }
    // Inferred that Suffix is Stack&lt;Int&gt;.
}
</code></pre>
<p><a name="where_clauses"></a></p>
<h2 id="泛型-where-语句">泛型 Where 语句</h2>
<p><a href="#type_constraints">类型约束</a>让你能够为泛型函数，下标，类型的类型参数定义一些强制要求。</p>
<p>为关联类型定义约束也是非常有用的。你可以在参数列表中通过 <code>where</code> 子句为关联类型定义约束。你能通过 <code>where</code> 子句要求一个关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句，<code>where</code> 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。</p>
<p>下面的例子定义了一个名为 <code>allItemsMatch</code> 的泛型函数，用来检查两个 <code>Container</code> 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>被检查的两个 <code>Container</code> 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 <code>where</code> 子句来表示：</p>
<pre><code class="language-swift">func allItemsMatch&lt;C1: Container, C2: Container&gt;
    (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool
    where C1.Item == C2.Item, C1.Item: Equatable {
        
        // 检查两个容器含有相同数量的元素
        if someContainer.count != anotherContainer.count {
            return false
        }
        
        // 检查每一对元素是否相等
        for i in 0..&lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }
        
        // 所有元素都匹配，返回 true
        return true
}
</code></pre>
<p>这个函数接受 <code>someContainer</code> 和 <code>anotherContainer</code> 两个参数。参数 <code>someContainer</code> 的类型为 <code>C1</code>，参数 <code>anotherContainer</code> 的类型为 <code>C2</code>。<code>C1</code> 和 <code>C2</code> 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。</p>
<p>这个函数的类型参数列表还定义了对两个类型参数的要求：</p>
<ul>
<li><code>C1</code> 必须符合 <code>Container</code> 协议（写作 <code>C1: Container</code>）。</li>
<li><code>C2</code> 必须符合 <code>Container</code> 协议（写作 <code>C2: Container</code>）。</li>
<li><code>C1</code> 的 <code>Item</code> 必须和 <code>C2</code> 的 <code>Item</code> 类型相同（写作 <code>C1.Item == C2.Item</code>）。</li>
<li><code>C1</code> 的 <code>Item</code> 必须符合 <code>Equatable</code> 协议（写作 <code>C1.Item: Equatable</code>）。</li>
</ul>
<p>第三个和第四个要求被定义为一个 <code>where</code> 子句，写在关键字 <code>where</code> 后面，它们也是泛型函数类型参数列表的一部分。</p>
<p>这些要求意味着：</p>
<ul>
<li><code>someContainer</code> 是一个 <code>C1</code> 类型的容器。</li>
<li><code>anotherContainer</code> 是一个 <code>C2</code> 类型的容器。</li>
<li><code>someContainer</code> 和 <code>anotherContainer</code> 包含相同类型的元素。</li>
<li><code>someContainer</code> 中的元素可以通过不等于操作符（<code>!=</code>）来检查它们是否彼此不同。</li>
</ul>
<p>第三个和第四个要求结合起来意味着 <code>anotherContainer</code> 中的元素也可以通过 <code>!=</code> 操作符来比较，因为它们和 <code>someContainer</code> 中的元素类型相同。</p>
<p>这些要求让 <code>allItemsMatch(_:_:)</code> 函数能够比较两个容器，即使它们的容器类型不同。</p>
<p><code>allItemsMatch(_:_:)</code> 函数首先检查两个容器是否拥有相同数量的元素，如果它们的元素数量不同，那么一定不匹配，函数就会返回 <code>false</code>。</p>
<p>进行这项检查之后，通过 <code>for-in</code> 循环和半闭区间操作符（<code>..&lt;</code>）来迭代每个元素，检查 <code>someContainer</code> 中的元素是否不等于 <code>anotherContainer</code> 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 <code>false</code>。</p>
<p>如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 <code>true</code>。</p>
<p>下面演示了 <code>allItemsMatch(_:_:)</code> 函数的使用：</p>
<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    print("All items match.")
} else {
    print("Not all items match.")
}
// 打印 “All items match.”
</code></pre>
<p>上面的例子创建了一个 <code>Stack</code> 实例来存储一些 <code>String</code> 值，然后将三个字符串压入栈中。这个例子还通过数组字面量创建了一个 <code>Array</code> 实例，数组中包含同栈中一样的三个字符串。即使栈和数组是不同的类型，但它们都遵从 <code>Container</code> 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 <code>allItemsMatch(_:_:)</code> 函数。在上面的例子中，<code>allItemsMatch(_:_:)</code> 函数正确地显示了这两个容器中的所有元素都是相互匹配的。</p>
<p><a name="extensions_with_a_generic_where_clause"></a></p>
<h2 id="具有泛型-where-子句的扩展">具有泛型 Where 子句的扩展</h2>
<p>你也可以使用泛型 <code>where</code> 子句作为扩展的一部分。基于以前的例子，下面的示例扩展了泛型 <code>Stack</code> 结构体，添加一个 <code>isTop(_:)</code> 方法。</p>
<pre><code class="language-swift">extension Stack where Element: Equatable {
    func isTop(_ item: Element) -&gt; Bool {
        guard let topItem = items.last else {
            return false
        }
        return topItem == item
    }
}
</code></pre>
<p>这个新的 <code>isTop(_:)</code> 方法首先检查这个栈是不是空的，然后比较给定的元素与栈顶部的元素。如果你尝试不用泛型 <code>where</code> 子句，会有一个问题：在 <code>isTop(_:)</code> 里面使用了 <code>==</code> 运算符，但是 <code>Stack</code> 的定义没有要求它的元素是符合 Equatable 协议的，所以使用 <code>==</code> 运算符导致编译时错误。使用泛型 <code>where</code> 子句可以为扩展添加新的条件，因此只有当栈中的元素符合 Equatable 协议时，扩展才会添加 <code>isTop(_:)</code> 方法。</p>
<p>以下是 <code>isTop(_:)</code> 方法的调用方式：</p>
<pre><code class="language-swift">if stackOfStrings.isTop("tres") {
    print("Top element is tres.")
} else {
    print("Top element is something else.")
}
// 打印 "Top element is tres."
</code></pre>
<p>如果尝试在其元素不符合 Equatable 协议的栈上调用 <code>isTop(_:)</code> 方法，则会收到编译时错误。</p>
<pre><code class="language-swift">struct NotEquatable { }
var notEquatableStack = Stack&lt;NotEquatable&gt;()
let notEquatableValue = NotEquatable()
notEquatableStack.push(notEquatableValue)
notEquatableStack.isTop(notEquatableValue)  // 报错
</code></pre>
<p>你可以使用泛型 <code>where</code> 子句去扩展一个协议。基于以前的示例，下面的示例扩展了 <code>Container</code> 协议，添加一个 <code>startsWith(_:)</code> 方法。</p>
<pre><code class="language-swift">extension Container where Item: Equatable {
    func startsWith(_ item: Item) -&gt; Bool {
        return count &gt;= 1 &amp;&amp; self[0] == item
    }
}
</code></pre>
<p>这个 <code>startsWith(_:)</code> 方法首先确保容器至少有一个元素，然后检查容器中的第一个元素是否与给定的元素相等。任何符合 <code>Container</code> 协议的类型都可以使用这个新的 <code>startsWith(_:)</code> 方法，包括上面使用的栈和数组，只要容器的元素是符合 Equatable 协议的。</p>
<pre><code class="language-swift">if [9, 9, 9].startsWith(42) {
    print("Starts with 42.")
} else {
    print("Starts with something else.")
}
// 打印 "Starts with something else."
</code></pre>
<p>上述示例中的泛型 <code>where</code> 子句要求 <code>Item</code> 符合协议，但也可以编写一个泛型 <code>where</code> 子句去要求 <code>Item</code> 为特定类型。例如：</p>
<pre><code class="language-swift">extension Container where Item == Double {
    func average() -&gt; Double {
        var sum = 0.0
        for index in 0..&lt;count {
            sum += self[index]
        }
        return sum / Double(count)
    }
}
print([1260.0, 1200.0, 98.6, 37.0].average())
// 打印 "648.9"
</code></pre>
<p>此示例将一个 <code>average()</code> 方法添加到 <code>Item</code> 类型为 <code>Double</code> 的容器中。此方法遍历容器中的元素将其累加，并除以容器的数量计算平均值。它将数量从 <code>Int</code> 转换为 <code>Double</code> 确保能够进行浮点除法。</p>
<p>就像可以在其他地方写泛型 <code>where</code> 子句一样，你可以在一个泛型 <code>where</code> 子句中包含多个条件作为扩展的一部分。用逗号分隔列表中的每个条件。</p>
<p><a name="associated_types_with_a_generic_where_clause"></a></p>
<h2 id="具有泛型-where-子句的关联类型">具有泛型 Where 子句的关联类型</h2>
<p>你可以在关联类型后面加上具有泛型 <code>where</code> 的字句。例如，建立一个包含迭代器（Iterator）的容器，就像是标准库中使用的 <code>Sequence</code> 协议那样。你应该这么写：</p>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
    
    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
    func makeIterator() -&gt; Iterator
}
</code></pre>
<p>迭代器（Iterator）的泛型 <code>where</code> 子句要求：无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。<code>makeIterator()</code> 则提供了容器的迭代器的访问接口。</p>
<p>一个协议继承了另一个协议，你通过在协议声明的时候，包含泛型 <code>where</code> 子句，来添加了一个约束到被继承协议的关联类型。例如，下面的代码声明了一个 <code>ComparableContainer</code> 协议，它要求所有的 <code>Item</code> 必须是 <code>Comparable</code> 的。</p>
<pre><code class="language-swift">protocol ComparableContainer: Container where Item: Comparable { }
</code></pre>
<p><a name="generic_subscripts"></a> ##泛型下标</p>
<p>下标能够是泛型的，他们能够包含泛型 <code>where</code> 子句。你可以把占位符类型的名称写在 <code>subscript</code> 后面的尖括号里，在下标代码体开始的标志的花括号之前写下泛型 <code>where</code> 子句。例如：</p>
<pre><code class="language-swift">extension Container {
    subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]
        where Indices.Iterator.Element == Int {
            var result = [Item]()
            for index in indices {
                result.append(self[index])
            }
            return result
    }
}
</code></pre>
<p>这个 <code>Container</code> 协议的扩展添加了一个下标方法，接收一个索引的集合，返回每一个索引所在的值的数组。这个泛型下标的约束如下：</p>
<p>这个 <code>Container</code> 协议的扩展添加了一个下标：下标是一个序列的索引，返回的则是索引所在的项目的值所构成的数组。这个泛型下标的约束如下：</p>
<ul>
<li>在尖括号中的泛型参数 <code>Indices</code>，必须是符合标准库中的 <code>Sequence</code> 协议的类型。</li>
<li>下标使用的单一的参数，<code>indices</code>，必须是 <code>Indices</code> 的实例。</li>
<li>泛型 <code>where</code> 子句要求 Sequence（Indices）的迭代器，其所有的元素都是 <code>Int</code> 类型。这样就能确保在序列（Sequence）中的索引和容器（Container）里面的索引类型是一致的。</li>
</ul>
<p>综合一下，这些约束意味着，传入到 <code>indices</code> 下标，是一个整型的序列。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/26/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/26/index.html">安卓应用安全指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">77页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 11个">11</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/107/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/laravel_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/107/index.html">Laravel 源码详解</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="laravel">laravel</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">42页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 4个">4</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/204/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/204/index.html">系统重构与迁移指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">183页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/134/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/github_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/134/index.html">GitHub 漫游指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="github">github</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 3472个">3472</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/115/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/115/index.html">ANTLR 4简明教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">19页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/48/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/tensorflow_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/48/index.html">机器学习基础笔记</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/25.html">zhjunqin</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="tensorflow">tensorflow</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">43页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月2日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../../" title="返回首页"><img class="" src="../../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../../book/12/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/chapter1.html" title="欢迎使用 Swift" data-book-page-rel-url="source/chapter1/chapter1.html" data-book-page-id="9797">欢迎使用 Swift</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/01_about_swift.html" title="关于 Swift" data-book-page-rel-url="source/chapter1/01_about_swift.html" data-book-page-id="9798">关于 Swift</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/02_version_compatibility.html" title="版本兼容性" data-book-page-rel-url="source/chapter1/02_version_compatibility.html" data-book-page-id="9799">版本兼容性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/03_a_swift_tour.html" title="Swift 初见" data-book-page-rel-url="source/chapter1/03_a_swift_tour.html" data-book-page-id="9800">Swift 初见</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/04_revision_history.html" title="Swift 版本历史记录" data-book-page-rel-url="source/chapter1/04_revision_history.html" data-book-page-id="9801">Swift 版本历史记录</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/v1.0.html" title="Swift 1.0 发布内容" data-book-page-rel-url="source/v1.0.html" data-book-page-id="9802">Swift 1.0 发布内容</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/chapter2.html" title="Swift 教程" data-book-page-rel-url="source/chapter2/chapter2.html" data-book-page-id="9803">Swift 教程</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/01_The_Basics.html" title="基础部分" data-book-page-rel-url="source/chapter2/01_The_Basics.html" data-book-page-id="9804">基础部分</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/02_Basic_Operators.html" title="基本运算符" data-book-page-rel-url="source/chapter2/02_Basic_Operators.html" data-book-page-id="9805">基本运算符</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/03_Strings_and_Characters.html" title="字符串和字符" data-book-page-rel-url="source/chapter2/03_Strings_and_Characters.html" data-book-page-id="9806">字符串和字符</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/04_Collection_Types.html" title="集合类型" data-book-page-rel-url="source/chapter2/04_Collection_Types.html" data-book-page-id="9807">集合类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/05_Control_Flow.html" title="控制流" data-book-page-rel-url="source/chapter2/05_Control_Flow.html" data-book-page-id="9808">控制流</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/06_Functions.html" title="函数" data-book-page-rel-url="source/chapter2/06_Functions.html" data-book-page-id="9809">函数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/07_Closures.html" title="闭包" data-book-page-rel-url="source/chapter2/07_Closures.html" data-book-page-id="9810">闭包</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/08_Enumerations.html" title="枚举" data-book-page-rel-url="source/chapter2/08_Enumerations.html" data-book-page-id="9811">枚举</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/09_Classes_and_Structures.html" title="类和结构体" data-book-page-rel-url="source/chapter2/09_Classes_and_Structures.html" data-book-page-id="9812">类和结构体</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/10_Properties.html" title="属性" data-book-page-rel-url="source/chapter2/10_Properties.html" data-book-page-id="9813">属性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/11_Methods.html" title="方法" data-book-page-rel-url="source/chapter2/11_Methods.html" data-book-page-id="9814">方法</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/12_Subscripts.html" title="下标" data-book-page-rel-url="source/chapter2/12_Subscripts.html" data-book-page-id="9815">下标</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/13_Inheritance.html" title="继承" data-book-page-rel-url="source/chapter2/13_Inheritance.html" data-book-page-id="9816">继承</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/14_Initialization.html" title="构造过程" data-book-page-rel-url="source/chapter2/14_Initialization.html" data-book-page-id="9817">构造过程</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/15_Deinitialization.html" title="析构过程" data-book-page-rel-url="source/chapter2/15_Deinitialization.html" data-book-page-id="9818">析构过程</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/16_Optional_Chaining.html" title="可选链" data-book-page-rel-url="source/chapter2/16_Optional_Chaining.html" data-book-page-id="9819">可选链</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/17_Error_Handling.html" title="错误处理" data-book-page-rel-url="source/chapter2/17_Error_Handling.html" data-book-page-id="9820">错误处理</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/18_Type_Casting.html" title="类型转换" data-book-page-rel-url="source/chapter2/18_Type_Casting.html" data-book-page-id="9821">类型转换</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/19_Nested_Types.html" title="嵌套类型" data-book-page-rel-url="source/chapter2/19_Nested_Types.html" data-book-page-id="9822">嵌套类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/20_Extensions.html" title="扩展" data-book-page-rel-url="source/chapter2/20_Extensions.html" data-book-page-id="9823">扩展</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/21_Protocols.html" title="协议" data-book-page-rel-url="source/chapter2/21_Protocols.html" data-book-page-id="9824">协议</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/22_Generics.html" title="泛型" data-book-page-rel-url="source/chapter2/22_Generics.html" data-book-page-id="9825">泛型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/23_Automatic_Reference_Counting.html" title="自动引用计数" data-book-page-rel-url="source/chapter2/23_Automatic_Reference_Counting.html" data-book-page-id="9826">自动引用计数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/24_Memory_Safety.html" title="内存安全" data-book-page-rel-url="source/chapter2/24_Memory_Safety.html" data-book-page-id="9827">内存安全</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/25_Access_Control.html" title="访问控制" data-book-page-rel-url="source/chapter2/25_Access_Control.html" data-book-page-id="9828">访问控制</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/26_Advanced_Operators.html" title="高级运算符" data-book-page-rel-url="source/chapter2/26_Advanced_Operators.html" data-book-page-id="9829">高级运算符</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="语言参考" disabled data-book-page-rel-url="" data-book-page-id="9830">语言参考</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/01_About_the_Language_Reference.html" title="关于语言参考" data-book-page-rel-url="source/chapter3/01_About_the_Language_Reference.html" data-book-page-id="9831">关于语言参考</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/02_Lexical_Structure.html" title="词法结构" data-book-page-rel-url="source/chapter3/02_Lexical_Structure.html" data-book-page-id="9832">词法结构</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/03_Types.html" title="类型" data-book-page-rel-url="source/chapter3/03_Types.html" data-book-page-id="9833">类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/04_Expressions.html" title="表达式" data-book-page-rel-url="source/chapter3/04_Expressions.html" data-book-page-id="9834">表达式</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/05_Statements.html" title="语句" data-book-page-rel-url="source/chapter3/05_Statements.html" data-book-page-id="9835">语句</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/06_Declarations.html" title="声明" data-book-page-rel-url="source/chapter3/06_Declarations.html" data-book-page-id="9836">声明</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/07_Attributes.html" title="特性" data-book-page-rel-url="source/chapter3/07_Attributes.html" data-book-page-id="9837">特性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/08_Patterns.html" title="模式" data-book-page-rel-url="source/chapter3/08_Patterns.html" data-book-page-id="9838">模式</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/09_Generic_Parameters_and_Arguments.html" title="泛型参数" data-book-page-rel-url="source/chapter3/09_Generic_Parameters_and_Arguments.html" data-book-page-id="9839">泛型参数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/10_Summary_of_the_Grammar.html" title="语法总结" data-book-page-rel-url="source/chapter3/10_Summary_of_the_Grammar.html" data-book-page-id="9840">语法总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="苹果官方 Blog 官方翻译" disabled data-book-page-rel-url="" data-book-page-id="9841">苹果官方 Blog 官方翻译</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/01_Access_Control.html" title="Access Control 权限控制的黑与白" data-book-page-rel-url="source/chapter4/01_Access_Control.html" data-book-page-id="9842">Access Control 权限控制的黑与白</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/02_Type_Custom.html" title="造个类型不是梦-白话 Swift 类型创建" data-book-page-rel-url="source/chapter4/02_Type_Custom.html" data-book-page-id="9843">造个类型不是梦-白话 Swift 类型创建</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/03_Ballons.html" title="WWDC 里面的那个“大炮打气球”" data-book-page-rel-url="source/chapter4/03_Ballons.html" data-book-page-id="9844">WWDC 里面的那个“大炮打气球”</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/04_Interacting_with_C_Pointers.html" title="Swift 与 C 语言指针友好合作" data-book-page-rel-url="source/chapter4/04_Interacting_with_C_Pointers.html" data-book-page-id="9845">Swift 与 C 语言指针友好合作</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/05_Value_and_Reference_Types.html" title="引用类型和值类型的恩怨" data-book-page-rel-url="source/chapter4/05_Value_and_Reference_Types.html" data-book-page-id="9846">引用类型和值类型的恩怨</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/06_Access_Control_and_Protected.html" title="访问控制和 Protected" data-book-page-rel-url="source/chapter4/06_Access_Control_and_Protected.html" data-book-page-id="9847">访问控制和 Protected</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/07_Optional_Case_Study.html" title="可选类型完美解决占位问题" data-book-page-rel-url="source/chapter4/07_Optional_Case_Study.html" data-book-page-id="9848">可选类型完美解决占位问题</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =12;var bookPageId =9825;var bookPageRelUrl ='source/chapter2/22_Generics.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>