
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>类型-Swift 官方教程(The Swift Programming Language)</title>
<meta content='类型,Swift 官方教程,The Swift Programming Language' name='keywords'>
<meta content='类型,Swift 官方教程,The Swift Programming Language' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../../book/12/source/chapter3/02_Lexical_Structure.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">词法结构</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../../book/12/source/chapter3/04_Expressions.html">
<span class="">表达式</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../../book/12/index.html">Swift 官方教程 (The Swift Programming Language)</a>
<a target="_blank" rel="nofollow" href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="类型types">类型（Types）</h1>
<hr>
<blockquote>
<p>1.0 翻译：<a href="https://github.com/lyuka">lyuka</a> 校对：<a href="https://github.com/numbbbbb">numbbbbb</a>, <a href="https://github.com/stanzhai">stanzhai</a></p>
</blockquote>
<blockquote>
<p>2.0 翻译+校对：<a href="https://github.com/EudeMorgen">EudeMorgen</a></p>
</blockquote>
<blockquote>
<p>2.1 翻译：<a href="https://github.com/mmoaay">mmoaay</a></p>
</blockquote>
<blockquote>
<p>4.1 翻译+校对：<a href="https://github.com/mylittleswift">mylittleswift</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#type_annotation">类型注解</a></li>
<li><a href="#type_identifier">类型标识符</a></li>
<li><a href="#tuple_type">元组类型</a></li>
<li><a href="#function_type">函数类型</a></li>
<li><a href="#array_type">数组类型</a></li>
<li><a href="#dictionary_type">字典类型</a></li>
<li><a href="#optional_type">可选类型</a></li>
<li><a href="#implicitly_unwrapped_optional_type">隐式解析可选类型</a></li>
<li><a href="#protocol_composition_type">协议合成类型</a></li>
<li><a href="#metatype_type">元类型</a></li>
<li><a href="#type_inheritance_clause">类型继承子句</a></li>
<li><a href="#type_inference">类型推断</a></li>
</ul>
<p>Swift 语言存在两种类型：命名型类型和复合型类型。命名型类型是指定义时可以给定名字的类型。命名型类型包括类、结构体、枚举和协议。比如，一个用户定义的类 <code>MyClass</code> 的实例拥有类型 <code>MyClass</code>。除了用户定义的命名型类型，Swift 标准库也定义了很多常用的命名型类型，包括那些表示数组、字典和可选值的类型。</p>
<p>那些通常被其它语言认为是基本或原始的数据型类型，比如表示数字、字符和字符串的类型，实际上就是命名型类型，这些类型在 Swift 标准库中是使用结构体来定义和实现的。因为它们是命名型类型，因此你可以按照 <a href="../chapter2/21_Extensions.html">扩展</a> 和 <a href="05_Declarations.html#extension_declaration">扩展声明</a> 中讨论的那样，声明一个扩展来增加它们的行为以满足你程序的需求。</p>
<p>复合型类型是没有名字的类型，它由 Swift 本身定义。Swift 存在两种复合型类型：函数类型和元组类型。一个复合型类型可以包含命名型类型和其它复合型类型。例如，元组类型 <code>(Int, (Int, Int))</code> 包含两个元素：第一个是命名型类型 <code>Int</code>，第二个是另一个复合型类型 <code>(Int, Int)</code>。</p>
<p>你可以在命名型类型和复合型类型使用小括号。但是在类型旁加小括号没有任何作用。举个例子，<code>(Int)</code> 等同于 <code>Int</code>。</p>
<p>本节讨论 Swift 语言本身定义的类型，并描述 Swift 中的类型推断行为。</p>
<blockquote>
<p>类型语法</p>
</blockquote>
<p><a name="type"></a></p>
<blockquote>
<p><em>类型</em> → <a href="#array-type"><em>数组类型</em></a> <em>类型</em> → <a href="#dictionary-type"><em>字典类型</em></a> <em>类型</em> → <a href="#function-type"><em>函数类型</em></a> <em>类型</em> → <a href="#type-identifier"><em>类型标识</em></a> <em>类型</em> → <a href="#tuple-type"><em>元组类型</em></a> <em>类型</em> → <a href="#optional-type"><em>可选类型</em></a> <em>类型</em> → <a href="#implicitly-unwrapped-optional-type"><em>隐式解析可选类型</em></a> <em>类型</em> → <a href="#protocol-composition-type"><em>协议合成类型</em></a> <em>类型</em> → <a href="#metatype-type"><em>元型类型</em></a> <em>类型</em> → <strong>任意类型</strong> <em>类型</em> → <strong>自身类型</strong> <em>类型</em> → <a href="#type"><em>(类型)</em></a></p>
</blockquote>
<p><a name="type_annotation"></a></p>
<h2 id="类型注解">类型注解</h2>
<p>类型注解显式地指定一个变量或表达式的值。类型注解始于冒号 <code>:</code> 终于类型，比如下面两个例子：</p>
<pre><code class="language-swift">let someTuple: (Double, Double) = (3.14159, 2.71828)
func someFunction(a: Int) { /* ... */ }
</code></pre>
<p>在第一个例子中，表达式 <code>someTuple</code> 的类型被指定为 <code>(Double, Double)</code>。在第二个例子中，函数 <code>someFunction</code> 的参数 <code>a</code> 的类型被指定为 <code>Int</code>。</p>
<p>类型注解可以在类型之前包含一个类型特性的可选列表。</p>
<blockquote>
<p>类型注解语法</p>
</blockquote>
<p><a name="type-annotation"></a></p>
<blockquote>
<p><em>类型注解</em> → <strong>:</strong> <a href="06_Attributes.html#attributes"><em>特性列表</em></a><sub>可选</sub> <strong>输入输出参数</strong><sub>可选</sub> <a href="#type"><em>类型</em></a></p>
</blockquote>
<p><a name="type_identifier"></a></p>
<h2 id="类型标识符">类型标识符</h2>
<p>类型标识符引用命名型类型，还可引用命名型或复合型类型的别名。</p>
<p>大多数情况下，类型标识符引用的是与之同名的命名型类型。例如类型标识符 <code>Int</code> 引用命名型类型 <code>Int</code>，同样，类型标识符 <code>Dictionary&lt;String, Int&gt;</code> 引用命名型类型 <code>Dictionary&lt;String, Int&gt;</code>。</p>
<p>在两种情况下类型标识符不引用同名的类型。情况一，类型标识符引用的是命名型或复合型类型的类型别名。比如，在下面的例子中，类型标识符使用 <code>Point</code> 来引用元组 <code>(Int, Int)</code>：</p>
<pre><code class="language-swift">typealias Point = (Int, Int)
let origin: Point = (0, 0)
</code></pre>
<p>情况二，类型标识符使用点语法（<code>.</code>）来表示在其它模块或其它类型嵌套内声明的命名型类型。例如，下面例子中的类型标识符引用在 <code>ExampleModule</code> 模块中声明的命名型类型 <code>MyType</code>：</p>
<pre><code class="language-swift">var someValue: ExampleModule.MyType
</code></pre>
<blockquote>
<p>类型标识符语法</p>
</blockquote>
<p><a name="type-identifier"></a></p>
<blockquote>
<p><em>类型标识符</em> → <a href="#type-name"><em>类型名称</em></a> <a href="08_Generic_Parameters_and_Arguments.html#generic_argument_clause"><em>泛型参数子句</em></a><sub>可选</sub> | <a href="#type-name"><em>类型名称</em></a> <a href="08_Generic_Parameters_and_Arguments.html#generic_argument_clause"><em>泛型参数子句</em></a><sub>可选</sub> <strong>.</strong> <a href="#type-identifier"><em>类型标识符</em></a> <a name="type-name"></a> <em>类型名称</em> → <a href="02_Lexical_Structure.html#identifier"><em>标识符</em></a></p>
</blockquote>
<p><a name="tuple_type"></a></p>
<h2 id="元组类型">元组类型</h2>
<p>元组类型是使用括号括起来的零个或多个类型，类型间用逗号隔开。</p>
<p>你可以使用元组类型作为一个函数的返回类型，这样就可以使函数返回多个值。你也可以命名元组类型中的元素，然后用这些名字来引用每个元素的值。元素的名字由一个标识符紧跟一个冒号 <code>(:)</code> 组成。<a href="../chapter2/06_Functions.html#functions_with_multiple_return_values">函数和多返回值</a> 章节里有一个展示上述特性的例子。</p>
<p>当一个元组类型的元素有名字的时候，这个名字就是类型的一部分。</p>
<pre><code class="language-swift">var someTuple = (top: 10, bottom: 12)  // someTuple 的类型为 (top: Int, bottom: Int)
someTuple = (top: 4, bottom: 42) // 正确：命名类型匹配
someTuple = (9, 99)              // 正确：命名类型被自动推断
someTuple = (left: 5, right: 5)  // 错误：命名类型不匹配
</code></pre>
<p>所有的元组类型都包含两个及以上元素， 除了 <code>Void</code>。<code>Void</code> 是空元组类型 <code>()</code> 的别名。</p>
<blockquote>
<p>元组类型语法</p>
</blockquote>
<p><a name="tuple-type"></a></p>
<blockquote>
<p><em>元组类型</em> → <strong>(</strong> <a href="#tuple-type-element-list"><em>元组类型元素列表</em></a> <sub>可选</sub> <strong>)</strong> <a name="tuple-type-element-list"></a> <em>元组类型元素列表</em> → <a href="#tuple-type-element"><em>元组类型元素</em></a> | <a href="#tuple-type-element"><em>元组类型元素</em></a> <strong>,</strong> <a href="#tuple-type-element-list"><em>元组类型元素列表</em></a> <a name="tuple-type-element"></a> <em>元组类型元素</em> → <a href="#element-name"><em>元素名</em></a> <a href="#type-annotation"><em>类型注解</em></a> | <a href="#type"><em>类型</em></a> <a name="element-name"></a> <em>元素名</em> → <a href="02_Lexical_Structure.html#identifier"><em>标识符</em></a></p>
</blockquote>
<p><a name="function_type"></a></p>
<h2 id="函数类型">函数类型</h2>
<p>函数类型表示一个函数、方法或闭包的类型，它由参数类型和返回值类型组成，中间用箭头（<code>-&gt;</code>）隔开：</p>
<blockquote>
<p><code>参数类型</code> -&gt; <code>返回值类型</code></p>
</blockquote>
<p>参数类型是由逗号间隔的类型列表。由于参数类型和返回值类型可以是元组类型，所以函数类型支持多参数与多返回值的函数与方法。</p>
<p>你可以对函数参数 <code>() -&gt; T</code>（其中 T 是任何类型）使用 <code>autoclosure</code> 特性。这会自动将参数表达式转化为闭包，表达式的结果即闭包返回值。这从语法结构上提供了一种便捷：延迟对表达式的求值，直到其值在函数体中被调用。以自动闭包做为参数的函数类型的例子详见 <a href="../chapter2/07_Closures.html#autoclosures">自动闭包</a> 。</p>
<p>函数类型可以拥有一个可变长参数作为参数类型中的最后一个参数。从语法角度上讲，可变长参数由一个基础类型名字紧随三个点（<code>...</code>）组成，如 <code>Int...</code>。可变长参数被认为是一个包含了基础类型元素的数组。即 <code>Int...</code> 就是 <code>[Int]</code>。关于使用可变长参数的例子，请参阅 <a href="../chapter2/06_Functions.html#variadic_parameters">可变参数</a>。</p>
<p>为了指定一个 <code>in-out</code> 参数，可以在参数类型前加 <code>inout</code> 前缀。但是你不可以对可变长参数或返回值类型使用 <code>inout</code>。关于这种参数的详细讲解请参阅 <a href="../chapter2/06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p>如果一个函数类型只有一个形式参数而且形式参数的类型是元组类型，那么元组类型在写函数类型的时候必须用圆括号括起来。比如说，<code>((Int, Int)) -&gt; Void</code> 是接收一个元组 <code>(Int, Int)</code> 作为形式参数的函数的类型。与此相反，不加括号的 <code>(Int, Int) -&gt; Void</code> 是一个接收两个 <code>Int</code> 形式参数并且不返回任何值的函数的类型。相似地，因为 <code>Void</code> 是空元组类型 <code>()</code> 的别名， 函数类型 <code>(Void)-&gt; Void</code> 与一个空元组的变量的函数类型 <code>(()) -&gt; ()</code> 是一样的。但这些类型和无变量的函数类型 <code>() -&gt; ()</code> 是不一样的。</p>
<p>函数和方法中的变量名并不是函数类型的一部分。例如：</p>
<pre><code class="language-swift">func someFunction(left: Int, right: Int) {}
func anotherFunction(left: Int, right: Int) {}
func functionWithDifferentLabels(top: Int, bottom: Int) {}

var f = someFunction // 函数 f 的类型为 (Int, Int) -&gt; Void, 而不是 (left: Int, right: Int) -&gt; Void.
f = anotherFunction              // 正确
f = functionWithDifferentLabels  // 正确

func functionWithDifferentArgumentTypes(left: Int, right: String) {}
func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}

f = functionWithDifferentArgumentTypes     // 错误
f = functionWithDifferentNumberOfArguments // 错误
</code></pre>
<p>由于变量标签不是函数类型的一部分，你可以在写函数类型的时候省略它们。</p>
<pre><code class="language-swift">var operation: (lhs: Int, rhs: Int) -&gt; Int      // 错误
var operation: (_ lhs: Int, _ rhs: Int) -&gt; Int  // 正确
var operation: (Int, Int) -&gt; Int                // 正确
</code></pre>
<p>如果一个函数类型包涵多个箭头（-&gt;），那么函数类型将从右向左进行组合。例如，函数类型 <code>Int -&gt; Int -&gt; Int</code> 可以理解为 <code>Int -&gt; (Int -&gt; Int)</code>，也就是说，该函数类型的参数为 <code>Int</code> 类型，其返回类型是一个参数类型为 <code>Int</code>，返回类型为 <code>Int</code> 的函数类型。</p>
<p>函数类型若要抛出错误就必须使用 <code>throws</code> 关键字来标记，若要重抛错误则必须使用 <code>rethrows</code> 关键字来标记。<code>throws</code> 关键字是函数类型的一部分，非抛出函数是抛出函数函数的一个子类型。因此，在使用抛出函数的地方也可以使用不抛出函数。抛出和重抛函数的相关描述见章节 <a href="05_Declarations.html#throwing_functions_and_methods">抛出函数与方法</a> 和 <a href="05_Declarations.html#rethrowing_functions_and_methods">重抛函数与方法</a>。</p>
<p><a name="Restrictions for Nonescaping Closures"></a></p>
<h3 id="对非逃逸闭包的限制">对非逃逸闭包的限制</h3>
<p>非逃逸闭包函数不能作为参数传递到另一个非逃逸闭包函数的参数。这样的限制可以让 Swift 在编译时就完成更多的内存访问冲突检查， 而不是在运行时。举个例子：</p>
<pre><code class="language-swift">let external: (Any) -&gt; Void = { _ in () }
func takesTwoFunctions(first: (Any) -&gt; Void, second: (Any) -&gt; Void) {
    first(first)    // 错误
    second(second)  // 错误
    
    first(second)   // 错误
    second(first)   // 错误
    
    first(external) // 正确
    external(first) // 正确
}
</code></pre>
<p>在上面代码里，<code>takesTwoFunctions(first:second:)</code> 的两个参数都是函数。 它们都没有标记为 <code>@escaping</code>, 因此它们都是非逃逸的。</p>
<p>上述例子里的被标记为“错误”的四个函数调用会产生编译错误。因为第一个和第二个参数是非逃逸函数，它们不能够被当作变量被传递到另一个非闭包函数参数。与此相反, 标记“正确”的两个函数不回产生编译错误。这些函数调用不会违反限制， 因为 <code>外部（external）</code> 不是 <code>takesTwoFunctions(first:second:)</code> 里的一个参数。</p>
<p>如果你需要避免这个限制， 标记其中之一的参数为逃逸， 或者使用 <code>withoutActuallyEscaping(_:do:)</code> 函数临时地转换非逃逸函数的其中一个参数为逃逸函数。关于避免内存访问冲突，可以参阅<a href="../chapter2/24_Memory_Safety.html">内存安全</a>。</p>
<blockquote>
<p>函数类型语法</p>
</blockquote>
<p><a name="function-type"></a></p>
<blockquote>
<p><em>函数类型</em> → <a href="06_Attributes.html#attributes"><em>特性列表</em></a><sub>可选</sub> <a href="#function-type-argument-clause"><em>函数类型子句</em></a> <strong>throws</strong><sub>可选</sub> <strong>-&gt;</strong> <a href="#type"><em>类型</em></a> <em>函数类型</em> → <a href="06_Attributes.html#attributes"><em>特性列表</em></a><sub>可选</sub> <a href="#function-type-argument-clause"><em>函数类型子句</em></a> <strong>rethrows­</strong> <strong>-&gt;</strong> <a href="#type"><em>类型</em></a> <a name="function-type-argument-clause"></a> <em>函数类型子句</em> → (­)­ <em>函数类型子句</em> → (<a href="#function-type-argument-list"><em>函数类型参数列表</em></a>*...*­<sub>可选</sub>)­ <a name="function-type-argument-list"></a> <em>函数类型参数列表</em> → <a href="function-type-argument"><em>函数类型参数</em></a> | <a href="function-type-argument"><em>函数类型参数</em></a>， <a href="#function-type-argument-list"><em>函数类型参数列表</em></a> <a name="function-type-argument"></a> <em>函数类型参数</em> → <a href="06_Attributes.html#attributes"><em>特性列表</em></a><sub>可选</sub> <strong>输入输出参数</strong><sub>可选</sub> <a href="#type"><em>类型</em></a> | <a href="#argument-label"><em>参数标签</em></a> <a href="#type-annotation"><em>类型注解</em></a> <a name="argument-label"></a> <em>参数标签</em> → <a href="02_Lexical_Structure.html#identifier"><em>标识符</em></a></p>
</blockquote>
<p><a name="array_type"></a></p>
<h2 id="数组类型">数组类型</h2>
<p>Swift 语言为标准库中定义的 <code>Array&lt;Element&gt;</code> 类型提供了如下语法糖：</p>
<blockquote>
<p>[<code>类型</code>]</p>
</blockquote>
<p>换句话说，下面两个声明是等价的：</p>
<pre><code class="language-swift">let someArray: Array&lt;String&gt; = ["Alex", "Brian", "Dave"]
let someArray: [String] = ["Alex", "Brian", "Dave"]
</code></pre>
<p>上面两种情况下，常量 <code>someArray</code> 都被声明为字符串数组。数组的元素也可以通过下标访问：<code>someArray[0]</code> 是指第 0 个元素 <code>"Alex"</code>。</p>
<p>你也可以嵌套多对方括号来创建多维数组，最里面的方括号中指明数组元素的基本类型。比如，下面例子中使用三对方括号创建三维整数数组：</p>
<pre><code class="language-swift">var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
</code></pre>
<p>访问一个多维数组的元素时，最左边的下标指向最外层数组的相应位置元素。接下来往右的下标指向第一层嵌入的相应位置元素，依次类推。这就意味着，在上面的例子中，<code>array3D[0]</code> 是 <code>[[1, 2], [3, 4]]</code>，<code>array3D[0][1]</code> 是 <code>[3, 4]</code>，<code>array3D[0][1][1]</code> 则是 <code>4</code>。</p>
<p>关于 Swift 标准库中 <code>Array</code> 类型的详细讨论，请参阅 <a href="../chapter2/04_Collection_Types.html#arrays">数组</a>。</p>
<blockquote>
<p>数组类型语法</p>
</blockquote>
<p><a name="array-type"></a></p>
<blockquote>
<p><em>数组类型</em> → <strong>[</strong> <a href="#type"><em>类型</em></a> <strong>]</strong></p>
</blockquote>
<p><a name="dictionary_type"></a></p>
<h2 id="字典类型">字典类型</h2>
<p>Swift 语言为标准库中定义的 <code>Dictionary&lt;Key, Value&gt;</code> 类型提供了如下语法糖：</p>
<blockquote>
<p>[<code>键类型</code> : <code>值类型</code>]</p>
</blockquote>
<p>换句话说，下面两个声明是等价的：</p>
<pre><code class="language-swift">let someDictionary: [String: Int] = ["Alex": 31, "Paul": 39]
let someDictionary: Dictionary&lt;String, Int&gt; = ["Alex": 31, "Paul": 39]
</code></pre>
<p>上面两种情况，常量 <code>someDictionary</code> 被声明为一个字典，其中键为 <code>String</code> 类型，值为 <code>Int</code> 类型。</p>
<p>字典中的值可以通过下标来访问，这个下标在方括号中指明了具体的键：<code>someDictionary["Alex"]</code> 返回键 <code>Alex</code> 对应的值。如果键在字典中不存在的话，则这个下标返回 <code>nil</code>。</p>
<p>字典中键的类型必须符合 Swift 标准库中的 <code>Hashable</code> 协议。</p>
<p>关于 Swift 标准库中 <code>Dictionary</code> 类型的详细讨论，请参阅 <a href="../chapter2/04_Collection_Types.html#dictionaries">字典</a>。</p>
<blockquote>
<p>字典类型语法</p>
</blockquote>
<p><a name="dictionary-type"></a></p>
<blockquote>
<p><em>字典类型</em> → <strong>[</strong> <a href="#type"><em>类型</em></a> <strong>:</strong> <a href="#type"><em>类型</em></a> <strong>]</strong></p>
</blockquote>
<p><a name="optional_type"></a></p>
<h2 id="可选类型">可选类型</h2>
<p>Swift 定义后缀 <code>?</code> 来作为标准库中的定义的命名型类型 <code>Optional&lt;Wrapped&gt;</code> 的语法糖。换句话说，下面两个声明是等价的：</p>
<pre><code class="language-swift">var optionalInteger: Int?
var optionalInteger: Optional&lt;Int&gt;
</code></pre>
<p>在上述两种情况下，变量 <code>optionalInteger</code> 都被声明为可选整型类型。注意在类型和 <code>?</code> 之间没有空格。</p>
<p>类型 <code>Optional&lt;Wrapped&gt;</code> 是一个枚举，有两个成员，<code>none</code> 和 <code>some(Wrapped)</code>，用来表示可能有也可能没有的值。任意类型都可以被显式地声明（或隐式地转换）为可选类型。如果你在声明或定义可选变量或属性的时候没有提供初始值，它的值则会自动赋为默认值 <code>nil</code>。</p>
<p>如果一个可选类型的实例包含一个值，那么你就可以使用后缀运算符 <code>!</code> 来获取该值，正如下面描述的：</p>
<pre><code class="language-swift">optionalInteger = 42
optionalInteger! // 42
</code></pre>
<p>使用 <code>!</code> 运算符解包值为 <code>nil</code> 的可选值会导致运行错误。</p>
<p>你也可以使用可选链式调用和可选绑定来选择性地在可选表达式上执行操作。如果值为 <code>nil</code>，不会执行任何操作，因此也就没有运行错误产生。</p>
<p>更多细节以及更多如何使用可选类型的例子，请参阅 <a href="../chapter2/01_The_Basics.html#optionals">可选类型</a>。</p>
<blockquote>
<p>可选类型语法</p>
</blockquote>
<p><a name="optional-type"></a></p>
<blockquote>
<p><em>可选类型</em> → <a href="#type"><em>类型</em></a> <strong>?</strong></p>
</blockquote>
<p><a name="implicitly_unwrapped_optional_type"></a></p>
<h2 id="隐式解析可选类型">隐式解析可选类型</h2>
<p>当可以被访问时，Swift 语言定义后缀 <code>!</code> 作为标准库中命名类型 <code>Optional&lt;Wrapped&gt;</code> 的语法糖，来实现自动解包的功能。换句话说，下面两个声明等价：</p>
<pre><code class="language-swift">var implicitlyUnwrappedString: String!
var explicitlyUnwrappedString: Optional&lt;String&gt;
</code></pre>
<p>注意类型与 <code>!</code> 之间没有空格。</p>
<p>由于隐式解包修改了包涵其类型的声明语义，嵌套在元组类型或泛型的可选类型（比如字典元素类型或数组元素类型），不能被标记为隐式解包。例如：</p>
<pre><code class="language-swift">let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  // 错误
let implicitlyUnwrappedTuple: (Int, Int)!             // 正确

let arrayOfImplicitlyUnwrappedElements: [Int!]        // 错误
let implicitlyUnwrappedArray: [Int]!                  // 正确
</code></pre>
<p>由于隐式解析可选类型和可选类型有同样的表达式 <code>Optional&lt;Wrapped&gt;</code>，你可以在使用可选类型的地方使用隐式解析可选类型。比如，你可以将隐式解析可选类型的值赋给变量、常量和可选属性，反之亦然。</p>
<p>正如可选类型一样，你在声明隐式解析可选类型的变量或属性的时候也不用指定初始值，因为它有默认值 <code>nil</code>。</p>
<p>可以使用可选链式调用来在隐式解析可选表达式上选择性地执行操作。如果值为 <code>nil</code>，就不会执行任何操作，因此也不会产生运行错误。</p>
<p>关于隐式解析可选类型的更多细节，请参阅 <a href="../chapter2/01_The_Basics.html#implicityly_unwrapped_optionals">隐式解析可选类型</a>。</p>
<blockquote>
<p>隐式解析可选类型语法</p>
</blockquote>
<p><a name="implicitly-unwrapped-optional-type"></a></p>
<blockquote>
<p><em>隐式解析可选类型</em> → <a href="#type"><em>类型</em></a> <strong>!</strong></p>
</blockquote>
<p><a name="protocol_composition_type"></a></p>
<h2 id="协议合成类型">协议合成类型</h2>
<p>协议合成类型是一种符合协议列表中每个指定协议的类型。协议合成类型可能会用在类型注解和泛型参数中。</p>
<p>协议合成类型的形式如下：</p>
<blockquote>
<p><code>Protocol 1</code> &amp; <code>Procotol 2</code></p>
</blockquote>
<p>协议合成类型允许你指定一个值，其类型符合多个协议的要求且不需要定义一个新的命名型协议来继承它想要符合的各个协议。比如，协议合成类型 <code>Protocol A &amp; Protocol B &amp; Protocol C</code> 等效于一个从 <code>Protocol A</code>，<code>Protocol B</code>，<code>Protocol C</code> 继承而来的新协议 <code>Protocol D</code>，很显然这样做有效率的多，甚至不需引入一个新名字。</p>
<p>协议合成列表中的每项必须是协议名或协议合成类型的类型别名。</p>
<blockquote>
<p>协议合成类型语法</p>
</blockquote>
<p><a name="protocol-composition-type"></a></p>
<blockquote>
<p><em>协议合成类型</em> → <a href="#protocol-identifier"><em>协议标识符</em></a> &amp; <a href="#protocol-composition-continuation"><em>协议合成延续</em></a> <a name="protocol-composition-continuation"></a> <em>协议合成延续</em> → <a href="#protocol-identifier"><em>协议标识符</em></a> | <a href="#protocol-composition-type"><em>协议合成类型</em></a> <a name="protocol-identifier"></a> <em>协议标识符</em> → <a href="#type-identifier"><em>类型标识符</em></a></p>
</blockquote>
<p><a name="metatype_type"></a></p>
<h2 id="元类型">元类型</h2>
<p>元类型是指类型的类型，包括类类型、结构体类型、枚举类型和协议类型。</p>
<p>类、结构体或枚举类型的元类型是相应的类型名紧跟 <code>.Type</code>。协议类型的元类型——并不是运行时符合该协议的具体类型——而是该协议名字紧跟 <code>.Protocol</code>。比如，类 <code>SomeClass</code> 的元类型就是 <code>SomeClass.Type</code>，协议 <code>SomeProtocol</code> 的元类型就是 <code>SomeProtocal.Protocol</code>。</p>
<p>你可以使用后缀 <code>self</code> 表达式来获取类型。比如，<code>SomeClass.self</code> 返回 <code>SomeClass</code> 本身，而不是 <code>SomeClass</code> 的一个实例。同样，<code>SomeProtocol.self</code> 返回 <code>SomeProtocol</code> 本身，而不是运行时符合 <code>SomeProtocol</code> 的某个类型的实例。还可以对类型的实例使用 <code>type(of:)</code> 表达式来获取该实例在运行阶段的类型，如下所示：</p>
<pre><code class="language-swift">class SomeBaseClass {
    class func printClassName() {
        println("SomeBaseClass")
    }
}
class SomeSubClass: SomeBaseClass {
    override class func printClassName() {
        println("SomeSubClass")
    }
}
let someInstance: SomeBaseClass = SomeSubClass()
// someInstance 在编译期是 SomeBaseClass 类型，
// 但是在运行期则是 SomeSubClass 类型
type(of: someInstance).printClassName()
// 打印 “SomeSubClass”
</code></pre>
<p>更多信息可以查看 Swift 标准库里的 <code>type(of:)</code>。</p>
<p>可以使用初始化表达式从某个类型的元类型构造出一个该类型的实例。对于类实例，被调用的构造器必须使用 <code>required</code> 关键字标记，或者整个类使用 <code>final</code> 关键字标记。</p>
<pre><code class="language-swift">class AnotherSubClass: SomeBaseClass {
    let string: String
    required init(string: String) {
        self.string = string
    }
    override class func printClassName() {
        print("AnotherSubClass")
    }
}
let metatype: AnotherSubClass.Type = AnotherSubClass.self
let anotherInstance = metatype.init(string: "some string")
</code></pre>
<blockquote>
<p>元类型语法</p>
</blockquote>
<p><a name="metatype-type"></a></p>
<blockquote>
<p><em>元类型</em> → <a href="#type"><em>类型</em></a> <strong>.</strong> <strong>Type</strong> | <a href="#type"><em>类型</em></a> <strong>.</strong> <strong>Protocol</strong></p>
</blockquote>
<p><a name="type_inheritance_clause"></a></p>
<h2 id="类型继承子句">类型继承子句</h2>
<p>类型继承子句被用来指定一个命名型类型继承自哪个类、采纳哪些协议。类型继承子句也用来指定一个类类型专属协议。类型继承子句开始于冒号 <code>:</code>，其后是所需要的类、类型标识符列表或两者都有。</p>
<p>类可以继承单个超类，采纳任意数量的协议。当定义一个类时，超类的名字必须出现在类型标识符列表首位，然后跟上该类需要采纳的任意数量的协议。如果一个类不是从其它类继承而来，那么列表可以以协议开头。关于类继承更多的讨论和例子，请参阅 <a href="../chapter2/13_Inheritance.html">继承</a>。</p>
<p>其它命名型类型可能只继承或采纳一系列协议。协议类型可以继承自任意数量的其他协议。当一个协议类型继承自其它协议时，其它协议中定义的要求会被整合在一起，然后从当前协议继承的任意类型必须符合所有这些条件。正如在 <a href="05_Declarations.html#protocol_declaration">协议声明</a> 中所讨论的那样，可以把 <code>class</code> 关键字放到协议类型的类型继承子句的首位，这样就可以声明一个类类型专属协议。</p>
<p>枚举定义中的类型继承子句可以是一系列协议，或是枚举的原始值类型的命名型类型。在枚举定义中使用类型继承子句来指定原始值类型的例子，请参阅 <a href="../chapter2/08_Enumerations.html#raw_values">原始值</a>。</p>
<blockquote>
<p>类型继承子句语法</p>
</blockquote>
<p><a name="type_inheritance_clause"></a></p>
<blockquote>
<p><em>类型继承子句</em> → <strong>:</strong> <a href="#type-inheritance-list"><em>类型继承列表</em></a> <a name="type-inheritance-list"></a> <em>类型继承列表</em> → <a href="#type-identifier"><em>类型标识符</em></a> | <a href="#type-identifier"><em>类型标识符</em></a> <strong>,</strong> <a href="#type-inheritance-list"><em>类型继承列表</em></a> <a name="class-requirement"></a></p>
</blockquote>
<p><a name="type_inference"></a></p>
<h2 id="类型推断">类型推断</h2>
<p>Swift 广泛使用类型推断，从而允许你省略代码中很多变量和表达式的类型或部分类型。比如，对于 <code>var x: Int = 0</code>，你可以完全省略类型而简写成 <code>var x = 0</code>，编译器会正确推断出 <code>x</code> 的类型 <code>Int</code>。类似的，当完整的类型可以从上下文推断出来时，你也可以省略类型的一部分。比如，如果你写了 <code>let dict: Dictionary = ["A" : 1]</code>，编译器能推断出 <code>dict</code> 的类型是 <code>Dictionary&lt;String, Int&gt;</code>。</p>
<p>在上面的两个例子中，类型信息从表达式树的叶子节点传向根节点。也就是说，<code>var x: Int = 0</code> 中 <code>x</code> 的类型首先根据 <code>0</code> 的类型进行推断，然后将该类型信息传递到根节点（变量 <code>x</code>）。</p>
<p>在 Swift 中，类型信息也可以反方向流动——从根节点传向叶子节点。在下面的例子中，常量 <code>eFloat</code> 上的显式类型注解（<code>: Float</code>）将导致数字字面量 <code>2.71828</code> 的类型是 <code>Float</code> 而非 <code>Double</code>。</p>
<pre><code class="language-swift">let e = 2.71828 // e 的类型会被推断为 Double
let eFloat: Float = 2.71828 // eFloat 的类型为 Float
</code></pre>
<p>Swift 中的类型推断在单独的表达式或语句上进行。这意味着所有用于类型推断的信息必须可以从表达式或其某个子表达式的类型检查中获取到。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/64/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/64/index.html">免费的编程中文书籍索引</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/40.html">justjavac</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">56页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 33914个">33914</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/89/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/89/index.html">Go 语言资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">74页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 207个">207</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/33/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/33/index.html">Scapy 中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">10页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 17个">17</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/32/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/32/index.html">浅入浅出 Android 安全</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">9页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 59个">59</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/191/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/191/index.html">Linux秘传心法</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/107.html">trimstray</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">81页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 20277个">20277</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../../book/101/index.html">
<img class="uk-book-cover" src="../../../../static/icons/48/chrome_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../../book/101/index.html">Chromium中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="chrome">chrome</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">165页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../../" title="返回首页"><img class="" src="../../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../../book/12/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/chapter1.html" title="欢迎使用 Swift" data-book-page-rel-url="source/chapter1/chapter1.html" data-book-page-id="9797">欢迎使用 Swift</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/01_about_swift.html" title="关于 Swift" data-book-page-rel-url="source/chapter1/01_about_swift.html" data-book-page-id="9798">关于 Swift</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/02_version_compatibility.html" title="版本兼容性" data-book-page-rel-url="source/chapter1/02_version_compatibility.html" data-book-page-id="9799">版本兼容性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/03_a_swift_tour.html" title="Swift 初见" data-book-page-rel-url="source/chapter1/03_a_swift_tour.html" data-book-page-id="9800">Swift 初见</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter1/04_revision_history.html" title="Swift 版本历史记录" data-book-page-rel-url="source/chapter1/04_revision_history.html" data-book-page-id="9801">Swift 版本历史记录</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/v1.0.html" title="Swift 1.0 发布内容" data-book-page-rel-url="source/v1.0.html" data-book-page-id="9802">Swift 1.0 发布内容</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/chapter2.html" title="Swift 教程" data-book-page-rel-url="source/chapter2/chapter2.html" data-book-page-id="9803">Swift 教程</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/01_The_Basics.html" title="基础部分" data-book-page-rel-url="source/chapter2/01_The_Basics.html" data-book-page-id="9804">基础部分</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/02_Basic_Operators.html" title="基本运算符" data-book-page-rel-url="source/chapter2/02_Basic_Operators.html" data-book-page-id="9805">基本运算符</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/03_Strings_and_Characters.html" title="字符串和字符" data-book-page-rel-url="source/chapter2/03_Strings_and_Characters.html" data-book-page-id="9806">字符串和字符</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/04_Collection_Types.html" title="集合类型" data-book-page-rel-url="source/chapter2/04_Collection_Types.html" data-book-page-id="9807">集合类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/05_Control_Flow.html" title="控制流" data-book-page-rel-url="source/chapter2/05_Control_Flow.html" data-book-page-id="9808">控制流</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/06_Functions.html" title="函数" data-book-page-rel-url="source/chapter2/06_Functions.html" data-book-page-id="9809">函数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/07_Closures.html" title="闭包" data-book-page-rel-url="source/chapter2/07_Closures.html" data-book-page-id="9810">闭包</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/08_Enumerations.html" title="枚举" data-book-page-rel-url="source/chapter2/08_Enumerations.html" data-book-page-id="9811">枚举</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/09_Classes_and_Structures.html" title="类和结构体" data-book-page-rel-url="source/chapter2/09_Classes_and_Structures.html" data-book-page-id="9812">类和结构体</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/10_Properties.html" title="属性" data-book-page-rel-url="source/chapter2/10_Properties.html" data-book-page-id="9813">属性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/11_Methods.html" title="方法" data-book-page-rel-url="source/chapter2/11_Methods.html" data-book-page-id="9814">方法</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/12_Subscripts.html" title="下标" data-book-page-rel-url="source/chapter2/12_Subscripts.html" data-book-page-id="9815">下标</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/13_Inheritance.html" title="继承" data-book-page-rel-url="source/chapter2/13_Inheritance.html" data-book-page-id="9816">继承</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/14_Initialization.html" title="构造过程" data-book-page-rel-url="source/chapter2/14_Initialization.html" data-book-page-id="9817">构造过程</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/15_Deinitialization.html" title="析构过程" data-book-page-rel-url="source/chapter2/15_Deinitialization.html" data-book-page-id="9818">析构过程</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/16_Optional_Chaining.html" title="可选链" data-book-page-rel-url="source/chapter2/16_Optional_Chaining.html" data-book-page-id="9819">可选链</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/17_Error_Handling.html" title="错误处理" data-book-page-rel-url="source/chapter2/17_Error_Handling.html" data-book-page-id="9820">错误处理</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/18_Type_Casting.html" title="类型转换" data-book-page-rel-url="source/chapter2/18_Type_Casting.html" data-book-page-id="9821">类型转换</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/19_Nested_Types.html" title="嵌套类型" data-book-page-rel-url="source/chapter2/19_Nested_Types.html" data-book-page-id="9822">嵌套类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/20_Extensions.html" title="扩展" data-book-page-rel-url="source/chapter2/20_Extensions.html" data-book-page-id="9823">扩展</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/21_Protocols.html" title="协议" data-book-page-rel-url="source/chapter2/21_Protocols.html" data-book-page-id="9824">协议</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/22_Generics.html" title="泛型" data-book-page-rel-url="source/chapter2/22_Generics.html" data-book-page-id="9825">泛型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/23_Automatic_Reference_Counting.html" title="自动引用计数" data-book-page-rel-url="source/chapter2/23_Automatic_Reference_Counting.html" data-book-page-id="9826">自动引用计数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/24_Memory_Safety.html" title="内存安全" data-book-page-rel-url="source/chapter2/24_Memory_Safety.html" data-book-page-id="9827">内存安全</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/25_Access_Control.html" title="访问控制" data-book-page-rel-url="source/chapter2/25_Access_Control.html" data-book-page-id="9828">访问控制</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter2/26_Advanced_Operators.html" title="高级运算符" data-book-page-rel-url="source/chapter2/26_Advanced_Operators.html" data-book-page-id="9829">高级运算符</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="语言参考" disabled data-book-page-rel-url="" data-book-page-id="9830">语言参考</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/01_About_the_Language_Reference.html" title="关于语言参考" data-book-page-rel-url="source/chapter3/01_About_the_Language_Reference.html" data-book-page-id="9831">关于语言参考</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/02_Lexical_Structure.html" title="词法结构" data-book-page-rel-url="source/chapter3/02_Lexical_Structure.html" data-book-page-id="9832">词法结构</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/03_Types.html" title="类型" data-book-page-rel-url="source/chapter3/03_Types.html" data-book-page-id="9833">类型</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/04_Expressions.html" title="表达式" data-book-page-rel-url="source/chapter3/04_Expressions.html" data-book-page-id="9834">表达式</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/05_Statements.html" title="语句" data-book-page-rel-url="source/chapter3/05_Statements.html" data-book-page-id="9835">语句</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/06_Declarations.html" title="声明" data-book-page-rel-url="source/chapter3/06_Declarations.html" data-book-page-id="9836">声明</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/07_Attributes.html" title="特性" data-book-page-rel-url="source/chapter3/07_Attributes.html" data-book-page-id="9837">特性</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/08_Patterns.html" title="模式" data-book-page-rel-url="source/chapter3/08_Patterns.html" data-book-page-id="9838">模式</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/09_Generic_Parameters_and_Arguments.html" title="泛型参数" data-book-page-rel-url="source/chapter3/09_Generic_Parameters_and_Arguments.html" data-book-page-id="9839">泛型参数</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter3/10_Summary_of_the_Grammar.html" title="语法总结" data-book-page-rel-url="source/chapter3/10_Summary_of_the_Grammar.html" data-book-page-id="9840">语法总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="苹果官方 Blog 官方翻译" disabled data-book-page-rel-url="" data-book-page-id="9841">苹果官方 Blog 官方翻译</a>
<ul>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/01_Access_Control.html" title="Access Control 权限控制的黑与白" data-book-page-rel-url="source/chapter4/01_Access_Control.html" data-book-page-id="9842">Access Control 权限控制的黑与白</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/02_Type_Custom.html" title="造个类型不是梦-白话 Swift 类型创建" data-book-page-rel-url="source/chapter4/02_Type_Custom.html" data-book-page-id="9843">造个类型不是梦-白话 Swift 类型创建</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/03_Ballons.html" title="WWDC 里面的那个“大炮打气球”" data-book-page-rel-url="source/chapter4/03_Ballons.html" data-book-page-id="9844">WWDC 里面的那个“大炮打气球”</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/04_Interacting_with_C_Pointers.html" title="Swift 与 C 语言指针友好合作" data-book-page-rel-url="source/chapter4/04_Interacting_with_C_Pointers.html" data-book-page-id="9845">Swift 与 C 语言指针友好合作</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/05_Value_and_Reference_Types.html" title="引用类型和值类型的恩怨" data-book-page-rel-url="source/chapter4/05_Value_and_Reference_Types.html" data-book-page-id="9846">引用类型和值类型的恩怨</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/06_Access_Control_and_Protected.html" title="访问控制和 Protected" data-book-page-rel-url="source/chapter4/06_Access_Control_and_Protected.html" data-book-page-id="9847">访问控制和 Protected</a>
</li>
<li>
<a class="pjax" href="../../../../book/12/source/chapter4/07_Optional_Case_Study.html" title="可选类型完美解决占位问题" data-book-page-rel-url="source/chapter4/07_Optional_Case_Study.html" data-book-page-id="9848">可选类型完美解决占位问题</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =12;var bookPageId =9833;var bookPageRelUrl ='source/chapter3/03_Types.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>