
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>愉快地结束-aiohttp 中文文档</title>
<meta content='愉快地结束,aiohttp 中文文档' name='keywords'>
<meta content='愉快地结束,aiohttp 中文文档' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/127/aiohttp文档/Introduce.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">简介及快速开始</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/127/aiohttp文档/ClientReference.html">
<span class="">客户端部分参考</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/127/index.html">aiohttp 中文文档</a>
<a target="_blank" rel="nofollow" href="https://github.com/HuberTRoy/aiohttp-chinese-documentation" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="客户端使用">客户端使用</h1>
<h2 id="发起请求">发起请求</h2>
<p>让我们从导入aiohttp模块开始:</p>
<p><code>import aiohttp</code></p>
<p>好啦，我们来尝试获取一个web页面。比如我们来获取下GitHub的时间轴。</p>
<pre><code>async with aiohttp.ClientSession() as session:
    async with session.get('https://api.github.com/events') as resp:
        print(resp.status)
        print(await resp.text())
</code></pre>
<p>我们现在有了一个<code>会话(session)</code>对象，由<strong>ClientSession</strong>对象赋值而来，还有一个变量<code>resp</code>，它其实是<strong>ClientResponse</strong>对象。我们可以从这个响应对象中获取我们任何想要的信息。协程方法<code>ClientSession.get()</code>的主要参数接受一个HTTP URL。</p>
<p>发起HTTP POST请求我们可以使用协程方法<strong>ClientSession.post</strong>():</p>
<pre><code>session.post('http://httpbin.org/post', data=b'data')
</code></pre>
<p>其他的HTTP方法也同样支持:</p>
<pre><code>session.put('http://httpbin.org/put', data=b'data')
session.delete('http://httpbin.org/delete')
session.head('http://httpbin.org/get')
session.options('http://httpbin.org/get')
session.patch('http://httpbin.org/patch', data=b'data')
</code></pre>
<blockquote>
<h3 id="注意">注意:</h3>
</blockquote>
<p>不要为每个请求都创建一个会话。大多数情况下每个应用程序只需要一个会话就可以执行所有的请求。 每个会话对象都包含一个连接池，可复用的连接和持久连接状态(keep-alives，这两个是默认的)可提升总体的执行效率。</p>
<h2 id="发起json请求">发起JSON请求:</h2>
<p>每个会话的请求方法都可接受json参数。</p>
<pre><code>async with aiohttp.ClientSession() as session:
    async with session.post(json={'test': 'object'})
</code></pre>
<p>默认情况下会话(session)使用Python标准库里的json模块解析json信息。但还可使用其他的json解析器。可以给ClientSession指定<em>json_serialize</em>参数来实现:</p>
<pre><code>import ujson

async with aiohttp.ClientSession(json_serialize=ujson.dumps) as session:
    async with session.post(json={'test': 'object'})
</code></pre>
<h2 id="传递url中的参数">传递URL中的参数:</h2>
<p>你可能经常想在URL中发送一系列的查询信息。如果你手动构建他们，这些信息会以键值对的形式出现在?后面，比如: <code>httpbin.org/get?key=val</code>。请求对象允许你使用**dict（字典，python中的数据类型）**发送它们，使用<code>params</code>参数即可。例如: 如果你要把 <code>key1=value1，key2=value2</code>放到<code>httpbin.org/get</code>后面，你可以用下面的方式:</p>
<pre><code>params = {'key1': 'value1', 'key2': 'value2'}
async with session.get('http://httpbin.org/get',
                       params=params) as resp:
    assert str(resp.url) == 'http://httpbin.org/get?key2=value2&amp;key1=value1'
</code></pre>
<p>看，URL已经被正确的编码啦。 同键不同值的**并联字典（MultiDict） **也同样支持。 可使用带有两个tuples(元组，python中的数据类型)的list(列表，python中的数据类型)来构建:</p>
<pre><code>params = [('key', 'value1'), ('key', 'value2')]
async with session.get('http://httpbin.org/get',
                       params=params) as r:
    assert str(r.url) == 'http://httpbin.org/get?key=value2&amp;key=value1'
</code></pre>
<p>同样也允许你传递<strong>str</strong>（字符串）给params，但要小心一些不能被编码的字符。<code>+</code>就是一个不能被编码的字符:</p>
<pre><code>async with session.get('http://httpbin.org/get',
                       params='key=value+1') as r:
        assert str(r.url) == 'http://httpbin.org/get?key=value+1'
</code></pre>
<blockquote>
<h3 id="注意-1">注意:</h3>
</blockquote>
<p><em>aiohttp</em>会在发送请求前标准化URL。 域名部分会用<a href="https://aiohttp.readthedocs.io/en/stable/glossary.html#term-idna">IDNA</a> 编码，路径和查询条件会<a href="https://aiohttp.readthedocs.io/en/stable/glossary.html#term-requoting">重新编译(requoting)</a>。 比如:<code>URL('http://example.com/путь%30?a=%31')</code> 会被转化为<code>URL('http://example.com/%D0%BF%D1%83%D1%82%D1%8C/0?a=1')</code> 如果服务器需要接受准确的表示并不要求编译URL，那标准化过程应是禁止的。 禁止标准化可以使用<code>encoded=True</code>:</p>
<pre><code>await session.get(URL('http://example.com/%30', encoded=True))
</code></pre>
<blockquote>
<h3 id="警告">警告:</h3>
</blockquote>
<p>传递<em>params</em>时不要用<code>encode=True</code>，这俩参数不能同时使用。</p>
<h2 id="获取响应内容">获取响应内容</h2>
<p>我们可以读取服务器的响应内容。想想我们获取GitHub时间轴的例子:</p>
<pre><code>async with session.get('https://api.github.com/events') as resp:
    print(await resp.text())
</code></pre>
<p>这样会打印出类似于下面的信息:</p>
<pre><code>'[{"created_at":"2015-06-12T14:06:22Z","public":true,"actor":{...
</code></pre>
<p><code>aiohttp</code>将会自动解码内容。你可以为<strong>text</strong>()方法指定编码(使用encoding参数):</p>
<pre><code>await resp.text(encoding='windows-1251')
</code></pre>
<h2 id="获取二进制响应内容">获取二进制响应内容</h2>
<p>你也可以以字节形式获取响应，这样得到的就不是文本了:</p>
<pre><code>print(await resp.read())
b'[{"created_at":"2015-06-12T14:06:22Z","public":true,"actor":{...
</code></pre>
<p><code>gzip</code>和<code>defalte</code>传输编码会自动解码。 你也可以使其支持<code>brotli</code>传输编码的解码，只需安装<a href="https://github.com/python-hyper/brotlipy">brotlipy</a>即可。</p>
<h2 id="获取json响应内容">获取JSON响应内容</h2>
<p>以防你需要处理JSON数据，内置了一个JSON解码器:</p>
<pre><code>async with session.get('https://api.github.com/events') as resp:
    print(await resp.json())
</code></pre>
<p>如果JSON解码失败，<strong>json</strong>()方法将会抛出一个异常。你还可以在调用<strong>json</strong>()时指定编码器和解码器函数。</p>
<blockquote>
<h3 id="注意-2">注意:</h3>
</blockquote>
<p>这些方法会读出内存中所有响应的内容。如果你要读非常多的数据，考虑使用流式响应方法进行读取。请看之后的文档。</p>
<h2 id="获取流式响应内容">获取流式响应内容</h2>
<p><strong>read</strong>(), <strong>json</strong>(), <strong>text</strong>()等方法使用起来很方便，但也要注意谨慎地使用。上述方法会将所有的响应内容加载到内存。举个例子，如果你要下载几个G的文件，这些方法还是会将所有内容都加载到内存，内存会表示"臣妾做不到啊~"(如果内存不够的话)。作为代替你可以用<strong>content</strong>属性。content其实是 <strong>aiohttp.StreamReader</strong>类的实例。<code>gzip</code>和<code>deflate</code>传输编码同样会自动解码。</p>
<pre><code>async with session.get('https://api.github.com/events') as resp:
    await resp.content.read(10)
</code></pre>
<p>一般情况下你可以使用下列模式将内容保存在一个文件中:</p>
<pre><code>with open(filename, 'wb') as fd:
    while True:
        chunk = await resp.content.read(chunk_size)
        if not chunk:
            break
        fd.write(chunk)
</code></pre>
<p>在使用<strong>content</strong>读了数据后，就不要在用<strong>read</strong>(), <strong>json</strong>(), <strong>text</strong>()了。</p>
<h2 id="获取请求信息">获取请求信息</h2>
<p><em>ClientResponse（客户端响应）<em>对象含有request_info(请求信息)，主要是</em>url</em>和<em>headers</em>信息。 <em>raise_for_status</em>结构体上的信息会被复制给ClientResponseError实例。</p>
<h2 id="自定义headers">自定义Headers</h2>
<p>如果你需要给某个请求添加HTTP头,可以使用headers参数，传递一个<strong>dict</strong>对象即可。 比如，如果你想给之前的例子指定 content-type可以这样:</p>
<pre><code>import json
url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}
headers = {'content-type': 'application/json'}

await session.post(url,
                   data=json.dumps(payload),
                   headers=headers)
</code></pre>
<h2 id="自定义cookies">自定义Cookies</h2>
<p>发送你自己的cookies给服务器，你可以为<strong>ClientSession</strong>对象指定<em>cookies</em>参数:</p>
<pre><code>url = 'http://httpbin.org/cookies'
cookies = {'cookies_are': 'working'}
async with ClientSession(cookies=cookies) as session:
    async with session.get(url) as resp:
        assert await resp.json() == {
           "cookies": {"cookies_are": "working"}}
</code></pre>
<blockquote>
<h3 id="注意-3">注意:</h3>
</blockquote>
<p>访问<code>httpbin.org/cookies</code> 会看到以JSON形式返回的cookies。查阅会话中的cookies请看<a href="https://aiohttp.readthedocs.io/en/stable/client_reference.html#aiohttp.ClientSession.cookie_jar">ClientSession.cookie_jar</a>。</p>
<h2 id="发起更复杂的post请求">发起更复杂的POST请求</h2>
<p>一般来说，如果你想以表单形式发送一些数据 - 就像HTML表单。那么只需要简单的将一个dict通过<em>data</em>参数传递就可以。传递的dict数据会自动编码:</p>
<pre><code>payload = {'key1': 'value1', 'key2': 'value2'}
async with session.post('http://httpbin.org/post',
                        data=payload) as resp:
    print(await resp.text())
{
  ...
  "form": {
    "key2": "value2",
    "key1": "value1"
  },
  ...
}
</code></pre>
<p>如果你想发送非表单形式的数据你可用<code>str(字符串)</code>代替<code>dict(字典)</code>。这些数据会直接发送出去。 例如，GitHub API v3 接受JSON编码POST/PATCH数据:</p>
<pre><code>import json
url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}

async with session.post(url, data=json.dumps(payload)) as resp:
    ...
</code></pre>
<h2 id="发送多部分编码文件multipart-encoded">发送多部分编码文件(Multipart-Encoded)</h2>
<p>上传多部分编码文件:</p>
<pre><code>url = 'http://httpbin.org/post'
files = {'file': open('report.xls', 'rb')}

await session.post(url, data=files)
</code></pre>
<p>你也可以显式地设置文件名，文件类型:</p>
<pre><code>url = 'http://httpbin.org/post'
data = FormData()
data.add_field('file',
               open('report.xls', 'rb'),
               filename='report.xls',
               content_type='application/vnd.ms-excel')

await session.post(url, data=data)
</code></pre>
<p>如果你把一个文件对象传递给data参数，aiohttp会自动将其以流的形式上传。查看<strong>StreamReader</strong>以获取支持的格式信息。</p>
<blockquote>
<h3 id="参见">参见:</h3>
</blockquote>
<p><a href="https://aiohttp.readthedocs.io/en/stable/multipart.html#aiohttp-multipart">使用Multipart.</a></p>
<h2 id="流式上传">流式上传</h2>
<p><strong>aiohttp</strong> 支持多种形式的流式上传，允许你直接发送大文件而不必读到内存。</p>
<p>下面是个简单的例子，提供类文件对象即可:</p>
<pre><code>with open('massive-body', 'rb') as f:
   await session.post('http://httpbin.org/post', data=f)
</code></pre>
<p>或者你也可以使用<em>aiohttp.streamer</em>对象：</p>
<pre><code>@aiohttp.streamer
def file_sender(writer, file_name=None):
    with open(file_name, 'rb') as f:
        chunk = f.read(2**16)
        while chunk:
            yield from writer.write(chunk)
            chunk = f.read(2**16)

# 之后你可以使用’file_sender‘传递给data:

async with session.post('http://httpbin.org/post',
                        data=file_sender(file_name='huge_file')) as resp:
    print(await resp.text())
</code></pre>
<p>同样可以使用<strong>StreamReader</strong>对象.</p>
<p>我们来看下如何把来自于另一个请求的内容作为文件上传并计算其SHA1值:</p>
<pre><code>async def feed_stream(resp, stream):
    h = hashlib.sha256()

    while True:
        chunk = await resp.content.readany()
        if not chunk:
            break
        h.update(chunk)
        stream.feed_data(chunk)

    return h.hexdigest()

resp = session.get('http://httpbin.org/post')
stream = StreamReader()
loop.create_task(session.post('http://httpbin.org/post', data=stream))

file_hash = await feed_stream(resp, stream)
</code></pre>
<p>因为响应对象的content属性是一个<code>StreamReader</code>实例，所以你可以将get和post请求连在一起用:</p>
<pre><code>r = await session.get('http://python.org')
await session.post('http://httpbin.org/post',
                   data=r.content)
</code></pre>
<h2 id="上传预压缩过的数据">上传预压缩过的数据</h2>
<p>上传一个已经压缩过的数据，需要为Headers中的<code>Content-Encoding</code>指定算法名(通常是deflate或者是zlib).</p>
<pre><code>async def my_coroutine(session, headers, my_data):
    data = zlib.compress(my_data)
    headers = {'Content-Encoding': 'deflate'}
    async with session.post('http://httpbin.org/post',
                            data=data,
                            headers=headers)
        pass
</code></pre>
<h2 id="持久连接keep-alive-连接池和cookies共享">持久连接(keep-alive), 连接池和cookies共享</h2>
<p><strong>ClientSession</strong>可以在多个请求之间共享cookies:</p>
<pre><code>async with aiohttp.ClientSession() as session:
    await session.get(
        'http://httpbin.org/cookies/set?my_cookie=my_value')
    filtered = session.cookie_jar.filter_cookies('http://httpbin.org')
    assert filtered['my_cookie'].value == 'my_value'
    async with session.get('http://httpbin.org/cookies') as r:
        json_body = await r.json()
        assert json_body['cookies']['my_cookie'] == 'my_value'
</code></pre>
<p>你也可以为所有的会话请求设置headers:</p>
<pre><code>async with aiohttp.ClientSession(
    headers={"Authorization": "Basic bG9naW46cGFzcw=="}) as session:
    async with session.get("http://httpbin.org/headers") as r:
        json_body = await r.json()
        assert json_body['headers']['Authorization'] == \
            'Basic bG9naW46cGFzcw=='
</code></pre>
<p><strong>ClientSession</strong>支持持久连接和连接池，可直接使用，不需要额外操作。</p>
<h2 id="安全cookies">安全cookies</h2>
<p><strong>ClientSession</strong>中的默认的<strong>aiohttp.CookiesJar</strong>使用的是严苛模式，<a href="https://tools.ietf.org/html/rfc2109.html">RFC 2109</a>明确禁止使用ip地址形式的URL携带cookies信息。比如: <em>http://127.0.0.1:80/cookie</em> 这样很好，不过有些时候我们测试时需要允许携带cookies。在<strong>aiohttp.CookiesJar</strong>中传递<em>unsafe=True</em>来实现这一效果:</p>
<pre><code>jar = aiohttp.CookieJar(unsafe=True)
session = aiohttp.ClientSession(cookie_jar=jar)
</code></pre>
<h2 id="使用虚假cookie-jar">使用虚假Cookie Jar</h2>
<p>有时不想处理cookie。这时可以在会话中使用<strong>aiohttp.DummyCookieJar</strong>来达到目的。</p>
<pre><code>jar = aiohttp.DummyCookieJar()
session = aiohttp.ClientSession(cookie_jar=jar)
</code></pre>
<h2 id="使用连接器">使用连接器</h2>
<p>想要调整请求的传输层你可以为<strong>ClientSession</strong>及其同类组件传递自定义的连接器。例如:</p>
<pre><code>conn = aiohttp.TCPConnector()
session = aiohttp.ClientSession(connector=conn)
</code></pre>
<blockquote>
<h3 id="注解">注解:</h3>
</blockquote>
<p>不要给多个会话对象使用同一个连接器，某一会话对象拥有其所有权。</p>
<blockquote>
<h3 id="参见-1">参见:</h3>
</blockquote>
<p>查看<a href="https://aiohttp.readthedocs.io/en/stable/client_reference.html#aiohttp-client-reference-connectors">连接器</a>部分了解更多不同的连接器类型和配置选项信息。</p>
<h2 id="限制连接池的容量">限制连接池的容量</h2>
<p>限制同一时间打开的连接数可以传递limit参数:</p>
<pre><code>conn = aiohttp.TCPConnector(limit=30)
</code></pre>
<p>这样就将总数限制在30.</p>
<p>默认情况下是100.</p>
<p>如果你不想有限制，传递0即可:</p>
<pre><code>conn = aiohttp.TCPConnector(limit=0)
</code></pre>
<p>限制同一时间在同一个端点((<code>host</code>, <code>port</code>, <code>is_ssl</code>) 3者都一样的情况)打开的连接数可指定limit_per_host参数:</p>
<pre><code>conn = aiohttp.TCPConnector(limit_per_host=30)
</code></pre>
<p>这样会限制在30. 默认情况下是0(也就是不做限制)。</p>
<h2 id="使用自定义域名服务器">使用自定义域名服务器</h2>
<p>底层需要<a href="https://aiohttp.readthedocs.io/en/stable/glossary.html#term-aiodns">aiodns</a>支持:</p>
<pre><code>from aiohttp.resolver import AsyncResolver

resolver = AsyncResolver(nameservers=["8.8.8.8", "8.8.4.4"])
conn = aiohttp.TCPConnector(resolver=resolver)
</code></pre>
<h2 id="为tcp-sockets添加ssl控制">为TCP sockets添加SSL控制:</h2>
<p>默认情况下aiohttp总会对使用了HTTPS协议(的URL请求)查验其身份。但也可将<em>verify_ssl</em>设置为<code>False</code>让其不检查:</p>
<pre><code>r = await session.get('https://example.com', verify_ssl=False)
</code></pre>
<p>如果你需要设置自定义SSL信息(比如使用自己的证书文件)你可以创建一个<strong>ssl.SSLContext</strong>实例并传递到<strong>ClientSession</strong>中:</p>
<pre><code>sslcontext = ssl.create_default_context(
   cafile='/path/to/ca-bundle.crt')
r = await session.get('https://example.com', ssl_context=sslcontext)
</code></pre>
<p>如果你要验证<em>自签名</em>的证书，你也可以用之前的例子做同样的事，但是用的是load_cert_chain():</p>
<pre><code>sslcontext = ssl.create_default_context(
   cafile='/path/to/ca-bundle.crt')
sslcontext.load_cert_chain('/path/to/client/public/device.pem',
                           '/path/to/client/private/device.jey')
r = await session.get('https://example.com', ssl_context=sslcontext)
</code></pre>
<p>SSL验证失败时抛出的错误:</p>
<p><strong>aiohttp.ClientConnectorSSLError</strong>:</p>
<pre><code>try:
    await session.get('https://expired.badssl.com/')
except aiohttp.ClientConnectorSSLError as e:
    assert isinstance(e, ssl.SSLError)
</code></pre>
<p><strong>aiohttp.ClientConnectorCertificateError</strong>:</p>
<pre><code>try:
    await session.get('https://wrong.host.badssl.com/')
except aiohttp.ClientConnectorCertificateError as e:
    assert isinstance(e, ssl.CertificateError)
</code></pre>
<p>如果你需要忽略所有SSL的错误:</p>
<p><strong>aiohttp.ClientSSLError</strong>:</p>
<pre><code>try:
    await session.get('https://expired.badssl.com/')
except aiohttp.ClientSSLError as e:
    assert isinstance(e, ssl.SSLError)

try:
    await session.get('https://wrong.host.badssl.com/')
except aiohttp.ClientSSLError as e:
    assert isinstance(e, ssl.CertificateError)
</code></pre>
<p>你还可以通过<em>SHA256</em>指纹验证证书:</p>
<pre><code># Attempt to connect to https://www.python.org
# with a pin to a bogus certificate:
bad_fingerprint = b'0'*64
exc = None
try:
    r = await session.get('https://www.python.org',
                          fingerprint=bad_fingerprint)
except aiohttp.FingerprintMismatch as e:
    exc = e
assert exc is not None
assert exc.expected == bad_fingerprint

# www.python.org cert's actual fingerprint
assert exc.got == b'...'
</code></pre>
<p>注意这是以DER编码的证书的指纹。如果你的证书是PEM编码，你需要转换成DER格式:</p>
<pre><code>openssl x509 -in crt.pem -inform PEM -outform DER &gt; crt.der
</code></pre>
<blockquote>
<h3 id="注解-1">注解:</h3>
</blockquote>
<p>提示: 从16进制数字转换成二进制字节码，你可以用<strong>binascii.unhexlify</strong>().</p>
<p><strong>TCPConnector</strong>中设置的<em>verify_ssl, fingerprint和ssl_context</em>都会被当做默认的verify_ssl, fingerprint和ssl_context，<strong>ClientSession</strong>或其他同类组件中的设置会覆盖默认值。</p>
<blockquote>
<h3 id="警告-1">警告:</h3>
</blockquote>
<p><em>verify_ssl 和 ssl_context</em>是<em>互斥</em>的。 <em>MD5</em>和<em>SHA1</em>指纹虽不赞成使用但是是支持的 - 这俩是非常不安全的哈希函数。</p>
<h2 id="unix-域套接字">Unix 域套接字</h2>
<p>如果你的服务器使用UNIX域套接字你可以用<strong>UnixConnector</strong>:</p>
<pre><code>conn = aiohttp.UnixConnector(path='/path/to/socket')
session = aiohttp.ClientSession(connector=conn)
</code></pre>
<h2 id="代理支持">代理支持</h2>
<p>aiohttp 支持 HTTP/HTTPS形式的代理。你需要使用<em>proxy</em>参数:</p>
<pre><code>async with aiohttp.ClientSession() as session:
    async with session.get("http://python.org",
                           proxy="http://some.proxy.com") as resp:
        print(resp.status)
</code></pre>
<p>同时支持认证代理:</p>
<pre><code>async with aiohttp.ClientSession() as session:
    proxy_auth = aiohttp.BasicAuth('user', 'pass')
    async with session.get("http://python.org",
                           proxy="http://some.proxy.com",
                           proxy_auth=proxy_auth) as resp:
        print(resp.status)
</code></pre>
<p>也可将代理的验证信息放在url中:</p>
<pre><code>session.get("http://python.org",
            proxy="http://user:pass@some.proxy.com")
</code></pre>
<p>与<code>requests(另一个广受欢迎的http包)</code>不同，aiohttp默认不会读取环境变量中的代理值。但你可以通过传递<code>trust_env=True</code>来让<strong>aiohttp.ClientSession</strong>读取<em>HTTP_PROXY</em>或<em>HTTPS_PROXY</em>环境变量中的代理信息(不区分大小写)。</p>
<pre><code>async with aiohttp.ClientSession() as session:
    async with session.get("http://python.org", trust_env=True) as resp:
        print(resp.status)
</code></pre>
<h2 id="查看响应状态码">查看响应状态码</h2>
<p>我们可以查询响应状态码:</p>
<pre><code>async with session.get('http://httpbin.org/get') as resp:
    assert resp.status == 200
</code></pre>
<h2 id="获取响应头信息">获取响应头信息</h2>
<p>我们可以查看服务器的响应信息, <strong>ClientResponse.headers</strong>使用的数据类型是<strong>CIMultiDcitProxy</strong>:</p>
<pre><code>&gt;&gt;&gt; resp.headers
{'ACCESS-CONTROL-ALLOW-ORIGIN': '*',
 'CONTENT-TYPE': 'application/json',
 'DATE': 'Tue, 15 Jul 2014 16:49:51 GMT',
 'SERVER': 'gunicorn/18.0',
 'CONTENT-LENGTH': '331',
 'CONNECTION': 'keep-alive'}
</code></pre>
<p>这是一个特别的字典，它只为HTTP头信息而生。根据<a href="http://tools.ietf.org/html/rfc7230#section-3.2"> RFC 7230</a>，HTTP头信息中的名字是不分区大小写的。同时也支持多个不同的值对应同一个键。</p>
<p>所以我们可以通过任意形式访问它:</p>
<pre><code>&gt;&gt;&gt; resp.headers['Content-Type']
'application/json'

&gt;&gt;&gt; resp.headers.get('content-type')
'application/json'
</code></pre>
<p>所有的header信息都是由二进制数据转换而来，使用带有<code>surrogateescape</code>选项的UTF-8编码方式(surrogateescape是一种错误处理方式，详情看&lt;a href="https://docs.python.org/3/library/codecs.html#error-handlers" 这里))。大部分时候都可以很好的工作，但如果服务器使用的不是标准编码就不能正常解码了。从<a href="http://tools.ietf.org/html/rfc7230#section-3.2"> RFC 7230</a>的角度来看这样的headers并不是合理的格式，你可以用<strong>ClientReponse.resp.raw_headers</strong>来查看原形:</p>
<pre><code>&gt;&gt;&gt; resp.raw_headers
((b'SERVER', b'nginx'),
 (b'DATE', b'Sat, 09 Jan 2016 20:28:40 GMT'),
 (b'CONTENT-TYPE', b'text/html; charset=utf-8'),
 (b'CONTENT-LENGTH', b'12150'),
 (b'CONNECTION', b'keep-alive'))
</code></pre>
<h2 id="获取响应cookies">获取响应cookies:</h2>
<p>如果某响应包含一些Cookies，你可以很容易地访问他们:</p>
<pre><code>url = 'http://example.com/some/cookie/setting/url'
async with session.get(url) as resp:
    print(resp.cookies['example_cookie_name'])
</code></pre>
<blockquote>
<h3 id="注意-4">注意:</h3>
</blockquote>
<p>响应中的cookies只包含重定向链中最后一个请求中的<code>Set-Cookies</code>头信息设置的值。如果每一次重定向请求都收集一次cookies请使用<a href="https://aiohttp.readthedocs.io/en/stable/client.html#aiohttp-client-session"> aiohttp.ClientSession</a>对象.</p>
<h2 id="获取响应历史">获取响应历史</h2>
<p>如果一个请求被重定向了，你可以用<strong>history</strong>属性查看其之前的响应:</p>
<pre><code>&gt;&gt;&gt; resp = await session.get('http://example.com/some/redirect/')
&gt;&gt;&gt; resp
&lt;ClientResponse(http://example.com/some/other/url/) [200]&gt;
&gt;&gt;&gt; resp.history
(&lt;ClientResponse(http://example.com/some/redirect/) [301]&gt;,)
</code></pre>
<p>如果没有重定向或<code>allow_redirects</code>设置为<code>False</code>，history会被设置为空。</p>
<h2 id="使用websockets">使用WebSockets</h2>
<p><strong>aiohttp</strong>提供开箱即用的客户端websocket。 你需要使用<strong>aiohttp.ClientSession.ws_connect</strong>()协程对象。它的第一个参数接受URL，返回值是<strong>ClientWebSocketResponse</strong>，这样你就可以用响应的方法与websocket服务器进行通信。</p>
<pre><code>session = aiohttp.ClientSession()
async with session.ws_connect('http://example.org/websocket') as ws:

    async for msg in ws:
        if msg.type == aiohttp.WSMsgType.TEXT:
            if msg.data == 'close cmd':
                await ws.close()
                break
            else:
                await ws.send_str(msg.data + '/answer')
        elif msg.type == aiohttp.WSMsgType.CLOSED:
            break
        elif msg.type == aiohttp.WSMsgType.ERROR:
            break
</code></pre>
<p>你只能使用一种读取方式(例如<code>await ws.receive()</code> 或者 <code>async for msg in ws:</code>)和写入方法，但可以有多个写入任务，写入任务也是异步完成的(<code>ws.send_str('data')</code>)。</p>
<h2 id="设置超时">设置超时</h2>
<p>默认情况下每个IO操作有5分钟超时时间。可以通过给<strong>ClientSession.get</strong>()及其同类组件传递<code>timeout</code>来覆盖原超时时间:</p>
<pre><code>async with session.get('https://github.com', timeout=60) as r:
    ...
</code></pre>
<p><code>None</code> 或者<code>0</code>则表示不检测超时。 还可通过调用<strong>async_timeout.timeout</strong>上下文管理器来为连接和解析响应内容添加一个总超时时间:</p>
<pre><code>import async_timeout

with async_timeout.timeout(0.001):
    async with session.get('https://github.com') as r:
        await r.text()
</code></pre>
<blockquote>
<h3 id="注意-5">注意:</h3>
</blockquote>
<p>超时时间是累计的，包含如发送情况，重定向，响应解析，处理响应等所有操作在内...</p>
<h2 id="愉快地结束">愉快地结束:</h2>
<p>当一个包含<code>ClientSession</code>的<code>async with</code>代码块的末尾行结束时(或直接调用了<code>.close()</code>)，因为asyncio内部的一些原因底层的连接其实没有关闭。在实际使用中，底层连接需要有一个缓冲时间来关闭。然而，如果事件循环在底层连接关闭之前就结束了，那么会抛出一个 资源警告: 存在未关闭的传输(通道)(<code>ResourceWarning: unclosed transport</code>),如果警告可用的话。 为了避免这种情况，在关闭事件循环前加入一小段延迟让底层连接得到关闭的缓冲时间。 对于非SSL的<code>ClientSession</code>, 使用0即可(<code>await asyncio.sleep(0)</code>):</p>
<pre><code>async def read_website():
    async with aiohttp.ClientSession() as session:
        async with session.get('http://example.org/') as response:
            await response.read()

loop = asyncio.get_event_loop()
loop.run_until_complete(read_website())
# Zero-sleep to allow underlying connections to close
loop.run_until_complete(asyncio.sleep(0))
loop.close()
</code></pre>
<p>对于使用了SSL的<code>ClientSession</code>, 需要设置一小段合适的时间:</p>
<pre><code>...
# Wait 250 ms for the underlying SSL connections to close
loop.run_until_complete(asyncio.sleep(0.250))
loop.close()
</code></pre>
<p>合适的时间因应用程序而异。</p>
<p>当asyncio内部的运行机制改变时就可以让aiohttp去等待底层连接关闭在退出啦，上面这种额外的方法总会废弃啦。你也可以跟进问题<a href="https://github.com/aio-libs/aiohttp/issues/1925">#1925</a>来参与改进。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/97/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/97/index.html">Twisted与异步编程入门</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/60.html">likebeta</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 158个">158</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/130/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/130/index.html">进击的Python</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/68.html">HuberTRoy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 169个">169</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/96/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/96/index.html">零基础学Python</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/59.html">qiwsir</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">80页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1635个">1635</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/74/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/74/index.html">Python进阶</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/46.html">东滨社</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">73页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2664个">2664</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/66/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/66/index.html">Java 8:新特性教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/42.html">shekhargulati</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">9页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1241个">1241</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/44/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/44/index.html">Shell 编程范例</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/23.html">泰晓科技</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月30日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 296个">296</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/127/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/127/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/127/SREADME.html" title="前言" data-book-page-rel-url="SREADME.html" data-book-page-id="9892">前言</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/Introduce.html" title="简介及快速开始" data-book-page-rel-url="aiohttp文档/Introduce.html" data-book-page-id="9893">简介及快速开始</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="客户端部分" disabled data-book-page-rel-url="Client.html" data-book-page-id="9894">客户端部分</a>
<ul>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/ClientUsage.html" title="愉快地结束" data-book-page-rel-url="aiohttp文档/ClientUsage.html" data-book-page-id="9895">愉快地结束</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/ClientReference.html" title="客户端部分参考" data-book-page-rel-url="aiohttp文档/ClientReference.html" data-book-page-id="9896">客户端部分参考</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="服务端部分" disabled data-book-page-rel-url="Server.html" data-book-page-id="9897">服务端部分</a>
<ul>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/ServerTutorial.html" title="使用中间件" data-book-page-rel-url="aiohttp文档/ServerTutorial.html" data-book-page-id="9898">使用中间件</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/ServerUsage.html" title="开发工具箱" data-book-page-rel-url="aiohttp文档/ServerUsage.html" data-book-page-id="9899">开发工具箱</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/LowLevelServer.html" title="底层服务器搭建" data-book-page-rel-url="aiohttp文档/LowLevelServer.html" data-book-page-id="9900">底层服务器搭建</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/ServerReference.html" title="服务器端参考" data-book-page-rel-url="aiohttp文档/ServerReference.html" data-book-page-id="9901">服务器端参考</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/Logging.html" title="日志" data-book-page-rel-url="aiohttp文档/Logging.html" data-book-page-id="9902">日志</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/Testing.html" title="测试" data-book-page-rel-url="aiohttp文档/Testing.html" data-book-page-id="9903">测试</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/ServerDeployment.html" title="服务器部署" data-book-page-rel-url="aiohttp文档/ServerDeployment.html" data-book-page-id="9904">服务器部署</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="其他工具包" disabled data-book-page-rel-url="Utilities.html" data-book-page-id="9905">其他工具包</a>
<ul>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/AbstractBaseClasses.html" title="抽象访问日志" data-book-page-rel-url="aiohttp文档/AbstractBaseClasses.html" data-book-page-id="9906">抽象访问日志</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/WorkWithMultipart.html" title="Multipart使用技巧" data-book-page-rel-url="aiohttp文档/WorkWithMultipart.html" data-book-page-id="9907">Multipart使用技巧</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/StreamingAPI.html" title="其他帮助信息" data-book-page-rel-url="aiohttp文档/StreamingAPI.html" data-book-page-id="9908">其他帮助信息</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/Helper.html" title="信号" data-book-page-rel-url="aiohttp文档/Helper.html" data-book-page-id="9909">信号</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/FrequentlyAskedQuestions.html" title="在web服务器汇总如何管理ClientSession？" data-book-page-rel-url="aiohttp文档/FrequentlyAskedQuestions.html" data-book-page-id="9910">在web服务器汇总如何管理ClientSession？</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="各种杂项" disabled data-book-page-rel-url="Miscellaneous.html" data-book-page-id="9911">各种杂项</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/Essays.html" title="相关文献" data-book-page-rel-url="aiohttp文档/Essays.html" data-book-page-id="9912">相关文献</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/Glossary.html" title="相关名词释义" data-book-page-rel-url="aiohttp文档/Glossary.html" data-book-page-id="9913">相关名词释义</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/ExternalSources.html" title="外部资源包" data-book-page-rel-url="aiohttp文档/ExternalSources.html" data-book-page-id="9914">外部资源包</a>
</li>
<li>
<a class="pjax" href="../../../book/127/aiohttp文档/Contributing.html" title="贡献须知" data-book-page-rel-url="aiohttp文档/Contributing.html" data-book-page-id="9915">贡献须知</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =127;var bookPageId =9895;var bookPageRelUrl ='aiohttp文档/ClientUsage.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>