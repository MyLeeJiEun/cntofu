
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>十三、卷积神经网络-Sklearn 与 TensorFlow 机器学习实用指南(Hands On Machine Learning with Scikit Learn and TensorFlow)</title>
<meta content='十三、卷积神经网络,Sklearn 与 TensorFlow 机器学习实用指南,Hands On Machine Learning with Scikit Learn and TensorFlow' name='keywords'>
<meta content='十三、卷积神经网络,Sklearn 与 TensorFlow 机器学习实用指南,Hands On Machine Learning with Scikit Learn and TensorFlow' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/27/docs/12.设备和服务器上的分布式_TensorFlow.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">十二、设备和服务器上的..</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/27/docs/14.循环神经网络.html">
<span class="">十四、循环神经网络</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/27/index.html">Sklearn 与 TensorFlow 机器学习实用指南 (Hands On Machine Learning with Scikit Learn and TensorFlow)</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/hands_on_Ml_with_Sklearn_and_TF" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="十三卷积神经网络">十三、卷积神经网络</h1>
<p>​尽管 IBM 的深蓝超级计算机在1996年击败了国际象棋世界冠军 Garry Kasparvo，直到近几年计算机都不能可靠地完成一些看起来较为复杂的任务，比如判别照片中是否有狗以及识别语音。为什么这些任务对于人类而言如此简单？答案在于感知主要发生在我们意识领域之外，在我们大脑中的专门视觉，听觉和其他感官模块内。当感官信息达到我们的意识时，它已经被装饰了高级特征;例如，当你看着一只可爱的小狗的照片时，你不能选择不看这只小狗，或不注意它的可爱。你也不能解释你如何认出这是一只可爱的小狗，这对你来说很明显。因此，我们不能相信我们的主观经验：感知并不是微不足道的，理解它我们必须看看感官模块是如何工作的。</p>
<p>​卷积神经网络（CNN）是从大脑视觉皮层的研究中出现的，自 20 世纪 80 年代以来它们一直用于图像识别。在过去的几年里，由于计算能力的增加，可用训练数据的数量以及第 11 章介绍的训练深度网络的技巧，CNN 致力于在某些复杂的视觉任务中做出超出人类的表现。他们使图像搜索服务，自动驾驶汽车，视频自动分类系统等变得强大。此外，CNN 并不局限于视觉感知：它们在其他任务中也很成功，如语音识别或自然语言处理（NLP）; 然而，我们现在将专注于视觉应用。</p>
<p>​在本章中，我们将介绍 CNN 的来源，构建它们模块的外观以及如何使用 TensorFlow 实现它们。然后我们将介绍一些最好的 CNN 架构。</p>
<p>​</p>
<h2 id="视觉皮层的结构">视觉皮层的结构</h2>
<p>​David H.Hubel 和 Torsten Wiesel 在 1958 年和 1959 年对猫进行了一系列实验（以及几年后在猴子上的实验），对视觉皮层的结构提供了重要的见解（1981 年作者因此获得了诺贝尔生理和医学奖）。具体来说，他们发现视皮层中的许多神经元有一个小的局部感受野，这意味着它们只对位于视野中有限的一部分区域的视觉刺激起作用（见图 13-1，五个神经元的局部感受野由虚线圆圈表示）。不同神经元的感受野可能重叠，并且它们一起平铺了整个视野。此外，作者表明，一些神经元只对水平线方向的图像作出反应，而另一些神经元只对不同方向的线作出反应（两个神经元可能具有相同的感受野，但对不同方向的线作出反应）。他们还注意到一些神经元具有较大的感受野，并且它们对较复杂的模式作出反应，这些模式是较低层模式的组合。这些观察结果让我们想到：更高级别的神经元是基于相邻低级神经元的输出（在图 13-1 中，请注意，每个神经元只与来自前一层的少数神经元相连）。这个强大的结构能够检测视野中任何区域的各种复杂图案。</p>
<p>​这些对视觉皮层的研究启发了 1980 年推出的新认知机（neocognitron），后者逐渐演变为我们现在称之为卷积神经网络。一个重要的里程碑是 Yann LeCun，LéonBottou，Yoshua Bengio 和 Patrick Haffner 于 1998 年发表的一篇论文，该论文引入了着名的 LeNet-5 架构，广泛用于识别手写支票号码。这个架构有一些你已经知道的构建块，比如完全连接层和 Sigmoid 激活函数，但是它还引入了两个新的构建块：卷积层和池化层。现在我们来看看他们。</p>
<h2 id="卷积层">卷积层</h2>
<p>​CNN 最重要的组成部分是卷积层：第一卷积层中的神经元不是连接到输入图像中的每一个像素（就像它们在前面的章节中那样），而是仅仅连接到它们的局部感受野中的像素（参见图 13-2）。 进而，第二卷积层中的每个神经元只与位于第一层中的小矩形内的神经元连接。 这种架构允许网络专注于第一隐藏层中的低级特征，然后将其组装成下一隐藏层中的高级特征，等等。 这种层次结构在现实世界的图像中是很常见的，这也是 CNN 在图像识别方面效果很好的原因之一。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-2.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-2.png" alt=""></a></p>
<p>​<strong>到目前为止，我们所看到的所有多层神经网络都有由一长串神经元组成的层，在输入到神经网络之前我们必须将输入图像压缩成 1D。 现在，每个图层都以 2D 表示，这使得神经元与其相应的输入进行匹配变得更加容易。</strong></p>
<p>​位于给定层的第<code>i</code>行第<code>j</code>列的神经元连接到位于前一层中的神经元的输出的第i行到第 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-1.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-1.png" alt=""></a> 行，第<code>j</code>列到第 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-2.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-2.png" alt=""></a> 列。<code>fh</code>和<code>fw</code>是局部感受野的高度和宽度（见图 13-3）。 为了使图层具有与前一图层相同的高度和宽度，通常在输入周围添加零，如图所示。 这被称为零填充.</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-3.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-3.png" alt=""></a></p>
<p>​如图 13-4 所示，通过将局部感受野隔开，还可以将较大的输入层连接到更小的层。 两个连续的感受野之间的距离被称为步幅。 在图中，一个<code>5×7</code>的输入层（加零填充）连接到一个<code>3×4</code>层，使用<code>3×3</code>的卷积核和一个步幅为 2（在这个例子中，步幅在两个方向是相同的，但是它并不一定总是如此）。 位于上层第<code>i</code>行第<code>j</code>列的神经元与位于前一层中的神经元的输出连接的第 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-4.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-4.png" alt=""></a> 至 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-5.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-5.png" alt=""></a> 行，第 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-6.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-6.png" alt=""></a> 列， <code>Sh</code>和<code>Sw</code>是垂直和水平的步幅。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-4.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-4.png" alt=""></a></p>
<h2 id="卷积核过滤器">卷积核/过滤器</h2>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-5.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-5.png" alt=""></a></p>
<p>​神经元的权重可以表示为局部感受野大小的小图像。 例如，图 13-5 显示了两个可能的权重集，称为过滤器（或卷积核）。第一个表示为中间有一条垂直的白线的黑色正方形（除了中间一列外，这是一个充满 0 的<code>7×7</code>矩阵，除了中央垂直线是 1）。 使用这些权重的神经元会忽略除了中央垂直线以外感受野的一切（因为除位于中央垂直线以外，所有的输入都将乘 0）。第二个卷积核是一个黑色的正方形，中间有一条水平的白线。 再一次，使用这些权重的神经元将忽略除了中心水平线之外的局部感受野中的一切。</p>
<p>​现在，如果一个图层中的所有神经元都使用相同的垂直线卷积核（以及相同的偏置项），并且将网络输入到图 13-5（底部图像）中所示的输入图像，则该图层将输出左上图像。 请注意，垂直的白线得到增强，其余的变得模糊。 类似地，如果所有的神经元都使用水平线卷积核，右上角的图像就是你所得到的。 注意到水平的白线得到增强，其余的则被模糊了。因此，使用相同卷积和的一个充满神经元的图层将为您提供一个特征映射，该特征映射突出显示图像中与卷积和最相似的区域。 在训练过程中，CNN 为其任务找到最有用的卷积和，并学习将它们组合成更复杂的模式（例如，交叉是图像中垂直卷积和和水平卷积和都激活的区域）。</p>
<h2 id="叠加的多个特征映射">叠加的多个特征映射</h2>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-6.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-6.png" alt=""></a></p>
<p>​到目前为止，为了简单起见，我们已经将每个卷积层表示为一个薄的二维层，但是实际上它是由几个相同大小的特征映射组成的，所以使用3D图表示其会更加准确（见图 13-6）。 在一个特征映射中，所有神经元共享相同的参数（权重和偏置，权值共享），但是不同的特征映射可能具有不同的参数。 神经元的感受野与前面描述的相同，但是它延伸到所有先前的层的特征映射。 简而言之，卷积层同时对其输入应用多个卷积核，使其能够检测输入中的任何位置的多个特征。</p>
<p>​<strong>事实上，特征地图中的所有神经元共享相同的参数会显着减少模型中的参数数量，但最重要的是，一旦 CNN 学会识别一个位置的模式，就可以在任何其他位置识别它。 相比之下，一旦一个常规 DNN 学会识别一个位置的模式，它只能在该特定位置识别它。</strong></p>
<p>​而且，输入图像也由多个子图层组成：每个颜色通道一个。 通常有三种：红色，绿色和蓝色（RGB）。 灰度图像只有一个通道，但是一些图像可能更多 - 例如捕捉额外光频（如红外线）的卫星图像。</p>
<p>​具体地，位于给定卷积层L中的特征映射k的i行，j列中的神经元连接到前一层（L-1）位于 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-7.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-7.png" alt=""></a> 行，<a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-8.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-8.png" alt=""></a> 列的神经元的输出。请注意，位于同一行第<code>i</code>列和第<code>j</code>列但位于不同特征映射中的所有神经元都连接到上一层中完全相同神经元的输出。</p>
<p>​公式 13-1 在一个总结前面解释的大的数学公式：它展示了如何计算卷积层中给定神经元的输出。它是计算所有投入的加权总并且加上偏置。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/e-13-1.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/e-13-1.png" alt=""></a></p>
<ul>
<li> <p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-9.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-9.png" alt=""></a> 是卷积层（L层）特征映射k中位于第<code>i</code>行第<code>j</code>列的神经元的输出.</p> </li>
<li> <p>如前所述，<a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-10.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-10.png" alt=""></a> 和 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-11.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-11.png" alt=""></a> 是垂直和水平的步幅，<a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-12.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-12.png" alt=""></a> 和 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-13.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-13.png" alt=""></a> 是感受野的高度和宽度，<a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-14.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-14.png" alt=""></a> 是前一层（第<code>l - 1</code>层）的特征映射的数量。</p> </li>
<li> <p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-15.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-15.png" alt=""></a> 是位于层<code>L-1</code>，<code>i'</code>行，<code>j'</code>列，特征映射<code>k'</code>（或者如果前一层是输入层的通道<code>k'</code>）的神经元的输出。</p> </li>
<li> <p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-16.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-16.png" alt=""></a> 是特征映射<code>k</code>的偏置项（在<code>L</code>层中）。您可以将其视为调整特征映射<code>k</code>的整体亮度的旋钮。</p> </li>
<li> <p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-17.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-17.png" alt=""></a> 是层<code>L</code>的特征映射<code>k</code>中的任何神经元与位于行<code>u</code>，列<code>v</code>（相对于神经元的感受野）的输入之间的连接权重，以及特征映射k'。</p> </li>
</ul>
<h2 id="tensorflow-实现">TensorFlow 实现</h2>
<p>​在 Tensorflow 中，每个输入图像的通常被表示为三维张量 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-18.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-18.png" alt=""></a>。 一个小批次被表示为四维张量 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-19.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-19.png" alt=""></a>。 卷积层的权重被表示为四维张量 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-20.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-20.png" alt=""></a>。 卷积层的偏差项简单地表示为一维形状的张量 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-21.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-21.png" alt=""></a>。我们来看一个简单的例子。 下面的代码使用 <strong>Scikit-Learn</strong> 的<code>load_sample_images()</code>（加载两个彩色图像，一个中国庙宇，另一个是一朵花）加载两个样本图像。 然后创建两个<code>7×7</code>的卷积核（一个中间是垂直的白线，另一个是水平的白线），并将他们应用到两张图形中,使用 TensorFlow 的<code>conv2d()</code>函数构建的卷积图层（使用零填充且步幅为 2）。 最后，绘制其中一个结果特征映射（类似于图 13-5 中的右上图）。</p>
<pre><code class="language-python">from sklearn.datasets import load_sample_image
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf

if __name__ == '__main__':

    # Load sample images
    china = load_sample_image("china.jpg")
    flower = load_sample_image("flower.jpg")
    dataset = np.array([china, flower], dtype=np.float32)
    batch_size, height, width, channels = dataset.shape

    # Create 2 filters
    filters = np.zeros(shape=(7, 7, channels, 2), dtype=np.float32)
    filters[:, 3, :, 0] = 1  # vertical line
    filters[3, :, :, 1] = 1  # horizontal line

    # Create a graph with input X plus a convolutional layer applying the 2 filters
    X = tf.placeholder(tf.float32, shape=(None, height, width, channels))
    convolution = tf.nn.conv2d(X, filters, strides=[1,2,2,1], padding="SAME")

    with tf.Session() as sess:
        output = sess.run(convolution, feed_dict={X: dataset})

    plt.imshow(output[0, :, :, 1], cmap="gray") # plot 1st image's 2nd feature map
    plt.show()

</code></pre>
<p>大部分代码是不言而喻的，但<code>conv2d()</code>这一行值得解释一下：</p>
<ul>
<li> <p><code>X</code>是输入小批次（4D 张量，如前所述）</p> </li>
<li> <p>卷积核是应用的一组卷积核（也是一个 4D 张量，如前所述）。</p> </li>
<li> <p>步幅是一个四元素的一维数组，其中两个中间的值是垂直和水平的步幅（<code>sh</code>和<code>sw</code>）。 第一个和最后一个元素现在必须等于 1。他们可能有一天会被用来指定批量步长（跳过一些实例）和频道步幅（跳过上一层的特征映射或通道）。</p> </li>
<li> <p><code>padding</code>必须是<code>"VALID"</code>或<code>"SAME"</code>：</p>
<ul>
<li>如果设置为<code>"VALID"</code>，卷积层不使用零填充，并且可能会忽略输入图像底部和右侧的某些行和列，具体取决于步幅，如图 13-7 所示（为简单起见， 这里只显示水平尺寸，当然，垂直尺寸也适用相同的逻辑）</li>
<li>如果设置为<code>"SAME"</code>，则卷积层在必要时使用零填充。 在这种情况下，输出神经元的数量等于输入神经元的数量除以该步幅，向上舍入（在这个例子中，<code>ceil(13/5)= 3</code>）。 然后在输入周围尽可能均匀地添加零。</li>
</ul> </li>
</ul>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-7.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-7.png" alt=""></a></p>
<p>不幸的是，卷积图层有很多超参数：你必须选择卷积核的数量，高度和宽度，步幅和填充类型。 与往常一样，您可以使用交叉验证来查找正确的超参数值，但这非常耗时。 稍后我们将讨论常见的 CNN 体系结构，以便让您了解超参数值在实践中的最佳工作方式。</p>
<h2 id="内存需求">内存需求</h2>
<p>​CNN 的另一个问题是卷积层需要大量的 RAM，特别是在训练期间，因为反向传播需要在正向传递期间计算的所有中间值。</p>
<p>​例如，考虑具有<code>5×5</code>卷积核的卷积层，输出 200 个尺寸为<code>150×100</code>的特征映射，步长为 1，使用<code>SAME</code>填充。 如果输入是<code>150×100</code>RGB 图像（三个通道），则参数的数量是<code>(5×5×3 + 1)×200 = 15,200</code>（<code>+1</code>对应于偏置项），这跟全连接层比较是相当小的。（具有<code>150×100</code>神经元的全连接层，每个连接到所有<code>150×100×3</code>输入，将具有<code>150 ^ 2×100 ^ 2×3 = 675,000,000</code>个参数！）然而，200 个特征映射中的每一个包含<code>150×100</code>个神经元，并且这些神经元中的每一个都需要计算其<code>5×5×3 = 75</code>个输入的权重和：总共 2.25 亿次浮点乘法。不像全连接层那么糟糕，但仍然是计算密集型的。 而且，如果使用 32 位浮点数来表示特征映射，则卷积层的输出将占用 RAM 的<code>200×150×100×32 = 9600万</code>位（大约 11.4MB）。 这只是一个例子！ 如果训练批次包含 100 个实例，则该层将占用超过 1 GB 的 RAM！</p>
<p>​在推理过程中（即对新实例进行预测时），一旦下一层计算完毕，一层所占用的 RAM 就可以被释放，因此只需要两个连续层所需的 RAM 数量。 但是在训练期间，在正向传递期间计算的所有内容都需要被保留用于反向传递，所以所需的 RAM 量（至少）是所有层所需的 RAM 总量。</p>
<p>​<strong>如果由于内存不足错误导致训练崩溃，则可以尝试减少小批量大小。 或者，您可以尝试使用步幅降低维度，或者删除几个图层。 或者你可以尝试使用 16 位浮点数而不是 32 位浮点数。 或者你可以在多个设备上分发 CNN。</strong></p>
<h2 id="池化层">池化层</h2>
<p>​一旦你理解了卷积层是如何工作的，池化层很容易掌握。 他们的目标是对输入图像进行二次抽样（即收缩）以减少计算负担，内存使用量和参数数量（从而限制过度拟合的风险）。 减少输入图像的大小也使得神经网络容忍一点点的图像变换（位置不变）。</p>
<p>​就像在卷积图层中一样，池化层中的每个神经元都连接到前一层中有限数量的神经元的输出，位于一个小的矩形感受野内。 您必须像以前一样定义其大小，跨度和填充类型。 但是，汇集的神经元没有权重; 它所做的只是使用聚合函数（如最大值或平均值）来聚合输入。 图 13-8 显示了最大池层，这是最常见的池化类型。 在这个例子中，我们使用一个2×2的核，步幅为 2，没有填充。 请注意，只有每个核中的最大输入值才会进入下一层。 其他输入被丢弃。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-8.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-8.png" alt=""></a></p>
<p>​这显然是一个非常具有破坏性的层：即使只有一个<code>2×2</code>的核和 2 的步幅，输出在两个方向上都会减小两倍（所以它的面积将减少四倍），一下减少了 75% 的输入值</p>
<p>​池化层通常独立于每个输入通道工作，因此输出深度与输入深度相同。 接下来可以看到，在这种情况下，图像的空间维度（高度和宽度）保持不变，但是通道数目可以减少。</p>
<p>​在 TensorFlow 中实现一个最大池层是非常容易的。 以下代码使用<code>2×2</code>核创建最大池化层，步幅为2，没有填充，然后将其应用于数据集中的所有图像：</p>
<pre><code class="language-python">import numpy as np
from sklearn.datasets import load_sample_image
import tensorflow as tf
import matplotlib.pyplot as plt

china = load_sample_image("china.jpg")
flower = load_sample_image("flower.jpg")

dataset = np.array([china, flower], dtype=np.float32)
batch_size, height, width, channels = dataset.shape

# Create 2 filters
filters = np.zeros(shape=(7, 7, channels, 2), dtype=np.float32)
filters[:, 3, :, 0] = 1  # vertical line
filters[3, :, :, 1] = 1  # horizontal line

X = tf.placeholder(tf.float32, shape=(None, height, width, channels))
max_pool = tf.nn.max_pool(X, ksize=[1,2,2,1], strides=[1,2,2,1],padding="VALID")

with tf.Session() as sess:
    output = sess.run(max_pool, feed_dict={X: dataset})

plt.imshow(output[0].astype(np.uint8))  # plot the output for the 1st image
plt.show()
</code></pre>
<p>​<code>ksize</code>参数包含沿输入张量的所有四维的核形状：<code>[min-batch, height, width, channels]</code>。 TensorFlow 目前不支持在多个实例上合并，因此<code>ksize</code>的第一个元素必须等于 1。此外，它不支持在空间维度（高度和宽度）和深度维度上合并，因此<code>ksize[1]</code>和<code>ksize[2]</code>都必须等于 1，否则<code>ksize[3]</code>必须等于 1。</p>
<p>​要创建一个平均池化层，只需使用<code>avg_pool()</code>函数而不是<code>max_pool()</code>。</p>
<p>​现在你知道所有的构建模块来创建一个卷积神经网络。 我们来看看如何组装它们。</p>
<h2 id="cnn-架构">CNN 架构</h2>
<p>​典型的 CNN 体系结构有一些卷积层（每一个通常跟着一个 ReLU 层），然后是一个池化层，然后是另外几个卷积层（+ ReLU），然后是另一个池化层，等等。 随着网络的进展，图像变得越来越小，但是由于卷积层的缘故，图像通常也会越来越深（即更多的特征映射）（见图 13-9）。 在堆栈的顶部，添加由几个全连接层（+ ReLU）组成的常规前馈神经网络，并且最终层输出预测（例如，输出估计类别概率的 softmax 层）。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-9.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-9.png" alt=""></a></p>
<p>​<strong>一个常见的错误是使用太大的卷积核。 通常可以通过将两个<code>3×3</code>内核堆叠在一起来获得与<code>9×9</code>内核相同的效果，计算量更少。</strong></p>
<p>​多年来，这种基础架构的变体已经被开发出来，导致了该领域的惊人进步。 这种进步的一个很好的衡量标准是比赛中的错误率，比如 ILSVRC ImageNet 的挑战。 在这个比赛中，图像分类的五大误差率在五年内从 26% 下降到仅仅 3% 左右。 前五位错误率是系统前5位预测未包含正确答案的测试图像的数量。 图像很大（256 像素），有 1000 个类，其中一些非常微妙（尝试区分 120 个狗的品种）。 查看获奖作品的演变是了解 CNN 如何工作的好方法。</p>
<p>​我们先来看看经典的 LeNet-5 架构（1998 年），然后是 ILSVRC 挑战赛的三名获胜者 AlexNet（2012），GoogLeNet（2014）和 ResNet（2015）。</p>
<p>​其他视觉任务在其他视觉任务中，如物体检测和定位以及图像分割，也取得了惊人的进展。 在物体检测和定位中，神经网络通常输出图像中各种物体周围的一系列边界框。 例如，参 见Maxine Oquab 等人的 2015 年论文，该论文为每个客体类别输出热图，或者 Russell Stewart 等人的 2015 年论文，该论文结合使用 CNN 来检测人脸，并使用递归神经网络来输出 围绕它们的一系列边界框。 在图像分割中，网络输出图像（通常与输入大小相同），其中每个像素指示相应输入像素所属的对象的类别。 例如，查看 Evan Shelhamer 等人的 2016 年论文。</p>
<h2 id="lenet-5">LeNet-5</h2>
<p>​LeNet-5 架构也许是最广为人知的 CNN 架构。 如前所述，它是由 Yann LeCun 于 1998 年创建的，广泛用于手写数字识别（MNIST）。 它由表 13-1 所示的层组成。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/t-13-1.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/t-13-1.png" alt=""></a></p>
<p>有一些额外的细节要注意：</p>
<ul>
<li>MNIST 图像是<code>28×28</code>像素，但是它们被零填充到<code>32×32</code>像素，并且在被输入到网络之前被归一化。 网络的其余部分不使用任何填充，这就是为什么随着图像在网络中的进展，大小不断缩小。</li>
<li>平均池化层比平常稍微复杂一些：每个神经元计算输入的平均值，然后将结果乘以一个可学习的系数（每个特征映射一个），并添加一个可学习的偏差项（每个特征映射一个），然后最后应用激活函数。</li>
<li>C3 图中的大多数神经元仅在三个或四个 S2 图（而不是全部六个 S2 图）中连接到神经元。有关详细信息，请参阅原始论文中的表 1。</li>
<li>输出层有点特殊：每个神经元不是计算输入和权向量的点积，而是输出其输入向量和其权向量之间的欧几里德距离的平方。 每个输出测量图像属于特定数字类别的多少。 交叉熵损失函数现在是首选，因为它更多地惩罚不好的预测，产生更大的梯度，从而更快地收敛。</li>
</ul>
<p>Yann LeCun 的网站（“LENET”部分）展示了 LeNet-5 分类数字的很好的演示。</p>
<h2 id="alexnet">AlexNet</h2>
<p>​AlexNet CNN 架构赢得了 2012 年的 ImageNet ILSVRC 挑战赛：它达到了 17% 的 top-5 的错误率，而第二名错误率只有 26%！ 它由 Alex Krizhevsky（因此而得名），Ilya Sutskever 和 Geoffrey Hinton 开发。 它与 LeNet-5 非常相似，只是更大更深，它是第一个将卷积层直接堆叠在一起，而不是在每个卷积层顶部堆叠一个池化层。 表 13-2 介绍了这种架构。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/t-13-2.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/t-13-2.png" alt=""></a></p>
<p>​为了减少过拟合，作者使用了前面章节中讨论的两种正则化技术：首先他们在训练期间将丢失率（dropout 率为 50%）应用于层 F8 和 F9 的输出。其次，他们通过随机对训练图像进行各种偏移，水平翻转和改变照明条件来进行数据增强。</p>
<p>​AlexNet 还在层 C1 和 C3 的 ReLU 步骤之后立即使用竞争标准化步骤，称为局部响应标准化（local response normalization）。 这种标准化形式使得在相同的位置的神经元被最强烈的激活但是在相邻的特征映射中抑制神经元（在生物神经元中观察到了这种竞争激活）。 这鼓励不同的特征映射特殊化，迫使它们分开，并让他们探索更广泛的特征，最终提升泛化能力。 公式 13-2 显示了如何应用 LRN。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/e-13-2.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/e-13-2.png" alt=""></a></p>
<ul>
<li><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-22.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-22.png" alt=""></a> 是位于特征映射<code>i</code>的神经元的标准化输出，在某行<code>u</code>和列<code>v</code>（注意，在这个等式中我们只考虑位于这个行和列的神经元，所以<code>u</code>和<code>v</code>没有显示）。</li>
<li><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-23.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-23.png" alt=""></a> 是在 ReLU 步骤之后，但在归一化之前的那个神经元的激活。</li>
<li><code>k</code>，<code>α</code>，<code>β</code>和<code>r</code>是超参数。 <code>k</code>称为偏置，<code>r</code>称为深度半径。</li>
<li><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-24.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/o-13-24.png" alt=""></a> 是特征映射的数量。</li>
</ul>
<p>​例如，如果<code>r = 2</code>且神经元具有强激活，则将抑制位于其上下的特征映射中的神经元的激活。</p>
<p>​在 AlexNet 中，超参数设置如下：<code>r = 2</code>，<code>α= 0.00002</code>，<code>β= 0.75</code>，<code>k = 1</code>。这个步骤可以使用 TensorFlow 的<code>local_response_normalization()</code>操作来实现。</p>
<p>​AlexNet 的一个名为 ZF Net 的变体由 Matthew Zeiler 和 Rob Fergus 开发，赢得了 2013 年 ILSVRC 的挑战。 它基本上是 AlexNet 的一些调整的超参数（特征映射的数量，内核大小，步幅等）。</p>
<h2 id="googlenet">GoogLeNet</h2>
<p>​GoogLeNet 架构是由 Christian Szegedy 等人开发的。 来自 Google Research，通过低于 7% 的 top-5 错误率，赢得了 ILSVRC 2014 的挑战赛。 这个伟大的表现很大程度上因为它比以前的 CNN 网络更深（见图 13-11）。 这是通过称为初始模块（inception modules）的子网络实现的，这使得 GoogLeNet 比以前的架构更有效地使用参数：实际上，GoogLeNet 的参数比 AlexNet 少了 10 倍（约 600 万而不是 6000 万）。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-10.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-10.png" alt=""></a></p>
<p>​初始模块的架构如图 13-10 所示。 符号<code>3×3 + 2(S)</code>表示该层使用<code>3×3</code>内核，步幅 2 和<code>SAME</code>填充。 输入信号首先被复制并馈送到四个不同的层。 所有卷积层都使用 ReLU 激活功能。 请注意，第二组卷积层使用不同的内核大小（<code>1×1</code>，<code>3×3</code>和<code>5×5</code>），允许它们以不同的比例捕获图案。 还要注意，每一层都使用了跨度为1和SAME填充的（即使是最大的池化层），所以它们的输出全都具有与其输入相同的高度和宽度。这使得将所有输出在最后的深度连接层（depth concat layer）上沿着深度方向堆叠成为可能（即，堆叠来自所有四个顶部卷积层的特征映射）。 这个连接层可以在 TensorFlow 中使用<code>concat()</code>操作实现，其中<code>axis = 3</code>（轴 3 是深度）。</p>
<p>​您可能想知道为什么初始模块具有<code>1×1</code>内核的卷积层。 当然这些图层不能捕获任何功能，因为他们一次只能看一个像素？ 实际上，这些层次有两个目的：</p>
<p>​首先，它们被配置为输出比输入少得多的特征映射，所以它们作为瓶颈层，意味着它们降低了维度。 在<code>3×3</code>和<code>5×5</code>卷积之前，这是特别有用的，因为这些在计算上是非常耗费内存的层。</p>
<p>​其次，每一个卷积层对（<code>[1 × 1, 3 × 3]</code>和<code>[1 × 1, 5 × 5]</code>表现地像一个强大的卷积层，可以捕捉到更多的复杂的模式。事实上，这一对卷积层不是在图像上扫过一个简单的线性分类器（就像单个卷积层一样），而是在图像上扫描一个双层神经网络。</p>
<p>​简而言之，您可以将整个初始模块视为类固醇卷积层，能够输出捕捉各种尺度复杂模式的特征映射。</p>
<p>​<strong>每个卷积层的卷积核的数量是一个超参数。 不幸的是，这意味着你有六个超参数来调整你添加的每个初始层。</strong></p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-11.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-11.png" alt=""></a></p>
<p>​现在让我们来看看 GoogLeNet CNN 的架构（见图 13-11）。 它非常深，我们不得不将它分成三列，但是 GoogLeNet 实际上是一列，包括九个初始模块（带有旋转顶端的框），每个模块实际上包含三层。每个卷积层和池化层输出的特征映射的数量显示在内核大小前。 初始模块中的六个数字表示模块中每个卷积层输出的特征映射的数量（与图 13-10 中的顺序相同）。 请注意，所有的卷积层都使用 ReLU 激活函数。</p>
<p>让我们来过一遍这个网络：</p>
<ul>
<li>前两层将图像的高度和宽度除以 4（使其面积除以 16），以减少计算负担。</li>
<li>然后，局部响应标准化层确保前面的层学习各种各样的功能（如前所述）</li>
<li>接下来是两个卷积层，其中第一个像瓶颈层一样。 正如前面所解释的，你可以把这一对看作是一个单一的更智能的卷积层。</li>
<li>再次，局部响应标准化层确保了先前的层捕捉各种各样的模式。</li>
<li>接下来，最大池化层将图像高度和宽度减少 2，再次加快计算速度。</li>
<li>然后是九个初始模块的堆叠，与几个最大池层交织，以降低维度并加速网络。</li>
<li>接下来，平均池化层使用具有<code>VALID</code>填充的特征映射的大小的内核，输出<code>1×1</code>特征映射：这种令人惊讶的策略被称为全局平均池化。 它有效地强制以前的图层产生特征映射，这些特征映射实际上是每个目标类的置信图（因为其他类型的功能将被平均步骤破坏）。 这样在 CNN 的顶部就不必有有几个全连接层（如 AlexNet），大大减少了网络中的参数数量，并减少了了过度拟合的风险。</li>
<li>最后一层是不言自明的：正则化 drop out，然后是具有 softmax 激活函数的完全连接层来输出估计类的概率。</li>
</ul>
<p>​这个图略有简化：原来的 GoogLeNet 架构还包括两个插在第三和第六个初始模块之上的辅助分类器。 它们都由一个平均池层，一个卷积层，两个全连接层和一个 softmax 激活层组成。 在训练期间，他们的损失（缩小了 70%）加在了整体损失上。 目标是解决消失梯度问题，正则化网络。 但是，结果显示其效果相对小。</p>
<h2 id="resnet"><strong>ResNet</strong></h2>
<p>​最后是，2015 年 ILSVRC 挑战赛的赢家 Kaiming He 等人开发的 Residual Network（或 ResNet），该网络的 top-5 误率低到惊人的 3.6%，它使用了一个非常深的 CNN，由 152 层组成。 能够训练如此深的网络的关键是使用跳过连接（skip connection，也称为快捷连接）：一个层的输入信号也被添加到位于下一层的输出。 让我们看看为什么这是有用的。</p>
<p>​当训练一个神经网络时，目标是使其模拟一个目标函数<code>h(x)</code>。 如果将输入x添加到网络的输出中（即添加跳过连接），那么网络将被迫模拟<code>f(x)= h(x) - x</code>而不是<code>h(x)</code>。 这被称为残留学习（见图 13-12）。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-12.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-12.png" alt=""></a></p>
<p>​当你初始化一个普通的神经网络时，它的权重接近于零，所以网络只输出接近零的值。 如果添加跳过连接，则生成的网络只输出其输入的副本; 换句话说，它最初对身份函数进行建模。 如果目标函数与身份函数非常接近（常常是这种情况），这将大大加快训练速度。</p>
<p>​而且，如果添加了许多跳转连接，即使几个层还没有开始学习，网络也可以开始进行（见图 13-13）。 由于跳过连接，信号可以很容易地通过整个网络。 深度剩余网络可以看作是一堆剩余单位，其中每个剩余单位是一个有跳过连接的小型神经网络。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-13.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-13.png" alt=""></a></p>
<p>​现在让我们看看 ResNet 的架构（见图 13-14）。 这实际上是令人惊讶的简单。 它的开始和结束与GoogLeNet完全一样（除了没有 dropout 层），而在两者之间只是一堆很简单的残余单位。 每个残差单元由两个卷积层组成，使用<code>3×3</code>的内核和保存空间维度（步幅 1，<code>SAME</code>填充），批量归一化（BN）和 ReLU 激活。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-14.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-14.png" alt=""></a></p>
<p>​需要注意的是特征映射的数量每隔几个残差单位会加倍，同时它们的高度和宽度减半（使用步幅 2 卷积层）。 发生这种情况时，输入不能直接添加到剩余单元的输出中，因为它们不具有相同的形状（例如，此问题影响图 13-14 中的虚线箭头表示的跳过连接）。 为了解决这个问题，输入通过一个<code>1×1</code>卷积层，步长2和正确数量的输出特征映射（见图 13-15）。</p>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-15.png" data-uk-lightbox><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_13/13-15.png" alt=""></a></p>
<p>​ResNet-34 是具有 34 个层（仅计算卷积层和完全连接层）的 ResNet，包含 3 个剩余单元输出 64 个特征映射，4 个剩余单元输出 128 个特征映射，6 个剩余单元输出 256 个特征映射，3 个剩余单元输出 512 个特征映射。</p>
<p>​ResNet-152 更深，使用稍微不同的剩余单位。 他们使用三个卷积层，而不是两个 256 个特征映射的<code>3×3</code>的卷积层，它们使用三个卷积层：第一个卷积层只有 64 个特征映射（少 4 倍），这是一个瓶颈层（已经讨论过） ，然后是具有 64 个特征映射的<code>3×3</code>层，最后是具有 256 个特征映射（<code>4×64</code>）的另一个<code>1×1</code>卷积层，以恢复原始深度。ResNet-152 包含三个这样的剩余单位，输出 256 个特征映射，然后是 8 个剩余单位，输出 512 个特征映射，高达 36 个剩余单位，输出 1024 个特征映射，最后是 3 个剩余单位，输出 2048 个特征映射。</p>
<p>​正如你所看到的，这个领域正在迅速发展，每年都会有各种各样的架构出现。 一个明显的趋势是 CNN 越来越深入。 他们也越来越轻量，需要越来越少的参数。 目前，ResNet 架构既是最强大的，也是最简单的，所以它现在应该是你应该使用的，但是每年都要继续关注 ILSVRC 的挑战。 2016 年获奖者是来自中国的 Trimps-Soushen 团队，他们的出错率惊人的缩减到 2.99%。 为了达到这个目标，他们训练了以前模型的组合，并将它们合并为一个整体。 根据任务的不同，降低的错误率可能会或可能不值得额外的复杂性。</p>
<p>​还有其他一些架构可供您参考，特别是 VGGNet（2014 年 ILSVRC 挑战赛的亚军）和 Inception-v4（将 GooLeNet 和 ResNet 的思想融合在一起，实现了接近 3% 的 top-5 误差 ImageNet 分类率）。</p>
<p>​实施我们刚刚讨论的各种CNN架构真的没什么特别的。 我们之前看到如何构建所有的独立构建模块，所以现在您只需要组装它们来创建所需的构架。 我们将在即将开始的练习中构建 ResNet-34，您将在 Jupyter 笔记本中找到完整的工作代码。</p>
<h2 id="tensorflow-卷积操作">TensorFlow 卷积操作</h2>
<p>TensorFlow 还提供了一些其他类型的卷积层：</p>
<ul>
<li><code>conv1d()</code>为 1D 输入创建一个卷积层。 例如，在自然语言处理中这是有用的，其中句子可以表示为一维单词阵列，并且接受场覆盖一些邻近单词。</li>
<li><code>conv3d()</code>创建一个 3D 输入的卷积层，如 3D PET 扫描。</li>
<li><code>atrous_conv2d()</code>创建了一个 atrous 卷积层（“àtrous”是法语“with holes”）。 这相当于使用具有通过插入行和列（即，孔）而扩大的卷积核的普通卷积层。 例如，等于<code>[[1,2,3]]</code>的<code>1×3</code>卷积核可以以4的扩张率扩张，导致扩张的卷积核<code>[[1,0,0,0,2,0,0,0,3]]</code>。 这使得卷积层在没有计算价格的情况下具有更大的局部感受野，并且不使用额外的参数。</li>
<li><code>conv2d_transpose()</code>创建了一个转置卷积层，有时称为去卷积层，它对图像进行上采样（这个名称是非常具有误导性的，因为这个层并不执行去卷积，这是一个定义良好的数学运算（卷积的逆）） 。这是通过在输入之间插入零来实现的，所以你可以把它看作是一个使用分数步长的普通卷积层。例如，在图像分割中，上采样是有用的：在典型的CNN中，特征映射越来越小当通过网络时，所以如果你想输出一个与输入大小相同的图像，你需要一个上采样层。</li>
<li><code>depthwise_conv2d()</code>创建一个深度卷积层，将每个卷积核独立应用于每个单独的输入通道。 因此，如果有<code>fn</code>卷积核和<code>fn'</code>输入通道，那么这将输出<code>fn×fn'</code>特征映射。</li>
<li><code>separable_conv2d()</code>创建一个可分离的卷积层，首先像深度卷积层一样工作，然后将<code>1×1</code>卷积层应用于结果特征映射。 这使得可以将卷积核应用于任意的输入通道组。</li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/59/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/tensorflow_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/59/index.html">TensorFlow 官方文档中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/35.html">jikexueyuanwiki</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="tensorflow">tensorflow</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">33页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8767个">8767</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/48/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/tensorflow_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/48/index.html">机器学习基础笔记</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/25.html">zhjunqin</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="tensorflow">tensorflow</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">43页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月2日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/134/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/github_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/134/index.html">GitHub 漫游指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="github">github</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 3472个">3472</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/131/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/visualstudio_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/131/index.html">Office 365 开发入门指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/70.html">chenxizhang</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="visualstudio">visualstudio</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">51页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 98个">98</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/12/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/swift_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/12/index.html">Swift 官方教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/8.html">numbbbbb</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="swift">swift</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">51页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 18022个">18022</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/72/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/72/index.html">前端开发规范手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/45.html">Aaaaaashu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 693个">693</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/27/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/27/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/0.前言.html" title="零、前言" data-book-page-rel-url="docs/0.前言.html" data-book-page-id="9223">零、前言</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/1.机器学习概览.html" title="一、机器学习概览" data-book-page-rel-url="docs/1.机器学习概览.html" data-book-page-id="9224">一、机器学习概览</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/2.一个完整的机器学习项目.html" title="二、一个完整的机器学习项目" data-book-page-rel-url="docs/2.一个完整的机器学习项目.html" data-book-page-id="9225">二、一个完整的机器学习项目</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/3.分类.html" title="三、分类" data-book-page-rel-url="docs/3.分类.html" data-book-page-id="9226">三、分类</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/4.训练模型.html" title="四、训练模型" data-book-page-rel-url="docs/4.训练模型.html" data-book-page-id="9227">四、训练模型</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/5.支持向量机.html" title="五、支持向量机" data-book-page-rel-url="docs/5.支持向量机.html" data-book-page-id="9228">五、支持向量机</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/6.决策树.html" title="六、决策树" data-book-page-rel-url="docs/6.决策树.html" data-book-page-id="9229">六、决策树</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/7.集成学习和随机森林.html" title="七、集成学习和随机森林" data-book-page-rel-url="docs/7.集成学习和随机森林.html" data-book-page-id="9230">七、集成学习和随机森林</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/8.降维.html" title="八、降维" data-book-page-rel-url="docs/8.降维.html" data-book-page-id="9231">八、降维</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/9.启动并运行_TensorFlow.html" title="九、启动并运行 TensorFlow" data-book-page-rel-url="docs/9.启动并运行_TensorFlow.html" data-book-page-id="9232">九、启动并运行 TensorFlow</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/10.人工神经网络介绍.html" title="十、人工神经网络介绍" data-book-page-rel-url="docs/10.人工神经网络介绍.html" data-book-page-id="9233">十、人工神经网络介绍</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/11.训练深层神经网络.html" title="十一、训练深层神经网络" data-book-page-rel-url="docs/11.训练深层神经网络.html" data-book-page-id="9234">十一、训练深层神经网络</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/12.设备和服务器上的分布式_TensorFlow.html" title="十二、设备和服务器上的分布式 TensorFlow" data-book-page-rel-url="docs/12.设备和服务器上的分布式_TensorFlow.html" data-book-page-id="9235">十二、设备和服务器上的分布式 TensorFlow</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/13.卷积神经网络.html" title="十三、卷积神经网络" data-book-page-rel-url="docs/13.卷积神经网络.html" data-book-page-id="9236">十三、卷积神经网络</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/14.循环神经网络.html" title="十四、循环神经网络" data-book-page-rel-url="docs/14.循环神经网络.html" data-book-page-id="9237">十四、循环神经网络</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/15.自编码器.html" title="十五、自编码器" data-book-page-rel-url="docs/15.自编码器.html" data-book-page-id="9238">十五、自编码器</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/16.强化学习.html" title="十六、强化学习" data-book-page-rel-url="docs/16.强化学习.html" data-book-page-id="9239">十六、强化学习</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/C.SVM_对偶问题.html" title="附录 C、SVM 对偶问题" data-book-page-rel-url="docs/C.SVM_对偶问题.html" data-book-page-id="9240">附录 C、SVM 对偶问题</a>
</li>
<li>
<a class="pjax" href="../../../book/27/docs/D.自动微分.html" title="附录 D、自动微分" data-book-page-rel-url="docs/D.自动微分.html" data-book-page-id="9241">附录 D、自动微分</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =27;var bookPageId =9236;var bookPageRelUrl ='docs/13.卷积神经网络.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>