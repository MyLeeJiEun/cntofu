
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>读者/写者信号量-Linux 内核揭密</title>
<meta content='读者/写者信号量,Linux 内核揭密' name='keywords'>
<meta content='读者/写者信号量,Linux 内核揭密' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/114/SyncPrim/sync-4.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">互斥锁</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/114/SyncPrim/sync-6.html">
<span class="">顺序锁</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/114/index.html">Linux 内核揭密</a>
<a target="_blank" rel="nofollow" href="https://github.com/tzivanmoe/linux-insides-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="synchronization-primitives-in-the-linux-kernel-part-5">Synchronization primitives in the Linux kernel. Part 5.</h1>
<h2 id="introduction">Introduction</h2>
<p>This is the fifth part of the <a href="https://0xax.gitbooks.io/linux-insides/content/SyncPrim/index.html">chapter</a> which describes synchronization primitives in the Linux kernel and in the previous parts we finished to consider different types <a href="https://en.wikipedia.org/wiki/Spinlock">spinlocks</a>, <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> and <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> synchronization primitives. We will continue to learn <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> in this part and start to consider special type of synchronization primitives - <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers–writer lock</a>.</p>
<p>The first synchronization primitive of this type will be already familiar for us - <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a>. As in all previous parts of this <a href="https://0xax.gitbooks.io/linux-insides/content">book</a>, before we will consider implementation of the <code>reader/writer semaphores</code> in the Linux kernel, we will start from the theoretical side and will try to understand what is the difference between <code>reader/writer semaphores</code> and <code>normal semaphores</code>.</p>
<p>So, let's start.</p>
<h2 id="readerwriter-semaphore">Reader/Writer semaphore</h2>
<p>Actually there are two types of operations may be performed on the data. We may read data and make changes in data. Two fundamental operations - <code>read</code> and <code>write</code>. Usually (but not always), <code>read</code> operation is performed more often than <code>write</code> operation. In this case, it would be logical to we may lock data in such way, that some processes may read locked data in one time, on condition that no one will not change the data. The <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers/writer lock</a> allows us to get this lock.</p>
<p>When a process which wants to write something into data, all other <code>writer</code> and <code>reader</code> processes will be blocked until the process which acquired a lock, will not release it. When a process reads data, other processes which want to read the same data too, will not be locked and will be able to do this. As you may guess, implementation of the <code>reader/writer semaphore</code> is based on the implementation of the <code>normal semaphore</code>. We already familiar with the <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> synchronization primitive from the third [part]((https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-4.html) of this chapter. From the theoretical side everything looks pretty simple. Let's look how <code>reader/writer semaphore</code> is represented in the Linux kernel.</p>
<p>The <code>semaphore</code> is represented by the:</p>
<pre><code class="language-C">struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
</code></pre>
<p>structure. If you will look in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/rwsem.h">include/linux/rwsem.h</a> header file, you will find definition of the <code>rw_semaphore</code> structure which represents <code>reader/writer semaphore</code> in the Linux kernel. Let's look at the definition of this structure:</p>
<pre><code class="language-C">#ifdef CONFIG_RWSEM_GENERIC_SPINLOCK
#include &lt;linux/rwsem-spinlock.h&gt;
#else
struct rw_semaphore {
        long count;
        struct list_head wait_list;
        raw_spinlock_t wait_lock;
#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
        struct optimistic_spin_queue osq;
        struct task_struct *owner;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
        struct lockdep_map      dep_map;
#endif
};
</code></pre>
<p>Before we will consider fields of the <code>rw_semaphore</code> structure, we may notice, that declaration of the <code>rw_semaphore</code> structure depends on the <code>CONFIG_RWSEM_GENERIC_SPINLOCK</code> kernel configuration option. This option is disabled for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture by default. We can be sure in this by looking at the corresponding kernel configuration file. In our case, this configuration file is - <a href="https://github.com/torvalds/linux/blob/master/arch/x86/um/Kconfig">arch/x86/um/Kconfig</a>:</p>
<pre><code>config RWSEM_XCHGADD_ALGORITHM
	def_bool 64BIT

config RWSEM_GENERIC_SPINLOCK
	def_bool !RWSEM_XCHGADD_ALGORITHM
</code></pre>
<p>So, as this <a href="https://0xax.gitbooks.io/linux-insides/content">book</a> describes only <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture related stuff, we will skip the case when the <code>CONFIG_RWSEM_GENERIC_SPINLOCK</code> kernel configuration is enabled and consider definition of the <code>rw_semaphore</code> structure only from the <a href="https://github.com/torvalds/linux/blob/master/include/linux/rwsem.h">include/linux/rwsem.h</a> header file.</p>
<p>If we will take a look at the definition of the <code>rw_semaphore</code> structure, we will notice that first three fields are the same that in the <code>semaphore</code> structure. It contains <code>count</code> field which represents amount of available resources, the <code>wait_list</code> field which represents <a href="https://0xax.gitbooks.io/linux-insides/content/DataStructures/dlist.html">doubly linked list</a> of processes which are waiting to acquire a lock and <code>wait_lock</code> <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for protection of this list. Notice that <code>rw_semaphore.count</code> field is <code>long</code> type unlike the same field in the <code>semaphore</code> structure.</p>
<p>The <code>count</code> field of a <code>rw_semaphore</code> structure may have following values:</p>
<ul>
<li><code>0x0000000000000000</code> - <code>reader/writer semaphore</code> is in unlocked state and no one is waiting for a lock;</li>
<li><code>0x000000000000000X</code> - <code>X</code> readers are active or attempting to acquire a lock and no writer waiting;</li>
<li><code>0xffffffff0000000X</code> - may represent different cases. The first is - <code>X</code> readers are active or attempting to acquire a lock with waiters for the lock. The second is - one writer attempting a lock, no waiters for the lock. And the last - one writer is active and no waiters for the lock;</li>
<li><code>0xffffffff00000001</code> - may represented two different cases. The first is - one reader is active or attempting to acquire a lock and exist waiters for the lock. The second case is one writer is active or attempting to acquire a lock and no waiters for the lock;</li>
<li><code>0xffffffff00000000</code> - represents situation when there are readers or writers are queued, but no one is active or is in the process of acquire of a lock;</li>
<li><code>0xfffffffe00000001</code> - a writer is active or attempting to acquire a lock and waiters are in queue.</li>
</ul>
<p>So, besides the <code>count</code> field, all of these fields are similar to fields of the <code>semaphore</code> structure. Last three fields depend on the two configuration options of the Linux kernel: the <code>CONFIG_RWSEM_SPIN_ON_OWNER</code> and <code>CONFIG_DEBUG_LOCK_ALLOC</code>. The first two fields may be familiar us by declaration of the <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> structure from the <a href="https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-4.html">previous part</a>. The first <code>osq</code> field represents <a href="http://www.cs.rochester.edu/~scott/papers/1991_TOCS_synch.pdf">MCS lock</a> spinner for <code>optimistic spinning</code> and the second represents process which is current owner of a lock.</p>
<p>The last field of the <code>rw_semaphore</code> structure is - <code>dep_map</code> - debugging related, and as I already wrote in previous parts, we will skip debugging related stuff in this chapter.</p>
<p>That's all. Now we know a little about what is it <code>reader/writer lock</code> in general and <code>reader/writer semaphore</code> in particular. Additionally we saw how a <code>reader/writer semaphore</code> is represented in the Linux kernel. In this case, we may go ahead and start to look at the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> which the Linux kernel provides for manipulation of <code>reader/writer semaphores</code>.</p>
<h2 id="readerwriter-semaphore-api">Reader/Writer semaphore API</h2>
<p>So, we know a little about <code>reader/writer semaphores</code> from theoretical side, let's look on its implementation in the Linux kernel. All <code>reader/writer semaphores</code> related <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> is located in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/rwsem.h">include/linux/rwsem.h</a> header file.</p>
<p>As always Before we will consider an <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of the <code>reader/writer semaphore</code> mechanism in the Linux kernel, we need to know how to initialize the <code>rw_semaphore</code> structure. As we already saw in previous parts of this <a href="https://0xax.gitbooks.io/linux-insides/content/SyncPrim/index.html">chapter</a>, all <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> may be initialized in two ways:</p>
<ul>
<li><code>statically</code>;</li>
<li><code>dynamically</code>.</li>
</ul>
<p>And <code>reader/writer semaphore</code> is not an exception. First of all, let's take a look at the first approach. We may initialize <code>rw_semaphore</code> structure with the help of the <code>DECLARE_RWSEM</code> macro in compile time. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/rwsem.h">include/linux/rwsem.h</a> header file and looks:</p>
<pre><code class="language-C">#define DECLARE_RWSEM(name) \
        struct rw_semaphore name = __RWSEM_INITIALIZER(name)
</code></pre>
<p>As we may see, the <code>DECLARE_RWSEM</code> macro just expands to the definition of the <code>rw_semaphore</code> structure with the given name. Additionally new <code>rw_semaphore</code> structure is initialized with the value of the <code>__RWSEM_INITIALIZER</code> macro:</p>
<pre><code class="language-C">#define __RWSEM_INITIALIZER(name)              \
{                                                              \
        .count = RWSEM_UNLOCKED_VALUE,                         \
        .wait_list = LIST_HEAD_INIT((name).wait_list),         \
        .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(name.wait_lock)  \
         __RWSEM_OPT_INIT(name)                                \
         __RWSEM_DEP_MAP_INIT(name)
} 
</code></pre>
<p>and expands to the initialization of fields of <code>rw_semaphore</code> structure. First of all we initialize <code>count</code> field of the <code>rw_semaphore</code> structure to the <code>unlocked</code> state with <code>RWSEM_UNLOCKED_VALUE</code> macro from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> architecture specific header file:</p>
<pre><code class="language-C">#define RWSEM_UNLOCKED_VALUE            0x00000000L
</code></pre>
<p>After this we initialize list of a lock waiters with the empty linked list and <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for protection of this list with the <code>unlocked</code> state too. The <code>__RWSEM_OPT_INIT</code> macro depends on the state of the <code>CONFIG_RWSEM_SPIN_ON_OWNER</code> kernel configuration option and if this option is enabled it expands to the initialization of the <code>osq</code> and <code>owner</code> fields of the <code>rw_semaphore</code> structure. As we already saw above, the <code>CONFIG_RWSEM_SPIN_ON_OWNER</code> kernel configuration option is enabled by default for <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture, so let's take a look at the definition of the <code>__RWSEM_OPT_INIT</code> macro:</p>
<pre><code class="language-C">#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
    #define __RWSEM_OPT_INIT(lockname) , .osq = OSQ_LOCK_UNLOCKED, .owner = NULL
#else
    #define __RWSEM_OPT_INIT(lockname)
#endif
</code></pre>
<p>As we may see, the <code>__RWSEM_OPT_INIT</code> macro initializes the <a href="http://www.cs.rochester.edu/~scott/papers/1991_TOCS_synch.pdf">MCS lock</a> lock with <code>unlocked</code> state and initial <code>owner</code> of a lock with <code>NULL</code>. From this moment, a <code>rw_semaphore</code> structure will be initialized in a compile time and may be used for data protection.</p>
<p>The second way to initialize a <code>rw_semaphore</code> structure is <code>dynamically</code> or use the <code>init_rwsem</code> macro from the <a href="https://github.com/torvalds/linux/blob/master/include/linux/rwsem.h">include/linux/rwsem.h</a> header file. This macro declares an instance of the <code>lock_class_key</code> which is related to the <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> of the Linux kernel and to the call of the <code>__init_rwsem</code> function with the given <code>reader/writer semaphore</code>:</p>
<pre><code class="language-C">#define init_rwsem(sem)                         \
do {                                                            \
        static struct lock_class_key __key;                     \
                                                                \
        __init_rwsem((sem), #sem, &amp;__key);                      \
} while (0)
</code></pre>
<p>If you will start definition of the <code>__init_rwsem</code> function, you will notice that there are couple of source code files which contain it. As you may guess, sometimes we need to initialize additional fields of the <code>rw_semaphore</code> structure, like the <code>osq</code> and <code>owner</code>. But sometimes not. All of this depends on some kernel configuration options. If we will look at the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/Makefile">kernel/locking/Makefile</a> makefile, we will see following lines:</p>
<pre><code class="language-Makefile">obj-$(CONFIG_RWSEM_GENERIC_SPINLOCK) += rwsem-spinlock.o
obj-$(CONFIG_RWSEM_XCHGADD_ALGORITHM) += rwsem-xadd.o
</code></pre>
<p>As we already know, the Linux kernel for <code>x86_64</code> architecture has enabled <code>CONFIG_RWSEM_XCHGADD_ALGORITHM</code> kernel configuration option by default:</p>
<pre><code>config RWSEM_XCHGADD_ALGORITHM
	def_bool 64BIT
</code></pre>
<p>in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/um/Kconfig">arch/x86/um/Kconfig</a> kernel configuration file. In this case, implementation of the <code>__init_rwsem</code> function will be located in the <a href="https://github.com/torvalds/linux/blob/master/locking/rwsem-xadd.c">kernel/locking/rwsem-xadd.c</a> source code file for us. Let's take a look at this function:</p>
<pre><code class="language-C">void __init_rwsem(struct rw_semaphore *sem, const char *name,
                    struct lock_class_key *key)
{
#ifdef CONFIG_DEBUG_LOCK_ALLOC
        debug_check_no_locks_freed((void *)sem, sizeof(*sem));
        lockdep_init_map(&amp;sem-&gt;dep_map, name, key, 0);
#endif
        sem-&gt;count = RWSEM_UNLOCKED_VALUE;
        raw_spin_lock_init(&amp;sem-&gt;wait_lock);
        INIT_LIST_HEAD(&amp;sem-&gt;wait_list);
#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
        sem-&gt;owner = NULL;
        osq_lock_init(&amp;sem-&gt;osq);
#endif
}
</code></pre>
<p>We may see here almost the same as in <code>__RWSEM_INITIALIZER</code> macro with difference that all of this will be executed in <a href="https://en.wikipedia.org/wiki/Run_time_%28program_lifecycle_phase%29">runtime</a>.</p>
<p>So, from now we are able to initialize a <code>reader/writer semaphore</code> let's look at the <code>lock</code> and <code>unlock</code> API. The Linux kernel provides following primary <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> to manipulate <code>reader/writer semaphores</code>:</p>
<ul>
<li><code>void down_read(struct rw_semaphore *sem)</code> - lock for reading;</li>
<li><code>int down_read_trylock(struct rw_semaphore *sem)</code> - try lock for reading;</li>
<li><code>void down_write(struct rw_semaphore *sem)</code> - lock for writing;</li>
<li><code>int down_write_trylock(struct rw_semaphore *sem)</code> - try lock for writing;</li>
<li><code>void up_read(struct rw_semaphore *sem)</code> - release a read lock;</li>
<li><code>void up_write(struct rw_semaphore *sem)</code> - release a write lock;</li>
</ul>
<p>Let's start as always from the locking. First of all let's consider implementation of the <code>down_write</code> function which executes a try of acquiring of a lock for <code>write</code>. This function is <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/rwsem.c">kernel/locking/rwsem.c</a> source code file and starts from the call of the macro from the <a href="https://github.com/torvalds/linux/blob/master/include/linux/kernel.h">include/linux/kernel.h</a> header file:</p>
<pre><code class="language-C">void __sched down_write(struct rw_semaphore *sem)
{
        might_sleep();
        rwsem_acquire(&amp;sem-&gt;dep_map, 0, 0, _RET_IP_);

        LOCK_CONTENDED(sem, __down_write_trylock, __down_write);
        rwsem_set_owner(sem);
}
</code></pre>
<p>We already met the <code>might_sleep</code> macro in the <a href="https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-4.html">previous part</a>. In short words, Implementation of the <code>might_sleep</code> macro depends on the <code>CONFIG_DEBUG_ATOMIC_SLEEP</code> kernel configuration option and if this option is enabled, this macro just prints a stack trace if it was executed in <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> context. As this macro is mostly for debugging purpose we will skip it and will go ahead. Additionally we will skip the next macro from the <code>down_read</code> function - <code>rwsem_acquire</code> which is related to the <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> of the Linux kernel, because this is topic of other part.</p>
<p>The only two things that remained in the <code>down_write</code> function is the call of the <code>LOCK_CONTENDED</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/lockdep.h">include/linux/lockdep.h</a> header file and setting of owner of a lock with the <code>rwsem_set_owner</code> function which sets owner to currently running process:</p>
<pre><code class="language-C">static inline void rwsem_set_owner(struct rw_semaphore *sem)
{
        sem-&gt;owner = current;
}
</code></pre>
<p>As you already may guess, the <code>LOCK_CONTENDED</code> macro does all job for us. Let's look at the implementation of the <code>LOCK_CONTENDED</code> macro:</p>
<pre><code class="language-C">#define LOCK_CONTENDED(_lock, try, lock) \
        lock(_lock)
</code></pre>
<p>As we may see it just calls the <code>lock</code> function which is third parameter of the <code>LOCK_CONTENDED</code> macro with the given <code>rw_semaphore</code>. In our case the third parameter of the <code>LOCK_CONTENDED</code> macro is the <code>__down_write</code> function which is architecture specific function and located in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> header file. Let's look at the implementation of the <code>__down_write</code> function:</p>
<pre><code class="language-C">static inline void __down_write(struct rw_semaphore *sem)
{
        __down_write_nested(sem, 0);
}
</code></pre>
<p>which just executes a call of the <code>__down_write_nested</code> function from the same source code file. Let's take a look at the implementation of the <code>__down_write_nested</code> function:</p>
<pre><code class="language-C">static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
{
        long tmp;

        asm volatile("# beginning down_write\n\t"
                     LOCK_PREFIX "  xadd      %1,(%2)\n\t"
                     "  test " __ASM_SEL(%w1,%k1) "," __ASM_SEL(%w1,%k1) "\n\t"
                     "  jz        1f\n"
                     "  call call_rwsem_down_write_failed\n"
                     "1:\n"
                     "# ending down_write"
                     : "+m" (sem-&gt;count), "=d" (tmp)
                     : "a" (sem), "1" (RWSEM_ACTIVE_WRITE_BIAS)
                     : "memory", "cc");
}
</code></pre>
<p>As for other synchronization primitives which we saw in this chapter, usually <code>lock/unlock</code> functions consists only from an <a href="https://0xax.gitbooks.io/linux-insides/content/Theory/asm.html">inline assembly</a> statement. As we may see, in our case the same for <code>__down_write_nested</code> function. Let's try to understand what does this function do. The first line of our assembly statement is just a comment, let's skip it. The second like contains <code>LOCK_PREFIX</code> which will be expanded to the <a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">LOCK</a> instruction as we already know. The next <a href="http://x86.renejeschke.de/html/file_module_x86_id_327.html">xadd</a> instruction executes <code>add</code> and <code>exchange</code> operations. In other words, <code>xadd</code> instruction adds value of the <code>RWSEM_ACTIVE_WRITE_BIAS</code>:</p>
<pre><code class="language-C">#define RWSEM_ACTIVE_WRITE_BIAS         (RWSEM_WAITING_BIAS + RWSEM_ACTIVE_BIAS)

#define RWSEM_WAITING_BIAS              (-RWSEM_ACTIVE_MASK-1)
#define RWSEM_ACTIVE_BIAS               0x00000001L
</code></pre>
<p>or <code>0xffffffff00000001</code> to the <code>count</code> of the given <code>reader/writer semaphore</code> and returns previous value of it. After this we check the active mask in the <code>rw_semaphore-&gt;count</code>. If it was zero before, this means that there were no-one writer before, so we acquired a lock. In other way we call the <code>call_rwsem_down_write_failed</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/lib/rwsem.S">arch/x86/lib/rwsem.S</a> assembly file. The the <code>call_rwsem_down_write_failed</code> function just calls the <code>rwsem_down_write_failed</code> function from the <a href="https://github.com/torvalds/linux/blob/master/locking/rwsem-xadd.c">kernel/locking/rwsem-xadd.c</a> source code file anticipatorily save general purpose registers:</p>
<pre><code class="language-assembly">ENTRY(call_rwsem_down_write_failed)
	FRAME_BEGIN
	save_common_regs
	movq %rax,%rdi
	call rwsem_down_write_failed
	restore_common_regs
	FRAME_END
	ret
    ENDPROC(call_rwsem_down_write_failed)
</code></pre>
<p>The <code>rwsem_down_write_failed</code> function starts from the <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> update of the <code>count</code> value:</p>
<pre><code class="language-C"> __visible
struct rw_semaphore __sched *rwsem_down_write_failed(struct rw_semaphore *sem)
{
    count = rwsem_atomic_update(-RWSEM_ACTIVE_WRITE_BIAS, sem);
    ...
    ...
    ...
}
</code></pre>
<p>with the <code>-RWSEM_ACTIVE_WRITE_BIAS</code> value. The <code>rwsem_atomic_update</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> header file and implement exchange and add logic:</p>
<pre><code class="language-C">static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
{
        return delta + xadd(&amp;sem-&gt;count, delta);
}
</code></pre>
<p>This function atomically adds the given delta to the <code>count</code> and returns old value of the count. After this it just returns sum of the given <code>delta</code> and old value of the <code>count</code> field. In our case we undo write bias from the <code>count</code> as we didn't acquire a lock. After this step we try to do <code>optimistic spinning</code> by the call of the <code>rwsem_optimistic_spin</code> function:</p>
<pre><code class="language-C">if (rwsem_optimistic_spin(sem))
      return sem;
</code></pre>
<p>We will skip implementation of the <code>rwsem_optimistic_spin</code> function, as it is similar on the <code>mutex_optimistic_spin</code> function which we saw in the <a href="https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-4.html">previous part</a>. In short words we check existence other tasks ready to run that have higher priority in the <code>rwsem_optimistic_spin</code> function. If there are such tasks, the process will be added to the <a href="http://www.cs.rochester.edu/~scott/papers/1991_TOCS_synch.pdf">MCS</a> <code>waitqueue</code> and start to spin in the loop until a lock will be able to be acquired. If <code>optimistic spinning</code> is disabled, a process will be added to the and marked as waiting for write:</p>
<pre><code class="language-C">waiter.task = current;
waiter.type = RWSEM_WAITING_FOR_WRITE;

if (list_empty(&amp;sem-&gt;wait_list))
    waiting = false;

list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);
</code></pre>
<p>waiters list and start to wait until it will successfully acquire the lock. After we have added a process to the waiters list which was empty before this moment, we update the value of the <code>rw_semaphore-&gt;count</code> with the <code>RWSEM_WAITING_BIAS</code>:</p>
<pre><code class="language-C">count = rwsem_atomic_update(RWSEM_WAITING_BIAS, sem);
</code></pre>
<p>with this we mark <code>rw_semaphore-&gt;counter</code> that it is already locked and exists/waits one <code>writer</code> which wants to acquire the lock. In other way we try to wake <code>reader</code> processes from the <code>wait queue</code> that were queued before this <code>writer</code> process and there are no active readers. In the end of the <code>rwsem_down_write_failed</code> a <code>writer</code> process will go to sleep which didn't acquire a lock in the following loop:</p>
<pre><code class="language-C">while (true) {
    if (rwsem_try_write_lock(count, sem))
        break;
    raw_spin_unlock_irq(&amp;sem-&gt;wait_lock);
    do {
        schedule();
        set_current_state(TASK_UNINTERRUPTIBLE);
    } while ((count = sem-&gt;count) &amp; RWSEM_ACTIVE_MASK);
    raw_spin_lock_irq(&amp;sem-&gt;wait_lock);
}
</code></pre>
<p>I will skip explanation of this loop as we already met similar functional in the <a href="https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-4.html">previous part</a>.</p>
<p>That's all. From this moment, our <code>writer</code> process will acquire or not acquire a lock depends on the value of the <code>rw_semaphore-&gt;count</code> field. Now if we will look at the implementation of the <code>down_read</code> function which executes a try of acquiring of a lock. We will see similar actions which we saw in the <code>down_write</code> function. This function calls different debugging and lock validator related functions/macros:</p>
<pre><code class="language-C">void __sched down_read(struct rw_semaphore *sem)
{
        might_sleep();
        rwsem_acquire_read(&amp;sem-&gt;dep_map, 0, 0, _RET_IP_);

        LOCK_CONTENDED(sem, __down_read_trylock, __down_read);
}
</code></pre>
<p>and does all job in the <code>__down_read</code> function. The <code>__down_read</code> consists of inline assembly statement:</p>
<pre><code class="language-C">static inline void __down_read(struct rw_semaphore *sem)
{
         asm volatile("# beginning down_read\n\t"
                     LOCK_PREFIX _ASM_INC "(%1)\n\t"
                     "  jns        1f\n"
                     "  call call_rwsem_down_read_failed\n"
                     "1:\n\t"
                     "# ending down_read\n\t"
                     : "+m" (sem-&gt;count)
                     : "a" (sem)
                     : "memory", "cc");
}
</code></pre>
<p>which increments value of the given <code>rw_semaphore-&gt;count</code> and call the <code>call_rwsem_down_read_failed</code> if this value is negative. In other way we jump at the label <code>1:</code> and exit. After this <code>read</code> lock will be successfully acquired. Notice that we check a sign of the <code>count</code> value as it may be negative, because as you may remember most significant <a href="https://en.wikipedia.org/wiki/Word_%28computer_architecture%29">word</a> of the <code>rw_semaphore-&gt;count</code> contains negated number of active writers.</p>
<p>Let's consider case when a process wants to acquire a lock for <code>read</code> operation, but it is already locked. In this case the <code>call_rwsem_down_read_failed</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/lib/rwsem.S">arch/x86/lib/rwsem.S</a> assembly file will be called. If you will look at the implementation of this function, you will notice that it does the same that <code>call_rwsem_down_read_failed</code> function does. Except it calls the <code>rwsem_down_read_failed</code> function instead of <code>rwsem_dow_write_failed</code>. Now let's consider implementation of the <code>rwsem_down_read_failed</code> function. It starts from the adding a process to the <code>wait queue</code> and updating of value of the <code>rw_semaphore-&gt;counter</code>:</p>
<pre><code class="language-C">long adjustment = -RWSEM_ACTIVE_READ_BIAS;

waiter.task = tsk;
waiter.type = RWSEM_WAITING_FOR_READ;

if (list_empty(&amp;sem-&gt;wait_list))
    adjustment += RWSEM_WAITING_BIAS;
list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);

count = rwsem_atomic_update(adjustment, sem);
</code></pre>
<p>Notice that if the <code>wait queue</code> was empty before we clear the <code>rw_semaphore-&gt;counter</code> and undo <code>read</code> bias in other way. At the next step we check that there are no active locks and we are first in the <code>wait queue</code> we need to join currently active <code>reader</code> processes. In other way we go to sleep until a lock will not be able to acquired.</p>
<p>That's all. Now we know how <code>reader</code> and <code>writer</code> processes will behave in different cases during a lock acquisition. Now let's take a short look at <code>unlock</code> operations. The <code>up_read</code> and <code>up_write</code> functions allows us to unlock a <code>reader</code> or <code>writer</code> lock. First of all let's take a look at the implementation of the <code>up_write</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/rwsem.c">kernel/locking/rwsem.c</a> source code file:</p>
<pre><code class="language-C">void up_write(struct rw_semaphore *sem)
{
        rwsem_release(&amp;sem-&gt;dep_map, 1, _RET_IP_);

        rwsem_clear_owner(sem);
        __up_write(sem);
}
</code></pre>
<p>First of all it calls the <code>rwsem_release</code> macro which is related to the lock validator of the Linux kernel, so we will skip it now. And at the next line the <code>rwsem_clear_owner</code> function which as you may understand from the name of this function, just clears the <code>owner</code> field of the given <code>rw_semaphore</code>:</p>
<pre><code class="language-C">static inline void rwsem_clear_owner(struct rw_semaphore *sem)
{
	sem-&gt;owner = NULL;
}
</code></pre>
<p>The <code>__up_write</code> function does all job of unlocking of the lock. The <code>_up_write</code> is architecture-specific function, so for our case it will be located in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> source code file. If we will take a look at the implementation of this function, we will see that it does almost the same that <code>__down_write</code> function, but conversely. Instead of adding of the <code>RWSEM_ACTIVE_WRITE_BIAS</code> to the <code>count</code>, we subtract the same value and check the <code>sign</code> of the previous value.</p>
<p>If the previous value of the <code>rw_semaphore-&gt;count</code> is not negative, a writer process released a lock and now it may be acquired by someone else. In other case, the <code>rw_semaphore-&gt;count</code> will contain negative values. This means that there is at least one <code>writer</code> in a wait queue. In this case the <code>call_rwsem_wake</code> function will be called. This function acts like similar functions which we already saw above. It store general purpose registers at the stack for preserving and call the <code>rwsem_wake</code> function.</p>
<p>First of all the <code>rwsem_wake</code> function checks if a spinner is present. In this case it will just acquire a lock which is just released by lock owner. In other case there must be someone in the <code>wait queue</code> and we need to wake or writer process if it exists at the top of the <code>wait queue</code> or all <code>reader</code> processes. The <code>up_read</code> function which release a <code>reader</code> lock acts in similar way like <code>up_write</code>, but with a little difference. Instead of subtracting of <code>RWSEM_ACTIVE_WRITE_BIAS</code> from the <code>rw_semaphore-&gt;count</code>, it subtracts <code>1</code> from it, because less significant word of the <code>count</code> contains number active locks. After this it checks <code>sign</code> of the <code>count</code> and calls the <code>rwsem_wake</code> like <code>__up_write</code> if the <code>count</code> is negative or in other way lock will be successfully released.</p>
<p>That's all. We have considered API for manipulation with <code>reader/writer semaphore</code>: <code>up_read/up_write</code> and <code>down_read/down_write</code>. We saw that the Linux kernel provides additional API, besides this functions, like the <code>,</code> and etc. But I will not consider implementation of these function in this part because it must be similar on that we have seen in this part of except few subtleties.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This is the end of the fifth part of the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> chapter in the Linux kernel. In this part we met with special type of <code>semaphore</code> - <code>readers/writer</code> semaphore which provides access to data for multiply process to read or for one process to writer. In the next part we will continue to dive into synchronization primitives in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">Synchronization primitives</a></li>
<li><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Readers/Writer lock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">Spinlocks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">Semaphore</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion">Mutex</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64 architecture</a></li>
<li><a href="https://0xax.gitbooks.io/linux-insides/content/DataStructures/dlist.html">Doubly linked list</a></li>
<li><a href="http://www.cs.rochester.edu/~scott/papers/1991_TOCS_synch.pdf">MCS lock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">Linux kernel lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">Atomic operations</a></li>
<li><a href="https://0xax.gitbooks.io/linux-insides/content/Theory/asm.html">Inline assembly</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_327.html">XADD instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">LOCK instruction</a></li>
<li><a href="https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-4.html">Previous part</a></li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/46/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/46/index.html">软件开发平台及语言笔记大全(超详细)</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/22.html">jasonblog</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="cplusplus">cplusplus</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1,399页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月30日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 16个">16</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/151/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/151/index.html">Shell脚本编程30分钟入门</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/83.html">qinjx</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">5页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 5224个">5224</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/44/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/44/index.html">Shell 编程范例</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/23.html">泰晓科技</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月30日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 296个">296</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/77/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/openstack_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/77/index.html">深入理解 Neutron -- OpenStack 网络实现</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/48.html">yeasy</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="openstack">openstack</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">47页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 136个">136</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/98/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/visualstudio_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/98/index.html">Microsoft Visual Studio Code 中文手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/60.html">likebeta</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="visualstudio">visualstudio</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">66页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/204/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/204/index.html">系统重构与迁移指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">183页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/114/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/114/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/README.html" title="简介" data-book-page-rel-url="README.html" data-book-page-id="8065">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/README.html" title="引导" data-book-page-rel-url="Booting/README.html" data-book-page-id="8066">引导</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-1.html" title="从引导加载程序内核" data-book-page-rel-url="Booting/linux-bootstrap-1.html" data-book-page-id="8067">从引导加载程序内核</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-2.html" title="在内核安装代码的第一步" data-book-page-rel-url="Booting/linux-bootstrap-2.html" data-book-page-id="8068">在内核安装代码的第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-3.html" title="视频模式初始化和转换到保护模式" data-book-page-rel-url="Booting/linux-bootstrap-3.html" data-book-page-id="8069">视频模式初始化和转换到保护模式</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-4.html" title="过渡到 64 位模式" data-book-page-rel-url="Booting/linux-bootstrap-4.html" data-book-page-id="8070">过渡到 64 位模式</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-5.html" title="内核解压缩" data-book-page-rel-url="Booting/linux-bootstrap-5.html" data-book-page-id="8071">内核解压缩</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/README.html" title="初始化" data-book-page-rel-url="Initialization/README.html" data-book-page-id="8072">初始化</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-1.html" title="内核解压之后的首要步骤" data-book-page-rel-url="Initialization/linux-initialization-1.html" data-book-page-id="8073">内核解压之后的首要步骤</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-2.html" title="早期的中断和异常控制" data-book-page-rel-url="Initialization/linux-initialization-2.html" data-book-page-id="8074">早期的中断和异常控制</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-3.html" title="在到达内核入口之前最后的准备" data-book-page-rel-url="Initialization/linux-initialization-3.html" data-book-page-id="8075">在到达内核入口之前最后的准备</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-4.html" title="内核入口 - start_kernel" data-book-page-rel-url="Initialization/linux-initialization-4.html" data-book-page-id="8076">内核入口 - start_kernel</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-5.html" title="体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-5.html" data-book-page-id="8077">体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-6.html" title="进一步初始化指定体系架构" data-book-page-rel-url="Initialization/linux-initialization-6.html" data-book-page-id="8078">进一步初始化指定体系架构</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-7.html" title="最后对指定体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-7.html" data-book-page-id="8079">最后对指定体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-8.html" title="调度器初始化" data-book-page-rel-url="Initialization/linux-initialization-8.html" data-book-page-id="8080">调度器初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-9.html" title="RCU 初始化" data-book-page-rel-url="Initialization/linux-initialization-9.html" data-book-page-id="8081">RCU 初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-10.html" title="初始化结束" data-book-page-rel-url="Initialization/linux-initialization-10.html" data-book-page-id="8082">初始化结束</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/README.html" title="中断" data-book-page-rel-url="Interrupts/README.html" data-book-page-id="8083">中断</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-1.html" title="中断和中断处理 Part 1." data-book-page-rel-url="Interrupts/interrupts-1.html" data-book-page-id="8084">中断和中断处理 Part 1.</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-2.html" title="深入 Linux 内核中的中断" data-book-page-rel-url="Interrupts/interrupts-2.html" data-book-page-id="8085">深入 Linux 内核中的中断</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-3.html" title="初步中断处理" data-book-page-rel-url="Interrupts/interrupts-3.html" data-book-page-id="8086">初步中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-4.html" title="中断处理" data-book-page-rel-url="Interrupts/interrupts-4.html" data-book-page-id="8087">中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-5.html" title="异常处理的实现" data-book-page-rel-url="Interrupts/interrupts-5.html" data-book-page-id="8088">异常处理的实现</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-6.html" title="处理不可屏蔽中断" data-book-page-rel-url="Interrupts/interrupts-6.html" data-book-page-id="8089">处理不可屏蔽中断</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-7.html" title="深入外部硬件中断" data-book-page-rel-url="Interrupts/interrupts-7.html" data-book-page-id="8090">深入外部硬件中断</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-8.html" title="IRQs的非早期初始化" data-book-page-rel-url="Interrupts/interrupts-8.html" data-book-page-id="8091">IRQs的非早期初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-9.html" title="Softirq, Tasklets and Workqueues" data-book-page-rel-url="Interrupts/interrupts-9.html" data-book-page-id="8092">Softirq, Tasklets and Workqueues</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-10.html" title="最后一部分" data-book-page-rel-url="Interrupts/interrupts-10.html" data-book-page-id="8093">最后一部分</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/README.html" title="系统调用" data-book-page-rel-url="SysCall/README.html" data-book-page-id="8094">系统调用</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-1.html" title="系统调用概念简介" data-book-page-rel-url="SysCall/syscall-1.html" data-book-page-id="8095">系统调用概念简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-2.html" title="Linux 内核如何处理系统调用" data-book-page-rel-url="SysCall/syscall-2.html" data-book-page-id="8096">Linux 内核如何处理系统调用</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-3.html" title="vsyscall and vDSO" data-book-page-rel-url="SysCall/syscall-3.html" data-book-page-id="8097">vsyscall and vDSO</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-4.html" title="Linux 内核如何运行程序" data-book-page-rel-url="SysCall/syscall-4.html" data-book-page-id="8098">Linux 内核如何运行程序</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-5.html" title="open 系统调用的实现" data-book-page-rel-url="SysCall/syscall-5.html" data-book-page-id="8099">open 系统调用的实现</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Linux 资源限制" disabled data-book-page-rel-url="SysCall/syscall-6.html" data-book-page-id="8100">Linux 资源限制</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/README.html" title="定时器和时钟管理" data-book-page-rel-url="Timers/README.html" data-book-page-id="8101">定时器和时钟管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-1.html" title="简介" data-book-page-rel-url="Timers/timers-1.html" data-book-page-id="8102">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-2.html" title="时钟源框架简介" data-book-page-rel-url="Timers/timers-2.html" data-book-page-id="8103">时钟源框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-3.html" title="The tick broadcast framework and dyntick" data-book-page-rel-url="Timers/timers-3.html" data-book-page-id="8104">The tick broadcast framework and dyntick</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-4.html" title="定时器介绍" data-book-page-rel-url="Timers/timers-4.html" data-book-page-id="8105">定时器介绍</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-5.html" title="Clockevents 框架简介" data-book-page-rel-url="Timers/timers-5.html" data-book-page-id="8106">Clockevents 框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-6.html" title="x86 相关的时钟源" data-book-page-rel-url="Timers/timers-6.html" data-book-page-id="8107">x86 相关的时钟源</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-7.html" title="Linux 内核中与时钟相关的系统调用" data-book-page-rel-url="Timers/timers-7.html" data-book-page-id="8108">Linux 内核中与时钟相关的系统调用</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/README.html" title="同步原语" data-book-page-rel-url="SyncPrim/README.html" data-book-page-id="8109">同步原语</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-1.html" title="自旋锁简介" data-book-page-rel-url="SyncPrim/sync-1.html" data-book-page-id="8110">自旋锁简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-2.html" title="队列自旋锁" data-book-page-rel-url="SyncPrim/sync-2.html" data-book-page-id="8111">队列自旋锁</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-3.html" title="信号量" data-book-page-rel-url="SyncPrim/sync-3.html" data-book-page-id="8112">信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-4.html" title="互斥锁" data-book-page-rel-url="SyncPrim/sync-4.html" data-book-page-id="8113">互斥锁</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-5.html" title="读者/写者信号量" data-book-page-rel-url="SyncPrim/sync-5.html" data-book-page-id="8114">读者/写者信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-6.html" title="顺序锁" data-book-page-rel-url="SyncPrim/sync-6.html" data-book-page-id="8115">顺序锁</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/MM/README.html" title="内存管理" data-book-page-rel-url="MM/README.html" data-book-page-id="8117">内存管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/MM/linux-mm-1.html" title="内存块" data-book-page-rel-url="MM/linux-mm-1.html" data-book-page-id="8118">内存块</a>
</li>
<li>
<a class="pjax" href="../../../book/114/MM/linux-mm-2.html" title="固定映射地址和 ioremap" data-book-page-rel-url="MM/linux-mm-2.html" data-book-page-id="8119">固定映射地址和 ioremap</a>
</li>
<li>
<a class="pjax" href="../../../book/114/MM/linux-mm-3.html" title="kmemcheck" data-book-page-rel-url="MM/linux-mm-3.html" data-book-page-id="8120">kmemcheck</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Cgroups/README.html" title="Cgroups" data-book-page-rel-url="Cgroups/README.html" data-book-page-id="8121">Cgroups</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Cgroups/cgroups1.html" title="控制组简介" data-book-page-rel-url="Cgroups/cgroups1.html" data-book-page-id="8122">控制组简介</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/README.html" title="概念" data-book-page-rel-url="Concepts/README.html" data-book-page-id="8123">概念</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Concepts/per-cpu.html" title="每个 CPU 的变量" data-book-page-rel-url="Concepts/per-cpu.html" data-book-page-id="8124">每个 CPU 的变量</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/cpumask.html" title="CPU 掩码" data-book-page-rel-url="Concepts/cpumask.html" data-book-page-id="8125">CPU 掩码</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/initcall.html" title="initcall 机制" data-book-page-rel-url="Concepts/initcall.html" data-book-page-id="8126">initcall 机制</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/notification_chains.html" title="Linux 内核的通知链" data-book-page-rel-url="Concepts/notification_chains.html" data-book-page-id="8127">Linux 内核的通知链</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/DataStructures/README.html" title="Linux 内核中的数据结构" data-book-page-rel-url="DataStructures/README.html" data-book-page-id="8128">Linux 内核中的数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/DataStructures/dlist.html" title="双向链表" data-book-page-rel-url="DataStructures/dlist.html" data-book-page-id="8129">双向链表</a>
</li>
<li>
<a class="pjax" href="../../../book/114/DataStructures/radix-tree.html" title="基数树" data-book-page-rel-url="DataStructures/radix-tree.html" data-book-page-id="8130">基数树</a>
</li>
<li>
<a class="pjax" href="../../../book/114/DataStructures/bitmap.html" title="位数组" data-book-page-rel-url="DataStructures/bitmap.html" data-book-page-id="8131">位数组</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Theory/README.html" title="理论" data-book-page-rel-url="Theory/README.html" data-book-page-id="8132">理论</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Theory/Paging.html" title="分页" data-book-page-rel-url="Theory/Paging.html" data-book-page-id="8133">分页</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Theory/ELF.html" title="Elf64 格式" data-book-page-rel-url="Theory/ELF.html" data-book-page-id="8134">Elf64 格式</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/README.html" title="杂项" data-book-page-rel-url="Misc/README.html" data-book-page-id="8135">杂项</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Misc/how_kernel_compiled.html" title="内核编译方法" data-book-page-rel-url="Misc/how_kernel_compiled.html" data-book-page-id="8136">内核编译方法</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/linkers.html" title="链接器" data-book-page-rel-url="Misc/linkers.html" data-book-page-id="8137">链接器</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/contribute.html" title="Linux 内核开发" data-book-page-rel-url="Misc/contribute.html" data-book-page-id="8138">Linux 内核开发</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/program_startup.html" title="用户空间的程序启动过程" data-book-page-rel-url="Misc/program_startup.html" data-book-page-id="8139">用户空间的程序启动过程</a>
</li>
<li>
<a class="pjax" href="../../../book/114/" title="书写并提交你第一个内核补丁" data-book-page-rel-url="" data-book-page-id="8116">书写并提交你第一个内核补丁</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/KernelStructures/README.html" title="内核数据结构" data-book-page-rel-url="KernelStructures/README.html" data-book-page-id="8140">内核数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/KernelStructures/idt.html" title="中断描述符表" data-book-page-rel-url="KernelStructures/idt.html" data-book-page-id="8141">中断描述符表</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/LINKS.html" title="有帮助的链接" data-book-page-rel-url="LINKS.html" data-book-page-id="8142">有帮助的链接</a>
</li>
<li>
<a class="pjax" href="../../../book/114/contributors.html" title="贡献者" data-book-page-rel-url="contributors.html" data-book-page-id="8143">贡献者</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =114;var bookPageId =8114;var bookPageRelUrl ='SyncPrim/sync-5.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>