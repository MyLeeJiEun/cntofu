
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>视频模式初始化和转换到保护模式-Linux 内核揭密</title>
<meta content='视频模式初始化和转换到保护模式,Linux 内核揭密' name='keywords'>
<meta content='视频模式初始化和转换到保护模式,Linux 内核揭密' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/114/Booting/linux-bootstrap-2.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">在内核安装代码的第一步</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/114/Booting/linux-bootstrap-4.html">
<span class="">过渡到 64 位模式</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/114/index.html">Linux 内核揭密</a>
<a target="_blank" rel="nofollow" href="https://github.com/tzivanmoe/linux-insides-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="内核启动过程第三部分">内核启动过程，第三部分</h1>
<h2 id="显示模式初始化和进入保护模式">显示模式初始化和进入保护模式</h2>
<p>这一章是<code>内核启动过程</code>的第三部分，在<a href="linux-bootstrap-2.html#kernel-booting-process-part-2">前一章</a>中，我们的内核启动过程之旅停在了对 <code>set_video</code> 函数的调用（这个函数定义在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/main.c?v=3.18#L181">main.c</a>）。在这一章中，我们将接着上一章继续我们的内核启动之旅。在这一章你将读到下面的内容：</p>
<ul>
<li>显示模式的初始化，</li>
<li>在进入保护模式之前的准备工作，</li>
<li>正式进入保护模式</li>
</ul>
<p><strong>注意</strong> 如果你对保护模式一无所知，你可以查看<a href="linux-bootstrap-2.html#protected-mode">前一章</a> 的相关内容。另外，你也可以查看下面这些<a href="linux-bootstrap-2.html#links">链接</a> 以了解更多关于保护模式的内容。</p>
<p>就像我们前面所说的，我们将从 <code>set_video</code> 函数开始我们这章的内容，你可以在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/video.c?v=3.18#L315">arch/x86/boot/video.c</a> 找到这个函数的定义。 这个函数首先从 <code>boot_params.hdr</code> 数据结构获取显示模式设置：</p>
<pre><code class="language-C">u16 mode = boot_params.hdr.vid_mode;
</code></pre>
<p>至于 <code>boot_params.hdr</code> 数据结构中的内容，是通过 <code>copy_boot_params</code> 函数实现的 （关于这个函数的实现细节请查看上一章的内容），<code>boot_params.hdr</code> 中的 <code>vid_mode</code> 是引导程序必须填入的字段。你可以在 <code>kernel boot protocol</code> 文档中找到关于 <code>vid_mode</code> 的详细信息：</p>
<pre><code>Offset	Proto	Name		Meaning
/Size
01FA/2	ALL	    vid_mode	Video mode control
</code></pre>
<p>而在 <code>linux kernel boot protocol</code> 文档中定义了如何通过命令行参数的方式为 <code>vid_mode</code> 字段传入相应的值：</p>
<pre><code>**** SPECIAL COMMAND LINE OPTIONS
vga=&lt;mode&gt;
	&lt;mode&gt; here is either an integer (in C notation, either
	decimal, octal, or hexadecimal) or one of the strings
	"normal" (meaning 0xFFFF), "ext" (meaning 0xFFFE) or "ask"
	(meaning 0xFFFD).  This value should be entered into the
	vid_mode field, as it is used by the kernel before the command
	line is parsed.
</code></pre>
<p>根据上面的描述，我们可以通过将 <code>vga</code> 选项写入 grub 或者写到引导程序的配置文件，从而让内核命令行得到相应的显示模式设置信息。这个选项可以接受不同类型的值来表示相同的意思。比如你可以传入 0XFFFD 或者 ask，这2个值都表示需要显示一个菜单让用户选择想要的显示模式。下面的链接就给出了这个菜单：</p>
<p><a href="http://oi59.tinypic.com/ejcz81.jpg" data-uk-lightbox><img src="http://oi59.tinypic.com/ejcz81.jpg" alt="video mode setup menu"></a></p>
<p>通过这个菜单，用户可以选择想要进入的显示模式。不过在我们进一步了解显示模式的设置过程之前，让我们先回头了解一些重要的概念。</p>
<h2 id="内核数据类型">内核数据类型</h2>
<p>在前面的章节中，我们已经接触到了一个类似于 <code>u16</code> 的内核数据类型。下面列出了更多内核支持的数据类型：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>char</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>u8</th>
<th>u16</th>
<th>u32</th>
<th>u64</th>
</tr>
</thead>
<tbody>
<tr>
<td>Size</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>如果你尝试阅读内核代码，最好能够牢记这些数据类型。</p>
<h2 id="堆操作-api">堆操作 API</h2>
<p>在 <code>set_video</code> 函数将 <code>vid_mod</code> 的值设置完成之后，将调用 <code>RESET_HEAP</code> 宏将 HEAP 头指向 <code>_end</code> 符号。<code>RESET_HEAP</code> 宏定义在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/boot.h?v=3.18#L199">boot.h</a>：</p>
<pre><code class="language-C">#define RESET_HEAP() ((void *)( HEAP = _end ))
</code></pre>
<p>如果你阅读过第二部分，你应该还记得在第二部分中，我们通过 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/main.c?v=3.18#L116"><code>init_heap</code></a> 函数完成了 HEAP 的初始化。在 <code>boot.h</code> 中定义了一系列的方法来操作被初始化之后的 HEAP。这些操作包括：</p>
<pre><code class="language-C">#define RESET_HEAP() ((void *)( HEAP = _end ))
</code></pre>
<p>就像我们在前面看到的，这个宏只是简单的将 HEAP 头设置到 <code>_end</code> 标号。在上一章中我们已经说明了 <code>_end</code> 标号，在 <code>boot.h</code> 中通过 <code>extern char _end[];</code> 来引用（从这里可以看出，在内核初始化的时候堆和栈是共享内存空间的，详细的信息可以查看第一章的堆栈初始化和第二章的堆初始化）：</p>
<p>下面一个是 <code>GET_HEAP</code> 宏：</p>
<pre><code class="language-C">#define GET_HEAP(type, n) \
	((type *)__get_heap(sizeof(type),__alignof__(type),(n)))
</code></pre>
<p>可以看出这个宏调用了 <code>__get_heap</code> 函数来进行内存的分配。<code>__get_heap</code> 需要下面3个参数来进行内存分配操作：</p>
<ul>
<li>某个数据类型所占用的字节数</li>
<li><code>__alignof__(type)</code> 返回对于请求的数据类型需要怎样的对齐方式 ( 根据我的了解这个是 gcc 提供的一个功能 ）</li>
<li><code>n</code> 需要分配多少个对应数据类型的对象</li>
</ul>
<p>下面是 <code>__get_heap</code> 函数的实现：</p>
<pre><code class="language-C">static inline char *__get_heap(size_t s, size_t a, size_t n)
{
	char *tmp;

	HEAP = (char *)(((size_t)HEAP+(a-1)) &amp; ~(a-1));
	tmp = HEAP;
	HEAP += s*n;
	return tmp;
}
</code></pre>
<p>现在让我们来了解这个函数是如何工作的。 这个函数首先根据对齐方式要求（参数 <code>a</code> ）调整 <code>HEAP</code> 的值，然后将 <code>HEAP</code> 值赋值给一个临时变量 <code>tmp</code>。接下来根据需要分配的对象的个数（参数 <code>n</code> ），预留出所需要的内存，然后将 <code>tmp</code> 返回给调用端。</p>
<p>最后一个关于 HEAP 的操作是：</p>
<pre><code class="language-C">static inline bool heap_free(size_t n)
{
	return (int)(heap_end - HEAP) &gt;= (int)n;
}
</code></pre>
<p>这个函数简单做了一个减法 <code>heap_end - HEAP</code>，如果相减的结果大于请求的内存，那么就返回真，否则返回假。</p>
<p>我们已经看到了所有可以对 HEAP 进行操作，下面让我们继续显示模式设置过程。</p>
<h2 id="设置显示模式">设置显示模式</h2>
<p>在我们分析了内核数据类型以及和 HEAP 相关的操作之后，让我们回来继续分析显示模式的初始化。在 <code>RESET_HEAP()</code> 函数被调用之后，<code>set_video</code> 函数接着调用 <code>store_mode_params</code> 函数将对应显示模式的相关参数写入 <code>boot_params.screen_info</code> 字段。这个字段的结构定义可以在 <a href="https://github.com/0xAX/linux/blob/master/include/uapi/linux/screen_info.h">include/uapi/linux/screen_info.h</a> 中找到。</p>
<p><code>store_mode_params</code> 函数将调用 <code>store_cursor_position</code> 函数将当前屏幕上光标的位置保存起来。下面让我们来看 <code>store_cursor_poistion</code> 函数是如何实现的。</p>
<p>首先函数初始化一个类型为 <code>biosregs</code> 的变量，将其中的 <code>AH</code> 寄存器内容设置成 <code>0x3</code>，然后调用 <code>0x10</code> BIOS 中断。当中断调用返回之后，<code>DL</code> 和 <code>DH</code> 寄存器分别包含了当前光标的行和列信息。接着，这2个信息将被保存到 <code>boot_params.screen_info</code> 字段的 <code>orig_x</code> 和 <code>orig_y</code>字段。</p>
<p>在 <code>store_cursor_position</code> 函数执行完毕之后，<code>store_mode_params</code> 函数将调用 <code>store_vide_mode</code> 函数将当前使用的显示模式保存到 <code>boot_params.screen_info.orig_video_mode</code>。</p>
<p>接下來 <code>store_mode_params</code> 函数将根据当前显示模式的设定，给 <code>video_segment</code> 变量设置正确的值（实际上就是设置显示内存的起始地址）。在 BIOS 将控制权转移到引导扇区的时候，显示内存地址和显示模式的对应关系如下表所示：</p>
<pre><code>0xB000:0x0000 	32 Kb 	Monochrome Text Video Memory
0xB800:0x0000 	32 Kb 	Color Text Video Memory
</code></pre>
<p>根据上表，如果当前显示模式是 MDA, HGC 或者单色 VGA 模式，那么 <code>video_sgement</code> 的值将被设置成 <code>0xB000</code>；如果当前显示模式是彩色模式，那么 <code>video_segment</code> 的值将被设置成 <code>0xB800</code>。在这之后，<code>store_mode_params</code> 函数将保存字体大小信息到 <code>boot_params.screen_info.orig_video_points</code>：</p>
<pre><code class="language-C">//保存字体大小信息
set_fs(0);
font_size = rdfs16(0x485);
boot_params.screen_info.orig_video_points = font_size;
</code></pre>
<p>这段代码首先调用 <code>set_fs</code> 函数（在 <a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/boot.h">boot.h</a> 中定义了许多类似的函数进行寄存器操作）将数字 <code>0</code> 放入 <code>FS</code> 寄存器。接着从内存地址 <code>0x485</code> 处获取字体大小信息并保存到 <code>boot_params.screen_info.orig_video_points</code>。</p>
<pre><code> x = rdfs16(0x44a);
 y = (adapter == ADAPTER_CGA) ? 25 : rdfs8(0x484)+1;
</code></pre>
<p>接下来代码将从地址 <code>0x44a</code> 处获得屏幕列信息，从地址 <code>0x484</code> 处获得屏幕行信息，并将它们保存到 <code>boot_params.screen_info.orig_video_cols</code> 和 <code>boot_params.screen_info.orig_video_lines</code>。到这里，<code>store_mode_params</code> 的执行就结束了。</p>
<p>接下来，<code>set_video</code> 函数将调用 <code>save_screen</code> 函数将当前屏幕上的所有信息保存到 HEAP 中。这个函数首先获得当前屏幕的所有信息（包括屏幕大小，当前光标位置，屏幕上的字符信息），并且保存到 <code>saved_screen</code> 结构体中。这个结构体的定义如下所示：</p>
<pre><code class="language-C">static struct saved_screen {
	int x, y;
	int curx, cury;
	u16 *data;
} saved;
</code></pre>
<p>接下来函数将检查 HEAP 中是否有足够的空间保存这个结构体的数据：</p>
<pre><code class="language-C">if (!heap_free(saved.x*saved.y*sizeof(u16)+512))
		return;
</code></pre>
<p>如果 HEAP 有足够的空间，代码将在 HEAP 中分配相应的空间并且将 <code>saved_screen</code> 保存到 HEAP。</p>
<p>接下来 <code>set_video</code> 函数将调用 <code>probe_cards(0)</code>（这个函数定义在 <a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/video-mode.c#L33">arch/x86/boot/video-mode.c</a>）。 这个函数简单遍历所有的显卡，并通过调用驱动程序设置显卡所支持的显示模式：</p>
<pre><code class="language-C">for (card = video_cards; card &lt; video_cards_end; card++) {
		if (card-&gt;unsafe == unsafe) {
			if (card-&gt;probe)
				card-&gt;nmodes = card-&gt;probe();
			else
				card-&gt;nmodes = 0;
		}
}
</code></pre>
<p>如果你仔细看上面的代码，你会发现 <code>video_cards</code> 这个变量并没有被声明，那么程序怎么能够正常编译执行呢？实际上很简单，它指向了一个在 <a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/setup.ld">arch/x86/boot/setup.ld</a> 中定义的叫做 <code>.videocards</code> 的内存段：</p>
<pre><code>	.videocards	: {
		video_cards = .;
		*(.videocards)
		video_cards_end = .;
	}
</code></pre>
<p>那么这段内存里面存放的数据是什么呢，下面我们就来详细分析。在内核初始化代码中，对于每个支持的显示模式都是使用下面的代码进行定义的：</p>
<pre><code class="language-C">static __videocard video_vga = {
	.card_name	= "VGA",
	.probe		= vga_probe,
	.set_mode	= vga_set_mode,
};
</code></pre>
<p><code>__videocard</code> 是一个宏定义，如下所示：</p>
<pre><code class="language-C">#define __videocard struct card_info __attribute__((used,section(".videocards")))
</code></pre>
<p>因此 <code>__videocard</code> 是一个 <code>card_info</code> 结构，这个结构定义如下：</p>
<pre><code class="language-C">struct card_info {
	const char *card_name;
	int (*set_mode)(struct mode_info *mode);
	int (*probe)(void);
	struct mode_info *modes;
	int nmodes;
	int unsafe;
	u16 xmode_first;
	u16 xmode_n;
};
</code></pre>
<p>在 <code>.videocards</code> 内存段实际上存放的就是所有被内核初始化代码定义的 <code>card_info</code> 结构（可以看成是一个数组），所以 <code>probe_cards</code> 函数可以使用 <code>video_cards</code>，通过循环遍历所有的 <code>card_info</code>。</p>
<p>在 <code>probe_cards</code> 执行完成之后，我们终于进入 <code>set_video</code> 函数的主循环了。在这个循环中，如果 <code>vid_mode=ask</code>，那么将显示一个菜单让用户选择想要的显示模式，然后代码将根据用户的选择或者 <code>vid_mod</code> 的值 ，通过调用 <code>set_mode</code> 函数来设置正确的显示模式。如果设置成功，循环结束，否则显示菜单让用户选择显示模式，继续进行设置显示模式的尝试。</p>
<pre><code class="language-c">for (;;) {
      if (mode == ASK_VGA)
          mode = mode_menu();

      if (!set_mode(mode))
          break;

      printf("Undefined video mode number: %x\n", mode);
      mode = ASK_VGA;
  }
</code></pre>
<p>你可以在 <a href="https://github.com/0xAX/linux/blob/master/arch/x86/boot/video-mode.c#L147">video-mode.c</a> 中找到 <code>set_mode</code> 函数的定义。这个函数只接受一个参数，这个参数是对应的显示模式的数字表示（这个数字来自于显示模式选择菜单，或者从内核命令行参数获得）。</p>
<p><code>set_mode</code> 函数首先检查传入的 <code>mode</code> 参数，然后调用 <code>raw_set_mode</code> 函数。而后者将遍历内核知道的所有 <code>card_info</code> 信息，如果发现某张显卡支持传入的模式，这调用 <code>card_info</code> 结构中保存的 <code>set_mode</code> 函数地址进行显卡显示模式的设置。以 <code>video_vga</code> 这个 <code>card_info</code> 结构来说，保存在其中的 <code>set_mode</code> 函数就指向了 <code>vga_set_mode</code> 函数。下面的代码就是 <code>vga_set_mode</code> 函数的实现，这个函数根据输入的 vga 显示模式，调用不同的函数完成显示模式的设置：</p>
<pre><code class="language-C">static int vga_set_mode(struct mode_info *mode)
{
	vga_set_basic_mode();

	force_x = mode-&gt;x;
	force_y = mode-&gt;y;

	switch (mode-&gt;mode) {
	case VIDEO_80x25:
		break;
	case VIDEO_8POINT:
		vga_set_8font();
		break;
	case VIDEO_80x43:
		vga_set_80x43();
		break;
	case VIDEO_80x28:
		vga_set_14font();
		break;
	case VIDEO_80x30:
		vga_set_80x30();
		break;
	case VIDEO_80x34:
		vga_set_80x34();
		break;
	case VIDEO_80x60:
		vga_set_80x60();
		break;
	}
	return 0;
}
</code></pre>
<p>在上面的代码中，每个 <code>vga_set***</code> 函数只是简单调用 <code>0x10</code> BIOS 中断来进行显示模式的设置。</p>
<p>在显卡的显示模式被正确设置之后，这个最终的显示模式被写回 <code>boot_params.hdr.vid_mode</code>。</p>
<p>接下来 <code>set_video</code> 函数将调用 <code>vesa_store_edid</code> 函数， 这个函数只是简单的将 <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a> (<strong>E</strong>xtended <strong>D</strong>isplay <strong>I</strong>dentification <strong>D</strong>ata) 写入内存，以便于内核访问。最后， <code>set_video</code> 将调用 <code>do_restore</code> 函数将前面保存的当前屏幕信息还原到屏幕上。</p>
<p>到这里为止，显示模式的设置完成，接下来我们可以切换到保护模式了。</p>
<h2 id="在切换到保护模式之前的最后的准备工作">在切换到保护模式之前的最后的准备工作</h2>
<p>在进入保护模式之前的最后一个函数调用发生在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/main.c?v=3.18#L184">main.c</a> 中的 <code>go_to_protected_mode</code> 函数，就像这个函数的注释说的，这个函数将进行最后的准备工作然后进入保护模式，下面就让我们来具体看看最后的准备工作是什么，以及系统是如何切换到保护模式的。</p>
<p><code>go_to_protected_mode</code> 函数本身定义在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/pm.c?v=3.18#L104">arch/x86/boot/pm.c</a>。 这个函数调用了一些其他的函数进行最后的准备工作，下面就让我们来具体看看这些函数。</p>
<p><code>go_to_protected_mode</code> 函数首先调用的是 <code>realmode_switch_hook</code> 函数，后者如果发现 <code>realmode_switch</code> hook， 那么将调用它并禁止 <a href="http://en.wikipedia.org/wiki/Non-maskable_interrupt">NMI</a> 中断，反之将直接禁止 NMI 中断。只有当 bootloader 运行在宿主环境下（比如在 DOS 下运行 ）， hook 才会被使用。你可以在 <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">boot protocol</a> (see <strong>ADVANCED BOOT LOADER HOOKS</strong>) 中详细了解 hook 函数的信息。</p>
<pre><code class="language-c">/*
 * Invoke the realmode switch hook if present; otherwise
 * disable all interrupts.
 */
static void realmode_switch_hook(void)
{
	if (boot_params.hdr.realmode_swtch) {
		asm volatile("lcallw *%0"
			     : : "m" (boot_params.hdr.realmode_swtch)
			     : "eax", "ebx", "ecx", "edx");
	} else {
		asm volatile("cli");
		outb(0x80, 0x70); /* Disable NMI */
		io_delay();
	}
}
</code></pre>
<p><code>realmode_switch</code> 指向了一个16 位实模式代码地址（远跳转指针），这个16位代码将禁止 NMI 中断。所以在上述代码中，如果 <code>realmode_swtch</code> hook 存在，代码是用了 <code>lcallw</code> 指令进行远函数调用。在我的环境中，因为不存在这个 hook ，所以代码是直接进入 <code>else</code> 部分进行了 NMI 的禁止：</p>
<pre><code class="language-assembly">asm volatile("cli");
outb(0x80, 0x70);	/* Disable NMI */
io_delay();
</code></pre>
<p>上面的代码首先调用 <code>cli</code> 汇编指令清除了中断标志 <code>IF</code>，这条指令执行之后，外部中断就被禁止了，紧接着的下一行代码就禁止了 NMI 中断。</p>
<p>这里简单介绍一下中断。中断是由硬件或者软件产生的，当中断产生的时候， CPU 将得到通知。这个时候， CPU 将停止当前指令的执行，保存当前代码的环境，然后将控制权移交到中断处理程序。当中断处理程序完成之后，将恢复中断之前的运行环境，从而被中断的代码将继续运行。 NMI 中断是一类特殊的中断，往往预示着系统发生了不可恢复的错误，所以在正常运行的操作系统中，NMI 中断是不会被禁止的，但是在进入保护模式之前，由于特殊需求，代码禁止了这类中断。我们将在后续的章节中对中断做更多的介绍，这里就不展开了。</p>
<p>现在让我们回到上面的代码，在 NMI 中断被禁止之后（通过写 <code>0x80</code> 进 CMOS 地址寄存器 <code>0x70</code> ），函数接着调用了 <code>io_delay</code> 函数进行了短暂的延时以等待 I/O 操作完成。下面就是 <code>io_delay</code> 函数的实现：</p>
<pre><code class="language-C">static inline void io_delay(void)
{
	const u16 DELAY_PORT = 0x80;
	asm volatile("outb %%al,%0" : : "dN" (DELAY_PORT));
}
</code></pre>
<p>对 I/O 端口 <code>0x80</code> 写入任何的字节都将得到 1 ms 的延时。在上面的代码中，代码将 <code>al</code> 寄存器中的值写到了这个端口。在这个 <code>io_delay</code> 调用完成之后， <code>realmode_switch_hook</code> 函数就完成了所有工作，下面让我们进入下一个函数。</p>
<p>下一个函数调用是 <code>enable_a20</code>，这个函数使能 <a href="http://en.wikipedia.org/wiki/A20_line">A20 line</a>，你可以在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/a20.c?v=3.18">arch/x86/boot/a20.c</a> 找到这个函数的定义，这个函数会尝试使用不同的方式来使能 A20 地址线。首先这个函数将调用 <code>a20_test_short</code>（该函数将调用 <code>a20_test</code> 函数） 来检测 A20 地址线是否已经被激活了：</p>
<pre><code class="language-C">static int a20_test(int loops)
{
	int ok = 0;
	int saved, ctr;

	set_fs(0x0000);
	set_gs(0xffff);

	saved = ctr = rdfs32(A20_TEST_ADDR);

    while (loops--) {
		wrfs32(++ctr, A20_TEST_ADDR);
		io_delay();	/* Serialize and make delay constant */
		ok = rdgs32(A20_TEST_ADDR+0x10) ^ ctr;
		if (ok)
			break;
	}

	wrfs32(saved, A20_TEST_ADDR);
	return ok;
}
</code></pre>
<p>这个函数首先将 <code>0x0000</code> 放入 <code>FS</code> 寄存器，将 <code>0xffff</code> 放入 <code>GS</code> 寄存器。然后通过 <code>rdfs32</code> 函数调用，将 <code>A20_TEST_ADDR</code> 内存地址的内容放入 <code>saved</code> 和 <code>ctr</code> 变量。</p>
<p>接下来我们使用 <code>wrfs32</code> 函数将更新过的 <code>ctr</code> 的值写入 <code>fs:gs</code> ，接着延时 1ms， 然后从 <code>GS:A20_TEST_ADDR+0x10</code> 读取内容，如果该地址内容不为0，那么 A20 已经被激活。如果 A20 没有被激活，代码将尝试使用多种方法进行 A20 地址激活。其中的一种方法就是调用 BIOS <code>0X15</code> 中断激活 A20 地址线。</p>
<p>如果 <code>enabled_a20</code> 函数调用失败，显示一个错误消息并且调用 <code>die</code> 函数结束操作系统运行。<code>die</code> 函数定义在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/header.S?v=3.18">arch/x86/boot/header.S</a>:</p>
<pre><code class="language-assembly">die:
	hlt
	jmp	die
	.size	die, .-die
</code></pre>
<p>A20 地址线被激活之后，<code>reset_coprocessor</code> 函数被调用：</p>
<pre><code class="language-C">outb(0, 0xf0);
outb(0, 0xf1);
</code></pre>
<p>这个函数非常简单，通过将 <code>0</code> 写入 I/O 端口 <code>0xf0</code> 和 <code>0xf1</code> 以复位数字协处理器。</p>
<p>接下来 <code>mask_all_interrupts</code> 函数将被调用：</p>
<pre><code class="language-C">outb(0xff, 0xa1);       /* Mask all interrupts on the secondary PIC */
outb(0xfb, 0x21);       /* Mask all but cascade on the primary PIC */
</code></pre>
<p>这个函数调用激活主和从中断控制器 (Programmable Interrupt Controller)上的中断，唯一的例外是主中断控制器上的级联中断（所有从中断控制器的中断将通过这个级联中断报告给 CPU ）。</p>
<p>到这里位置，我们就完成了所有的准备工作，下面我们就将正式开始从实模式转换到保护模式。</p>
<h2 id="设置中断描述符表">设置中断描述符表</h2>
<p>现在内核将调用 <code>setup_idt</code> 方法来设置中断描述符表（ IDT ）：</p>
<pre><code class="language-C">static void setup_idt(void)
{
	static const struct gdt_ptr null_idt = {0, 0};
	asm volatile("lidtl %0" : : "m" (null_idt));
}
</code></pre>
<p>上面的代码使用 <code>lidtl</code> 指令将 <code>null_idt</code> 所指向的中断描述符表引入寄存器 IDT。由于 <code>null_idt</code> 没有设定中断描述符表的长度（长度为 0 ），所以这段指令执行之后，实际上没有任何中断调用被设置成功（所有中断调用都是空的），在后面的章节中我们将看到正确的设置。<code>null_idt</code> 是一个 <code>gdt_ptr</code> 结构的数据，这个结构的定义如下所示：</p>
<pre><code class="language-C">struct gdt_ptr {
	u16 len;
	u32 ptr;
} __attribute__((packed));
</code></pre>
<p>在上面的定义中，我们可以看到上面这个结构包含一个 16 bit 的长度字段，和一个 32 bit 的指针字段。<code>__attribute__((packed))</code> 意味着这个结构就只包含 48 bit 信息（没有字节对齐优化）。在下面一节中，我们将看到相同的结构将被导入 <code>GDTR</code> 寄存器（如果你还记得上一章的内容，应该记得 GDTR 寄存器是 48 bit 长度的）。</p>
<h2 id="设置全局描述符表">设置全局描述符表</h2>
<p>在设置完中断描述符表之后，我们将使用 <code>setup_gdt</code> 函数来设置全局描述符表（关于全局描述符表，大家可以参考<a href="linux-bootstrap-2.html#protected-mode">上一章</a> 的内容）。在 <code>setup_gdt</code> 函数中，使用 <code>boot_gdt</code> 数组定义了需要引入 GDTR 寄存器的段描述符信息：</p>
<pre><code class="language-C">   //GDT_ENTRY_BOOT_CS 定义在http://lxr.free-electrons.com/source/arch/x86/include/asm/segment.h#L19 = 2
	static const u64 boot_gdt[] __attribute__((aligned(16))) = {
		[GDT_ENTRY_BOOT_CS] = GDT_ENTRY(0xc09b, 0, 0xfffff),
		[GDT_ENTRY_BOOT_DS] = GDT_ENTRY(0xc093, 0, 0xfffff),
		[GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(0x0089, 4096, 103),
	};
</code></pre>
<p>在上面的 <code>boot_gdt</code> 数组中，我们定义了代码，数据和 TSS 段(Task State Segment, 任务状态段)的段描述符，因为我们并没有设置任何的中断调用（记得上面说的 <code>null_idt</code>吗？），所以 TSS 段并不会被使用到。TSS 段存在的唯一目的就是让 Intel 处理器能够正确进入保护模式。下面让我们详细了解一下 <code>boot_gdt</code> 这个数组，首先，这个数组被 <code>__attribute__((aligned(16)))</code> 修饰，这就意味着这个数组将以 16 字节为单位对齐。让我们通过下面的例子来了解一下什么叫 16 字节对齐：</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

struct aligned {
	int a;
}__attribute__((aligned(16)));

struct nonaligned {
	int b;
};

int main(void)
{
	struct aligned    a;
	struct nonaligned na;

	printf("Not aligned - %zu \n", sizeof(na));
	printf("Aligned - %zu \n", sizeof(a));

	return 0;
}
</code></pre>
<p>上面的代码可以看出，一旦指定了 16 字节对齐，即使结构中只有一个 <code>int</code> 类型的字段，整个结构也将占用 16 个字节：</p>
<pre><code>$ gcc test.c -o test &amp;&amp; test
Not aligned - 4
Aligned - 16
</code></pre>
<p>因为在 <code>boot_gdt</code> 的定义中， <code>GDT_ENTRY_BOOT_CS = 2</code>，所以在数组中有2个空项，第一项是一个空的描述符，第二项在代码中没有使用。在没有 <code>align 16</code> 之前，整个结构占用了（8*5=40）个字节，加了 <code>align 16</code> 之后，结构就占用了 48 字节 。</p>
<p>上面代码中出现的 <code>GDT_ENTRY</code> 是一个宏定义，这个宏接受 3 个参数（标志，基地址，段长度）来产生段描述符结构。让我们来具体分析上面数组中的代码段描述符（ <code>GDT_ENTRY_BOOT_CS</code> ）来看看这个宏是如何工作的，对于这个段，<code>GDT_ENTRY</code> 接受了下面 3 个参数：</p>
<ul>
<li>基地址 - 0</li>
<li>段长度 - 0xfffff</li>
<li>标志 - 0xc09b</li>
</ul>
<p>上面这些数字表明，这个段的基地址是 0， 段长度是 <code>0xfffff</code> （ 1 MB ），而标志字段展开之后是下面的二进制数据：</p>
<pre><code>1100 0000 1001 1011
</code></pre>
<p>这些二进制数据的具体含义如下:</p>
<ul>
<li>1 - (G) 这里为 1，表示段的实际长度是 <code>0xfffff * 4kb</code> = <code>4GB</code></li>
<li>1 - (D) 表示这个段是一个32位段</li>
<li>0 - (L) 这个代码段没有运行在 long mode</li>
<li>0 - (AVL) Linux 没有使用</li>
<li>0000 - 段长度的4个位</li>
<li>1 - (P) 段已经位于内存中</li>
<li>00 - (DPL) - 段优先级为0</li>
<li>1 - (S) 说明这个段是一个代码或者数据段</li>
<li>101 - 段类型为可执行/可读</li>
<li>1 - 段可访问</li>
</ul>
<p>关于段描述符的更详细的信息你可以从上一章中获得 <a href="linux-bootstrap-2.html">上一章</a>，你也可以阅读 <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel® 64 and IA-32 Architectures Software Developer's Manuals 3A</a>获取全部信息。</p>
<p>在定义了数组之后，代码将获取 GDT 的长度：</p>
<pre><code class="language-C">gdt.len = sizeof(boot_gdt)-1;
</code></pre>
<p>接下来是将 GDT 的地址放入 gdt.ptr 中：</p>
<pre><code class="language-C">gdt.ptr = (u32)&amp;boot_gdt + (ds() &lt;&lt; 4);
</code></pre>
<p>这里的地址计算很简单，因为我们还在实模式，所以就是 （ ds &lt;&lt; 4 + 数组起始地址）。</p>
<p>最后通过执行 <code>lgdtl</code> 指令将 GDT 信息写入 GDTR 寄存器：</p>
<pre><code class="language-C">asm volatile("lgdtl %0" : : "m" (gdt));
</code></pre>
<h2 id="切换进入保护模式">切换进入保护模式</h2>
<p><code>go_to_protected_mode</code> 函数在完成 IDT, GDT 初始化，并禁止了 NMI 中断之后，将调用 <code>protected_mode_jump</code> 函数完成从实模式到保护模式的跳转：</p>
<pre><code class="language-C">protected_mode_jump(boot_params.hdr.code32_start, (u32)&amp;boot_params + (ds() &lt;&lt; 4));
</code></pre>
<p><code>protected_mode_jump</code> 函数定义在 <a href="http://lxr.free-electrons.com/source/arch/x86/boot/pmjump.S?v=3.18#L26">arch/x86/boot/pmjump.S</a>，它接受下面2个参数:</p>
<ul>
<li>保护模式代码的入口</li>
<li><code>boot_params</code> 结构的地址</li>
</ul>
<p>第一个参数保存在 <code>eax</code> 寄存器，而第二个参数保存在 <code>edx</code> 寄存器。</p>
<p>代码首先在 <code>boot_params</code> 地址放入 <code>esi</code> 寄存器，然后将 <code>cs</code> 寄存器内容放入 <code>bx</code> 寄存器，接着执行 <code>bx &lt;&lt; 4 + 标号为2的代码的地址</code>，这样一来 <code>bx</code> 寄存器就包含了标号为2的代码的地址。接下来代码将把数据段索引放入 <code>cx</code> 寄存器，将 TSS 段索引放入 <code>di</code> 寄存器：</p>
<pre><code class="language-assembly">movw	$__BOOT_DS, %cx
movw	$__BOOT_TSS, %di
</code></pre>
<p>就像前面我们看到的 <code>GDT_ENTRY_BOOT_CS</code> 的值为2，每个段描述符都是 8 字节，所以 <code>cx</code> 寄存器的值将是 <code>2*8 = 16</code>，<code>di</code> 寄存器的值将是 <code>4*8 =32</code>。</p>
<p>接下来，我们通过设置 <code>CR0</code> 寄存器相应的位使 CPU 进入保护模式：</p>
<pre><code class="language-assembly">movl	%cr0, %edx
orb	$X86_CR0_PE, %dl
movl	%edx, %cr0
</code></pre>
<p>在进入保护模式之后，通过一个长跳转进入 32 位代码：</p>
<pre><code class="language-assembly">	.byte	0x66, 0xea
2:	.long	in_pm32
	.word	__BOOT_CS ;(GDT_ENTRY_BOOT_CS*8) = 16，段描述符表索引
</code></pre>
<p>这段代码中</p>
<ul>
<li><code>0x66</code> 操作符前缀允许我们混合执行 16 位和 32 位代码</li>
<li><code>0xea</code> - 跳转指令的操作符</li>
<li><code>in_pm32</code> 跳转地址偏移</li>
<li><code>__BOOT_CS</code> 代码段描述符索引</li>
</ul>
<p>在执行了这个跳转命令之后，我们就在保护模式下执行代码了：</p>
<pre><code class="language-assembly">.code32
.section ".text32","ax"
</code></pre>
<p>保护模式代码的第一步就是重置所有的段寄存器（除了 <code>CS</code> 寄存器）:</p>
<pre><code class="language-assembly">GLOBAL(in_pm32)
movl	%ecx, %ds
movl	%ecx, %es
movl	%ecx, %fs
movl	%ecx, %gs
movl	%ecx, %ss
</code></pre>
<p>还记得我们在实模式代码中将 <code>$__BOOT_DS</code> （数据段描述符索引）放入了 <code>cx</code> 寄存器，所以上面的代码设置所有段寄存器（除了 <code>CS</code> 寄存器）指向数据段。接下来代码将所有的通用寄存器清 0 ：</p>
<pre><code class="language-assembly">xorl	%ecx, %ecx
xorl	%edx, %edx
xorl	%ebx, %ebx
xorl	%ebp, %ebp
xorl	%edi, %edi
</code></pre>
<p>最后使用长跳转跳入正在的 32 位代码（通过参数传入的地址）</p>
<pre><code>jmpl	*%eax ;?jmpl cs:eax?
</code></pre>
<p>到这里，我们就进入了保护模式开始执行代码了，下一章我们将分析这段 32 位代码到底做了些什么。</p>
<h2 id="结论">结论</h2>
<p>这章到这里就结束了，在下一章中我们将具体介绍这章最后跳转到的 32 位代码，并且了解系统是如何进入 <a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a>的。</p>
<p>如果你有任何的问题或者建议，你可以留言，也可以直接发消息给我<a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>如果你发现文中描述有任何问题，请提交一个 PR 到 <a href="https://github.com/MintCN/linux-insides-zh">linux-insides-zh</a> 。</strong></p>
<h2 id="链接">链接</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Video_Graphics_Array">VGA</a></li>
<li><a href="http://en.wikipedia.org/wiki/VESA_BIOS_Extensions">VESA BIOS Extensions</a></li>
<li><a href="http://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-maskable interrupt</a></li>
<li><a href="http://en.wikipedia.org/wiki/A20_line">A20</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Designated-Inits.html">GCC designated inits</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html">GCC type attributes</a></li>
<li><a href="linux-bootstrap-2.html">Previous part</a></li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/195/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/195/index.html">Linux命令大全搜索工具</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/111.html">jaywcjlove</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">30页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/31/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/31/index.html">操作系统思考</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 74个">74</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/29/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/29/index.html">雪城大学计算机与网络安全讲义</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">10页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7个">7</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/101/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/chrome_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/101/index.html">Chromium中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="chrome">chrome</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">165页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/195/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/linux_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/195/index.html">Linux命令大全搜索工具</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/111.html">jaywcjlove</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="linux">linux</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">30页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2021年10月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 个"></span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/129/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/machine-learning_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/129/index.html">机器学习实战</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/69.html">gaolinjie</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="machine-learning">machine-learning</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">18页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 10个">10</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/114/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/114/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/README.html" title="简介" data-book-page-rel-url="README.html" data-book-page-id="8065">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/README.html" title="引导" data-book-page-rel-url="Booting/README.html" data-book-page-id="8066">引导</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-1.html" title="从引导加载程序内核" data-book-page-rel-url="Booting/linux-bootstrap-1.html" data-book-page-id="8067">从引导加载程序内核</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-2.html" title="在内核安装代码的第一步" data-book-page-rel-url="Booting/linux-bootstrap-2.html" data-book-page-id="8068">在内核安装代码的第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-3.html" title="视频模式初始化和转换到保护模式" data-book-page-rel-url="Booting/linux-bootstrap-3.html" data-book-page-id="8069">视频模式初始化和转换到保护模式</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-4.html" title="过渡到 64 位模式" data-book-page-rel-url="Booting/linux-bootstrap-4.html" data-book-page-id="8070">过渡到 64 位模式</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Booting/linux-bootstrap-5.html" title="内核解压缩" data-book-page-rel-url="Booting/linux-bootstrap-5.html" data-book-page-id="8071">内核解压缩</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/README.html" title="初始化" data-book-page-rel-url="Initialization/README.html" data-book-page-id="8072">初始化</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-1.html" title="内核解压之后的首要步骤" data-book-page-rel-url="Initialization/linux-initialization-1.html" data-book-page-id="8073">内核解压之后的首要步骤</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-2.html" title="早期的中断和异常控制" data-book-page-rel-url="Initialization/linux-initialization-2.html" data-book-page-id="8074">早期的中断和异常控制</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-3.html" title="在到达内核入口之前最后的准备" data-book-page-rel-url="Initialization/linux-initialization-3.html" data-book-page-id="8075">在到达内核入口之前最后的准备</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-4.html" title="内核入口 - start_kernel" data-book-page-rel-url="Initialization/linux-initialization-4.html" data-book-page-id="8076">内核入口 - start_kernel</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-5.html" title="体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-5.html" data-book-page-id="8077">体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-6.html" title="进一步初始化指定体系架构" data-book-page-rel-url="Initialization/linux-initialization-6.html" data-book-page-id="8078">进一步初始化指定体系架构</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-7.html" title="最后对指定体系架构初始化" data-book-page-rel-url="Initialization/linux-initialization-7.html" data-book-page-id="8079">最后对指定体系架构初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-8.html" title="调度器初始化" data-book-page-rel-url="Initialization/linux-initialization-8.html" data-book-page-id="8080">调度器初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-9.html" title="RCU 初始化" data-book-page-rel-url="Initialization/linux-initialization-9.html" data-book-page-id="8081">RCU 初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Initialization/linux-initialization-10.html" title="初始化结束" data-book-page-rel-url="Initialization/linux-initialization-10.html" data-book-page-id="8082">初始化结束</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/README.html" title="中断" data-book-page-rel-url="Interrupts/README.html" data-book-page-id="8083">中断</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-1.html" title="中断和中断处理 Part 1." data-book-page-rel-url="Interrupts/interrupts-1.html" data-book-page-id="8084">中断和中断处理 Part 1.</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-2.html" title="深入 Linux 内核中的中断" data-book-page-rel-url="Interrupts/interrupts-2.html" data-book-page-id="8085">深入 Linux 内核中的中断</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-3.html" title="初步中断处理" data-book-page-rel-url="Interrupts/interrupts-3.html" data-book-page-id="8086">初步中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-4.html" title="中断处理" data-book-page-rel-url="Interrupts/interrupts-4.html" data-book-page-id="8087">中断处理</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-5.html" title="异常处理的实现" data-book-page-rel-url="Interrupts/interrupts-5.html" data-book-page-id="8088">异常处理的实现</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-6.html" title="处理不可屏蔽中断" data-book-page-rel-url="Interrupts/interrupts-6.html" data-book-page-id="8089">处理不可屏蔽中断</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-7.html" title="深入外部硬件中断" data-book-page-rel-url="Interrupts/interrupts-7.html" data-book-page-id="8090">深入外部硬件中断</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-8.html" title="IRQs的非早期初始化" data-book-page-rel-url="Interrupts/interrupts-8.html" data-book-page-id="8091">IRQs的非早期初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-9.html" title="Softirq, Tasklets and Workqueues" data-book-page-rel-url="Interrupts/interrupts-9.html" data-book-page-id="8092">Softirq, Tasklets and Workqueues</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Interrupts/interrupts-10.html" title="最后一部分" data-book-page-rel-url="Interrupts/interrupts-10.html" data-book-page-id="8093">最后一部分</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/README.html" title="系统调用" data-book-page-rel-url="SysCall/README.html" data-book-page-id="8094">系统调用</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-1.html" title="系统调用概念简介" data-book-page-rel-url="SysCall/syscall-1.html" data-book-page-id="8095">系统调用概念简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-2.html" title="Linux 内核如何处理系统调用" data-book-page-rel-url="SysCall/syscall-2.html" data-book-page-id="8096">Linux 内核如何处理系统调用</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-3.html" title="vsyscall and vDSO" data-book-page-rel-url="SysCall/syscall-3.html" data-book-page-id="8097">vsyscall and vDSO</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-4.html" title="Linux 内核如何运行程序" data-book-page-rel-url="SysCall/syscall-4.html" data-book-page-id="8098">Linux 内核如何运行程序</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SysCall/syscall-5.html" title="open 系统调用的实现" data-book-page-rel-url="SysCall/syscall-5.html" data-book-page-id="8099">open 系统调用的实现</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Linux 资源限制" disabled data-book-page-rel-url="SysCall/syscall-6.html" data-book-page-id="8100">Linux 资源限制</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/README.html" title="定时器和时钟管理" data-book-page-rel-url="Timers/README.html" data-book-page-id="8101">定时器和时钟管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-1.html" title="简介" data-book-page-rel-url="Timers/timers-1.html" data-book-page-id="8102">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-2.html" title="时钟源框架简介" data-book-page-rel-url="Timers/timers-2.html" data-book-page-id="8103">时钟源框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-3.html" title="The tick broadcast framework and dyntick" data-book-page-rel-url="Timers/timers-3.html" data-book-page-id="8104">The tick broadcast framework and dyntick</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-4.html" title="定时器介绍" data-book-page-rel-url="Timers/timers-4.html" data-book-page-id="8105">定时器介绍</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-5.html" title="Clockevents 框架简介" data-book-page-rel-url="Timers/timers-5.html" data-book-page-id="8106">Clockevents 框架简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-6.html" title="x86 相关的时钟源" data-book-page-rel-url="Timers/timers-6.html" data-book-page-id="8107">x86 相关的时钟源</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Timers/timers-7.html" title="Linux 内核中与时钟相关的系统调用" data-book-page-rel-url="Timers/timers-7.html" data-book-page-id="8108">Linux 内核中与时钟相关的系统调用</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/README.html" title="同步原语" data-book-page-rel-url="SyncPrim/README.html" data-book-page-id="8109">同步原语</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-1.html" title="自旋锁简介" data-book-page-rel-url="SyncPrim/sync-1.html" data-book-page-id="8110">自旋锁简介</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-2.html" title="队列自旋锁" data-book-page-rel-url="SyncPrim/sync-2.html" data-book-page-id="8111">队列自旋锁</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-3.html" title="信号量" data-book-page-rel-url="SyncPrim/sync-3.html" data-book-page-id="8112">信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-4.html" title="互斥锁" data-book-page-rel-url="SyncPrim/sync-4.html" data-book-page-id="8113">互斥锁</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-5.html" title="读者/写者信号量" data-book-page-rel-url="SyncPrim/sync-5.html" data-book-page-id="8114">读者/写者信号量</a>
</li>
<li>
<a class="pjax" href="../../../book/114/SyncPrim/sync-6.html" title="顺序锁" data-book-page-rel-url="SyncPrim/sync-6.html" data-book-page-id="8115">顺序锁</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/MM/README.html" title="内存管理" data-book-page-rel-url="MM/README.html" data-book-page-id="8117">内存管理</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/MM/linux-mm-1.html" title="内存块" data-book-page-rel-url="MM/linux-mm-1.html" data-book-page-id="8118">内存块</a>
</li>
<li>
<a class="pjax" href="../../../book/114/MM/linux-mm-2.html" title="固定映射地址和 ioremap" data-book-page-rel-url="MM/linux-mm-2.html" data-book-page-id="8119">固定映射地址和 ioremap</a>
</li>
<li>
<a class="pjax" href="../../../book/114/MM/linux-mm-3.html" title="kmemcheck" data-book-page-rel-url="MM/linux-mm-3.html" data-book-page-id="8120">kmemcheck</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Cgroups/README.html" title="Cgroups" data-book-page-rel-url="Cgroups/README.html" data-book-page-id="8121">Cgroups</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Cgroups/cgroups1.html" title="控制组简介" data-book-page-rel-url="Cgroups/cgroups1.html" data-book-page-id="8122">控制组简介</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/README.html" title="概念" data-book-page-rel-url="Concepts/README.html" data-book-page-id="8123">概念</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Concepts/per-cpu.html" title="每个 CPU 的变量" data-book-page-rel-url="Concepts/per-cpu.html" data-book-page-id="8124">每个 CPU 的变量</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/cpumask.html" title="CPU 掩码" data-book-page-rel-url="Concepts/cpumask.html" data-book-page-id="8125">CPU 掩码</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/initcall.html" title="initcall 机制" data-book-page-rel-url="Concepts/initcall.html" data-book-page-id="8126">initcall 机制</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Concepts/notification_chains.html" title="Linux 内核的通知链" data-book-page-rel-url="Concepts/notification_chains.html" data-book-page-id="8127">Linux 内核的通知链</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/DataStructures/README.html" title="Linux 内核中的数据结构" data-book-page-rel-url="DataStructures/README.html" data-book-page-id="8128">Linux 内核中的数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/DataStructures/dlist.html" title="双向链表" data-book-page-rel-url="DataStructures/dlist.html" data-book-page-id="8129">双向链表</a>
</li>
<li>
<a class="pjax" href="../../../book/114/DataStructures/radix-tree.html" title="基数树" data-book-page-rel-url="DataStructures/radix-tree.html" data-book-page-id="8130">基数树</a>
</li>
<li>
<a class="pjax" href="../../../book/114/DataStructures/bitmap.html" title="位数组" data-book-page-rel-url="DataStructures/bitmap.html" data-book-page-id="8131">位数组</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Theory/README.html" title="理论" data-book-page-rel-url="Theory/README.html" data-book-page-id="8132">理论</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Theory/Paging.html" title="分页" data-book-page-rel-url="Theory/Paging.html" data-book-page-id="8133">分页</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Theory/ELF.html" title="Elf64 格式" data-book-page-rel-url="Theory/ELF.html" data-book-page-id="8134">Elf64 格式</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/README.html" title="杂项" data-book-page-rel-url="Misc/README.html" data-book-page-id="8135">杂项</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/Misc/how_kernel_compiled.html" title="内核编译方法" data-book-page-rel-url="Misc/how_kernel_compiled.html" data-book-page-id="8136">内核编译方法</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/linkers.html" title="链接器" data-book-page-rel-url="Misc/linkers.html" data-book-page-id="8137">链接器</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/contribute.html" title="Linux 内核开发" data-book-page-rel-url="Misc/contribute.html" data-book-page-id="8138">Linux 内核开发</a>
</li>
<li>
<a class="pjax" href="../../../book/114/Misc/program_startup.html" title="用户空间的程序启动过程" data-book-page-rel-url="Misc/program_startup.html" data-book-page-id="8139">用户空间的程序启动过程</a>
</li>
<li>
<a class="pjax" href="../../../book/114/" title="书写并提交你第一个内核补丁" data-book-page-rel-url="" data-book-page-id="8116">书写并提交你第一个内核补丁</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/KernelStructures/README.html" title="内核数据结构" data-book-page-rel-url="KernelStructures/README.html" data-book-page-id="8140">内核数据结构</a>
<ul>
<li>
<a class="pjax" href="../../../book/114/KernelStructures/idt.html" title="中断描述符表" data-book-page-rel-url="KernelStructures/idt.html" data-book-page-id="8141">中断描述符表</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/114/LINKS.html" title="有帮助的链接" data-book-page-rel-url="LINKS.html" data-book-page-id="8142">有帮助的链接</a>
</li>
<li>
<a class="pjax" href="../../../book/114/contributors.html" title="贡献者" data-book-page-rel-url="contributors.html" data-book-page-id="8143">贡献者</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =114;var bookPageId =8069;var bookPageRelUrl ='Booting/linux-bootstrap-3.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>