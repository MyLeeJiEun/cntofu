
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>1.6. 常见的并发模式-Go语言高级编程</title>
<meta content='1.6. 常见的并发模式,Go语言高级编程' name='keywords'>
<meta content='1.6. 常见的并发模式,Go语言高级编程' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/73/ch1-basic/ch1-05-mem.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">1.5. 面向并发的内..</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/73/ch1-basic/ch1-07-error-and-panic.html">
<span class="">1.7. 错误和异常</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/73/index.html">Go语言高级编程</a>
<a target="_blank" rel="nofollow" href="https://github.com/chai2010/advanced-go-programming-book" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="16-常见的并发模式">1.6. 常见的并发模式</h1>
<p>Go语言最吸引人的地方是它内建的并发支持。Go语言并发体系的理论是C.A.R Hoare在1978年提出的CSP（Communicating Sequential Process，通讯顺序进程）。CSP有着精确的数学模型，并实际应用在了Hoare实际参与设计的T9000通用计算机上。从NewSqueak、Alef、Limbo到现在的Go语言，对于对CSP有着20多年实战经验的Rob Pike来说，他更关注的是将CSP应用在通用编程语言上的潜力。作为Go并发编程核心的CSP理论的核心概念只有一个：同步通信。关于同步通信的话题我们在前面一节已经讲过，本节我们将简单介绍下Go语言中常见的并发模式。</p>
<p>首先要明确一个概念：并发不是并行。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的，只有在真正的多核CPU上才可能真正地同时运行。并行更关注的是程序的运行层面，并行一般是简单的大量重复，例如GPU中对图像处理都会有大量的并行运算。Go语言从一开始设计，就围绕着如何能在编程语言的层级，为更好的编写并发程序设计一个简洁安全高效的抽象模型，让程序员专注于分解问题和组合方案，而且不用被线程管理和信号互斥这些繁琐的操作分散精力。</p>
<p>在并发编程中，对共享资源的正确访问需要精确的控制，在目前的绝大多数语言中，都是通过加锁等线程同步方案来解决这一困难问题，而Go语言却另辟蹊径，它将共享的值通过信道传递(实际上多个独立执行的线程很少主动共享资源)。在任意给定的时刻，最好只有一个Goroutine能够拥有该资源。数据竞争从设计层面上就被杜绝了。为了提倡这种思考方式，Go语言将其并发编程哲学化为一句口号：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<p>这是更高层次的并发编程哲学(通过管道来传值是Go语言推荐的做法)。虽然像引用计数这类简章的并发问题通过原子操作或互斥锁就能很好地实现，但是通过信道来控制访问能够让你写出更简洁正确的程序。</p>
<h2 id="并发版本的hello-world">并发版本的Hello world</h2>
<p>我们先以在一个新的Goroutine中输出“Hello world”，<code>main</code>等待后台线程输出工作完成之后退出，这样一个简单的并发程序作为热身。</p>
<p>并发编程的核心概念是同步通信，但是同步的方式却有多种。我们先以大家熟悉的互斥量<code>sync.Mutex</code>来实现同步通信。根据文档，我们不能直接对一个未加锁状态的<code>sync.Mutex</code>进行解锁，这会导致运行时异常。下面这种方式并不能保证正常工作：</p>
<pre><code class="language-go">func main() {
    var mu sync.Mutex

    go func(){
        fmt.Println("你好, 世界")
        mu.Lock()
    }()

	mu.Unlock()
}
</code></pre>
<p>因为<code>mu.Lock()</code>和<code>mu.Unlock()</code>并不在同一个Goroutine中，所以也就不满足顺序一致性内存模型。同时它们也没有其它的同步事件可以参考，这两个事件不可排序也就是可以并发的。因为可能是并发的事件，所以<code>main</code>函数中的<code>mu.Unlock()</code>很有可能先发生，而这个时刻<code>mu</code>互斥对象还处于未加锁的状态，从而会导致运行时异常。</p>
<p>下面是修复后的代码：</p>
<pre><code class="language-go">func main() {
    var mu sync.Mutex

    mu.Lock()
    go func(){
        fmt.Println("你好, 世界")
        mu.Unlock()
    }()

    mu.Lock()
}
</code></pre>
<p>修复的方式是在<code>main</code>函数所在线程中执行两次<code>mu.Lock()</code>，当第二次加锁时会因为锁已经被占用（不是递归锁）而阻塞，<code>main</code>函数的阻塞状态驱动后台线程继续向前执行。当后台线程执行到<code>mu.Unlock()</code>时解锁，此时打印工作已经完成了，解锁会导致<code>main</code>函数中的第二个<code>mu.Lock()</code>阻塞状态取消，此时后台线程和主线程再没有其它的同步事件参考，它们退出的事件将是并发的：在<code>main</code>函数退出导致程序退出时，后台线程可能已经退出了，也可能没有退出。虽然无法确定两个线程退出的时间，但是打印工作是可以正确完成的。</p>
<p>使用<code>sync.Mutex</code>互斥锁同步是比较低级的做法。我们现在改用无缓存的管道来实现同步：</p>
<pre><code class="language-go">func main() {
    done := make(chan int)

    go func(){
        fmt.Println("你好, 世界")
        &lt;-done
    }()

    done &lt;- 1
}
</code></pre>
<p>根据Go语言内存模型规范，对于从无缓冲信道进行的接收，发生在对该信道进行的发送完成之前。因此，后台线程<code>&lt;-done</code>接收操作完成之后，<code>main</code>线程的<code>done &lt;- 1</code>发生操作才可能完成（从而退出main、退出程序），而此时打印工作已经完成了。</p>
<p>上面的代码虽然可以正确同步，但是对管道的缓存大小太敏感：如果管道有缓存的话，就无法保证能main退出之前后台线程能正常打印了。更好的做法是将管道的发送和接收方向调换一下，这样可以避免同步事件受管道缓存大小的影响：</p>
<pre><code class="language-go">func main() {
    done := make(chan int, 1) // 带缓存的管道

    go func(){
        fmt.Println("你好, 世界")
		done &lt;- 1
    }()

	&lt;-done
}
</code></pre>
<p>对于带缓冲的Channel，对于Channel的第K个接收完成操作发生在第K+C个发送操作完成之前，其中C是Channel的缓存大小。虽然管道是带缓存的，<code>main</code>线程接收完成是在后台线程发送开始但还未完成的时刻，此时打印工作也是已经完成的。</p>
<p>基于带缓存的管道，我们可以很容易将打印线程扩展到N个。下面的例子是开启10个后台线程分别打印：</p>
<pre><code class="language-go">func main() {
    done := make(chan int, 10) // 带 10 个缓存

	// 开N个后台打印线程
	for i := 0; i &lt; cap(done); i++ {
    	go func(){
        	fmt.Println("你好, 世界")
			done &lt;- 1
    	}()
	}

	// 等待N个后台线程完成
	for i := 0; i &lt; cap(done); i++ {
		&lt;-done
	}
}
</code></pre>
<p>对于这种要等待N个线程完成后再进行下一步的同步操作有一个简单的做法，就是使用<code>sync.WaitGroup</code>来等待一组事件：</p>
<pre><code class="language-go">func main() {
	var wg sync.WaitGroup

	// 开N个后台打印线程
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)

    	go func() {
        	fmt.Println("你好, 世界")
 			wg.Done()
     	}()
	}

	// 等待N个后台线程完成
	wg.Wait()
}
</code></pre>
<p>其中<code>wg.Add(1)</code>用于增加等待事件的个数，必须确保在后台线程启动之前执行（如果放到后台线程之中执行则不能保证被正常执行到）。当后台线程完成打印工作之后，调用<code>wg.Done()</code>表示完成一个事件。<code>main</code>函数的<code>wg.Wait()</code>是等待全部的事件完成。</p>
<h2 id="生产者消费者模型">生产者消费者模型</h2>
<p>并发编程中最常见的例子就是生产者/消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致CPU被剥夺的下岗问题。</p>
<p>Go语言实现生产者消费者并发很简单：</p>
<pre><code class="language-go">// 生产者: 生成 factor 整数倍的序列
func Producer(factor int, out chan&lt;- int) {
	for i := 0; ; i++ {
		out &lt;- i*factor
	}
}

// 消费者
func Consumer(in &lt;-chan int) {
	for v := range in {
		fmt.Println(v)
	}
}
func main() {
	ch := make(chan int, 64) // 成果队列

	go Producer(3, ch) // 生成 3 的倍数的序列
	go Producer(5, ch) // 生成 5 的倍数的序列
	go Consumer(ch)    // 消费 生成的队列

	// 运行一定时间后退出
	time.Sleep(5 * time.Second)
}
</code></pre>
<p>我们开启了2个<code>Producer</code>生产流水线，分别用于生成3和5的倍数的序列。然后开启1个<code>Consumer</code>消费者线程，打印获取的结果。我们通过在<code>main</code>函数休眠一定的时间来让生产者和消费者工作一定时间。正如前面一节说的，这种靠休眠方式是无法保证稳定的输出结果的。</p>
<p>我们可以让<code>main</code>函数保存阻塞状态不退出，只有当用户输入<code>Ctrl-C</code>时才真正退出程序：</p>
<pre><code class="language-go">func main() {
	ch := make(chan int, 64) // 成果队列

	go Producer(3, ch) // 生成 3 的倍数的序列
	go Producer(5, ch) // 生成 5 的倍数的序列
	go Consumer(ch)    // 消费 生成的队列

	// Ctrl+C 退出
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	fmt.Printf("quit (%v)\n", &lt;-sig)
}
</code></pre>
<p>我们这个例子中有2个生产者，并且2个生产者之间并无同步事件可参考，它们是并发的。因此，消费者输出的结果序列的顺序是不确定的，这并没有问题，生产者和消费者依然可以相互配合工作。</p>
<h2 id="发布订阅模型">发布订阅模型</h2>
<p>发布／订阅（publish-and-subscribe）模型通常被简写为pub／sub模型。在这个模型中，消息生产者成为发布者（publisher），而消息消费者则称对应订阅者（subscriber），生产者和消费者是M：N的关系。在传统生产者和消费者模型中，成果是将消息发送到一个队列中，而发布/订阅模型则是将消息发布给一个主题。</p>
<p>为此，我们构建了一个名为<code>pubsub</code>的发布订阅模型支持包：</p>
<pre><code class="language-go">// Package pubsub implements a simple multi-topic pub-sub library.
package pubsub

import (
	"sync"
	"time"
)

type (
	subscriber chan interface{}         // 订阅者为一个管道
	topicFunc  func(v interface{}) bool // 主题为一个过滤器
)

// 发布者对象
type Publisher struct {
	m           sync.RWMutex             // 读写锁
	buffer      int                      // 订阅队列的缓存大小
	timeout     time.Duration            // 发布超时时间
	subscribers map[subscriber]topicFunc // 订阅者信息
}

// 构建一个发布者对象, 可以设置发布超时时间和缓存队列的长度
func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher{
		buffer:      buffer,
		timeout:     publishTimeout,
		subscribers: make(map[subscriber]topicFunc),
	}
}

// 添加一个新的订阅者，订阅全部主题
func (p *Publisher) Subscribe() chan interface{} {
	return p.SubscribeTopic(nil)
}

// 添加一个新的订阅者，订阅过滤器筛选后的主题
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
	ch := make(chan interface{}, p.buffer)
	p.m.Lock()
	p.subscribers[ch] = topic
	p.m.Unlock()
	return ch
}

// 退出订阅
func (p *Publisher) Evict(sub chan interface{}) {
	p.m.Lock()
	defer p.m.Unlock()

	delete(p.subscribers, sub)
	close(sub)
}

// 发布一个主题
func (p *Publisher) Publish(v interface{}) {
	p.m.RLock()
	defer p.m.RUnlock()

	var wg sync.WaitGroup
	for sub, topic := range p.subscribers {
		wg.Add(1)
		go p.sendTopic(sub, topic, v, &amp;wg)
	}
	wg.Wait()
}

// 关闭发布者对象，同时关闭所有的订阅者管道。
func (p *Publisher) Close() {
	p.m.Lock()
	defer p.m.Unlock()

	for sub := range p.subscribers {
		delete(p.subscribers, sub)
		close(sub)
	}
}

// 发送主题，可以容忍一定的超时
func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {
	defer wg.Done()
	if topic != nil &amp;&amp; !topic(v) {
		return
	}

	select {
	case sub &lt;- v:
	case &lt;-time.After(p.timeout):
	}
}
</code></pre>
<p>下面的例子中，有两个订阅者分别订阅了全部主题和含有"golang"的主题：</p>
<pre><code class="language-go">import "path/to/pubsub"

func main() {
	p := pubsub.NewPublisher(100*time.Millisecond, 10)
	defer p.Close()

	all := p.Subscribe()
	golang := p.SubscribeTopic(func(v interface{}) bool {
		if s, ok := v.(string); ok {
			return strings.Contains(s, "golang")
		}
		return false
	})

	p.Publish("hello,  world!")
	p.Publish("hello, golang!")

	go func() {
		for  msg := range all {
			fmt.Println("all:", msg)
		}
	} ()

	go func() {
		for  msg := range golang {
			fmt.Println("golang:", msg)
		}
	} ()

	// 运行一定时间后退出
	time.Sleep(3 * time.Second)
}
</code></pre>
<p>在发布订阅模型中，每条消息都会传送给多个订阅者。发布者通常不会知道、也不关心哪一个订阅者正在接收主题消息。订阅者和发布者可以在运行时动态添加是一种松散的耦合关心，这使得系统的复杂性可以随时间的推移而增长。在现实生活中，不同城市的象天气预报之类的应用就可以应用这个并发模式。</p>
<h2 id="赢者为王">赢者为王</h2>
<p>采用并发编程的动机有很多：并发编程可以简化问题，比如一类问题对应一个处理线程会更简单；并发编程还可以提升性能，在一个多核CPU上开2个线程一般会比开1个线程快一些。其实对于提升性能而言，程序并不是简单地运行速度快就表示用户体验好的；很多时候程序能快速响应用户请求才是最重要的，当没有用户请求需要处理的时候才合适处理一些低优先级的后台任务。</p>
<p>假设我们想快速地检索“golang”相关的主题，我们可能会同时打开Bing、Google或百度等多个检索引擎。当某个检索最先返回结果后，就可以关闭其它检索页面了。因为受限于网络环境和检索引擎算法的影响，某些检索引擎可能很快返回检索结果，某些检索引擎也可能遇到等到他们公司倒闭也没有完成检索的情况。我们可以采用类似的策略来编写这个程序：</p>
<pre><code class="language-go">func main() {
	ch := make(chan string, 32)

	go func() {
		ch &lt;- searchByBing("golang")
	}
	go func() {
		ch &lt;- searchByGoogle("golang")
	}
	go func() {
		ch &lt;- searchByBaidu("golang")
	}

	fmt.Println(&lt;-ch)
}
</code></pre>
<p>首先，我们创建了一个带缓存的管道，管道的缓存数目要足够大，保证不会因为缓存的容量引起不必要的阻塞。然后我们开启了多个后台线程，分别向不同的检索引擎提交检索请求。当任意一个检索引擎最先有结果之后，都会马上将结果发到管道中（因为管道带了足够的缓存，这个过程不会阻塞）。但是最终我们只从管道取第一个结果，也就是最先返回的结果。</p>
<p>通过适当开启一些冗余的线程，尝试用不同途径去解决同样的问题，最终以赢者为王的方式提升了程序的相应性能。</p>
<h2 id="控制并发数">控制并发数</h2>
<p>很多用户在适应了Go语言强大的并发特性之后，都倾向于编写最大并发的程序，因为这样似乎可以提供最大的性能。在现实中我们行色匆匆，但有时却需要我们放慢脚步享受生活，并发的程序也是一样：有时候我们需要适当地控制并发的程度，因为这样不仅仅可给其它的应用/任务让出/预留一定的CPU资源，也可以适当降低功耗缓解电池的压力。</p>
<p>在Go语言自带的godoc程序实现中有一个<code>vfs</code>的包对应虚拟的文件系统，在<code>vfs</code>包下面有一个<code>gatefs</code>的子包，<code>gatefs</code>子包的目的就是为了控制访问该虚拟文件系统的最大并发数。<code>gatefs</code>包的应用很简单：</p>
<pre><code class="language-go">import (
	"golang.org/x/tools/godoc/vfs"
	"golang.org/x/tools/godoc/vfs/gatefs"
)

func main() {
	fs := gatefs.New(vfs.OS("../../../path"), make(chan bool, 8))
	// ...
}
</code></pre>
<p>其中<code>vfs.OS("../../../path")</code>基于本地文件系统构造一个虚拟的文件系统，然后<code>gatefs.New</code>基于现有的虚拟文件系统构造一个并发受控的虚拟文件系统。并发数控制的原理在前面一节已经讲过，就是通过带缓存管道的发送和接收规则来实现最大并发阻塞：</p>
<pre><code class="language-go">var limit = make(chan int, 3)

func main() {
    for _, w := range work {
        go func() {
            limit &lt;- 1
            w()
            &lt;-limit
        }()
    }
    select{}
}
</code></pre>
<p>不过<code>gatefs</code>对此做一个抽象类型<code>gate</code>，增加了<code>enter</code>和<code>leave</code>方法分别对应并发代码的进入和离开。当超出并发数目限制的时候，<code>enter</code>方法会阻塞直到并发数降下来为止。</p>
<pre><code class="language-go">type gate chan bool

func (g gate) enter() { g &lt;- true }
func (g gate) leave() { &lt;-g }
</code></pre>
<p><code>gatefs</code>包装的新的虚拟文件系统就是将需要控制并发的方法增加了<code>enter</code>和<code>leave</code>调用而已：</p>
<pre><code class="language-go">type gatefs struct {
	fs vfs.FileSystem
	gate
}

func (fs gatefs) Lstat(p string) (os.FileInfo, error) {
	fs.enter()
	defer fs.leave()
	return fs.fs.Lstat(p)
}
</code></pre>
<p>我们不仅可以控制最大的并发数目，而且可以通过带缓存Channel的使用量和最大容量比例来判断程序运行的并发率。当管道为空的时候可以认为是空闲状态，当管道满了时任务是繁忙状态，这对于后台一些低级任务的运行是有参考价值的。增加的方法如下：</p>
<pre><code class="language-go">func (g gate) Len() int { return len(g) }
func (g gate) Cap() int { return cap(g) }

func (g gate) Idle() bool { return len(g) == 0 }
func (g gate) Busy() bool { return len(g) == cap(g) }

func (g gate) Fraction() float64 {
	return float64(len(g)) / float64(cap(g))
}
</code></pre>
<p>然后我们可以在相对空闲的时候处理一些后台低优先级的任务，在并发相对繁忙或超出一定比例的时候提供预警：</p>
<pre><code class="language-go">func New(fs vfs.FileSystem, gate chan bool) *gatefs {
	p := &amp;gatefs{fs, gate}

	// 后台监控线程
	go func() {
		for {
			switch {
			case p.gate.Idle():
				// 处理后台任务
			case p.gate.Fraction() &gt;= 0.7:
				// 并发预警
			default:
				time.Sleep(time.Second)
			}
		}
	}()

	return p
}
</code></pre>
<p>这样我们通过后台线程就可以根据程序的状态动态调整自己的工作模式。</p>
<h2 id="素数筛">素数筛</h2>
<p>在“Hello world 的革命”一节中，我们为了演示Newsqueak的并发特性，文中给出了并发版本素数筛的实现。并发版本的素数筛是一个经典的并发例子，通过它我们可以更深刻地理解Go语言的并发特性。“素数筛”的原理如图：</p>
<p><a href="https://img.cntofu.com/book/advanced-go-programming-book/images/ch1-02-prime-sieve.png" data-uk-lightbox><img src="https://img.cntofu.com/book/advanced-go-programming-book/images/ch1-02-prime-sieve.png" alt=""></a></p>
<p>我们需要先生成最初的<code>2, 3, 4, ...</code>自然数序列（不包含开头的0、1）：</p>
<pre><code class="language-go">// 返回生成自然数序列的管道: 2, 3, 4, ...
func GenerateNatural() chan int {
	ch := make(chan int)
	go func() {
		for i := 2; ; i++ {
			ch &lt;- i
		}
	}()
	return ch
}
</code></pre>
<p><code>GenerateNatural</code>函数内部启动一个Goroutine生产序列，返回对应的管道。</p>
<p>然后是为每个素数构造一个筛子：将输入序列中是素数倍数的数提出，并返回新的序列，是一个新的管道。</p>
<pre><code class="language-go">// 管道过滤器: 删除能被素数整除的数
func PrimeFilter(in &lt;-chan int, prime int) chan int {
	out := make(chan int)
	go func() {
		for {
			if i := &lt;-in; i%prime != 0 {
				out &lt;- i
			}
		}
	}()
	return out
}
</code></pre>
<p><code>PrimeFilter</code>函数也是内部启动一个Goroutine生产序列，返回过滤后序列对应的管道。</p>
<p>现在我们可以在<code>main</code>函数中驱动这个并发的素数筛了：</p>
<pre><code class="language-go">func main() {
	ch := GenerateNatural() // 自然数序列: 2, 3, 4, ...
	for i := 0; i &lt; 100; i++ {
		prime := &lt;-ch // 新出现的素数
		fmt.Printf("%v: %v\n", i+1, prime)
		ch = PrimeFilter(ch, prime) // 基于新素数构造的过滤器
	}
}
</code></pre>
<p>我们先是调用<code>GenerateNatural()</code>生成最原始的从2开始的自然数序列。然后开始一个100次迭代的循环，希望生成100个素数。在每次循环迭代开始的时候，管道中的第一个数必定是素数，我们先读取并打印这个素数。然后基于管道中剩余的数列，并以当前取出的素数为筛子过滤后面的素数。不同的素数筛子对应的管道是串联在一起的。</p>
<p>素数筛展示了一种优雅的并发程序结构。但是因为每个并发体处理的任务粒度太细微，程序整体的性能并不理想。对于细力度的并发程序，CSP模型中固有的消息传递的代价太高了（多线程并发模型同样要面临线程启动的代价）。</p>
<h2 id="并发的安全退出">并发的安全退出</h2>
<p>有时候我们需要通知goroutine停止它正在干的事情，特别是当它工作在错误的方向上的时候。Go语言并没有提供在一个直接终止Goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。但是如果我们想要退出两个或者任意多个Goroutine怎么办呢？</p>
<p>Go语言中不同Goroutine之间主要依靠管道进行通信和同步。要同时处理多个管道的发送或接收操作，我们需要使用<code>select</code>关键字（这个关键字和网络编程中的<code>select</code>函数的行为类似）。当<code>select</code>有多个分支时，会随机选择一个可用的管道分支，如果没有可用的管道分支则选择<code>default</code>分支，否则会一直保存阻塞状态。</p>
<p>基于<code>select</code>实现的管道的超时判断：</p>
<pre><code class="language-go">    select {
    case v := &lt;-in:
        fmt.Println(v)
    case &lt;-time.After(time.Second):
        return // 超时
    }
</code></pre>
<p>通过<code>select</code>的<code>default</code>分支实现非阻塞的管道发送或接收操作：</p>
<pre><code class="language-go">    select {
    case v := &lt;-in:
        fmt.Println(v)
    default:
        // 没有数据
    }
</code></pre>
<p>通过<code>select</code>来阻止<code>main</code>函数退出：</p>
<pre><code class="language-go">func main() {
	// do some thins
	select{}
}
</code></pre>
<p>当有多个管道均可操作时，<code>select</code>会随机选择一个管道。基于该特性我们可以用<code>select</code>实现一个生成随机数列的程序：</p>
<pre><code class="language-go">func main() {
	ch := make(chan int)
	go func() {
		for {
			select {
			case ch &lt;- 0:
			case ch &lt;- 1:
			}
		}
	}()

	for v := range ch {
		fmt.Println(v)
	}
}
</code></pre>
<p>我们通过<code>select</code>和<code>default</code>分支可以很容易实现一个Goroutine的退出控制:</p>
<pre><code class="language-go">func worker(cannel chan bool) {
	for {
		select {
    	default:
			fmt.Println("hello")
        	// 正常工作
		case &lt;-cannel:
        	// 退出
		}
	}
}

func main() {
	cannel := make(chan bool)
	go worker(cannel)

	time.Sleep(time.Second)
	cannel &lt;- true
}
</code></pre>
<p>但是管道的发送操作和接收操作是一一对应的，如果要停止多个Goroutine那么可能需要创建同样数量的管道，这个代价太大了。其实我们可以通过<code>close</code>关闭一个管道来实现广播的效果，所有从关闭管道接收的操作均会收到一个零值和一个可选的失败标志。</p>
<pre><code class="language-go">func worker(cannel chan bool) {
	for {
		select {
    	default:
			fmt.Println("hello")
        	// 正常工作
		case &lt;-cannel:
        	// 退出
		}
	}
}

func main() {
	cancel := make(chan bool)

	for i := 0; i &lt; 10; i++ {
		go worker(cancel)
	}

	time.Sleep(time.Second)
	close(cancel)
}
</code></pre>
<p>我们通过<code>close</code>来关闭<code>cancel</code>管道向多个Goroutine广播退出的指令。不过这个程序依然不够稳健：当每个Goroutine收到退出指令退出时一般会进行一定的清理工作，但是退出的清理工作并不能保证被完成，因为<code>main</code>线程并没有等待各个工作Goroutine退出工作完成的机制。我们可以结合<code>sync.WaitGroup</code>来改进:</p>
<pre><code class="language-go">func worker(wg *sync.WaitGroup, cannel chan bool) {
	defer wg.Done()

	for {
		select {
    	default:
			fmt.Println("hello")
		case &lt;-cannel:
        	return
		}
	}
}

func main() {
	cancel := make(chan bool)

	var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go worker(&amp;wg, cancel)
	}

	time.Sleep(time.Second)
	close(cancel)
	wg.Wait()
}
</code></pre>
<p>现在每个工作者并发体的创建、运行、暂停和退出都是在<code>main</code>函数的安全控制之下了。</p>
<h2 id="消费海量的请求">消费海量的请求</h2>
<p>在前面的生产者、消费者并发模型中，只有当生产者和消费的速度近似相等时才会达到最佳的效果，同时通过引入带缓存的管道可以消除因临时效率波动产生的影响。但是当生产者和消费者的速度严重不匹配时，我们是无法通过带缓存的管道来提高性能的（缓存的管道只能延缓问题发生的时间，无法消除速度差异带来的问题）。当消费者无法及时消费生产者的输出时，时间积累会导致问题越来越严重。</p>
<p>对于生产者、消费者并发模型，我们当然可以通过降低生产者的产能来避免资源的浪费。但在很多场景中，生产者才是核心对象，它们生产出各种问题或任务单据，这时候产出的问题是必须要解决的、任务单据也是必须要完成的。在现实生活中，制造各种生活垃圾的海量人类其实就是垃圾生产者，而清理生活垃圾的少量的清洁工就是垃圾消费者。在网络服务中，提交POST数据的海量用户则变成了生产者，Web后台服务则对应POST数据的消费者。海量生产者的问题也就变成了：如何构造一个能够处理海量请求的Web服务（假设每分钟百万级请求）。</p>
<p>在Web服务中，用户提交的每个POST请求可以看作是一个Job任务，而服务器是通过后台的Worker工作者来消费这些Job任务。当面向海量的Job处理时，我们一般可以通过构造一个Worker工作者池来提高Job的处理效率；通过一个带缓存的Job管道来接收新的任务请求，避免任务请求功能无法响应；Job请求接收管道和Worker工作者池通过分发系统来衔接。</p>
<p>我们可以用管道来模拟工作者池：当需要处理一个任务时，先从工作者池取一个工作者，处理完任务之后将工作者返回给工作者池。<code>WorkerPool</code>对应工作者池，<code>Worker</code>对应工作者。</p>
<pre><code class="language-go">type WorkerPool struct {
	workers []*Worker
	pool    chan *Worker
}

// 构造工作者池
func NewWorkerPool(maxWorkers int) *WorkerPool {
	p := &amp;WorkerPool{
		workers: make([]*Worker, maxWorkers)
		pool:    make(chan *Worker, maxWorkers)
	}

	// 初始化工作者
	for i, _ := range p.workers {
		worker := NewWorker(0)
		p.workers[i] = worker
		p.pool &lt;- worker
	}
	return p
}

// 启动工作者
func (p *WorkerPool) Start() {
	for _, worker := range p.workers {
		worker.Start()
	}
}

// 停止工作者
func (p *WorkerPool) Stop() {
	for _, worker := range p.workers {
		worker.Stop()
	}
}

// 获取工作者(阻塞)
func (p *WorkerPool) Get() *Worker {
	return &lt;-p.pool
}

// 返回工作者
func (p *WorkerPool) Put(w *Worker)  {
	p.pool &lt;- w
}
</code></pre>
<p>工作者池通过一个带缓存的管道来提高工作者的管理。当所有工作者都在处理任务时，工作者的获取会阻塞自动有工作者可用为止。</p>
<p><code>Worker</code>对应工作者实现，具体任务由后台一个固定的Goroutine完成，和外界通过专有的管道通信（工作者的私有管道也可以选择带有一定的缓存）具体实现如下：</p>
<pre><code class="language-go">type Worker struct {
	job  chan interface{}
	quit chan bool
	wg   sync.WaitGroup
}

// 构造工作者
func NewWorker(maxJobs int) *Worker {
	return &amp;Worker{
		job:  make(chan interface{}, maxJobs),
		quit: make(chan bool),
	}
}

// 启动任务
func (w *Worker) Start() {
	p.wg.Add(1)

	go func() {
		defer p.wg.Done()

		for {
			// 接收任务
			// 此时工作中已经从工作者池中取出
			select {
			case job := &lt;-p.job:
				// 处理任务

			case &lt;-w.quit:
				return
			}
		}
	}()
}

// 关闭任务
func (p *Worker) Stop() {
	p.quit &lt;- true
	p.wg.Wait()
}

// 提交任务
func (p *Worker) AddJob(job interface{}) {
	p.job &lt;- job
}
</code></pre>
<p>任务的分发系统在<code>Service</code>对象中完成：</p>
<pre><code class="language-go">type Service struct {
	workers *WorkerPool
	jobs    chan interface{}
	maxJobs int
	wg      sync.WaitGroup
}

func NewService(maxWorkers, maxJobs int) *Service {
	return &amp;Service {
		workers: NewWorkerPool(maxWorkers),
		jobs:    make(chan interface{}, maxJobs),
	}
}

func (p *Service) Start() {
	p.jobs = make(chan interface{}, maxJobs)

	p.wg.Add(1)
	p.workers.Start()

	go func() {
		defer p.wg.Done()

		for job := range p.jobs:
			go func(job Job) {
				// 从工作者池取一个工作者
				worker := p.workers.Get()

				// 完成任务后返回给工作者池
				defer p.workers.Put(worker)

				// 提交任务处理(异步)
				worker.AddJob(job)
			}(job)
		}
	}()
}
func (p *Service) Stop() {
	p.workers.Stop()
	close(p.jobs)
	p.wg.Wait()
}

// 提交任务
// 任务管道带较大的缓存, 延缓阻塞的时间
func (p *Service) AddJob(job interface{}) {
	p.jobs &lt;- job
}
</code></pre>
<p>主程序可以是一个web服务器：</p>
<pre><code class="language-go">var (
	MaxWorker = os.Getenv("MAX_WORKERS")
	MaxQueue  = os.Getenv("MAX_QUEUE")
)

func main() {
	service := NewService(MaxWorker, MaxQueue)

	service.Start()
	defer service.Stop()

	// 处理海量的任务
	http.HandleFunc("../../../jobs", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != "POST" {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		// Job以JSON格式提交
		var jobs []Job
		err := json.NewDecoder(io.LimitReader(r.Body, MaxLength)).Decode(&amp;jobs)
		if err != nil {
			w.Header().Set("Content-Type", "application/json; charset=UTF-8")
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		// 处理任务
		for _, job := range jobs {
			service.AddJob(job)
		}

		// OK
		w.WriteHeader(http.StatusOK)
	})

	// 启动web服务
	log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>
<p>基于Go语言特有的管道和Goroutine特性，我们以非常简单的方式设计了一个针对海量请求的处理系统结构。在世纪的系统中，用户可以根据任务的具体类型和特性，将管道定义为具体类型以避免接口等动态特性导致的开销。</p>
<h2 id="更多">更多</h2>
<p>在Go1.7发布时，标准库增加了一个<code>context</code>包，用来简化对于处理单个请求的多个Goroutine之间与请求域的数据、超时和退出等操作，官方有博文对此做了专门介绍。我们可以用<code>context</code>包来重新实现前面的线程安全退出或超时的控制:</p>
<pre><code class="language-go">func worker(ctx context.Context, wg *sync.WaitGroup) error {
	defer wg.Done()

	for {
		select {
    	default:
			fmt.Println("hello")
		case &lt;-ctx.Done():
        	return ctx.Err()
		}
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)

	var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go worker(ctx, &amp;wg)
	}

	time.Sleep(time.Second)
	cancel()

	wg.Wait()
}
</code></pre>
<p>当并发体超时或<code>main</code>主动停止工作者Goroutine时，每个工作者都可以安全退出。</p>
<p>Go语言是带内存自动回收的特性，因此内存一般不会泄漏。在前面素数筛的例子中，<code>GenerateNatural</code>和<code>PrimeFilter</code>函数内部都启动了新的Goroutine，当<code>main</code>函数不再使用管道时后台Goroutine有泄漏的风险。我们可以通过<code>context</code>包来避免这个问题，下面是改进的素数筛实现：</p>
<pre><code class="language-go">// 返回生成自然数序列的管道: 2, 3, 4, ...
func GenerateNatural(ctx context.Context) chan int {
	ch := make(chan int)
	go func() {
		for i := 2; ; i++ {
			select {
			case &lt;- ctx.Done():
				return
			case ch &lt;- i:
			}
		}
	}()
	return ch
}

// 管道过滤器: 删除能被素数整除的数
func PrimeFilter(ctx context.Context, in &lt;-chan int, prime int) chan int {
	out := make(chan int)
	go func() {
		for {
			if i := &lt;-in; i%prime != 0 {
				select {
				case &lt;- ctx.Done():
					return
				case out &lt;- i:
				}
			}
		}
	}()
	return out
}

func main() {
	// 通过 Context 控制后台Goroutine状态
	ctx, cancel := context.WithCancel(context.Background())

	ch := GenerateNatural(ctx) // 自然数序列: 2, 3, 4, ...
	for i := 0; i &lt; 100; i++ {
		prime := &lt;-ch // 新出现的素数
		fmt.Printf("%v: %v\n", i+1, prime)
		ch = PrimeFilter(ctx, ch, prime) // 基于新素数构造的过滤器
	}
	
	cancel()
}
</code></pre>
<p>当main函数完成工作前，通过调用<code>cancel()</code>来通知后台Goroutine退出，这样就避免了Goroutine的泄漏。</p>
<p>并发是一个非常大的主题，我们这里只是展示几个非常基础的并发编程的例子。官方文档也有很多关于并发编程的讨论，国内也有专门讨论Go语言并发编程的书籍。读者可以根据自己的需求查阅相关的文献。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/3/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/3/index.html">深入解析Go</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/3.html">tiancaiamao</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">41页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1018个">1018</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/15/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/15/index.html">Go语言标准库</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/11.html">polaris1119</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">49页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 3356个">3356</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/164/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/164/index.html">Go 开发者路线图</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/93.html">Alikhll</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 4583个">4583</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/149/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/git_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/149/index.html">Git Cheat Sheet 中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/81.html">flyhigher139</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="git">git</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 642个">642</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/6/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/spring_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/6/index.html">Spring Framework 4.x 参考文档中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/6.html">waylau</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="spring">spring</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">47页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1192个">1192</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/146/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/146/index.html">http2讲解</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/78.html">bagder</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1463个">1463</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/73/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/73/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/readme.html" title="第一章 语言基础" data-book-page-rel-url="ch1-basic/readme.html" data-book-page-id="5589">第一章 语言基础</a>
<ul>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-01-genesis.html" title="1.1. Go语言创世纪" data-book-page-rel-url="ch1-basic/ch1-01-genesis.html" data-book-page-id="5590">1.1. Go语言创世纪</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-02-hello-revolution.html" title="1.2. Hello, World 的革命" data-book-page-rel-url="ch1-basic/ch1-02-hello-revolution.html" data-book-page-id="5591">1.2. Hello, World 的革命</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-03-array-string-and-slice.html" title="1.3. 数组、字符串和切片" data-book-page-rel-url="ch1-basic/ch1-03-array-string-and-slice.html" data-book-page-id="5592">1.3. 数组、字符串和切片</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-04-func-method-interface.html" title="1.4. 函数、方法和接口" data-book-page-rel-url="ch1-basic/ch1-04-func-method-interface.html" data-book-page-id="5593">1.4. 函数、方法和接口</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-05-mem.html" title="1.5. 面向并发的内存模型" data-book-page-rel-url="ch1-basic/ch1-05-mem.html" data-book-page-id="5594">1.5. 面向并发的内存模型</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-06-goroutine.html" title="1.6. 常见的并发模式" data-book-page-rel-url="ch1-basic/ch1-06-goroutine.html" data-book-page-id="5595">1.6. 常见的并发模式</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-07-error-and-panic.html" title="1.7. 错误和异常" data-book-page-rel-url="ch1-basic/ch1-07-error-and-panic.html" data-book-page-id="5596">1.7. 错误和异常</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch1-basic/ch1-08-ide.html" title="1.8. 配置开发环境" data-book-page-rel-url="ch1-basic/ch1-08-ide.html" data-book-page-id="5597">1.8. 配置开发环境</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/readme.html" title="第二章 CGO编程" data-book-page-rel-url="ch2-cgo/readme.html" data-book-page-id="5598">第二章 CGO编程</a>
<ul>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-01-hello-cgo.html" title="2.1. 快速入门" data-book-page-rel-url="ch2-cgo/ch2-01-hello-cgo.html" data-book-page-id="5599">2.1. 快速入门</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-02-basic.html" title="2.2. CGO基础" data-book-page-rel-url="ch2-cgo/ch2-02-basic.html" data-book-page-id="5600">2.2. CGO基础</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-03-cgo-types.html" title="2.3. 类型转换" data-book-page-rel-url="ch2-cgo/ch2-03-cgo-types.html" data-book-page-id="5601">2.3. 类型转换</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-04-func.html" title="2.4. 函数调用" data-book-page-rel-url="ch2-cgo/ch2-04-func.html" data-book-page-id="5602">2.4. 函数调用</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-05-internal.html" title="2.5. 内部机制" data-book-page-rel-url="ch2-cgo/ch2-05-internal.html" data-book-page-id="5603">2.5. 内部机制</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-06-qsort.html" title="2.6. 实战: 封装qsort" data-book-page-rel-url="ch2-cgo/ch2-06-qsort.html" data-book-page-id="5604">2.6. 实战: 封装qsort</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-07-memory.html" title="2.7. CGO内存模型" data-book-page-rel-url="ch2-cgo/ch2-07-memory.html" data-book-page-id="5605">2.7. CGO内存模型</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-08-class.html" title="2.8. C++类包装" data-book-page-rel-url="ch2-cgo/ch2-08-class.html" data-book-page-id="5606">2.8. C++类包装</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-09-static-shared-lib.html" title="2.9. 静态库和动态库" data-book-page-rel-url="ch2-cgo/ch2-09-static-shared-lib.html" data-book-page-id="5607">2.9. 静态库和动态库</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-10-py-module.html" title="2.10. Go实现Python模块" data-book-page-rel-url="ch2-cgo/ch2-10-py-module.html" data-book-page-id="5608">2.10. Go实现Python模块</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-11-link.html" title="2.11. 编译和链接参数" data-book-page-rel-url="ch2-cgo/ch2-11-link.html" data-book-page-id="5609">2.11. 编译和链接参数</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch2-cgo/ch2-12-faq.html" title="2.12. 补充说明" data-book-page-rel-url="ch2-cgo/ch2-12-faq.html" data-book-page-id="5610">2.12. 补充说明</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/readme.html" title="第三章 汇编语言" data-book-page-rel-url="ch3-asm/readme.html" data-book-page-id="5611">第三章 汇编语言</a>
<ul>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-01-basic.html" title="3.1. 快速入门" data-book-page-rel-url="ch3-asm/ch3-01-basic.html" data-book-page-id="5612">3.1. 快速入门</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-02-arch.html" title="3.2. 计算机结构" data-book-page-rel-url="ch3-asm/ch3-02-arch.html" data-book-page-id="5613">3.2. 计算机结构</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-03-const-and-var.html" title="3.3. 常量和全局变量" data-book-page-rel-url="ch3-asm/ch3-03-const-and-var.html" data-book-page-id="5614">3.3. 常量和全局变量</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-04-func.html" title="3.4. 函数" data-book-page-rel-url="ch3-asm/ch3-04-func.html" data-book-page-id="5615">3.4. 函数</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-05-control-flow.html" title="3.5. 控制流" data-book-page-rel-url="ch3-asm/ch3-05-control-flow.html" data-book-page-id="5616">3.5. 控制流</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-06-func-again.html" title="3.6. 再论函数" data-book-page-rel-url="ch3-asm/ch3-06-func-again.html" data-book-page-id="5617">3.6. 再论函数</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-07-core-type.html" title="3.7. Go核心对象结构(TODO)" data-book-page-rel-url="ch3-asm/ch3-07-core-type.html" data-book-page-id="5618">3.7. Go核心对象结构(TODO)</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-08-runtime-func.html" title="3.8. runtime内置函数(TODO)" data-book-page-rel-url="ch3-asm/ch3-08-runtime-func.html" data-book-page-id="5619">3.8. runtime内置函数(TODO)</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch3-asm/ch3-09-faq.html" title="3.9. 补充说明(TODO)" data-book-page-rel-url="ch3-asm/ch3-09-faq.html" data-book-page-id="5620">3.9. 补充说明(TODO)</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/73/ch4-rpc/readme.html" title="第四章 RPC和Protobuf(TODO)" data-book-page-rel-url="ch4-rpc/readme.html" data-book-page-id="5621">第四章 RPC和Protobuf(TODO)</a>
<ul>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.1. RPC入门(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-01-rpc-intro.html" data-book-page-id="5622">4.1. RPC入门(TODO)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.2. Protobuf简介(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-02-pb-intro.html" data-book-page-id="5623">4.2. Protobuf简介(TODO)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.3. protorpc(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-03-protorpc.html" data-book-page-id="5624">4.3. protorpc(TODO)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.4. grpc(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-04-grpc.html" data-book-page-id="5625">4.4. grpc(TODO)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.5. 反向rpc(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-05-reverse-rpc.html" data-book-page-id="5626">4.5. 反向rpc(TODO)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.6. Protobuf扩展(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-06-pb-option.html" data-book-page-id="5627">4.6. Protobuf扩展(TODO)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.7. 基于pb的rpc定制(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-07-pb-rpc.html" data-book-page-id="5628">4.7. 基于pb的rpc定制(TODO)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.8. 补充说明(TODO)" disabled data-book-page-rel-url="ch4-rpc/ch4-08-faq.html" data-book-page-id="5629">4.8. 补充说明(TODO)</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/73/ch5-wtf/readme.html" title="第五章 这是一个坑(TODO)" data-book-page-rel-url="ch5-wtf/readme.html" data-book-page-id="5630">第五章 这是一个坑(TODO)</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch6-web/readme.html" title="第六章 Go和Web" data-book-page-rel-url="ch6-web/readme.html" data-book-page-id="5631">第六章 Go和Web</a>
<ul>
<li>
<a class="pjax" href="../../../book/73/ch6-web/ch6-01-introduction.html" title="6.1. Web开发简介" data-book-page-rel-url="ch6-web/ch6-01-introduction.html" data-book-page-id="5632">6.1. Web开发简介</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch6-web/ch6-02-router.html" title="6.2. Router请求路由" data-book-page-rel-url="ch6-web/ch6-02-router.html" data-book-page-id="5633">6.2. Router请求路由</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch6-web/ch6-03-middleware.html" title="6.3. Middleware中间件" data-book-page-rel-url="ch6-web/ch6-03-middleware.html" data-book-page-id="5634">6.3. Middleware中间件</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch6-web/ch6-04-validator.html" title="6.4. Validator请求校验" data-book-page-rel-url="ch6-web/ch6-04-validator.html" data-book-page-id="5635">6.4. Validator请求校验</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch6-web/ch6-05-database.html" title="6.5. Database和数据库打交道" data-book-page-rel-url="ch6-web/ch6-05-database.html" data-book-page-id="5636">6.5. Database和数据库打交道</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch6-web/ch6-08-layout-of-web-project.html" title="6.8. Layout大型web项目分层" data-book-page-rel-url="ch6-web/ch6-08-layout-of-web-project.html" data-book-page-id="5637">6.8. Layout大型web项目分层</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch6-web/ch6-12-load-balance.html" title="6.12. Load-balance负载均衡" data-book-page-rel-url="ch6-web/ch6-12-load-balance.html" data-book-page-id="5638">6.12. Load-balance负载均衡</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/73/ch7-ast/readme.html" title="第七章 Go和ast" data-book-page-rel-url="ch7-ast/readme.html" data-book-page-id="5639">第七章 Go和ast</a>
</li>
<li>
<a class="pjax" href="../../../book/73/ch8-tools/readme.html" title="第八章 Go和那些生产力工具" data-book-page-rel-url="ch8-tools/readme.html" data-book-page-id="5640">第八章 Go和那些生产力工具</a>
</li>
<li>
<a class="pjax" href="../../../book/73/appendix/readme.html" title="附录" data-book-page-rel-url="appendix/readme.html" data-book-page-id="5641">附录</a>
<ul>
<li>
<a class="pjax" href="../../../book/73/appendix/appendix-a-trap.html" title="附录A: Go语言常见坑" data-book-page-rel-url="appendix/appendix-a-trap.html" data-book-page-id="5642">附录A: Go语言常见坑</a>
</li>
<li>
<a class="pjax" href="../../../book/73/appendix/appendix-b-ref.html" title="附录B: 参考资料" data-book-page-rel-url="appendix/appendix-b-ref.html" data-book-page-id="5643">附录B: 参考资料</a>
</li>
<li>
<a class="pjax" href="../../../book/73/appendix/appendix-c-author.html" title="附录C: 作者简介" data-book-page-rel-url="appendix/appendix-c-author.html" data-book-page-id="5644">附录C: 作者简介</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =73;var bookPageId =5595;var bookPageRelUrl ='ch1-basic/ch1-06-goroutine.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>