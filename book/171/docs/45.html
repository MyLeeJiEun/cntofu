
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>37.异步编程的 Promise-[译] 写给不耐烦程序员的 JavaScript</title>
<meta content='37.异步编程的 Promise,[译] 写给不耐烦程序员的 JavaScript' name='keywords'>
<meta content='37.异步编程的 Promise,[译] 写给不耐烦程序员的 JavaScript' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/171/docs/44.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">36. JavaScr..</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/171/docs/46.html">
<span class="">38.异步函数</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/171/index.html">[译] 写给不耐烦程序员的 JavaScript</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/impatient-js-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h2 id="37异步编程的-promise">37.异步编程的 Promise</h2>
<blockquote>
<p>原文： <a href="http://exploringjs.com/impatient-js/ch_promises.html">http://exploringjs.com/impatient-js/ch_promises.html</a></p>
<p>译者：<a href="https://github.com/iChrisJ">iChrisJ</a></p>
</blockquote>
<p>在本章中，我们将探索 Promise，另一种交付异步结果的模式。</p>
<p>本章建立在<a href="ch_async-js.html">前一章</a>的基础上，以JavaScript异步编程为背景。</p>
<h3 id="371-使用-promise-的基础知识">37.1. 使用 Promise 的基础知识</h3>
<p>Promise 是一种交付异步结果的模式。</p>
<h4 id="3711-使用基于-promise-的函数">37.1.1. 使用基于 Promise 的函数</h4>
<p>以下代码是使用基于 Promise 的函数<code>addAsync()</code>的示例（其实现将很快会被展示）：</p>
<pre><code class="language-JavaScript">addAsync(3, 4)
  .then(result =&gt; { // success
    assert.equal(result, 7);
  })
  .catch(error =&gt; { // failure
    assert.fail(error);
  });
</code></pre>
<p>Promise 结合了<a href="ch_async-js.html#callback-pattern">回调模式</a>和<a href="ch_async-js.html#event-pattern">事件模式</a>的各个方面：</p>
<ul>
<li> <p>与回调模式一样，Promise 专注于提供一次性结果。</p> </li>
<li> <p>与某些事件模式类似，一个基于 Promise 的函数通过返回一个对象（ <em>Promise</em> ）来传递其结果。使用该对象，你可以注册处理结果（<code>.then()</code>）和错误（<code>.catch()</code>）的回调。</p> </li>
<li> <p>Promise 的一个独特之处在于你可以串联<code>.then()</code>和<code>.catch()</code>，因为它们都返回 Promise。这有助于顺序调用多个异步函数。我们稍后将探讨其详情。</p> </li>
</ul>
<h4 id="3712-什么是-promise">37.1.2. 什么是 Promise？</h4>
<p>那么什么是 Promise？有两种方式来看待它：</p>
<ul>
<li>一方面，它是最终要被交付结果的一个占位符或容器。</li>
<li>另一方面，它是一个可以注册监听器的对象。</li>
</ul>
<h4 id="3713-实现基于-promise-的函数">37.1.3. 实现基于 Promise 的函数</h4>
<p>这是你如何实现一个基于 Promise 的关于两个数字<code>x</code>和<code>y</code>相加的函数：</p>
<pre><code class="language-JavaScript">function addAsync(x, y) {
  return new Promise(
    (resolve, reject) =&gt; { // (A)
      if (x === undefined || y === undefined) {
        reject(new Error('Must provide two parameters'));
      } else {
        resolve(x + y);
      }
    });
}
</code></pre>
<p>使用这种返回 Promise 的方式，<code>addAsync()</code>立即调用<code>Promise</code>构造函数。该函数的实际实现存在于传递给该构造函数的回调中（行 A）。该回调被提供了两个方法：</p>
<ul>
<li><code>resolve</code>用于传递结果（如果成功）。</li>
<li><code>reject</code>用于传递错误（如果失败）。</li>
</ul>
<h4 id="3714-promise-的状态">37.1.4. Promise 的状态</h4>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/ed5229efe27af8abed3d803bf84899d5.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/ed5229efe27af8abed3d803bf84899d5.svg" alt="Figure 21: A Promise can be in either one of three states: pending, fulfilled, or rejected. If a Promise is in a final (non-pending) state, it is called settled."></a></p>
<p>图 21: 一个 Promise 可以处于三种状态中的任何一种: pending（待定）, fulfilled(已履行), 或 rejected（被拒绝）. 如果一个 Promise 处于最终 (non-pending 非待定) 状态, 则称为 <em>settled（已结算）</em> .</p>
<p>图 <a href="#fig:promise_states_simple">21</a> 描述了 Promise 可以进入的三种状态. Promise 专注于一次性结果并保护您免受 <em>竞态条件</em>（过早注册或太晚注册）：</p>
<ul>
<li>如果您过早注册<code>.then()</code>回调或<code>.catch()</code>回调，则会在 Promise 结算后被通知。</li>
<li>一旦一个 Promise 被结算了，其结算值（结果或错误）会被缓存。因此，如果在结算后调用<code>.then()</code>或<code>.catch()</code>，它们将收到被缓存的值。</li>
</ul>
<p>此外，一旦 Promise 得到结算，其状态和结算值就不能再改变了。这有助于使代码变得可预测，并加强了 Promise 的一次性特性。</p>
<p>接下来，我们将看到更多创建 Promise 的方法。</p>
<h4 id="3715-promiseresolve创建一个被给定值履行的-promise">37.1.5. <code>Promise.resolve()</code>：创建一个被给定值履行的 Promise</h4>
<p><code>Promise.resolve(x)</code>创建一个使用值<code>x</code>实现的 Promise：</p>
<pre><code class="language-JavaScript">Promise.resolve(123)
.then(x =&gt; {
  assert.equal(x, 123);
});
</code></pre>
<p>如果参数已经是一个 Promise，则返回是不变：</p>
<pre><code class="language-JavaScript">const abcPromise = Promise.resolve('abc');
assert.equal(
  Promise.resolve(abcPromise),
  abcPromise);
</code></pre>
<p>因此，给定任意值<code>x</code>，您可以使用<code>Promise.resolve(x)</code>确保您拥有一个 Promise。</p>
<p>请注意，函数名称是<code>resolve</code>，而不是<code>fulfill</code>，因为如果参数是一个被拒绝的 Promise，<code>.resolve()</code>会返回被拒绝的 Promise。</p>
<h4 id="3716-promisereject创建一个被给定值拒绝的-promise">37.1.6. <code>Promise.reject()</code>：创建一个被给定值拒绝的 Promise</h4>
<p><code>Promise.reject(err)</code>创建一个使用值<code>err</code>实现的 Promise：</p>
<pre><code class="language-JavaScript">const myError = new Error('My error!');
Promise.reject(myError)
.catch(err =&gt; {
  assert.equal(err, myError);
});
</code></pre>
<h4 id="3717-在then回调中返回或抛出">37.1.7. 在<code>.then()</code>回调中返回或抛出</h4>
<p><code>.then()</code>处理 Promise 的履行。它返回一个新鲜的 Promise。这个 Promise 是如何达成的取决于回调中发生了什么。我们来看看三种常见情况。</p>
<h5 id="37171-返回一个非-promise-值">37.1.7.1. 返回一个非 Promise 值</h5>
<p>首先，回调可以返回一个非 Promise 值（行 A）。因此，<code>.then()</code>返回的 Promise 满足该值（如 B 行所示）：</p>
<pre><code class="language-JavaScript">Promise.resolve('abc')
.then(str =&gt; {
  return str + str; // (A)
})
.then(str2 =&gt; {
  assert.equal(str2, 'abcabc'); // (B)
});
</code></pre>
<h5 id="37172-返回一个-promise">37.1.7.2. 返回一个 Promise</h5>
<p>其次，回调可以返回一个 Promise <code>p</code>（行 A）。因此，<code>p</code>“成为”<code>.then()</code>返回的内容（<code>.then()</code>已经返回的 Promise 实际上被<code>p</code>替换）。</p>
<pre><code class="language-JavaScript">Promise.resolve('abc')
.then(str =&gt; {
  return Promise.resolve(123); // (A)
})
.then(num =&gt; {
  assert.equal(num, 123);
});
</code></pre>
<h5 id="37173-抛出异常">37.1.7.3. 抛出异常</h5>
<p>第三，回调可以抛出异常。因此，<code>.then()</code>返回的 Promise 被该异常拒绝。也就是说，同步错误被转换为异步错误。</p>
<pre><code class="language-JavaScript">const myError = new Error('My error!');
Promise.resolve('abc')
.then(str =&gt; {
  throw myError;
})
.catch(err =&gt; {
  assert.equal(err, myError);
});
</code></pre>
<h4 id="3718-catch及其回调">37.1.8. <code>.catch()</code>及其回调</h4>
<p><code>.then()</code>和<code>.catch()</code>之间的唯一区别是后者是由拒绝而不是履行触发的。但是，这两种方法都以相同的方式将其回调的操作转换为 Promise。例如，在以下代码中，行 A 中<code>.catch()</code>回调返回的值将成为履行值：</p>
<pre><code class="language-JavaScript">const err = new Error();

Promise.reject(err)
.catch(e =&gt; {
  assert.equal(e, err);
  // Something went wrong, use a default value
  return 'default value'; // (A)
})
.then(str =&gt; {
  assert.equal(str, 'default value');
});
</code></pre>
<h4 id="3719-串联方法调用">37.1.9. 串联方法调用</h4>
<p>由于<code>.then()</code>和<code>.catch()</code>总是返回 Promise，您可以创建任意长度的方法调用链：</p>
<pre><code class="language-JavaScript">function myAsyncFunc() {
  return asyncFunc1()
  .then(result1 =&gt; {
    // ···
    return asyncFunc2(); // a Promise
  })
  .then(result2 =&gt; {
    // ···
    return result2 || '(Empty)'; // not a Promise
  })
  .then(result3 =&gt; {
    // ···
    return asyncFunc4(); // a Promise
  });
}
</code></pre>
<p>在某种程度上，<code>.then()</code>是同步分号的异步版本：</p>
<ul>
<li><code>.then()</code>是按顺序执行两个异步操作。</li>
<li>分号是按顺序执行两个同步操作。</li>
</ul>
<p>您还可以将<code>.catch()</code>添加到混合的方法调用链中，并让它同时处理多个错误源：</p>
<pre><code class="language-JavaScript">asyncFunc1()
.then(result1 =&gt; {
  // ···
  return asyncFunction2();
})
.then(result2 =&gt; {
  // ···
})
.catch(error =&gt; {
  // Failure: handle errors of asyncFunc1(), asyncFunc2()
  // and any (sync) exceptions thrown in previous callbacks
});
</code></pre>
<h4 id="37110-promise-的优势">37.1.10. Promise 的优势</h4>
<p>在处理一次性结果时，这些是 Promise 优于普通回调的一些优点：</p>
<ul>
<li> <p>基于 Promise 的函数和方法的类型签名更清晰：如果函数是基于回调的，则某些参数是关于输入，而最后的一个或两个回调是关于输出。使用 Promise，与输出相关的所有内容都通过返回值处理。</p> </li>
<li> <p>链式异步处理步骤更方便。</p> </li>
<li> <p>错误处理可以负责同步和异步错误。</p> </li>
<li> <p>编写基于 Promise 的函数稍微容易一些，因为您可以使用一些调用函数和处理结果的同步工具（例如<code>.map()</code>）。我们将在本章末尾看到一个例子。</p> </li>
<li> <p>Promise 是一个单一的标准，正逐渐取代几个互不相容的替代方案。例如，在 Node.js 中，许多函数现在都可以在基于 Promise 的版本中可用。新的异步浏览器 API 通常是基于 Promise 的。</p> </li>
</ul>
<p>Promise 最大的优势之一就是不直接使用它们：它们是 <em>异步函数</em> 的基础，一种用于执行异步计算的同步语法。异步函数将在下一章中介绍。</p>
<h3 id="372-范例">37.2. 范例</h3>
<p>看到它们的使用有助于理解 Promise。我们来看看例子。</p>
<h4 id="3721-nodejs异步读取文件">37.2.1. Node.js：异步读取文件</h4>
<p>考虑以下带有 JSON 数据的文本文件<code>person.json</code>：</p>
<pre><code class="language-JSON">{
  "first": "Jane",
  "last": "Doe"
}
</code></pre>
<p>让我们看看两个版本的代码，它们读取这个文件并将其解析为一个对象。首先，基于回调的版本。第二，基于 Promise 的版本。</p>
<h5 id="37211-基于回调的版本">37.2.1.1. 基于回调的版本</h5>
<p>以下代码读取此文件的内容并将其转换为 JavaScript 对象。它基于 Node.js 风格的回调：</p>
<pre><code class="language-JavaScript">import * as fs from 'fs';
fs.readFile('person.json',
  (error, text) =&gt; {
    if (error) { // (A)
      // Failure
      assert.fail(error);
    } else {
      // Success
      try { // (B)
        const obj = JSON.parse(text); // (C)
        assert.deepEqual(obj, {
          first: 'Jane',
          last: 'Doe',
        });
      } catch (e) {
        // Invalid JSON
        assert.fail(e);
      }
    }
  });
</code></pre>
<p><code>fs</code>是用于文件系统操作的 Node.js 内置模块。我们使用基于回调的函数<code>fs.readFile()</code>来读取名称为<code>person.json</code>的文件。如果我们成功，内容将通过参数<code>text</code>作为字符串传递。在 C 行中，我们将该字符串从基于文本的数据格式 <em>JSON</em> 转换为 JavaScript 对象。 <code>JSON</code>是 JavaScript 标准库的一部分。</p>
<p>请注意，有两种错误处理机制：行 A 中的<code>if</code>负责<code>fs.readFile()</code>报告的异步错误，而行 B 中的<code>try</code>负责<code>JSON.parse()</code>报告的同步错误。</p>
<h5 id="37212-基于-promise-的版本">37.2.1.2. 基于 Promise 的版本</h5>
<p>以下代码使用<code>readFileAsync()</code>，一个基于 Promise 的<code>fs.readFile()</code>版本（通过<code>util.promisify()</code>创建，稍后会解释）：</p>
<pre><code class="language-JavaScript">readFileAsync('person.json')
.then(text =&gt; { // (A)
  // Success
  const obj = JSON.parse(text);
  assert.deepEqual(obj, {
    first: 'Jane',
    last: 'Doe',
  });
})
.catch(err =&gt; { // (B)
  // Failure: file I/O error or JSON syntax error
  assert.fail(err);
});
</code></pre>
<p>函数<code>readFileAsync()</code>返回一个 Promise。在行 A 中，我们通过 Promise 的方法<code>.then()</code>指定成功的回调。 <code>then</code>回调中的剩余代码是同步的。</p>
<p><code>.then()</code>返回一个 Promise，它允许在 B 行调用 Promise 方法<code>.catch()</code>。我们用它来指定一个失败的回调。</p>
<p>请注意，<code>.catch()</code>允许我们处理<code>readFileAsync()</code>的异步错误和<code>JSON.parse()</code>的同步错误。我们稍后会看到它究竟是如何工作的。</p>
<h4 id="3722-浏览器promisifyingpromise化-xmlhttprequest">37.2.2. 浏览器：Promisifying（Promise化） <code>XMLHttpRequest</code></h4>
<p>我们以前见过基于事件的<code>XMLHttpRequest</code> API，用于在 Web 浏览器中下载数据。以下函数将Promise化 API：</p>
<pre><code class="language-JavaScript">function httpGet(url) {
  return new Promise(
    (resolve, reject) =&gt; {
      const xhr = new XMLHttpRequest();
      xhr.onload = () =&gt; {
        if (xhr.status === 200) {
          resolve(xhr.responseText); // (A)
        } else {
          // Something went wrong (404 etc.)
          reject(new Error(xhr.statusText)); // (B)
        }
      }
      xhr.onerror = () =&gt; {
        reject(new Error('Network error')); // (C)
      };
      xhr.open('GET', url);
      xhr.send();
    });
}
</code></pre>
<p>注意如何通过<code>resolve()</code>和<code>reject()</code>处理<code>XMLHttpRequest</code>的结果：</p>
<ul>
<li>一个成功的结果导致返回的 Promise 得以实现（行 A）。</li>
<li>错误导致 Promise 被拒绝（B 行和 C 行）。</li>
</ul>
<p>这是您使用<code>httpGet()</code>的方式：</p>
<pre><code class="language-JavaScript">httpGet('http://example.com/textfile.txt')
.then(content =&gt; {
  assert.equal(content, 'Content of textfile.txt\n');
})
.catch(error =&gt; {
  assert.fail(error);
});
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：找出 Promise</strong></p>
<p><code>exercises/promises/promise_timeout_test.js</code></p>
<h4 id="3723-nodejsutilpromisify">37.2.3. Node.js：<code>util.promisify()</code></h4>
<p><code>util.promisify()</code>是一个实用程序函数，它将基于回调的函数<code>f</code>转换为基于 Promise 的函数<code>f</code>。也就是说，我们将从这种类型的签名：</p>
<pre><code class="language-JavaScript">f(arg_1, ···, arg_n, (err: Error, result: T) =&gt; void) : void
</code></pre>
<p>对于这种类型的签名：</p>
<pre><code class="language-JavaScript">f(arg_1, ···, arg_n) : Promise&lt;T&gt;
</code></pre>
<p>以下代码Promise化了基于回调的<code>fs.readFile()</code>（行 A）并使用它：</p>
<pre><code class="language-JavaScript">import * as fs from 'fs';
import {promisify} from 'util';

const readFileAsync = promisify(fs.readFile); // (A)

readFileAsync('some-file.txt', {encoding: 'utf8'})
  .then(text =&gt; {
    assert.equal(text, 'The content of some-file.txt\n');
  })
  .catch(err =&gt; {
    assert.fail(err);
  });
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：<code>util.promisify()</code></strong></p>
<ul>
<li>使用<code>util.promisify()</code>：<code>exercises/promises/read_file_async_exrc.js</code></li>
<li>自己实现<code>util.promisify()</code>：<code>exercises/promises/my_promisify_test.js</code></li>
</ul>
<h4 id="3724-浏览器fetch-api">37.2.4. 浏览器：Fetch API</h4>
<p>所有现代浏览器都支持 Fetch，这是一种基于 Promise 的新 API，用于下载数据。可以把它想象成<code>XMLHttpRequest</code>的基于 Promise 的版本。以下是 <a href="https://fetch.spec.whatwg.org/#fetch-api">API</a> 的一段摘录：</p>
<pre><code class="language-JavaScript">interface Body {
  text() : Promise&lt;string&gt;;
  ···
}
interface Response extends Body {
  ···
}
declare function fetch(str) : Promise&lt;Response&gt;;
</code></pre>
<p>这意味着，你可以使用<code>fetch()</code>如下：</p>
<pre><code class="language-JavaScript">fetch('http://example.com/textfile.txt')
.then(response =&gt; response.text())
.then(text =&gt; {
  assert.equal(text, 'Content of textfile.txt\n');
});
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：使用 fetch API</strong></p>
<p><code>exercises/promises/fetch_json_test.js</code></p>
<h3 id="373-错误处理不要混淆拒绝和异常">37.3. 错误处理：不要混淆拒绝和异常</h3>
<p>异步代码中错误处理的一般规则是：</p>
<blockquote>
<p>不要混淆（异步）拒绝和（同步）异常</p>
</blockquote>
<p>理由是，如果您可以使用单一的错误处理机制，那么您的代码就不那么冗余了。</p>
<p>唉，很容易意外地打破这个规则。例如：</p>
<pre><code class="language-JavaScript">// Don't do this
function asyncFunc() {
  doSomethingSync(); // (A)
  return doSomethingAsync()
  .then(result =&gt; {
    // ···
  });
}
</code></pre>
<p>问题是，如果在 行 A 抛出异常，那么<code>asyncFunc()</code>将抛出异常。该函数的调用者只会期待拒绝，并且不会为异常做好准备。我们可以通过三种方式解决此问题。</p>
<p>我们可以在<code>try-catch</code>语句中包装函数的整个主体，并在抛出异常时返回被拒绝的 Promise：</p>
<pre><code class="language-JavaScript">// Solution 1
function asyncFunc() {
  try {
    doSomethingSync();
    return doSomethingAsync()
    .then(result =&gt; {
      // ···
    });
  } catch (err) {
    return Promise.reject(err);
  }
}
</code></pre>
<p>鉴于<code>.then()</code>将异常转换为拒绝，我们可以在<code>.then()</code>回调中执行<code>doSomethingSync()</code>。为此，我们通过<code>Promise.resolve()</code>启动 Promise 链。我们忽略了最初的 Promise 的履行值<code>undefined</code>。</p>
<pre><code class="language-JavaScript">// Solution 2
function asyncFunc() {
  return Promise.resolve()
  .then(() =&gt; {
    doSomethingSync();
    return doSomethingAsync();
  })
  .then(result =&gt; {
    // ···
  });
}
</code></pre>
<p>最后，<code>new Promise()</code>还将异常转换为拒绝。因此，使用此构造函数与以前的解决方案类似：</p>
<pre><code class="language-JavaScript">// Solution 3
function asyncFunc() {
  return new Promise((resolve, reject) =&gt; {
    doSomethingSync();
    resolve(doSomethingAsync());
  })
  .then(result =&gt; {
    // ···
  });
}
</code></pre>
<h3 id="374-基于-promise-的函数同步启动异步解决">37.4. 基于 Promise 的函数同步启动，异步解决</h3>
<p>大多数基于 Promise 的函数执行如下：</p>
<ul>
<li>他们的执行立即开始，同步。</li>
<li>但他们返回的 Promise 保证可以异步结算（如果有的话）。</li>
</ul>
<p>以下代码演示了：</p>
<pre><code class="language-JavaScript">function asyncFunc() {
  console.log('asyncFunc');
  return new Promise(
    (resolve, _reject) =&gt; {
      console.log('Callback of new Promise()');
      resolve();
    });
}
console.log('Start');
asyncFunc()
.then(() =&gt; {
  console.log('Callback of .then()'); // (A)
});
console.log('End');

// Output:
// 'Start'
// 'asyncFunc'
// 'Callback of new Promise()'
// 'End'
// 'Callback of .then()'
</code></pre>
<p>我们可以看到<code>new Promise()</code>的回调在代码结束之前执行，而结果在稍后传递（行 A）。</p>
<p>这意味着您的代码可以依赖于运行到完成语义（如<a href="ch_async-js.html">前一章</a>中所述），并且串联的 Promise 不会匮乏其他任务的处理时间。</p>
<p>此外，此规则导致基于 Promise 的函数前后一致的异步地返回结果。不是有时立即，有时异步的。这种可预测性使代码更易于使用。有关更多信息，请参阅 Isaac Z. Schlueter 的<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">“异步设计 API”</a>。</p>
<h3 id="375-promiseall并发和-promise-数组">37.5. <code>Promise.all()</code>：并发和 Promise 数组</h3>
<h4 id="3751-顺序执行与并发执行">37.5.1. 顺序执行与并发执行</h4>
<p>请考虑以下代码：</p>
<pre><code class="language-JavaScript">const asyncFunc1 = () =&gt; Promise.resolve('one');
const asyncFunc2 = () =&gt; Promise.resolve('two');

asyncFunc1()
.then(result1 =&gt; {
  assert.equal(result1, 'one');
  return asyncFunc2();
})
.then(result2 =&gt; {
  assert.equal(result2, 'two');
});
</code></pre>
<p>使用<code>.then()</code>，基于 Promise 的函数始终顺序地执行：仅在<code>asyncFunc1()</code>的结果确定后，才会执行<code>asyncFunc2()</code>。</p>
<p>相反，辅助函数<code>Promise.all()</code>以更多并发的方式执行基于 Promise 的函数：</p>
<pre><code class="language-JavaScript">Promise.all([asyncFunc1(), asyncFunc2()])
.then(arr =&gt; {
  assert.deepEqual(arr, ['one', 'two']);
});
</code></pre>
<p>它的类型签名是：</p>
<pre><code class="language-JavaScript">Promise.all&lt;T&gt;(promises: Iterable&lt;Promise&lt;T&gt;&gt;): Promise&lt;T[]&gt;
</code></pre>
<p>参数<code>promises</code>是 Promise 的可迭代参数。结果是单个 Promise，其结算方式如下：</p>
<ul>
<li>如果满足所有输入 Promise，则输出 Promise 将通过一个履行值数组来实现。</li>
<li>如果至少有一个输入 Promise 被拒绝，则输出 Promise 将被拒绝，并带有输入 Promise 的拒绝值。</li>
</ul>
<p>换句话说：你从一个可变的 Promise 转到一个 Array 的 Promise。</p>
<h4 id="3752-并发提示关注计算何时开始">37.5.2. 并发提示：关注计算何时开始</h4>
<p>确定“并发”异步代码的方法的提示：关注异步计算何时开始，而不是如何处理 Promise。例如，以下使用<code>.then()</code>的代码与使用<code>Promise.all()</code>的版本一样“并发”：</p>
<pre><code class="language-JavaScript">const promise1 = asyncFunc1();
const promise2 = asyncFunc2();

promise1
.then(result1 =&gt; {
  assert.equal(result1, 'one');
  return promise2;
})
.then(result2 =&gt; {
  assert.equal(result2, 'two');
});
</code></pre>
<p><code>asyncFunc1()</code>和<code>asyncFunc2()</code>大致同时开始。一旦两个 Promise 都满足，两个<code>.then()</code>调用几乎立即执行。如果首先满足<code>promise1</code>，这种方法甚至比使用<code>Promise.all()</code>（等待所有 Promise 都满足）更快。</p>
<h4 id="3753-promiseall是-fork-join">37.5.3. <code>Promise.all()</code>是 fork-join</h4>
<p><code>Promise.all()</code>与并发模式“fork join”松散相关。例如：</p>
<pre><code class="language-JavaScript">Promise.all([
  // Fork async computations
  httpGet('http://example.com/file1.txt'),
  httpGet('http://example.com/file2.txt'),
])
// Join async computations
.then(([text1, text2]) =&gt; {
  assert.equal(text1, 'Content of file1.txt\n');
  assert.equal(text2, 'Content of file2.txt\n');
});
</code></pre>
<h4 id="3754通过promiseall异步map">37.5.4。通过<code>Promise.all()</code>异步<code>.map()</code></h4>
<p>诸如<code>.map()</code>，<code>.filter()</code>等的数组变换方法用于同步计算。例如：</p>
<pre><code class="language-JavaScript">function timesTwoSync(x) {
  return 2 * x;
}
const arr = [1, 2, 3];
const result = arr.map(timesTwoSync);
assert.deepEqual(result, [2, 4, 6]);
</code></pre>
<p><code>.map()</code>的回调是否可能是基于 Promise 的函数？是的，如果你使用<code>Promise.all()</code>将一个 Promise 数组转换为一个（履行）值数组：</p>
<pre><code class="language-JavaScript">function timesTwoAsync(x) {
  return new Promise(resolve =&gt; resolve(x * 2));
}
const arr = [1, 2, 3];
const promiseArr = arr.map(timesTwoAsync);
Promise.all(promiseArr)
.then(result =&gt; {
  assert.deepEqual(result, [2, 4, 6]);
});
</code></pre>
<h5 id="37541一个更现实的例子">37.5.4.1。一个更现实的例子</h5>
<p>下面的代码是一个更现实的例子：我们使用<code>.map()</code>将示例从 fork-join 部分转换为一个函数，其参数是一个带有要下载的文本文件 URL 的 Array。</p>
<pre><code class="language-JavaScript">function downloadTexts(fileUrls) {
  const promisedTexts = fileUrls.map(httpGet);
  return Promise.all(promisedTexts);
}

downloadTexts([
  'http://example.com/file1.txt',
  'http://example.com/file2.txt',
])
.then(texts =&gt; {
  assert.deepEqual(
    texts, [
      'Content of file1.txt\n',
      'Content of file2.txt\n',
    ]);
});
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：<code>Promise.all()</code>和列表文件</strong></p>
<p><code>exercises/promises/list_files_async_test.js</code></p>
<h3 id="376-串联-promise-的提示">37.6. 串联 Promise 的提示</h3>
<p>本节提供了串联 Promise 的提示。</p>
<h4 id="3761-串联错误失去尾巴">37.6.1. 串联错误：失去尾巴</h4>
<p>问题：</p>
<pre><code class="language-JavaScript">// Don't do this
function foo() {
  const promise = asyncFunc();
  promise.then(result =&gt; {
    // ···
  });

  return promise;
}
</code></pre>
<p>计算从<code>asyncFunc()</code>返回的 Promise 开始。但之后，计算继续，并通过<code>.then()</code>创建另一个 Promise。 <code>foo()</code>返回前 Promise，但应返回后者。这是如何解决它：</p>
<pre><code class="language-JavaScript">function foo() {
  const promise = asyncFunc();
  return promise.then(result =&gt; {
    // ···
  });
}
</code></pre>
<h4 id="3762-串联错误嵌套">37.6.2. 串联错误：嵌套</h4>
<p>问题：</p>
<pre><code class="language-JavaScript">// Don't do this
asyncFunc1()
.then(result1 =&gt; {
  return asyncFunc2()
  .then(result2 =&gt; { // (A)
    // ···
  });
});
</code></pre>
<p>行 A 中的<code>.then()</code>是嵌套的。扁平结构会更好：</p>
<pre><code class="language-JavaScript">asyncFunc1()
.then(result1 =&gt; {
  return asyncFunc2();
})
.then(result2 =&gt; {
  // ···
});
</code></pre>
<h4 id="3763-串联错误多余的嵌套">37.6.3. 串联错误：多余的嵌套</h4>
<p>这是可避免嵌套的另一个例子：</p>
<pre><code class="language-JavaScript">// Don't do this
asyncFunc1()
.then(result1 =&gt; {
  if (result1 &lt; 0) {
    return asyncFuncA()
    .then(resultA =&gt; 'Result: ' + resultA);
  } else {
    return asyncFuncB()
    .then(resultB =&gt; 'Result: ' + resultB);
  }
});
</code></pre>
<p>我们可以再次获得扁平结构：</p>
<pre><code class="language-JavaScript">asyncFunc1()
.then(result1 =&gt; {
  return result1 &lt; 0 ? asyncFuncA() : asyncFuncB();
})
.then(resultAB =&gt; {
  return 'Result: ' + resultAB;
});
</code></pre>
<h4 id="3764-嵌套本身并不邪恶">37.6.4. 嵌套本身并不邪恶</h4>
<p>在以下代码中，我们受益于 <em>不是</em> 嵌套：</p>
<pre><code class="language-JavaScript">db.open()
.then(connection =&gt; { // (A)
  return connection.select({ name: 'Jane' })
  .then(result =&gt; { // (B)
    // Process result
    // Use `connection` to make more queries
  })
  // ···
  .catch(error =&gt; {
    // handle errors
  })
  .finally(() =&gt; {
    connection.close(); // (C)
  });
})
</code></pre>
<p>我们在 行 A 接收异步结果。在 B 行中，我们正在嵌套，因此我们可以在回调内和 C 行中访问变量<code>connection</code>。</p>
<h4 id="3765-串联错误创建-promise-而不是串联">37.6.5. 串联错误：创建 Promise 而不是串联</h4>
<p>问题：</p>
<pre><code class="language-JavaScript">// Don't do this
class Model {
  insertInto(db) {
    return new Promise((resolve, reject) =&gt; { // (A)
      db.insert(this.fields)
        .then(resultCode =&gt; {
          this.notifyObservers({event: 'created', model: this});
          resolve(resultCode);
        }).catch(err =&gt; {
          reject(err);
        })
    });
  }
  // ···
}
</code></pre>
<p>在 行 A 中，我们创建了一个 Promise 来提供<code>db.insert()</code>的结果。这是不必要的冗长，可以简化：</p>
<pre><code class="language-JavaScript">class Model {
  insertInto(db) {
    return db.insert(this.fields)
    .then(resultCode =&gt; {
      this.notifyObservers({event: 'created', model: this});
      return resultCode;
    });
  }
  // ···
}
</code></pre>
<p>关键的想法是我们不需要创造一个 Promise;我们可以返回<code>.then()</code>调用的结果。另一个好处是我们不需要捕获并重新拒绝<code>db.insert()</code>的失败。我们只是将其拒绝传递给<code>.insertInto()</code>的调用者。</p>
<h3 id="377-进一步阅读">37.7. 进一步阅读</h3>
<ul>
<li><a href="http://exploringjs.com/es6/ch_promises.html">“探索 ES6”</a>深入了解 Promise，包括它们的实现方式。</li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/72/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/72/index.html">前端开发规范手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/45.html">Aaaaaashu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 693个">693</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/99/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/99/index.html">ECMAScript 6入门</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/60.html">likebeta</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">24页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/61/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/61/index.html">前端开发者手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/37.html">dwqs</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 548个">548</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/89/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/89/index.html">Go 语言资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">74页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 207个">207</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/187/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/187/index.html">软件开发的工程化</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 112个">112</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/172/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/172/index.html">Seaborn 0.9 中文文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/18.html">ApacheCN</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">76页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 32个">32</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/171/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/171/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/1.html" title="I.背景" data-book-page-rel-url="docs/1.html" data-book-page-id="11641">I.背景</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/2.html" title="1.关于本书（ES2019 版）" data-book-page-rel-url="docs/2.html" data-book-page-id="11642">1.关于本书（ES2019 版）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/3.html" title="2.常见问题：本书" data-book-page-rel-url="docs/3.html" data-book-page-id="11643">2.常见问题：本书</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/4.html" title="3. JavaScript 的历史和演变" data-book-page-rel-url="docs/4.html" data-book-page-id="11644">3. JavaScript 的历史和演变</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/5.html" title="4.常见问题：JavaScript" data-book-page-rel-url="docs/5.html" data-book-page-id="11645">4.常见问题：JavaScript</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/6.html" title="II.第一步" data-book-page-rel-url="docs/6.html" data-book-page-id="11646">II.第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/7.html" title="5.概览" data-book-page-rel-url="docs/7.html" data-book-page-id="11647">5.概览</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/8.html" title="6.语法" data-book-page-rel-url="docs/8.html" data-book-page-id="11648">6.语法</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/9.html" title="7.在控制台上打印信息（`console.*`）" data-book-page-rel-url="docs/9.html" data-book-page-id="11649">7.在控制台上打印信息（`console.*`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/10.html" title="8.断言 API" data-book-page-rel-url="docs/10.html" data-book-page-id="11650">8.断言 API</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/11.html" title="9.测验和练习入门" data-book-page-rel-url="docs/11.html" data-book-page-id="11651">9.测验和练习入门</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/12.html" title="III.变量和值" data-book-page-rel-url="docs/12.html" data-book-page-id="11652">III.变量和值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/13.html" title="10.变量和赋值" data-book-page-rel-url="docs/13.html" data-book-page-id="11653">10.变量和赋值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/14.html" title="11.值" data-book-page-rel-url="docs/14.html" data-book-page-id="11654">11.值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/15.html" title="12.运算符" data-book-page-rel-url="docs/15.html" data-book-page-id="11655">12.运算符</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/16.html" title="IV.原始值" data-book-page-rel-url="docs/16.html" data-book-page-id="11656">IV.原始值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/17.html" title="13.非值`undefined`和`null`" data-book-page-rel-url="docs/17.html" data-book-page-id="11657">13.非值`undefined`和`null`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/18.html" title="14.布尔值" data-book-page-rel-url="docs/18.html" data-book-page-id="11658">14.布尔值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/19.html" title="15.数字" data-book-page-rel-url="docs/19.html" data-book-page-id="11659">15.数字</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/20.html" title="16. `Math`" data-book-page-rel-url="docs/20.html" data-book-page-id="11660">16. `Math`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/21.html" title="17. Unicode - 简要介绍（高级）" data-book-page-rel-url="docs/21.html" data-book-page-id="11661">17. Unicode - 简要介绍（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/22.html" title="18.字符串" data-book-page-rel-url="docs/22.html" data-book-page-id="11662">18.字符串</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/23.html" title="19.使用模板字面值和标记模板" data-book-page-rel-url="docs/23.html" data-book-page-id="11663">19.使用模板字面值和标记模板</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/24.html" title="20.符号" data-book-page-rel-url="docs/24.html" data-book-page-id="11664">20.符号</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/25.html" title="V.控制流和数据流" data-book-page-rel-url="docs/25.html" data-book-page-id="11665">V.控制流和数据流</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/26.html" title="21.控制流语句" data-book-page-rel-url="docs/26.html" data-book-page-id="11666">21.控制流语句</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/27.html" title="22.异常处理" data-book-page-rel-url="docs/27.html" data-book-page-id="11667">22.异常处理</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/28.html" title="23.可调用值" data-book-page-rel-url="docs/28.html" data-book-page-id="11668">23.可调用值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/29.html" title="VI.模块化" data-book-page-rel-url="docs/29.html" data-book-page-id="11669">VI.模块化</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/30.html" title="24.模块" data-book-page-rel-url="docs/30.html" data-book-page-id="11670">24.模块</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/31.html" title="25.单个对象" data-book-page-rel-url="docs/31.html" data-book-page-id="11671">25.单个对象</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/32.html" title="26.原型链和类" data-book-page-rel-url="docs/32.html" data-book-page-id="11672">26.原型链和类</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/33.html" title="七.集合" data-book-page-rel-url="docs/33.html" data-book-page-id="11673">七.集合</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/34.html" title="27.同步迭代" data-book-page-rel-url="docs/34.html" data-book-page-id="11674">27.同步迭代</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/35.html" title="28.数组（`Array`）" data-book-page-rel-url="docs/35.html" data-book-page-id="11675">28.数组（`Array`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/36.html" title="29.类型化数组：处理二进制数据（高级）" data-book-page-rel-url="docs/36.html" data-book-page-id="11676">29.类型化数组：处理二进制数据（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/37.html" title="30.映射（`Map`）" data-book-page-rel-url="docs/37.html" data-book-page-id="11677">30.映射（`Map`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/38.html" title="31. WeakMaps（`WeakMap`）" data-book-page-rel-url="docs/38.html" data-book-page-id="11678">31. WeakMaps（`WeakMap`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/39.html" title="32.集（`Set`）" data-book-page-rel-url="docs/39.html" data-book-page-id="11679">32.集（`Set`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/40.html" title="33. WeakSets（`WeakSet`）" data-book-page-rel-url="docs/40.html" data-book-page-id="11680">33. WeakSets（`WeakSet`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/41.html" title="34.解构" data-book-page-rel-url="docs/41.html" data-book-page-id="11681">34.解构</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/42.html" title="35.同步生成器（高级）" data-book-page-rel-url="docs/42.html" data-book-page-id="11682">35.同步生成器（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/43.html" title="八.异步" data-book-page-rel-url="docs/43.html" data-book-page-id="11683">八.异步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/44.html" title="36. JavaScript 中的异步编程" data-book-page-rel-url="docs/44.html" data-book-page-id="11684">36. JavaScript 中的异步编程</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/45.html" title="37.异步编程的 Promise" data-book-page-rel-url="docs/45.html" data-book-page-id="11685">37.异步编程的 Promise</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/46.html" title="38.异步函数" data-book-page-rel-url="docs/46.html" data-book-page-id="11686">38.异步函数</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/47.html" title="IX.更多标准库" data-book-page-rel-url="docs/47.html" data-book-page-id="11687">IX.更多标准库</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/48.html" title="39.正则表达式（`RegExp`）" data-book-page-rel-url="docs/48.html" data-book-page-id="11688">39.正则表达式（`RegExp`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/49.html" title="40.日期（`Date`）" data-book-page-rel-url="docs/49.html" data-book-page-id="11689">40.日期（`Date`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/50.html" title="41.创建和解析 JSON（`JSON`）" data-book-page-rel-url="docs/50.html" data-book-page-id="11690">41.创建和解析 JSON（`JSON`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/51.html" title="42.其余章节在哪里？" data-book-page-rel-url="docs/51.html" data-book-page-id="11691">42.其余章节在哪里？</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =171;var bookPageId =11685;var bookPageRelUrl ='docs/45.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>