
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>25.单个对象-[译] 写给不耐烦程序员的 JavaScript</title>
<meta content='25.单个对象,[译] 写给不耐烦程序员的 JavaScript' name='keywords'>
<meta content='25.单个对象,[译] 写给不耐烦程序员的 JavaScript' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/171/docs/30.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">24.模块</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/171/docs/32.html">
<span class="">26.原型链和类</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/171/index.html">[译] 写给不耐烦程序员的 JavaScript</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/impatient-js-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h2 id="25单个对象">25.单个对象</h2>
<blockquote>
<p>原文： <a href="http://exploringjs.com/impatient-js/ch_single-objects.html">http://exploringjs.com/impatient-js/ch_single-objects.html</a></p>
</blockquote>
<p>在本书中，JavaScript 的面向对象编程（OOP）风格分四步介绍。本章介绍步骤 1，<a href="ch_proto-chains-classes.html">下一章</a>涵盖步骤 2-4。步骤是（图 <a href="#fig:oop_steps1">7</a> ）：</p>
<ol>
<li><strong>单个对象：</strong> _ 对象 _，JavaScript 的基本 OOP 构建块如何独立工作？</li>
<li>原型链：每个对象都有一个零个或多个 _ 原型对象链 _。原型是 JavaScript 的核心继承机制。</li>
<li>类：JavaScript 的 _ 类 _ 是对象的工厂。类及其实例之间的关系基于原型继承。</li>
<li>子类化：_ 子类 _ 与其 _ 超类 _ 之间的关系也基于原型继承。</li>
</ol>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/0830ec030f20d1678516a091d45c69bb.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/0830ec030f20d1678516a091d45c69bb.svg" alt="Figure 7: This book introduces object-oriented programming in JavaScript in four steps."></a></p>
<p>Figure 7: This book introduces object-oriented programming in JavaScript in four steps.</p>
<h3 id="251-javascript-中对象的两个角色">25.1。 JavaScript 中对象的两个角色</h3>
<p>在 JavaScript 中，对象是一组称为 _ 属性 _ 的键值条目。</p>
<p>对象在 JavaScript 中扮演两个角色：</p>
<ul>
<li> <p>记录：作为记录的对象具有固定数量的属性，其密钥在开发时是已知的。它们的值可以有不同的类型。本章首先介绍了这种使用对象的方法。</p> </li>
<li> <p>字典：Objects-as-dictionaries 具有可变数量的属性，其密钥在开发时是未知的。它们的所有值都具有相同的类型。通常最好将映射用作词典而不是对象（本章稍后将对此进行介绍）。</p> </li>
</ul>
<h3 id="252对象作为记录">25.2。对象作为记录</h3>
<h4 id="2521对象字面值属性">25.2.1。对象字面值：属性</h4>
<p>作为记录的对象是通过所谓的 _ 对象字面值 _ 创建的。对象字面值是 JavaScript 的一个突出特点：它们允许您直接创建对象。不需要上课！这是一个例子：</p>
<pre><code class="language-js">const jane = {
  first: 'Jane',
  last: 'Doe', // optional trailing comma
};
</code></pre>
<p>在这个例子中，我们通过一个对象字面值创建了一个对象，它以花括号<code>{}</code>开头和结尾。在其中，我们定义了两个 _ 属性 _（键值条目）：</p>
<ul>
<li>第一个属性具有键<code>first</code>和值<code>'Jane'</code>。</li>
<li>第二个属性具有键<code>last</code>和值<code>'Doe'</code>。</li>
</ul>
<p>如果以这种方式编写它们，则属性键必须遵循 JavaScript 变量名称的规则，但允许使用保留字。</p>
<p>访问属性如下：</p>
<pre><code class="language-js">assert.equal(jane.first, 'Jane'); // get property .first
jane.first = 'John'; // set property .first
assert.equal(jane.first, 'John');
</code></pre>
<h4 id="2522对象字面值属性值缩写">25.2.2。对象字面值：属性值缩写</h4>
<p>每当通过变量名定义属性的值并且该名称与键相同时，您可以省略该键。</p>
<h4 id="2523术语属性键属性名称属性符号">25.2.3。术语：属性键，属性名称，属性符号</h4>
<p>鉴于属性键可以是字符串和符号，因此进行以下区分：</p>
<pre><code class="language-js">const x = 4;
const y = 1;

assert.deepEqual(
  { x, y },
  { x: x, y: y }
);
</code></pre>
<ul>
<li>如果属性键是字符串，则它也称为 _ 属性名称 _。</li>
<li>如果属性键是符号，则它也称为 _ 属性符号 _。</li>
</ul>
<p>此术语用于 JavaScript 标准库（“自己”表示“未继承”，将在下一章中介绍）：</p>
<ul>
<li><code>Object.keys(obj)</code>：返回<code>obj</code>的所有属性键</li>
<li><code>Object.getOwnPropertyNames(obj)</code></li>
<li><code>Object.getOwnPropertySymbols(obj)</code></li>
</ul>
<h4 id="2524获得属性">25.2.4。获得属性</h4>
<p>这就是你 _ 得到 _（读）财产的方式：</p>
<pre><code class="language-js">obj.propKey
</code></pre>
<p>如果<code>obj</code>没有其键为<code>propKey</code>的属性，则此表达式求值为<code>undefined</code>：</p>
<pre><code class="language-js">const obj = {};
assert.equal(obj.propKey, undefined);
</code></pre>
<h4 id="2525设置属性">25.2.5。设置属性</h4>
<p>这就是你 _ 设置 _（写入）属性的方式：</p>
<pre><code class="language-js">obj.propKey = value;
</code></pre>
<p>如果<code>obj</code>已经有一个键为<code>propKey</code>的属性，则此语句将更改该属性。否则，它会创建一个新属性：</p>
<pre><code class="language-js">const obj = {};
assert.deepEqual(
  Object.keys(obj), []);

obj.propKey = 123;
assert.deepEqual(
  Object.keys(obj), ['propKey']);
</code></pre>
<h4 id="2526对象字面值方法">25.2.6。对象字面值：方法</h4>
<p>以下代码显示如何通过对象字面值创建方法<code>.describe()</code>：</p>
<pre><code class="language-js">const jane = {
  first: 'Jane', // data property
  says(text) {   // method
    return `${this.first} says “${text}”`; // (A)
  }, // comma as separator (optional at end)
};
assert.equal(jane.says('hello'), 'Jane says “hello”');
</code></pre>
<p>在方法调用<code>jane.says('hello')</code>期间，<code>jane</code>被称为方法调用的 _ 接收器 _，并被分配给特殊变量<code>this</code>。这使方法<code>.says()</code>能够访问 A 行中的兄弟属性<code>.first</code>。</p>
<h4 id="2527对象字面值访问者">25.2.7。对象字面值：访问者</h4>
<p>JavaScript 中有两种访问器：</p>
<ul>
<li><em>getter</em> 是 _ 调用 _（读取）属性调用的方法。</li>
<li><em>setter</em> 是由 _ 设置 _（写入）属性调用的方法。</li>
</ul>
<h5 id="25271吸气剂">25.2.7.1。吸气剂</h5>
<p>通过在方法定义前添加关键字<code>get</code>来创建 getter：</p>
<pre><code class="language-js">const jane = {
  first: 'Jane',
  last: 'Doe',
  get full() {
    return `${this.first} ${this.last}`;
  },
};

assert.equal(jane.full, 'Jane Doe');
jane.first = 'John';
assert.equal(jane.full, 'John Doe');
</code></pre>
<h5 id="25272塞特斯">25.2.7.2。塞特斯</h5>
<p>通过在方法定义前添加关键字<code>set</code>来创建 setter：</p>
<pre><code class="language-js">const jane = {
  first: 'Jane',
  last: 'Doe',
  set full(fullName) {
    const parts = fullName.split(' ');
    this.first = parts[0];
    this.last = parts[1];
  },
};

jane.full = 'Richard Roe';
assert.equal(jane.first, 'Richard');
assert.equal(jane.last, 'Roe');
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：通过对象字面值创建对象</strong></p>
<p><code>exercises/single-objects/color_point_object_test.js</code></p>
<h3 id="253传播到对象字面值">25.3。传播到对象字面值（<code>...</code>）</h3>
<p>我们已经看到在函数调用中使用扩展（<code>...</code>），它将迭代的内容转换为参数。</p>
<p>在对象字面值内部，_ 扩展属性 _ 将另一个对象的属性添加到当前对象：</p>
<pre><code class="language-js">&gt; const obj = {foo: 1, bar: 2};
&gt; {...obj, baz: 3}
{ foo: 1, bar: 2, baz: 3 }
</code></pre>
<p>如果属性键发生冲突，则上次提到的属性为“wins”：</p>
<pre><code class="language-js">&gt; const obj = {foo: 1, bar: 2, baz: 3};
&gt; {...obj, foo: true}
{ foo: true, bar: 2, baz: 3 }
&gt; {foo: true, ...obj}
{ foo: 1, bar: 2, baz: 3 }
</code></pre>
<h4 id="2531传播的用例复制对象">25.3.1。传播的用例：复制对象</h4>
<p>您可以使用 spread 来创建对象的副本<code>original</code>：</p>
<pre><code class="language-js">const copy = {...original};
</code></pre>
<p>警告 - 复制是 _ 浅 _：<code>copy</code>是一个新对象，带有<code>original</code>的所有属性（键值对）的副本。但是如果属性值是对象，那么不会复制它们;它们在<code>original</code>和<code>copy</code>之间共享。以下代码演示了这意味着什么。</p>
<pre><code class="language-js">const original = { a: 1, b: {foo: true} };
const copy = {...original};

// The first level is a true copy:
assert.deepEqual(
  copy, { a: 1, b: {foo: true} });
original.a = 2;
assert.deepEqual(
  copy, { a: 1, b: {foo: true} }); // no change

// Deeper levels are not copied:
original.b.foo = false;
// The value of property `b` is shared
// between original and copy.
assert.deepEqual(
  copy, { a: 1, b: {foo: false} });
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/8763e1931520190f777bbf536e527ac9.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/8763e1931520190f777bbf536e527ac9.svg" alt=""></a> ** JavaScript 不做深拷贝**</p>
<p>_ 对象的深拷贝 _（所有级别都被复制）是众所周知的难以做到的。因此，JavaScript 没有内置的操作（暂时）。如果您需要这样的操作，则必须自己实现。</p>
<h4 id="2532传播的用例缺失属性的默认值">25.3.2。传播的用例：缺失属性的默认值</h4>
<p>如果代码的其中一个输入是包含数据的对象，则可以在为其指定默认值时使属性成为可选属性。这样做的一种技术是通过其属性包含默认值的对象。在以下示例中，该对象是<code>DEFAULTS</code>：</p>
<pre><code class="language-js">const DEFAULTS = {foo: 'a', bar: 'b'};
const providedData = {foo: 1};

const allData = {...DEFAULTS, ...providedData};
assert.deepEqual(allData, {foo: 1, bar: 'b'});
</code></pre>
<p>结果，对象<code>allData</code>是通过创建<code>DEFAULTS</code>的副本并用<code>providedData</code>覆盖其属性来创建的。</p>
<p>但是您不需要对象来指定默认值，您也可以单独在对象字面值中指定它们：</p>
<pre><code class="language-js">const providedData = {foo: 1};

const allData = {foo: 'a', bar: 'b', ...providedData};
assert.deepEqual(allData, {foo: 1, bar: 'b'});
</code></pre>
<h4 id="2533用例传播非破坏性变化的属性">25.3.3。用例传播：非破坏性变化的属性</h4>
<p>到目前为止，我们遇到了一种更改对象属性的方法：我们 _ 设置 _ 并改变对象。也就是说，这种改变属性的方式是 _ 破坏性 _</p>
<p>通过传播，您可以非破坏性地更改属性：您可以复制属性具有不同值的对象。</p>
<p>例如，此代码非破坏性地更新属性<code>.foo</code>：</p>
<pre><code class="language-js">const obj = {foo: 'a', bar: 'b'};
const updatedObj = {...obj, foo: 1};
assert.deepEqual(updatedObj, {foo: 1, bar: 'b'});
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：通过传播（固定密钥）非破坏性更新属性</strong></p>
<p><code>exercises/single-objects/update_name_test.js</code></p>
<h3 id="254方法">25.4。方法</h3>
<h4 id="2541方法是值为函数的属性">25.4.1。方法是值为函数的属性</h4>
<p>让我们重温一下用于介绍方法的示例：</p>
<pre><code class="language-js">const jane = {
  first: 'Jane',
  says(text) {
    return `${this.first} says “${text}”`;
  },
};
</code></pre>
<p>有些令人惊讶的是，方法是函数：</p>
<pre><code class="language-js">assert.equal(typeof jane.says, 'function');
</code></pre>
<p>这是为什么？请记住，在<a href="ch_callables.html#roles-of-ordinary-functions">关于可调用实体</a>的章节中，我们了解到普通函数扮演了几个角色。 _ 方法 _ 是其中一个角色。因此，在引擎盖下，<code>jane</code>大致如下所示。</p>
<pre><code class="language-js">const jane = {
  first: 'Jane',
  says: function (text) {
    return `${this.first} says “${text}”`;
  },
};
</code></pre>
<h4 id="2542-call显式参数this">25.4.2。 <code>.call()</code>：显式参数<code>this</code></h4>
<p>请记住，每个函数<code>someFunc</code>也是一个对象，因此有方法。一种这样的方法是<code>.call()</code> - 它允许您在明确指定<code>this</code>时调用函数：</p>
<pre><code class="language-js">someFunc.call(thisValue, arg1, arg2, arg3);
</code></pre>
<h5 id="25421方法和call">25.4.2.1。方法和<code>.call()</code></h5>
<p>如果进行方法调用，<code>this</code>始终是隐式参数：</p>
<pre><code class="language-js">const obj = {
  method(x) {
    assert.equal(this, obj); // implicit parameter
    assert.equal(x, 'a');
  },
};

obj.method('a');
// Equivalent:
obj.method.call(obj, 'a');
</code></pre>
<p>顺便说一句，这意味着实际上有两个不同的点运算符：</p>
<ol>
<li>一个用于访问属性：<code>obj.prop</code></li>
<li>一个用于进行方法调用：<code>obj.prop()</code></li>
</ol>
<p>它们的不同之处在于（2）不仅仅是（1），后面是函数调用运算符<code>()</code>。相反，（2）另外指定<code>this</code>的值（如前面的例子所示）。</p>
<h5 id="25422功能和call">25.4.2.2。功能和<code>.call()</code></h5>
<p>但是，如果函数调用普通函数，<code>this</code>也是一个隐式参数：</p>
<pre><code class="language-js">function func(x) {
  assert.equal(this, undefined); // implicit parameter
  assert.equal(x, 'a');
}

func('a');
// Equivalent:
func.call(undefined, 'a');
</code></pre>
<p>也就是说，在函数调用期间，普通函数具有<code>this</code>，但它被设置为<code>undefined</code>，这表示它在这里没有真正的用途。</p>
<p>接下来，我们将研究使用<code>this</code>的缺陷。在我们能够做到这一点之前，我们还需要一个工具：函数的方法<code>.bind()</code>。</p>
<h4 id="2543-bind预填充this和功能参数">25.4.3。 <code>.bind()</code>：预填充<code>this</code>和功能参数</h4>
<p><code>.bind()</code>是函数对象的另一种方法。调用此方法如下。</p>
<pre><code class="language-js">const boundFunc = someFunc.bind(thisValue, arg1, arg2, arg3);
</code></pre>
<p><code>.bind()</code>返回一个新函数<code>boundFunc()</code>。调用该函数调用<code>someFunc()</code>并将<code>this</code>设置为<code>thisValue</code>并且这些参数：<code>arg1</code>，<code>arg2</code>，<code>arg3</code>，然后是<code>boundFunc()</code>的参数。</p>
<p>也就是说，以下两个函数调用是等效的：</p>
<pre><code class="language-js">boundFunc('a', 'b')
someFunc.call(thisValue, arg1, arg2, arg3, 'a', 'b')
</code></pre>
<p>另一种预填<code>this</code>和参数的方法是通过箭头功能：</p>
<pre><code class="language-js">const boundFunc2 = (...args) =&gt;
  someFunc.call(thisValue, arg1, arg2, arg3, ...args);
</code></pre>
<p>因此，<code>.bind()</code>可以实现为如下的实际功能：</p>
<pre><code class="language-js">function bind(func, thisValue, ...boundArgs) {
  return (...args) =&gt;
    func.call(thisValue, ...boundArgs, ...args);
}
</code></pre>
<h5 id="25431示例绑定实际函数">25.4.3.1。示例：绑定实际函数</h5>
<p>将<code>.bind()</code>用于实际功能有点不直观，因为你必须为<code>this</code>提供一个值。该值通常是<code>undefined</code>，反映了函数调用期间发生的情况。</p>
<p>在下面的示例中，我们通过将<code>add()</code>的第一个参数绑定到<code>8</code>来创建<code>add8()</code>，这是一个具有一个参数的函数。</p>
<pre><code class="language-js">function add(x, y) {
  return x + y;
}

const add8 = add.bind(undefined, 8);
assert.equal(add8(1), 9);
</code></pre>
<h5 id="25432示例绑定方法">25.4.3.2。示例：绑定方法</h5>
<p>在下面的代码中，我们将方法<code>.says()</code>转换为独立函数<code>func()</code>：</p>
<pre><code class="language-js">const jane = {
  first: 'Jane',
  says(text) {
    return `${this.first} says “${text}”`; // (A)
  },
};

const func = jane.says.bind(jane, 'hello');
assert.equal(func(), 'Jane says “hello”');
</code></pre>
<p>通过<code>.bind()</code>将<code>this</code>设置为<code>jane</code>至关重要。否则，<code>func()</code>将无法正常工作，因为在行 A 中使用了<code>this</code>。</p>
<h4 id="2544-this陷阱提取方法">25.4.4。 <code>this</code>陷阱：提取方法</h4>
<p>我们现在对函数和方法有了很多了解，并准备好了解涉及方法和<code>this</code>的最大缺陷：如果你不小心，函数调用从对象中提取的方法可能会失败。</p>
<p>在下面的例子中，当我们提取方法<code>jane.says()</code>时，我们失败，将它存储在变量<code>func</code>和函数调用<code>func()</code>中。</p>
<pre><code class="language-js">const jane = {
  first: 'Jane',
  says(text) {
    return `${this.first} says “${text}”`;
  },
};
const func = jane.says; // extract the method
assert.throws(
  () =&gt; func('hello'), // (A)
  {
    name: 'TypeError',
    message: "Cannot read property 'first' of undefined",
  });
</code></pre>
<p>A 行中的函数调用相当于：</p>
<pre><code class="language-js">assert.throws(
  () =&gt; jane.says.call(undefined, 'hello'), // `this` is undefined!
  {
    name: 'TypeError',
    message: "Cannot read property 'first' of undefined",
  });
</code></pre>
<p>那么我们如何解决这个问题呢？我们需要使用<code>.bind()</code>来提取方法<code>.says()</code>：</p>
<pre><code class="language-js">const func2 = jane.says.bind(jane);
assert.equal(func2('hello'), 'Jane says “hello”');
</code></pre>
<p>当我们调用<code>func()</code>时，<code>.bind()</code>确保<code>this</code>始终为<code>jane</code>。</p>
<p>您还可以使用箭头函数来提取方法：</p>
<pre><code class="language-js">const func3 = text =&gt; jane.says(text);
assert.equal(func3('hello'), 'Jane says “hello”');
</code></pre>
<h5 id="25441示例提取方法">25.4.4.1。示例：提取方法</h5>
<p>以下是您在实际 Web 开发中可能看到的代码的简化版本：</p>
<pre><code class="language-js">class ClickHandler {
  constructor(elem) {
    elem.addEventListener('click', this.handleClick); // (A)
  }
  handleClick(event) {
    alert('Clicked!');
  }
}
</code></pre>
<p>在 A 行中，我们没有正确提取方法<code>.handleClick()</code>。相反，我们应该这样做：</p>
<pre><code class="language-js">elem.addEventListener('click', this.handleClick.bind(this));
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：提取方法</strong></p>
<p><code>exercises/single-objects/method_extraction_exrc.js</code></p>
<h4 id="2545-this陷阱意外遮蔽this">25.4.5。 <code>this</code>陷阱：意外遮蔽<code>this</code></h4>
<p>如果使用普通功能，意外遮蔽<code>this</code>只是一个问题。</p>
<p>请考虑以下问题：当您在普通函数内部时，您无法访问周围范围的<code>this</code>，因为普通函数有自己的<code>this</code>。换句话说：内部作用域中的变量将变量隐藏在外部作用域中。这被称为 _ 阴影 _。以下代码是一个示例：</p>
<pre><code class="language-js">const obj = {
  name: 'Jane',
  sayHiTo(friends) {
    return friends.map(
      function (friend) { // (A)
        return `${this.name} says hi to ${friend}`; // (B)
      });
  }
};
assert.throws(
  () =&gt; obj.sayHiTo(['Tarzan', 'Cheeta']),
  {
    name: 'TypeError',
    message: "Cannot read property 'name' of undefined",
  });
</code></pre>
<p>为什么错误？ B 行中的<code>this</code>不是<code>.sayHiTo()</code>的<code>this</code>，它是从 B 行开始的普通函数的<code>this</code>。</p>
<p>有几种方法可以解决这个问题。最简单的方法是使用箭头函数 - 它没有自己的<code>this</code>，因此阴影不是问题。</p>
<pre><code class="language-js">const obj = {
  name: 'Jane',
  sayHiTo(friends) {
    return friends.map(
      (friend) =&gt; {
        return `${this.name} says hi to ${friend}`;
      });
  }
};
assert.deepEqual(
  obj.sayHiTo(['Tarzan', 'Cheeta']),
  ['Jane says hi to Tarzan', 'Jane says hi to Cheeta']);
</code></pre>
<h4 id="2546避免this的陷阱">25.4.6。避免<code>this</code>的陷阱</h4>
<p>我们已经看到了两个与<code>this</code>相关的重大陷阱：</p>
<ol>
<li><a href="ch_single-objects.html#this-pitfall-extracting-methods">提取方法</a></li>
<li><a href="ch_single-objects.html#this-pitfall-shadowing">意外遮蔽<code>this</code></a></li>
</ol>
<p>一个简单的规则有助于避免第二个陷阱：</p>
<blockquote>
<p>“避免关键字<code>function</code>”：绝不使用普通函数，只使用箭头函数（用于实际函数）和方法定义。</p>
</blockquote>
<p>让我们打破这个规则：</p>
<ul>
<li>如果所有实际函数都是箭头函数，则第二个陷阱永远不会发生。</li>
<li>使用方法定义意味着您只能在方法中看到<code>this</code>，这使得此功能不那么混乱。</li>
</ul>
<p>但是，即使我不使用（普通）函数 _ 表达式 _，我还是在语法上喜欢函数 _ 声明 _。如果您没有参考其中的<code>this</code>，您可以安全地使用它们。检查工具 ESLint 有<a href="https://eslint.org/docs/rules/no-invalid-this">规则</a>，有助于此。</p>
<p>唉，第一个陷阱没有简单的方法：每当你提取一个方法时，你必须小心并正确地做到这一点。例如，通过绑定<code>this</code>。</p>
<h4 id="2547-this在各种情况下的值">25.4.7。 <code>this</code>在各种情况下的值</h4>
<p><code>this</code>在各种情况下的值是多少？</p>
<p>在可调用实体中，<code>this</code>的值取决于调用可调用实体的方式以及它是什么类型的可调用实体：</p>
<ul>
<li>功能调用：
<ul>
<li>普通功能：<code>this === undefined</code></li>
<li>箭头功能：<code>this</code>与周围范围相同（词汇<code>this</code>）</li>
</ul> </li>
<li>方法调用：<code>this</code>是呼叫接收方</li>
<li><code>new</code>：<code>this</code>是指新创建的实例</li>
</ul>
<p>您还可以在所有常见的顶级范围中访问<code>this</code>：</p>
<ul>
<li><code>&lt;script&gt;</code>元素：<code>this === window</code></li>
<li>ES 模块：<code>this === undefined</code></li>
<li>CommonJS 模块：<code>this === module.exports</code></li>
</ul>
<p>但是，我喜欢假装您无法访问顶级作用域中的<code>this</code>，因为顶级<code>this</code>令人困惑且没有用处。</p>
<h3 id="255对象作为词典">25.5。对象作为词典</h3>
<p>对象最适合作为记录。但在 ES6 之前，JavaScript 没有字典的数据结构（ES6 带来了映射）。因此，必须将对象用作字典。因此，键必须是字符串，但值可以是任意类型。</p>
<p>我们首先看一下与字典相关的对象的特征，但偶尔也可用于对象作为记录。本节最后提供了实际使用对象作为词典的提示（剧透：如果可以，请避免使用映射）。</p>
<h4 id="2551任意固定字符串作为属性键">25.5.1。任意固定字符串作为属性键</h4>
<p>从对象作为记录到对象作为字典时，一个重要的变化是我们必须能够使用任意字符串作为属性键。本小节解释了如何实现固定字符串键。下一小节将介绍如何动态计算任意键。</p>
<p>到目前为止，我们只看到合法的 JavaScript 标识符作为属性键（符号除外）：</p>
<pre><code class="language-js">const obj = {
  mustBeAnIdentifier: 123,
};

// Get property
assert.equal(obj.mustBeAnIdentifier, 123);

// Set property
obj.mustBeAnIdentifier = 'abc';
assert.equal(obj.mustBeAnIdentifier, 'abc');
</code></pre>
<p>两种技术允许我们使用任意字符串作为属性键。</p>
<p>首先 - 当通过对象字面值创建属性键时，我们可以引用属性键（带单引号或双引号）：</p>
<pre><code class="language-js">const obj = {
  'Can be any string!': 123,
};
</code></pre>
<p>第二 - 获取或设置属性时，我们可以使用带有字符串的方括号：</p>
<pre><code class="language-js">// Get property
assert.equal(obj['Can be any string!'], 123);

// Set property
obj['Can be any string!'] = 'abc';
assert.equal(obj['Can be any string!'], 'abc');
</code></pre>
<p>您还可以引用方法的键：</p>
<pre><code class="language-js">const obj = {
  'A nice method'() {
    return 'Yes!';
  },
};

assert.equal(obj['A nice method'](), 'Yes!');
</code></pre>
<h4 id="2552计算属性键">25.5.2。计算属性键</h4>
<p>到目前为止，我们受到了对象字面值内部属性键的限制：它们总是固定的，它们总是字符串。如果我们将表达式放在方括号中，我们可以动态计算任意键：</p>
<pre><code class="language-js">const obj = {
  ['Hello world!']: true,
  ['f'+'o'+'o']: 123,
  [Symbol.toStringTag]: 'Goodbye', // (A)
};

assert.equal(obj['Hello world!'], true);
assert.equal(obj.foo, 123);
assert.equal(obj[Symbol.toStringTag], 'Goodbye');
</code></pre>
<p>计算键的主要用例是将符号作为属性键（行 A）。</p>
<p>请注意，用于获取和设置属性的方括号运算符适用于任意表达式：</p>
<pre><code class="language-js">assert.equal(obj['f'+'o'+'o'], 123);
assert.equal(obj['==&gt; foo'.slice(-3)], 123);
</code></pre>
<p>方法也可以有计算属性键：</p>
<pre><code class="language-js">const methodKey = Symbol();
const obj = {
  [methodKey]() {
    return 'Yes!';
  },
};

assert.equal(obj[methodKey](), 'Yes!');
</code></pre>
<p>我们现在切换回固定属性键，但如果需要计算属性键，则可以始终使用方括号。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：通过传播非破坏性更新属性（计算密钥）</strong></p>
<p><code>exercises/single-objects/update_property_test.js</code></p>
<h4 id="2553-in运算符是否存在具有给定键的属性">25.5.3。 <code>in</code>运算符：是否存在具有给定键的属性？</h4>
<p><code>in</code>运算符检查对象是否具有给定键的属性：</p>
<pre><code class="language-js">const obj = {
  foo: 'abc',
  bar: false,
};

assert.equal('foo' in obj, true);
assert.equal('unknownKey' in obj, false);
</code></pre>
<h5 id="25531通过真实性检查财产是否存在">25.5.3.1。通过真实性检查财产是否存在</h5>
<p>您还可以使用真实性检查来确定属性是否存在：</p>
<pre><code class="language-js">assert.equal(
  obj.unknownKey ? 'exists' : 'does not exist',
  'does not exist');
assert.equal(
  obj.foo ? 'exists' : 'does not exist',
  'exists');
</code></pre>
<p>之前的检查有效，因为读取不存在的属性会返回<code>undefined</code>，这是假的。因为<code>obj.foo</code>是真实的。</p>
<p>但是，有一个重要的警告：如果属性存在，则真实性检查失败，但具有假值（<code>undefined</code>，<code>null</code>，<code>false</code>，<code>0</code>，<code>""</code>等）：</p>
<pre><code class="language-js">assert.equal(
  obj.bar ? 'exists' : 'does not exist',
  'does not exist'); // should be: 'exists'
</code></pre>
<h4 id="2554删除属性">25.5.4。删除属性</h4>
<p>您可以通过<code>delete</code>运算符删除属性：</p>
<pre><code class="language-js">const obj = {
  foo: 123,
};
assert.deepEqual(Object.keys(obj), ['foo']);

delete obj.foo;

assert.deepEqual(Object.keys(obj), []);
</code></pre>
<h4 id="2555字典陷阱">25.5.5。字典陷阱</h4>
<p>如果使用普通对象（通过对象字面值创建）作为字典，则必须注意两个陷阱。</p>
<p>第一个缺陷是<code>in</code>运算符还找到了继承的属性：</p>
<pre><code class="language-js">const dict = {};
assert.equal('toString' in dict, true);
</code></pre>
<p>我们希望<code>dict</code>被视为空，但<code>in</code>运算符会检测它从原型<code>Object.prototype</code>继承的属性。</p>
<p>第二个缺陷是你不能使用属性键<code>__proto__</code>，因为它具有特殊的权力（它设置了对象的原型）：</p>
<pre><code class="language-js">const dict = {};

dict['__proto__'] = 123;
// No property was added to dict:
assert.deepEqual(Object.keys(dict), []);
</code></pre>
<p>那么我们如何解决这些陷阱呢？</p>
<ul>
<li> <p>只要你可以，使用映射。它们是词典的最佳解决方案。</p> </li>
<li> <p>如果你不能：将库用于可以安全地完成所有操作的对象字典。</p> </li>
<li> <p>如果你不能：使用没有原型的对象。这消除了现代 JavaScript 中的两个陷阱。</p> <pre><code class="language-js">const dict = Object.create(null); // no prototype

assert.equal('toString' in dict, false);

dict['__proto__'] = 123;
assert.deepEqual(Object.keys(dict), ['__proto__']);
</code></pre> </li>
</ul>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：使用对象作为字典</strong></p>
<p><code>exercises/single-objects/simple_dict_test.js</code></p>
<h4 id="2556列出属性键">25.5.6。列出属性键</h4>
<p>Table 19: Standard library methods for listing <em>own</em> (non-inherited) property keys. All of them return Arrays with strings and/or symbols.</p>
<table>
<thead>
<tr>
<th></th>
<th>枚举</th>
<th>没有。</th>
<th>串</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Object.keys()</code></td>
<td><code>✔</code></td>
<td></td>
<td><code>✔</code></td>
<td></td>
</tr>
<tr>
<td><code>Object.getOwnPropertyNames()</code></td>
<td><code>✔</code></td>
<td><code>✔</code></td>
<td><code>✔</code></td>
<td></td>
</tr>
<tr>
<td><code>Object.getOwnPropertySymbols()</code></td>
<td><code>✔</code></td>
<td><code>✔</code></td>
<td></td>
<td><code>✔</code></td>
</tr>
<tr>
<td><code>Reflect.ownKeys()</code></td>
<td><code>✔</code></td>
<td><code>✔</code></td>
<td><code>✔</code></td>
<td><code>✔</code></td>
</tr>
</tbody>
</table>
<p>tbl 中的每个方法。 <a href="#tbl:listing-property-keys">19</a> 返回一个带有参数自身属性键的数组。在方法的名称中，您可以看到我们之前讨论过的属性键（字符串和符号），属性名称（仅字符串）和属性符号（仅符号）之间的区别。</p>
<p>可枚举性是属性的 _ 属性 _。默认情况下，属性是可枚举的，但有一些方法可以改变它（在下一个示例中显示，<a href="ch_single-objects.html#property-attributes">稍后将详细描述</a>）。</p>
<p>例如：</p>
<pre><code class="language-js">const enumerableSymbolKey = Symbol('enumerableSymbolKey');
const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

// We create the enumerable properties via an object literal
const obj = {
  enumerableStringKey: 1,
  [enumerableSymbolKey]: 2,
}

// For the non-enumerable properties,
// we need a more powerful tool:
Object.defineProperties(obj, {
  nonEnumStringKey: {
    value: 3,
    enumerable: false,
  },
  [nonEnumSymbolKey]: {
    value: 4,
    enumerable: false,
  },
});

assert.deepEqual(
  Object.keys(obj),
  [ 'enumerableStringKey' ]);
assert.deepEqual(
  Object.getOwnPropertyNames(obj),
  [ 'enumerableStringKey', 'nonEnumStringKey' ]);
assert.deepEqual(
  Object.getOwnPropertySymbols(obj),
  [ enumerableSymbolKey, nonEnumSymbolKey ]);
assert.deepEqual(
  Reflect.ownKeys(obj),
  [ 'enumerableStringKey',
    'nonEnumStringKey',
    enumerableSymbolKey,
    nonEnumSymbolKey ]);
</code></pre>
<h4 id="2557通过objectvalues列出属性值">25.5.7。通过<code>Object.values()</code>列出属性值</h4>
<p><code>Object.values()</code>列出对象的所有可枚举属性的值：</p>
<pre><code class="language-js">const obj = {foo: 1, bar: 2};
assert.deepEqual(
  Object.values(obj),
  [1, 2]);
</code></pre>
<h4 id="2558通过objectentries列出属性条目">25.5.8。通过<code>Object.entries()</code>列出属性条目</h4>
<p><code>Object.entries()</code>列出了可枚举属性的键值对。每对编码为一个双元素数组：</p>
<pre><code class="language-js">const obj = {foo: 1, bar: 2};
assert.deepEqual(
  Object.entries(obj),
  [
    ['foo', 1],
    ['bar', 2],
  ]);
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：<code>Object.entries()</code></strong></p>
<p><code>exercises/single-objects/find_key_test.js</code></p>
<h4 id="2559确定性地列出属性">25.5.9。确定性地列出属性</h4>
<p>对象的自有（非继承）属性始终按以下顺序列出：</p>
<ol>
<li>具有整数索引的属性（例如，数组索引）</li>
</ol>
<ul>
<li>按升序数字顺序</li>
</ul>
<ol>
<li>带字符串键的剩余属性</li>
</ol>
<ul>
<li>按照添加顺序</li>
</ul>
<ol>
<li>带符号键的属性</li>
</ol>
<ul>
<li>按照添加顺序</li>
</ul>
<p>以下示例演示如何根据以下规则对属性键进行排序：</p>
<pre><code class="language-js">&gt; Object.keys({b:0,a:0, 2:0,1:0})
[ '1', '2', 'b', 'a' ]
</code></pre>
<p>（<a href="https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys">您可以在规格中查找详细信息。</a>）</p>
<h4 id="25510通过objectfromentries组装对象">25.5.10。通过<code>Object.fromEntries()</code>组装对象</h4>
<p>给定[key，value]对可迭代，<code>Object.fromEntries()</code>创建一个对象：</p>
<pre><code class="language-js">assert.deepEqual(
  Object.fromEntries([['foo',1], ['bar',2]]),
  {
    foo: 1,
    bar: 2,
  }
);
</code></pre>
<p>它与 <a href="ch_single-objects.html#Object.entries"><code>Object.entries()</code></a> 相反。</p>
<p>接下来，我们将使用<code>Object.entries()</code>和<code>Object.fromEntries()</code>从库 <a href="https://underscorejs.org">Underscore</a> 中实现多个工具功能。</p>
<h5 id="255101示例pickobject-keys">25.5.10.1。示例：<code>pick(object, ...keys)</code></h5>
<p><a href="https://underscorejs.org/#pick"><code>pick()</code></a> 从<code>object</code>中删除其键不在<code>keys</code>中的所有属性。删除 _ 非破坏性 _：<code>pick()</code>创建修改后的副本并且不会更改原始文件。例如：</p>
<pre><code class="language-js">const address = {
  street: 'Evergreen Terrace',
  number: '742',
  city: 'Springfield',
  state: 'NT',
  zip: '49007',
};
assert.deepEqual(
  pick(address, 'street', 'number'),
  {
    street: 'Evergreen Terrace',
    number: '742',
  }
);
</code></pre>
<p>我们可以按如下方式实现<code>pick()</code>：</p>
<pre><code class="language-js">function pick(object, ...keys) {
  const filteredEntries = Object.entries(object)
    .filter(([key, _value]) =&gt; keys.includes(key));
  return Object.fromEntries(filteredEntries);
}
</code></pre>
<h5 id="255102示例invertobject">25.5.10.2。示例：<code>invert(object)</code></h5>
<p><a href="https://underscorejs.org/#invert"><code>invert()</code></a> 非破坏性地交换键和对象的值：</p>
<pre><code class="language-js">assert.deepEqual(
  invert({a: 1, b: 2, c: 3}),
  {1: 'a', 2: 'b', 3: 'c'}
);
</code></pre>
<p>我们可以像这样实现它：</p>
<pre><code class="language-js">function invert(object) {
  const mappedEntries = Object.entries(object)
    .map(([key, value]) =&gt; [value, key]);
  return Object.fromEntries(mappedEntries);
}
</code></pre>
<h5 id="255103-objectfromentries的简单实现">25.5.10.3。 <code>Object.fromEntries()</code>的简单实现</h5>
<p><code>Object.fromEntries()</code>可以实现如下（我省略了几个检查）：</p>
<pre><code class="language-js">function fromEntries(iterable) {
  const result = {};
  for (const [key, value] of iterable) {
    let coercedKey;
    if (typeof key === 'string' || typeof key === 'symbol') {
      coercedKey = key;
    } else {
      coercedKey = String(key);
    }
    Object.defineProperty(result, coercedKey, {
      value,
      writable: true,
      enumerable: true,
      configurable: true,
    });
  }
  return result;
}
</code></pre>
<p>笔记：</p>
<ul>
<li><code>Object.defineProperty()</code>在本章后面中解释<a href="ch_single-objects.html#property-attributes">。</a></li>
<li>官方 polyfill 可通过 <a href="https://github.com/es-shims/Object.fromEntries">npm 包<code>object.fromentries</code></a> 获得。</li>
</ul>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：<code>Object.entries()</code>和<code>Object.fromEntries()</code></strong></p>
<p><code>exercises/single-objects/omit_properties_test.js</code></p>
<h3 id="256标准方法">25.6。标准方法</h3>
<p><code>Object.prototype</code>定义了几个可以覆盖的标准方法。两个重要的是：</p>
<ul>
<li><code>.toString()</code></li>
<li><code>.valueOf()</code></li>
</ul>
<p>粗略地说，<code>.toString()</code>配置对象如何转换为字符串：</p>
<pre><code class="language-js">&gt; String({toString() { return 'Hello!' }})
'Hello!'
&gt; String({})
'[object Object]'
</code></pre>
<p>并且<code>.valueOf()</code>配置对象如何转换为数字：</p>
<pre><code class="language-js">&gt; Number({valueOf() { return 123 }})
123
&gt; Number({})
NaN
</code></pre>
<h3 id="257高级主题">25.7。高级主题</h3>
<p>以下小节简要概述了超出本书范围的主题。</p>
<h4 id="2571-objectassign">25.7.1。 <code>Object.assign()</code></h4>
<p><code>Object.assign()</code>是一种工具方法：</p>
<pre><code class="language-js">Object.assign(target, source_1, source_2, ···)
</code></pre>
<p>这个表达式（破坏性地）将<code>source_1</code>合并到<code>target</code>，然后<code>source_2</code>等。最后，它返回<code>target</code>。例如：</p>
<pre><code class="language-js">const target = { foo: 1 };
const result = Object.assign(
  target,
  {bar: 2},
  {baz: 3, bar: 4});
assert.deepEqual(
  result, { foo: 1, bar: 4, baz: 3 });
// target was changed!
assert.deepEqual(target, result);
</code></pre>
<p><code>Object.assign()</code>的用例类似于传播属性的用例。在某种程度上，它破坏性地传播。</p>
<p>有关<code>Object.assign()</code>的更多信息，请参阅<a href="http://exploringjs.com/es6/ch_oop-besides-classes.html#Object_assign">“探索 ES6”</a>。</p>
<h4 id="2572冻结对象">25.7.2。冻结对象</h4>
<p><code>Object.freeze(obj)</code>使<code>obj</code>不可变：您无法更改或添加属性或更改<code>obj</code>的原型。</p>
<p>例如：</p>
<pre><code class="language-js">const frozen = Object.freeze({ x: 2, y: 5 });
assert.throws(
  () =&gt; { frozen.x = 7 },
  {
    name: 'TypeError',
    message: /^Cannot assign to read only property 'x'/,
  });
</code></pre>
<p>有一点需要注意：<code>Object.freeze(obj)</code>浅薄地冻结。也就是说，只冻结<code>obj</code>的属性，而不冻结属性中存储的对象。</p>
<p>有关<code>Object.freeze()</code>的更多信息，请参阅<a href="http://speakingjs.com/es5/ch17.html#freezing_objects">“Speaking JavaScript”</a>。</p>
<h4 id="2573属性属性和属性描述符">25.7.3。属性属性和属性描述符</h4>
<p>就像对象由属性组成一样，属性由 _ 属性 _ 组成。也就是说，您可以配置的不仅仅是属性的值 - 这只是几个属性中的一个。其他属性包括：</p>
<ul>
<li><code>writable</code>：是否可以更改属性的值？</li>
<li><code>enumerable</code>：<code>Object.keys()</code>是否列出了该属性？</li>
</ul>
<p>当您使用其中一个操作来访问属性属性时，通过 _ 属性描述符 _ 指定属性：每个属性代表一个属性的对象。例如，这是您阅读属性<code>obj.foo</code>的属性的方法：</p>
<pre><code class="language-js">const obj = { foo: 123 };
assert.deepEqual(
  Object.getOwnPropertyDescriptor(obj, 'foo'),
  {
    value: 123,
    writable: true,
    enumerable: true,
    configurable: true,
  });
</code></pre>
<p>这就是你设置属性<code>obj.bar</code>的属性的方法：</p>
<pre><code class="language-js">const obj = {
  foo: 1,
  bar: 2,
};

assert.deepEqual(Object.keys(obj), ['foo', 'bar']);

// Hide property `bar` from Object.keys()
Object.defineProperty(obj, 'bar', {
  enumerable: false,
});

assert.deepEqual(Object.keys(obj), ['foo']);
</code></pre>
<p>有关属性属性和属性描述符的更多信息，请参阅<a href="http://speakingjs.com/es5/ch17.html#property_attributes">“Speaking JavaScript”</a>。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/bf533f04c482f83bfc407f318306f995.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/bf533f04c482f83bfc407f318306f995.svg" alt=""></a> <strong>测验</strong></p>
<p>参见<a href="ch_quizzes-exercises.html#quizzes">测验应用程序</a>。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/72/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/72/index.html">前端开发规范手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/45.html">Aaaaaashu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 693个">693</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/53/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/53/index.html">前端开发者指南 2018</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/30.html">稀土</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">103页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 282个">282</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/67/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/67/index.html">JavaScript 资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 4565个">4565</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/190/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/nginx_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/190/index.html">Nginx 管理员手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/107.html">trimstray</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="nginx">nginx</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">307页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8424个">8424</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/122/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/spark_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/122/index.html">Databricks Spark 知识库简体中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="spark">spark</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">15页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/126/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/126/index.html">前端晚自修</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/67.html">if2er</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">22页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1个">1</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/171/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/171/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/1.html" title="I.背景" data-book-page-rel-url="docs/1.html" data-book-page-id="11641">I.背景</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/2.html" title="1.关于本书（ES2019 版）" data-book-page-rel-url="docs/2.html" data-book-page-id="11642">1.关于本书（ES2019 版）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/3.html" title="2.常见问题：本书" data-book-page-rel-url="docs/3.html" data-book-page-id="11643">2.常见问题：本书</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/4.html" title="3. JavaScript 的历史和演变" data-book-page-rel-url="docs/4.html" data-book-page-id="11644">3. JavaScript 的历史和演变</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/5.html" title="4.常见问题：JavaScript" data-book-page-rel-url="docs/5.html" data-book-page-id="11645">4.常见问题：JavaScript</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/6.html" title="II.第一步" data-book-page-rel-url="docs/6.html" data-book-page-id="11646">II.第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/7.html" title="5.概览" data-book-page-rel-url="docs/7.html" data-book-page-id="11647">5.概览</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/8.html" title="6.语法" data-book-page-rel-url="docs/8.html" data-book-page-id="11648">6.语法</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/9.html" title="7.在控制台上打印信息（`console.*`）" data-book-page-rel-url="docs/9.html" data-book-page-id="11649">7.在控制台上打印信息（`console.*`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/10.html" title="8.断言 API" data-book-page-rel-url="docs/10.html" data-book-page-id="11650">8.断言 API</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/11.html" title="9.测验和练习入门" data-book-page-rel-url="docs/11.html" data-book-page-id="11651">9.测验和练习入门</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/12.html" title="III.变量和值" data-book-page-rel-url="docs/12.html" data-book-page-id="11652">III.变量和值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/13.html" title="10.变量和赋值" data-book-page-rel-url="docs/13.html" data-book-page-id="11653">10.变量和赋值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/14.html" title="11.值" data-book-page-rel-url="docs/14.html" data-book-page-id="11654">11.值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/15.html" title="12.运算符" data-book-page-rel-url="docs/15.html" data-book-page-id="11655">12.运算符</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/16.html" title="IV.原始值" data-book-page-rel-url="docs/16.html" data-book-page-id="11656">IV.原始值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/17.html" title="13.非值`undefined`和`null`" data-book-page-rel-url="docs/17.html" data-book-page-id="11657">13.非值`undefined`和`null`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/18.html" title="14.布尔值" data-book-page-rel-url="docs/18.html" data-book-page-id="11658">14.布尔值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/19.html" title="15.数字" data-book-page-rel-url="docs/19.html" data-book-page-id="11659">15.数字</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/20.html" title="16. `Math`" data-book-page-rel-url="docs/20.html" data-book-page-id="11660">16. `Math`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/21.html" title="17. Unicode - 简要介绍（高级）" data-book-page-rel-url="docs/21.html" data-book-page-id="11661">17. Unicode - 简要介绍（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/22.html" title="18.字符串" data-book-page-rel-url="docs/22.html" data-book-page-id="11662">18.字符串</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/23.html" title="19.使用模板字面值和标记模板" data-book-page-rel-url="docs/23.html" data-book-page-id="11663">19.使用模板字面值和标记模板</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/24.html" title="20.符号" data-book-page-rel-url="docs/24.html" data-book-page-id="11664">20.符号</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/25.html" title="V.控制流和数据流" data-book-page-rel-url="docs/25.html" data-book-page-id="11665">V.控制流和数据流</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/26.html" title="21.控制流语句" data-book-page-rel-url="docs/26.html" data-book-page-id="11666">21.控制流语句</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/27.html" title="22.异常处理" data-book-page-rel-url="docs/27.html" data-book-page-id="11667">22.异常处理</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/28.html" title="23.可调用值" data-book-page-rel-url="docs/28.html" data-book-page-id="11668">23.可调用值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/29.html" title="VI.模块化" data-book-page-rel-url="docs/29.html" data-book-page-id="11669">VI.模块化</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/30.html" title="24.模块" data-book-page-rel-url="docs/30.html" data-book-page-id="11670">24.模块</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/31.html" title="25.单个对象" data-book-page-rel-url="docs/31.html" data-book-page-id="11671">25.单个对象</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/32.html" title="26.原型链和类" data-book-page-rel-url="docs/32.html" data-book-page-id="11672">26.原型链和类</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/33.html" title="七.集合" data-book-page-rel-url="docs/33.html" data-book-page-id="11673">七.集合</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/34.html" title="27.同步迭代" data-book-page-rel-url="docs/34.html" data-book-page-id="11674">27.同步迭代</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/35.html" title="28.数组（`Array`）" data-book-page-rel-url="docs/35.html" data-book-page-id="11675">28.数组（`Array`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/36.html" title="29.类型化数组：处理二进制数据（高级）" data-book-page-rel-url="docs/36.html" data-book-page-id="11676">29.类型化数组：处理二进制数据（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/37.html" title="30.映射（`Map`）" data-book-page-rel-url="docs/37.html" data-book-page-id="11677">30.映射（`Map`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/38.html" title="31. WeakMaps（`WeakMap`）" data-book-page-rel-url="docs/38.html" data-book-page-id="11678">31. WeakMaps（`WeakMap`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/39.html" title="32.集（`Set`）" data-book-page-rel-url="docs/39.html" data-book-page-id="11679">32.集（`Set`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/40.html" title="33. WeakSets（`WeakSet`）" data-book-page-rel-url="docs/40.html" data-book-page-id="11680">33. WeakSets（`WeakSet`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/41.html" title="34.解构" data-book-page-rel-url="docs/41.html" data-book-page-id="11681">34.解构</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/42.html" title="35.同步生成器（高级）" data-book-page-rel-url="docs/42.html" data-book-page-id="11682">35.同步生成器（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/43.html" title="八.异步" data-book-page-rel-url="docs/43.html" data-book-page-id="11683">八.异步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/44.html" title="36. JavaScript 中的异步编程" data-book-page-rel-url="docs/44.html" data-book-page-id="11684">36. JavaScript 中的异步编程</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/45.html" title="37.异步编程的 Promise" data-book-page-rel-url="docs/45.html" data-book-page-id="11685">37.异步编程的 Promise</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/46.html" title="38.异步函数" data-book-page-rel-url="docs/46.html" data-book-page-id="11686">38.异步函数</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/47.html" title="IX.更多标准库" data-book-page-rel-url="docs/47.html" data-book-page-id="11687">IX.更多标准库</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/48.html" title="39.正则表达式（`RegExp`）" data-book-page-rel-url="docs/48.html" data-book-page-id="11688">39.正则表达式（`RegExp`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/49.html" title="40.日期（`Date`）" data-book-page-rel-url="docs/49.html" data-book-page-id="11689">40.日期（`Date`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/50.html" title="41.创建和解析 JSON（`JSON`）" data-book-page-rel-url="docs/50.html" data-book-page-id="11690">41.创建和解析 JSON（`JSON`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/51.html" title="42.其余章节在哪里？" data-book-page-rel-url="docs/51.html" data-book-page-id="11691">42.其余章节在哪里？</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =171;var bookPageId =11671;var bookPageRelUrl ='docs/31.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>