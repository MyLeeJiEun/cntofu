
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>28.数组（`Array`）-[译] 写给不耐烦程序员的 JavaScript</title>
<meta content='28.数组（`Array`）,[译] 写给不耐烦程序员的 JavaScript' name='keywords'>
<meta content='28.数组（`Array`）,[译] 写给不耐烦程序员的 JavaScript' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/171/docs/34.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">27.同步迭代</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/171/docs/36.html">
<span class="">29.类型化数组：处理..</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/171/index.html">[译] 写给不耐烦程序员的 JavaScript</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/impatient-js-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h2 id="28数组array">28.数组（<code>Array</code>）</h2>
<blockquote>
<p>原文： <a href="http://exploringjs.com/impatient-js/ch_arrays.html">http://exploringjs.com/impatient-js/ch_arrays.html</a></p>
</blockquote>
<h3 id="281-javascript-中的数组的两个角色">28.1。 JavaScript 中的数组的两个角色</h3>
<p>数组在 JavaScript 中扮演两个角色：</p>
<ul>
<li>元组：Arrays-as-tuples 具有固定数量的索引元素。这些元素中的每一个都可以具有不同的类型。</li>
<li>序列：Arrays-as-sequences 具有可变数量的索引元素。每个元素都具有相同的类型。</li>
</ul>
<p>实际上，这两种角色也有其混合物。</p>
<p>值得注意的是，Arrays-as-sequences 非常灵活，您可以将它们用作（传统）数组，堆栈和队列（请参阅本章末尾的练习）。</p>
<h3 id="282基本数组操作">28.2。基本数组操作</h3>
<h4 id="2821数组创建阅读写作">28.2.1。数组：创建，阅读，写作</h4>
<p>创建数组的最佳方法是通过 _ 数组字面值 _：</p>
<pre><code class="language-js">const arr = ['a', 'b', 'c'];
</code></pre>
<p>Array 字面值以方括号<code>[]</code>开头和结尾。它创建一个包含三个 _ 元素 _ 的数组：<code>'a'</code>，<code>'b'</code>和<code>'c'</code>。</p>
<p>要读取 Array 元素，请将索引放在方括号中（索引从零开始）：</p>
<pre><code class="language-js">assert.equal(arr[0], 'a');
</code></pre>
<p>要更改 Array 元素，请为具有索引的 Array 指定：</p>
<pre><code class="language-js">arr[0] = 'x';
assert.deepEqual(arr, ['x', 'b', 'c']);
</code></pre>
<p>数组索引的范围是 32 位（不包括最大长度）：[0,2 32 -1）</p>
<h4 id="2822数组length">28.2.2。数组：<code>.length</code></h4>
<p>每个 Array 都有一个属性<code>.length</code>，可用于读取和更改（！）数组中元素的数量。</p>
<p>数组的长度始终是最高的索引加一：</p>
<pre><code class="language-js">&gt; const arr = ['a', 'b'];
&gt; arr.length
2
</code></pre>
<p>如果在长度的索引处写入数组，则追加一个元素：</p>
<pre><code class="language-js">&gt; arr[arr.length] = 'c';
&gt; arr
[ 'a', 'b', 'c' ]
&gt; arr.length
3
</code></pre>
<p>（破坏性地）附加元素的另一种方法是通过 Array 方法<code>.push()</code>：</p>
<pre><code class="language-js">&gt; arr.push('d');
&gt; arr
[ 'a', 'b', 'c', 'd' ]
</code></pre>
<p>如果设置<code>.length</code>，则通过删除元素来修剪数组：</p>
<pre><code class="language-js">&gt; arr.length = 1;
&gt; arr
[ 'a' ]
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：通过<code>.push()</code></strong> 删除空行</p>
<p><code>exercises/arrays/remove_empty_lines_push_test.js</code></p>
<h4 id="2823传播到数组">28.2.3。传播到数组</h4>
<p>在 Arrry 字面值中，_ 扩展元素 _ 由三个点（<code>...</code>）组成，后跟一个表达式。它导致表达式被评估然后迭代。每个迭代值都成为一个额外的 Array 元素。例如：</p>
<pre><code class="language-js">&gt; const iterable = ['b', 'c'];
&gt; ['a', ...iterable, 'd']
[ 'a', 'b', 'c', 'd' ]
</code></pre>
<p>传播很方便将数组和其他迭代连接到数组中：</p>
<pre><code class="language-js">const arr1 = ['a', 'b'];
const arr2 = ['c', 'd'];

const concatenated = [...arr1, ...arr2, 'e'];
assert.deepEqual(
  concatenated,
  ['a', 'b', 'c', 'd', 'e']);
</code></pre>
<h4 id="2824数组列出索引和条目">28.2.4。数组：列出索引和条目</h4>
<p>方法<code>.keys()</code>列出数组的索引：</p>
<pre><code class="language-js">const arr = ['a', 'b'];
assert.deepEqual(
  [...arr.keys()], // (A)
  [0, 1]);
</code></pre>
<p><code>.keys()</code>返回一个可迭代的。在 A 行，我们传播以获得一个数组。</p>
<p>列表数组索引与列表属性不同。当你执行后者时，你得到索引 - 但作为字符串 - 加上非索引属性键：</p>
<pre><code class="language-js">const arr = ['a', 'b'];
arr.prop = true;

assert.deepEqual(
  Object.keys(arr),
  ['0', '1', 'prop']);
</code></pre>
<p>方法<code>.entries()</code>将数组的内容列为[index，element]对：</p>
<pre><code class="language-js">const arr = ['a', 'b'];
assert.deepEqual(
  [...arr.entries()],
  [[0, 'a'], [1, 'b']]);
</code></pre>
<h4 id="2825数值是一个数组吗">28.2.5。数值是一个数组吗？</h4>
<p>这两种方法可以检查值是否为数组：</p>
<pre><code class="language-js">&gt; [] instanceof Array
true
&gt; Array.isArray([])
true
</code></pre>
<p><code>instanceof</code>通常很好。如果某个值可能来自另一个 _ 域 _，则需要<code>Array.isArray()</code>。粗略地说，领域是 JavaScript 全局范围的一个实例。一些领域彼此隔离（例如浏览器中的 <a href="ch_async-js.html#web-workers">Web Workers</a> ），但也有一些领域可以移动数据（例如浏览器中的同源 iframe）。 <code>x instanceof Array</code>检查<code>x</code>的原型链，因此如果<code>x</code>是来自另一个域的数组，则返回<code>false</code>。</p>
<p><code>typeof</code>将数组归类为对象：</p>
<pre><code class="language-js">&gt; typeof []
'object'
</code></pre>
<h3 id="283-for-of和数组">28.3。 <code>for-of</code>和数组</h3>
<p>我们已经遇到了<code>for-of</code>循环。本节简要介绍如何将它用于数组。</p>
<h4 id="2831-for-of迭代元素">28.3.1。 <code>for-of</code>：迭代元素</h4>
<p>以下<code>for-of</code>循环遍历数组的元素。</p>
<pre><code class="language-js">for (const element of ['a', 'b']) {
  console.log(element);
}
// Output:
// 'a'
// 'b'
</code></pre>
<h4 id="2832-for-of迭代indexelement对">28.3.2。 <code>for-of</code>：迭代[index，element]对</h4>
<p>以下<code>for-of</code>循环遍历[index，element]对。解构（稍后描述）为我们提供了在<code>for-of</code>的头部设置<code>index</code>和<code>element</code>的便捷语法。</p>
<pre><code class="language-js">for (const [index, element] of ['a', 'b'].entries()) {
  console.log(index, element);
}
// Output:
// 0, 'a'
// 1, 'b'
</code></pre>
<h3 id="284类似于数组的对象">28.4。类似于数组的对象</h3>
<p>一些使用 Arrays 的操作只需要最小值：值必须只是 _ 类似于 _。类似数组的值是具有以下属性的对象：</p>
<ul>
<li><code>.length</code>：保存类似 Array 的对象的长度。</li>
<li><code>['0']</code>：将元素保持在索引 0 处。（等等）</li>
</ul>
<p><code>ArrayLike</code>的 TypeScript 接口如下所示。</p>
<pre><code class="language-js">interface ArrayLike&lt;T&gt; {
  length: number;
  [n: number]: T;
}
</code></pre>
<p><code>Array.from()</code>接受类似 Array 的对象并将它们转换为 Arrays：</p>
<pre><code class="language-js">// If you omit .length, it is interpreted as 0
assert.deepEqual(
  Array.from({}),
  []);

assert.deepEqual(
  Array.from({length:2, 0:'a', 1:'b'}),
  [ 'a', 'b' ]);
</code></pre>
<p>类似于数组的对象曾经在 ES6 之前很常见;现在你不经常看到它们。</p>
<h3 id="285将可迭代和类似数组的值转换为数组">28.5。将可迭代和类似数组的值转换为数组</h3>
<p>将可迭代和类似数组的值转换为数组有两种常用方法：扩展和<code>Array.from()</code>。</p>
<h4 id="2851通过传播将迭代转换为数组">28.5.1。通过传播将迭代转换为数组（<code>...</code>）</h4>
<p>在 Array 文本中，通过<code>...</code>传播将任何可迭代对象转换为一系列 Array 元素。例如：</p>
<pre><code class="language-js">// Get an Array-like collection from a web browser’s DOM
const domCollection = document.querySelectorAll('a');

// Alas, the collection is missing many Array methods
assert.equal('map' in domCollection, false);

// Solution: convert it to an Array
const arr = [...domCollection];
assert.deepEqual(
  arr.map(x =&gt; x.href),
  ['http://2ality.com', 'http://exploringjs.com']);
</code></pre>
<p>转换有效，因为 DOM 集合是可迭代的。</p>
<h4 id="2852通过arrayfrom将可迭代和类似数组的对象转换为数组高级">28.5.2。通过<code>Array.from()</code>将可迭代和类似数组的对象转换为数组（高级）</h4>
<p><code>Array.from()</code>可以使用两种模式。</p>
<h5 id="28521-arrayfrom的模式-1转换">28.5.2.1。 <code>Array.from()</code>的模式 1：转换</h5>
<p>第一种模式具有以下类型签名：</p>
<pre><code class="language-js">.from&lt;T&gt;(iterable: Iterable&lt;T&gt; | ArrayLike&lt;T&gt;): T[];
</code></pre>
<p>接口<code>Iterable</code>在<a href="ch_sync-iteration.html#iterable-iterator-iteratorresult">中显示了介绍迭代</a>的章节。本章前面出现[HTD2]接口<code>ArrayLike</code>。</p>
<p>使用单个参数，<code>Array.from()</code>将任何可迭代或类似 Array 的数据转换为数组：</p>
<pre><code class="language-js">&gt; Array.from(new Set(['a', 'b']))
[ 'a', 'b' ]
&gt; Array.from({length: 2, 0:'a', 1:'b'})
[ 'a', 'b' ]
</code></pre>
<h5 id="28522-arrayfrom的模式-2转换和映射">28.5.2.2。 <code>Array.from()</code>的模式 2：转换和映射</h5>
<p><code>Array.from()</code>的第二种模式涉及两个参数：</p>
<pre><code class="language-js">.from&lt;T, U&gt;(
  iterable: Iterable&lt;T&gt; | ArrayLike&lt;T&gt;,
  mapFunc: (v: T, i: number) =&gt; U,
  thisArg?: any)
  : U[];
</code></pre>
<p>在这种模式下，<code>Array.from()</code>做了几件事：</p>
<ul>
<li>它迭代<code>iterable</code>。</li>
<li>它将<code>mapFunc</code>应用于每个迭代值。</li>
<li>它将结果收集到一个新数组中并返回它。</li>
</ul>
<p>可选参数<code>thisArg</code>指定<code>mapFunc</code>的<code>this</code>。</p>
<p>这意味着我们将从具有<code>T</code>类型的元素的 iterable 转变为具有<code>U</code>类型的元素的 Array。</p>
<p>这是一个例子：</p>
<pre><code class="language-js">&gt; Array.from(new Set(['a', 'b']), x =&gt; x + x)
[ 'aa', 'bb' ]
</code></pre>
<h3 id="286创建和填充任意长度的数组">28.6。创建和填充任意长度的数组</h3>
<p>创建数组的最佳方法是通过数组字面值。但是，您不能总是使用一个：数组可能太大，您可能在开发过程中不知道它的长度，或者您可能希望保持其长度灵活。然后我推荐以下用于创建和填充数组的技术：</p>
<ul>
<li> <p>你需要创建一个你将完全填充的空数组，稍后呢？</p> <pre><code class="language-js">&gt; new Array(3)
[ , , ,]
</code></pre> <p>请注意，结果有 3 个孔 - 数组字面值中的最后一个逗号始终被忽略。</p> </li>
<li> <p>你需要创建一个用原始值初始化的数组吗？</p> <pre><code class="language-js">&gt; new Array(3).fill(0)
[0, 0, 0]
</code></pre> <p>警告：如果对对象使用<code>.fill()</code>，则每个 Array 元素将引用同一个对象。</p> </li>
<li> <p>你需要创建一个用对象初始化的数组吗？</p> <pre><code class="language-js">&gt; Array.from({length: 3}, () =&gt; ({}))
[{}, {}, {}]
</code></pre> </li>
<li> <p>你需要创建一系列整数吗？</p> <pre><code class="language-js">const START = 2;
const END = 5;
assert.deepEqual(
  Array.from({length: END-START}, (x, i) =&gt; i+START),
  [2, 3, 4]);
</code></pre> </li>
</ul>
<p>如果您正在处理整数或浮点数的数组，请考虑 <a href="ch_typed-arrays.html">_ 类型数组 _</a> - 这是为此目的而创建的。</p>
<h3 id="287多维数组">28.7。多维数组</h3>
<p>JavaScript 没有真正的多维数组;你需要求助于其元素为数组的数组：</p>
<pre><code class="language-js">const DIM_X = 4;
const DIM_Y = 3;
const DIM_Z = 2;

const arr = [];
for (let x=0; x&lt;DIM_X; x++) {
  arr[x] = []; // (A)
  for (let y=0; y&lt;DIM_Y; y++) {
    arr[x][y] = []; // (B)
    for (let z=0; z&lt;DIM_Z; z++) {
      arr[x][y][z] = 0; // (C)
    }
  }
}
arr[3][0][1] = 7;
assert.deepEqual(arr, [
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 7 ], [ 0, 0 ], [ 0, 0 ] ],
]);
</code></pre>
<p>观察：</p>
<ul>
<li> <p>我们通过为索引为当前长度的插槽分配值来增长数组。</p> </li>
<li> <p>每个维度 - 除了最后一个维度 - 是一个数组，其元素是下一个维度（行 A，行 B）。</p> </li>
<li> <p>最后一个维度包含实际值（第 C 行）。</p> </li>
</ul>
<h3 id="288更多数组功能高级">28.8。更多数组功能（高级）</h3>
<p>在本节中，我们将介绍在使用 Arrays 时经常遇到的现象。</p>
<h4 id="2881数组元素是稍微特殊属性">28.8.1。数组元素是（稍微特殊）属性</h4>
<p>您认为 Array 元素是特殊的，因为您通过数字访问它们。但是这样做的方括号运算符（<code>[ ]</code>）与用于访问属性的运算符相同。并且，根据语言规范，它将任何值（不是符号）强制转换为字符串。因此：数组元素是（几乎）正常属性（A 行），如果使用数字或字符串作为索引（行 B 和 C），则无关紧要：</p>
<pre><code class="language-js">const arr = ['a', 'b'];
arr.prop = 123;
assert.deepEqual(
  Object.keys(arr),
  ['0', '1', 'prop']); // (A)

assert.equal(arr[0], 'a');  // (B)
assert.equal(arr['0'], 'a'); // (C)
</code></pre>
<p>更令人困惑的是，这只是语言规范如何定义事物（JavaScript 的理论，如果你愿意的话）。大多数 JavaScript 引擎都经过优化，并且使用数字（甚至是整数）来访问 Array 元素（如果你愿意，可以使用 JavaScript 的实践）。</p>
<p>用于 Array 元素的属性键（字符串！）称为 _ 索引 _。字符串<code>str</code>是将其转换为 32 位无符号整数并返回后生成原始值的索引。写成公式：</p>
<pre><code class="language-js">ToString(ToUint32(key)) === key
</code></pre>
<p>JavaScript 在列出所有对象的属性键时特别对待索引！它们总是排在第一位并按数字排序，而不是按字典顺序排列（<code>'10'</code>将在<code>'2'</code>之前出现）：</p>
<pre><code class="language-js">const arr = 'abcdefghijk'.split('');
arr.prop = 123;
assert.deepEqual(
  Object.keys(arr),
  ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'prop']);
</code></pre>
<p>请注意，<code>.length</code>，<code>.entries()</code>和<code>.keys()</code>将数组索引视为数字并忽略非索引属性：</p>
<pre><code class="language-js">const arr = ['a', 'b'];
arr.prop = true;

assert.deepEqual(
  Object.keys(arr), ['0', '1', 'prop']);

assert.equal(arr.length, 2);
assert.deepEqual(
  [...arr.keys()], [0, 1]);
assert.deepEqual(
  [...arr.entries()], [[0, 'a'], [1, 'b']]);
</code></pre>
<p>我们使用扩展元素（<code>...</code>）将<code>.keys()</code>和<code>.entries()</code>返回的迭代转换为数组。</p>
<h4 id="2882数组是字典可以有洞">28.8.2。数组是字典，可以有洞</h4>
<p>JavaScript 支持两种数组：</p>
<ul>
<li>密集数组：是数组形成连续序列的数组。这是迄今为止我们见过的唯一一种数组。</li>
<li>稀疏数组：包含空洞的数组。也就是说，一些指数缺失。</li>
</ul>
<p>一般来说，最好避免漏洞，因为它们会使代码更复杂，并且不会被 Array 方法一致地处理。此外，JavaScript 引擎优化密集数组，因此它们更快。</p>
<p>您可以在分配元素时通过跳过索引来创建孔：</p>
<pre><code class="language-js">const arr = [];
arr[0] = 'a';
arr[2] = 'c';

assert.deepEqual(Object.keys(arr), ['0', '2']); // (A)

assert.equal(0 in arr, true); // element
assert.equal(1 in arr, false); // hole
</code></pre>
<p>在 A 行中，我们使用<code>Object.keys()</code>，因为<code>arr.keys()</code>将孔视为<code>undefined</code>元素并且不会显示它们。</p>
<p>另一种创建漏洞的方法是跳过数组字面值中的元素：</p>
<pre><code class="language-js">const arr = ['a', , 'c'];

assert.deepEqual(Object.keys(arr), ['0', '2']);
</code></pre>
<p>你可以删除数组元素：</p>
<pre><code class="language-js">const arr = ['a', 'b', 'c'];
assert.deepEqual(Object.keys(arr), ['0', '1', '2']);
delete arr[1];
assert.deepEqual(Object.keys(arr), ['0', '2']);
</code></pre>
<p>有关 JavaScript 如何处理数组中的漏洞的更多信息，请参阅<a href="http://exploringjs.com/es6/ch_arrays.html#sec_array-holes">“探索 ES6”</a>。</p>
<h3 id="289添加和删除元素破坏性和非破坏性">28.9。添加和删​​除元素（破坏性和非破坏性）</h3>
<p>JavaScript 的<code>Array</code>非常灵活，更像是数组，堆栈和队列的组合。本节探讨添加和删除 Array 元素的方法。大多数操作可以破坏性地（修改数组）和非破坏性地（生成修改的副本）执行。</p>
<h4 id="2891预先添加元素和数组">28.9.1。预先添加元素和数组</h4>
<p>在下面的代码中，我们破坏性地将单个元素添加到<code>arr1</code>，将数组添加到<code>arr2</code>：</p>
<pre><code class="language-js">const arr1 = ['a', 'b'];
arr1.unshift('x', 'y'); // prepend single elements
assert.deepEqual(arr1, ['x', 'y', 'a', 'b']);

const arr2 = ['a', 'b'];
arr2.unshift(...['x', 'y']); // prepend Array
assert.deepEqual(arr2, ['x', 'y', 'a', 'b']);
</code></pre>
<p>传播让我们将数组移入<code>arr2</code>。</p>
<p>非破坏性预先支付通过扩散元素完成：</p>
<pre><code class="language-js">const arr1 = ['a', 'b'];
assert.deepEqual(
  ['x', 'y', ...arr1], // prepend single elements
  ['x', 'y', 'a', 'b']);
assert.deepEqual(arr1, ['a', 'b']); // unchanged!

const arr2 = ['a', 'b'];
assert.deepEqual(
  [...['x', 'y'], ...arr2], // prepend Array
  ['x', 'y', 'a', 'b']);
assert.deepEqual(arr2, ['a', 'b']); // unchanged!
</code></pre>
<h4 id="2892附加元素和数组">28.9.2。附加元素和数组</h4>
<p>在下面的代码中，我们破坏性地将单个元素附加到<code>arr1</code>，将数组附加到<code>arr2</code>：</p>
<pre><code class="language-js">const arr1 = ['a', 'b'];
arr1.push('x', 'y'); // append single elements
assert.deepEqual(arr1, ['a', 'b', 'x', 'y']);

const arr2 = ['a', 'b'];
arr2.push(...['x', 'y']); // append Array
assert.deepEqual(arr2, ['a', 'b', 'x', 'y']);
</code></pre>
<p>传播让我们将数组推入<code>arr2</code>。</p>
<p>非破坏性附加是通过扩散元素完成的：</p>
<pre><code class="language-js">const arr1 = ['a', 'b'];
assert.deepEqual(
  [...arr1, 'x', 'y'], // append single elements
  ['a', 'b', 'x', 'y']);
assert.deepEqual(arr1, ['a', 'b']); // unchanged!

const arr2 = ['a', 'b'];
assert.deepEqual(
  [...arr2, ...['x', 'y']], // append Array
  ['a', 'b', 'x', 'y']);
assert.deepEqual(arr2, ['a', 'b']); // unchanged!
</code></pre>
<h4 id="2893删除元素">28.9.3。删除元素</h4>
<p>这是删除 Array 元素的三种破坏性方法：</p>
<pre><code class="language-js">// Destructively remove first element:
const arr1 = ['a', 'b', 'c'];
assert.equal(arr1.shift(), 'a');
assert.deepEqual(arr1, ['b', 'c']);

// Destructively remove last element:
const arr2 = ['a', 'b', 'c'];
assert.equal(arr2.pop(), 'c');
assert.deepEqual(arr2, ['a', 'b']);

// Remove one or more elements anywhere:
const arr3 = ['a', 'b', 'c'];
assert.deepEqual(arr3.splice(1, 1), ['b']);
assert.deepEqual(arr3, ['a', 'c']);
</code></pre>
<p><a href="ch_arrays.html#quickref-arrays">快速参考部分</a>中详细介绍了<code>.splice()</code>。</p>
<p>通过 rest 元素进行解构使您可以从数组的开头非破坏性地删除元素（稍后将介绍解构）。</p>
<pre><code class="language-js">const arr1 = ['a', 'b', 'c'];
// Ignore first element, extract remaining elements
const [, ...arr2] = arr1;

assert.deepEqual(arr1, ['a', 'b', 'c']); // unchanged!
assert.deepEqual(arr2, ['b', 'c']);
</code></pre>
<p>唉，一个 rest 元素必须始终位于 Array 中。因此，您只能使用它来提取后缀。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：通过数组实现队列</strong></p>
<p><code>exercises/arrays/queue_via_array_test.js</code></p>
<h3 id="2810方法迭代和转换findmapfilter等">28.10。方法：迭代和转换（<code>.find()</code>，<code>.map()</code>，<code>.filter()</code>等）</h3>
<p>在本节中，我们将介绍用于迭代数组和转换数组的 Array 方法。在我们这样做之前，让我们考虑两种不同的迭代方法。它将帮助我们理解这些方法的工作原理。</p>
<h4 id="28101外部迭代与内部迭代">28.10.1。外部迭代与内部迭代</h4>
<p>假设您的代码想要迭代对象“内部”的值。这样做的两种常用方法是：</p>
<ul>
<li> <p>外部迭代（pull）：您的代码通过迭代协议向对象请求值。例如，<code>for-of</code>循环基于 JavaScript 的迭代协议：</p> <pre><code class="language-js">for (const x of ['a', 'b']) {
  console.log(x);
}
// Output:
// 'a'
// 'b'
</code></pre> <p>有关更长的示例，请参阅<a href="ch_sync-generators.html#external-iteration-example">有关同步生成器</a>的章节。</p> </li>
<li> <p>内部迭代（推送）：您将<a href="ch_callables.html#callback-function">回调函数</a>传递给对象的方法，并且该方法将值提供给回调。例如，Arrays 有方法<code>.forEach()</code>：</p> <pre><code class="language-js">['a', 'b'].forEach((x) =&gt; {
  console.log(x);
});
// Output:
// 'a'
// 'b'
</code></pre> <p>有关更长的示例，请参阅<a href="ch_sync-generators.html#internal-iteration-example">有关同步生成器</a>的章节。</p> </li>
</ul>
<p>我们接下来要看的方法都使用内部迭代。</p>
<h4 id="28102迭代和转换方法的回调">28.10.2。迭代和转换方法的回调</h4>
<p>迭代或转换方法的回调，具有以下签名：</p>
<pre><code class="language-js">callback: (value: T, index: number, array: Array&lt;T&gt;) =&gt; boolean
</code></pre>
<p>也就是说，回调有三个参数（可以忽略其中任何一个）：</p>
<ul>
<li><code>value</code>是最重要的一个。此参数保存当前正在处理的迭代值。</li>
<li><code>index</code>还可以告诉回调迭代值的索引是什么。</li>
<li><code>array</code>指向当前 Array（方法调用的接收者）。一些算法需要引用整个数组 - 例如搜索它的答案。此参数允许您为此类算法编写可重用的回调。</li>
</ul>
<p>预期返回的回调取决于传递给它的方法。可能性包括：</p>
<ul>
<li>没什么（<code>.forEach()</code>）。</li>
<li>布尔值（<code>.find()</code>）。</li>
<li>任意值（<code>.map()</code>）。</li>
</ul>
<h4 id="28103搜索元素findfindindex">28.10.3。搜索元素：<code>.find()</code>，<code>.findIndex()</code></h4>
<p><code>.find()</code>返回其回调返回 truthy 值的第一个元素：</p>
<pre><code class="language-js">&gt; [6, -5, 8].find(x =&gt; x &lt; 0)
-5
&gt; [6, 5, 8].find(x =&gt; x &lt; 0)
undefined
</code></pre>
<p><code>.findIndex()</code>返回其回调返回 truthy 值的第一个元素的索引：</p>
<pre><code class="language-js">&gt; [6, -5, 8].findIndex(x =&gt; x &lt; 0)
1
&gt; [6, 5, 8].findIndex(x =&gt; x &lt; 0)
-1
</code></pre>
<p><code>.findIndex()</code>可以实现如下：</p>
<pre><code class="language-js">function findIndex(arr, callback) {
  for (const [i, x] of arr.entries()) {
    if (callback(x, i, arr)) {
      return i;
    }
  }
  return -1;
}

assert.equal(1, findIndex(['a', 'b', 'c'], x =&gt; x === 'b'));
</code></pre>
<h4 id="28104-map复制时给予元素新值">28.10.4。 <code>.map()</code>：复制时给予元素新值</h4>
<p><code>.map()</code>返回接收器的副本。副本的元素是将<code>map</code>的回调参数应用于接收器元素的结果。</p>
<p>所有这些都通过示例更容易理解：</p>
<pre><code class="language-js">&gt; [1, 2, 3].map(x =&gt; x * 3)
[ 3, 6, 9 ]
&gt; ['how', 'are', 'you'].map(str =&gt; str.toUpperCase())
[ 'HOW', 'ARE', 'YOU' ]
&gt; [true, true, true].map((_, index) =&gt; index)
[ 0, 1, 2 ]
</code></pre>
<p>注意：<code>_</code>只是另一个变量名。</p>
<p><code>.map()</code>可以实现如下：</p>
<pre><code class="language-js">function map(arr, mapFunc) {
  const result = [];
  for (const [i, x] of arr.entries()) {
    result.push(mapFunc(x, i, arr));
  }
  return result;
}

assert.deepEqual(
  map(['a', 'b', 'c'], (x, i) =&gt; `${i}.${x}`),
  ['0.a', '1.b', '2.c']);
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：通过<code>.map()</code></strong> 编号行</p>
<p><code>exercises/arrays/number_lines_test.js</code></p>
<h4 id="28105-flatmap映射到零个或多个值">28.10.5。 <code>.flatMap()</code>：映射到零个或多个值</h4>
<p><code>Array&lt;T&gt;.prototype.flatMap()</code>的类型签名是：</p>
<pre><code class="language-js">.flatMap&lt;U&gt;(
  callback: (value: T, index: number, array: T[]) =&gt; U|Array&lt;U&gt;,
  thisValue?: any
): U[]
</code></pre>
<p><code>.map()</code>和<code>.flatMap()</code>都将函数<code>f</code>作为控制输入数组如何转换为输出数组的参数：</p>
<ul>
<li>使用<code>.map()</code>，每个输入数组元素都被转换为一个输出元素。也就是说，<code>f</code>返回单个值。</li>
<li>使用<code>.flatMap()</code>，每个输入数组元素都转换为零个或多个输出元素。也就是说，<code>f</code>返回一个值数组（它也可以返回非数组值，但这很少见）。</li>
</ul>
<p>这是<code>.flatMap()</code>的作用：</p>
<pre><code class="language-js">&gt; ['a', 'b', 'c'].flatMap(x =&gt; [x,x])
[ 'a', 'a', 'b', 'b', 'c', 'c' ]
&gt; ['a', 'b', 'c'].flatMap(x =&gt; [x])
[ 'a', 'b', 'c' ]
&gt; ['a', 'b', 'c'].flatMap(x =&gt; [])
[]
</code></pre>
<h5 id="281051一个简单的实现">28.10.5.1。一个简单的实现</h5>
<p>您可以按如下方式实现<code>.flatMap()</code>。注意：此实现比内置版本更简单，例如，执行更多检查。</p>
<pre><code class="language-js">function flatMap(arr, mapFunc) {
  const result = [];
  for (const [index, elem] of arr.entries()) {
    const x = mapFunc(elem, index, arr);
    // We allow mapFunc() to return non-Arrays
    if (Array.isArray(x)) {
      result.push(...x);
    } else {
      result.push(x);
    }
  }
  return result;
}
</code></pre>
<p>什么是<code>.flatMap()</code>有用？我们来看看用例吧！</p>
<h5 id="281052使用案例同时过滤和映射">28.10.5.2。使用案例：同时过滤和映射</h5>
<p>Array 方法<code>.map()</code>的结果始终与调用它的 Array 的长度相同。也就是说，它的回调不能跳过它不感兴趣的数组元素。</p>
<p><code>.flatMap()</code>执行此操作的功能在下一个示例中很有用：<code>processArray()</code>返回一个数组，其中每个元素都是包装值或包装错误。</p>
<pre><code class="language-js">function processArray(arr, process) {
  return arr.map(x =&gt; {
    try {
      return { value: process(x) };
    } catch (e) {
      return { error: e };
    }
  });
}
</code></pre>
<p>以下代码显示<code>processArray()</code>正在运行：</p>
<pre><code class="language-js">let err;
function myFunc(value) {
  if (value &lt; 0) {
    throw (err = new Error('Illegal value: '+value));
  }
  return value;
}
const results = processArray([1, -5, 6], myFunc);
assert.deepEqual(results, [
  { value: 1 },
  { error: err },
  { value: 6 },
]);
</code></pre>
<p><code>.flatMap()</code>使我们能够仅从<code>results</code>中提取值或仅提取错误：</p>
<pre><code class="language-js">const values = results.flatMap(
  result =&gt; result.value ? [result.value] : []);
assert.deepEqual(values, [1, 6]);
  
const errors = results.flatMap(
  result =&gt; result.error ? [result.error] : []);
assert.deepEqual(errors, [err]);
</code></pre>
<h5 id="281053用例映射到多个值">28.10.5.3。用例：映射到多个值</h5>
<p>Array 方法<code>.map()</code>将每个输入 Array 元素映射到一个输出元素。但是如果我们想将它映射到多个输出元素呢？</p>
<p>这在以下示例中变得必要：</p>
<ul>
<li>输入：<code>['a', 'b', 'c']</code></li>
<li>输出：<code>['&lt;span&gt;a&lt;/span&gt;', ', ', '&lt;span&gt;b&lt;/span&gt;', ', ', '&lt;span&gt;c&lt;/span&gt;']</code></li>
</ul>
<p>进行此转换的函数<code>wrap()</code>类似于您为前端库 React 编写的代码：</p>
<pre><code class="language-js">function wrap(tags) {
  return tags.flatMap(
    (tag, index) =&gt; {
      const html = `&lt;span&gt;${tag}&lt;/span&gt;`;
      if (index === 0) {
        return [html];
      } else {
        return [', ', html];
      }
    }
  );
}

assert.deepEqual(
  wrap(['a', 'b', 'c']),
  ['&lt;span&gt;a&lt;/span&gt;', ', ', '&lt;span&gt;b&lt;/span&gt;', ', ', '&lt;span&gt;c&lt;/span&gt;']
);
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：<code>.flatMap()</code></strong></p>
<ul>
<li> <p><code>exercises/arrays/convert_to_numbers_test.js</code></p> </li>
<li> <p><code>exercises/arrays/replace_objects_test.js</code></p> </li>
</ul>
<h4 id="28106-filter只保留一些元素">28.10.6。 <code>.filter()</code>：只保留一些元素</h4>
<p>Array 方法<code>.filter()</code>返回一个 Array，收集回调返回 truthy 值的所有元素。</p>
<p>例如：</p>
<pre><code class="language-js">&gt; [-1, 2, 5, -7, 6].filter(x =&gt; x &gt;= 0)
[ 2, 5, 6 ]
&gt; ['a', 'b', 'c', 'd'].filter((_,i) =&gt; (i%2)===0)
[ 'a', 'c' ]
</code></pre>
<p><code>.filter()</code>可以实现如下：</p>
<pre><code class="language-js">function filter(arr, filterFunc) {
  const result = [];
  for (const [i, x] of arr.entries()) {
    if (filterFunc(x, i, arr)) {
      result.push(x);
    }
  }
  return result;
}

assert.deepEqual(
  filter([ 1, 'a', 5, 4, 'x'], x =&gt; typeof x === 'number'),
  [1, 5, 4]);
assert.deepEqual(
  filter([ 1, 'a', 5, 4, 'x'], x =&gt; typeof x === 'string'),
  ['a', 'x']);
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：通过<code>.filter()</code></strong> 删除空行</p>
<p><code>exercises/arrays/remove_empty_lines_filter_test.js</code></p>
<h4 id="28107-reduce从数组中获取值高级">28.10.7。 <code>.reduce()</code>：从数组中获取值（高级）</h4>
<p>方法<code>.reduce()</code>是一个用于计算数组“摘要”的强大工具。摘要可以是任何类型的值：</p>
<ul>
<li>一个号码。例如，所有 Array 元素的总和。</li>
<li>数组。例如，Array 的副本，元素乘以 2。</li>
<li>等等。</li>
</ul>
<p>此操作在函数式编程中也称为<code>foldl</code>（“向左折叠”）并且在那里流行。需要注意的是，它可能使代码难以理解。</p>
<p><code>.reduce()</code>具有以下类型签名（在<code>Array&lt;T&gt;</code>内）：</p>
<pre><code class="language-js">.reduce&lt;U&gt;(
  callback: (accumulator: U, element: T, index: number, array: T[]) =&gt; U,
  init?: U)
  : U
</code></pre>
<p><code>T</code>是数组元素的类型，<code>U</code>是摘要的类型。两者可能有所不同，也可能没有。 <code>accumulator</code>只是“摘要”的另一个名称。</p>
<p>要计算数组<code>arr</code>的摘要，<code>.reduce()</code>将所有数组元素一次一个地提供给其回调：</p>
<pre><code class="language-js">const accumulator_0 = callback(init, arr[0]);
const accumulator_1 = callback(accumulator_0, arr[1]);
const accumulator_2 = callback(accumulator_1, arr[2]);
// Etc.
</code></pre>
<p><code>callback</code>将先前计算的摘要（存储在其参数<code>accumulator</code>中）与当前的 Array 元素组合，并返回下一个<code>accumulator</code>。 <code>.reduce()</code>的结果是最终累加器 - <code>callback</code>的最后一个结果，在它访问了所有元素之后。</p>
<p>换句话说：<code>callback</code>完成大部分工作，<code>.reduce()</code>只是以有用的方式调用它。</p>
<p>你可以说回调将数组元素折叠到累加器中。这就是为什么这个操作在函数式编程中称为“折叠”。</p>
<h5 id="281071第一个例子">28.10.7.1。第一个例子</h5>
<p>让我们看一下<code>.reduce()</code>的实例：函数<code>addAll()</code>计算数组<code>arr</code>中所有数字的总和。</p>
<pre><code class="language-js">function addAll(arr) {
  const startSum = 0;
  const callback = (sum, element) =&gt; sum + element;
  return arr.reduce(callback, startSum);
}
assert.equal(addAll([1,  2, 3]), 6); // (A)
assert.equal(addAll([7, -4, 2]), 5);
</code></pre>
<p>在这种情况下，累加器保存<code>callback</code>已经访问过的所有数组元素的总和。</p>
<p>结果<code>6</code>是如何从 A 行的数组中得出的？通过以下<code>callback</code>调用：</p>
<pre><code class="language-js">callback(0, 1) --&gt; 1
callback(1, 2) --&gt; 3
callback(3, 3) --&gt; 6
</code></pre>
<p>笔记：</p>
<ul>
<li>第一个参数是电流累加器（从<code>.reduce()</code>的参数<code>init</code>开始）。</li>
<li>第二个参数是当前的 Array 元素。</li>
<li>结果是下一个累加器。</li>
<li><code>callback</code>的最后结果也是<code>.reduce()</code>的结果。</li>
</ul>
<p>或者，我们可以通过<code>for-of</code>循环实现<code>addAll()</code>：</p>
<pre><code class="language-js">function addAll(arr) {
  let sum = 0;
  for (const element of arr) {
    sum = sum + element;
  }
  return sum;
}
</code></pre>
<p>很难说这两个实现中的哪一个“更好”：基于<code>.reduce()</code>的实现更简洁，而基于<code>for-of</code>的实现可能更容易理解 - 特别是如果你不熟悉函数式编程。</p>
<h5 id="281072示例通过reduce查找索引">28.10.7.2。示例：通过<code>.reduce()</code>查找索引</h5>
<p>以下函数是 Array 方法<code>.indexOf()</code>的实现。它返回给定<code>searchValue</code>出现在 Array <code>arr</code>内​​的第一个索引：</p>
<pre><code class="language-js">const NOT_FOUND = -1;
function indexOf(arr, searchValue) {
  return arr.reduce(
    (result, elem, index) =&gt; {
      if (result !== NOT_FOUND) {
        // We have already found something: don’t change anything
        return result;
      } else if (elem === searchValue) {
        return index;
      } else {
        return NOT_FOUND;
      }
    },
    NOT_FOUND);
}
assert.equal(indexOf(['a', 'b', 'c'], 'b'), 1);
assert.equal(indexOf(['a', 'b', 'c'], 'x'), -1);
</code></pre>
<p><code>.reduce()</code>的一个限制是您无法提前完成（在<code>for-of</code>循环中，您可以<code>break</code>）。在这里，一旦我们找到了我们想要的东西，我们就不会做任何事情。</p>
<h5 id="281073示例加倍数组元素">28.10.7.3。示例：加倍数组元素</h5>
<p>函数<code>double(arr)</code>返回<code>inArr</code>的副本，其元素全部乘以 2：</p>
<pre><code class="language-js">function double(inArr) {
  return inArr.reduce(
    (outArr, element) =&gt; {
      outArr.push(element * 2);
      return outArr;
    },
    []);
}
assert.deepEqual(
  double([1, 2, 3]),
  [2, 4, 6]);
</code></pre>
<p>我们通过推入修改初始值<code>[]</code>。 <code>double()</code>的非破坏性，功能更强的版本如下：</p>
<pre><code class="language-js">function double(inArr) {
  return inArr.reduce(
    // Don’t change `outArr`, return a fresh Array
    (outArr, element) =&gt; [...outArr, element * 2],
    []);
}
assert.deepEqual(
  double([1, 2, 3]),
  [2, 4, 6]);
</code></pre>
<p>这个版本更优雅，但也更慢并且使用更多内存。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：<code>.reduce()</code></strong></p>
<ul>
<li><code>map()</code>通过<code>.reduce()</code>：<code>exercises/arrays/map_via_reduce_test.js</code></li>
<li><code>filter()</code>通过<code>.reduce()</code>：<code>exercises/arrays/filter_via_reduce_test.js</code></li>
<li><code>countMatches()</code>通过<code>.reduce()</code>：<code>exercises/arrays/count_matches_via_reduce_test.js</code></li>
</ul>
<h3 id="2811-sort排序数组">28.11。 <code>.sort()</code>：排序数组</h3>
<p><code>.sort()</code>具有以下类型定义：</p>
<pre><code class="language-js">sort(compareFunc?: (a: T, b: T) =&gt; number): this
</code></pre>
<p><code>.sort()</code>始终对元素的字符串表示进行排序。这些表示通过<code>&lt;</code>进行比较。该运算符按字典顺序比较 <em>（第一个字符最重要）。您可以在比较数字时看到：</em></p>
<pre><code class="language-js">&gt; [200, 3, 10].sort()
[ 10, 200, 3 ]
</code></pre>
<p>比较人类语言字符串时，您需要知道它们是根据它们的代码单元值（字符代码）进行比较的：</p>
<pre><code class="language-js">&gt; ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()
[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]
</code></pre>
<p>正如您所看到的，所有非重音大写字母都出现在所有重音字母之前，这些字母位于所有重音字母之前。如果要对人类语言进行适当的排序，请使用<code>Intl</code>， <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">JavaScript 国际化 API</a> 。</p>
<p>最后，<code>.sort()</code>将 _ 排序到位 _：它改变并返回其接收器：</p>
<pre><code class="language-js">&gt; const arr = ['a', 'c', 'b'];
&gt; arr.sort() === arr
true
&gt; arr
[ 'a', 'b', 'c' ]
</code></pre>
<h4 id="28111自定义排序顺序">28.11.1。自定义排序顺序</h4>
<p>您可以通过参数<code>compareFunc</code>自定义排序顺序，该参数返回一个数字：</p>
<ul>
<li>否定如果<code>a &lt; b</code></li>
<li>如果<code>a === b</code>为零</li>
<li>如果<code>a &gt; b</code>为正</li>
</ul>
<p>记住这些规则的提示：负数是 _ 小于 _ 零（等）。</p>
<h4 id="28112排序数字">28.11.2。排序数字</h4>
<p>您可以使用以下辅助函数来比较数字：</p>
<pre><code class="language-js">function compareNumbers(a, b) {
  if (a &lt; b) {
    return -1;
  } else if (a === b) {
    return 0;
  } else {
    return 1;
  }
}
assert.deepEqual(
  [200, 3, 10].sort(compareNumbers),
  [3, 10, 200]);
</code></pre>
<p>以下是一个快速而肮脏的选择。它的缺点是它很神秘，存在数字溢出的风险：</p>
<pre><code class="language-js">&gt; [200, 3, 10].sort((a,b) =&gt; a-b)
[ 3, 10, 200 ]
</code></pre>
<h4 id="28113排序对象">28.11.3。排序对象</h4>
<p>如果要对对象进行排序，还需要使用比较函数。例如，以下代码显示了如何按年龄对对象进行排序。</p>
<pre><code class="language-js">const arr = [ {age: 200}, {age: 3}, {age: 10} ];
assert.deepEqual(
  arr.sort((obj1, obj2) =&gt; obj1.age - obj2.age),
  [{ age: 3 }, { age: 10 }, { age: 200 }] );
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：按名称排序对象</strong></p>
<p><code>exercises/arrays/sort_objects_test.js</code></p>
<h3 id="2812快速参考arrayt">28.12。快速参考：<code>Array&lt;T&gt;</code></h3>
<p>传说：</p>
<ul>
<li><code>R</code>：方法不改变接收器（非破坏性）。</li>
<li><code>W</code>：方法改变接收器（破坏性）。</li>
</ul>
<h4 id="28121-new-array">28.12.1。 <code>new Array()</code></h4>
<p><code>new Array(n)</code>创建一个长度为<code>n</code>的数组，其中包含<code>n</code>孔：</p>
<pre><code class="language-js">// Trailing commas are always ignored.
// Therefore: number of commas = number of holes
assert.deepEqual(new Array(3), [,,,]);
</code></pre>
<p><code>new Array()</code>创建一个空数组。但是，我建议总是使用<code>[]</code>。</p>
<h4 id="28122-array的静态方法">28.12.2。 <code>Array</code>的静态方法</h4>
<ul>
<li> <p><code>Array.from&lt;T&gt;(iterable: Iterable&lt;T&gt; | ArrayLike&lt;T&gt;): T[]</code> [ES6]</p> </li>
<li> <p><code>Array.from&lt;T,U&gt;(iterable: Iterable&lt;T&gt; | ArrayLike&lt;T&gt;, mapFunc: (v: T, k: number) =&gt; U, thisArg?: any): U[]</code> [ES6]</p> <p>将可迭代或类似 Array 的对象转换为 Array。可选地，输入值可以在添加到输出数组之前通过<code>mapFunc</code>进行转换。</p> <p>类数组对象具有<code>.length</code>和索引属性（粗略地，非负整数的字符串表示）：</p> <pre><code class="language-js">interface ArrayLike&lt;T&gt; {
  length: number;
  [n: number]: T;
}
</code></pre> <p>例子：</p> <pre><code class="language-js">&gt; Array.from(new Set(['a', 'b']))
[ 'a', 'b' ]
&gt; Array.from({length: 2, 0:'a', 1:'b'})
[ 'a', 'b' ]
</code></pre> </li>
<li> <p><code>Array.of&lt;T&gt;(...items: T[]): T[]</code> [ES6]</p> <p>这个静态方法主要用于<code>Array</code>和 Typed Arrays 的子类，它用作自定义数组字面值：</p> <pre><code class="language-js">assert.equal(
  Uint8Array.of(1, 2, 3) instanceof Uint8Array, true);
</code></pre> </li>
</ul>
<h4 id="28123-arraytprototype的方法">28.12.3。 <code>Array&lt;T&gt;.prototype</code>的方法</h4>
<ul>
<li> <p><code>.concat(...items: Array&lt;T[] | T&gt;): T[]</code> [R，ES3]</p> <p>返回一个新的 Array，它是接收器和所有<code>items</code>的串联。非数组参数被视为具有单个元素的数组。</p> <pre><code class="language-js">&gt; ['a'].concat('b', ['c', 'd'])
[ 'a', 'b', 'c', 'd' ]
</code></pre> </li>
<li> <p><code>.copyWithin(target: number, start: number, end=this.length): this</code> [W，ES6]</p> <p>将索引范围从<code>start</code>到（excel。）<code>end</code>的元素复制到以<code>target</code>开头的索引。正确处理重叠。</p> <pre><code class="language-js">&gt; ['a', 'b', 'c', 'd'].copyWithin(0, 2, 4)
[ 'c', 'd', 'c', 'd' ]
</code></pre> </li>
<li> <p><code>.entries(): Iterable&lt;[number, T]&gt;</code> [R，ES6]</p> <p>返回[index，element]对上的可迭代。</p> <pre><code class="language-js">&gt; Array.from(['a', 'b'].entries())
[ [ 0, 'a' ], [ 1, 'b' ] ]
</code></pre> </li>
<li> <p><code>.every(callback: (value: T, index: number, array: Array&lt;T&gt;) =&gt; boolean, thisArg?: any): boolean</code> [R，ES5]</p> <p>如果<code>callback</code>为每个元素和<code>false</code>返回<code>true</code>，则返回<code>true</code>，否则返回。收到<code>false</code>后立即停止。该方法对应于数学中的通用量化（对于所有，<code>∀</code>）。</p> <pre><code class="language-js">&gt; [1, 2, 3].every(x =&gt; x &gt; 0)
true
&gt; [1, -2, 3].every(x =&gt; x &gt; 0)
false
</code></pre> </li>
<li> <p><code>.fill(value: T, start=0, end=this.length): this</code> [W，ES6]</p> <p>将<code>value</code>分配给（incl。）<code>start</code>和（excl。）<code>end</code>之间的每个索引。</p> <pre><code class="language-js">&gt; [0, 1, 2].fill('a')
[ 'a', 'a', 'a' ]
</code></pre> </li>
<li> <p><code>.filter(callback: (value: T, index: number, array: Array&lt;T&gt;) =&gt; any, thisArg?: any): T[]</code> [R，ES5]</p> <p>返回一个只包含<code>callback</code>返回<code>true</code>的元素的数组。</p> <pre><code class="language-js">&gt; [1, -2, 3].filter(x =&gt; x &gt; 0)
[ 1, 3 ]
</code></pre> </li>
<li> <p><code>.find(predicate: (value: T, index: number, obj: T[]) =&gt; boolean, thisArg?: any): T | undefined</code> [R，ES6]</p> <p>结果是<code>predicate</code>返回<code>true</code>的第一个元素。如果它永远不会，结果是<code>undefined</code>。</p> <pre><code class="language-js">&gt; [1, -2, 3].find(x =&gt; x &lt; 0)
-2
&gt; [1, 2, 3].find(x =&gt; x &lt; 0)
undefined
</code></pre> </li>
<li> <p><code>.findIndex(predicate: (value: T, index: number, obj: T[]) =&gt; boolean, thisArg?: any): number</code> [R，ES6]</p> <p>结果是<code>predicate</code>返回<code>true</code>的第一个元素的索引。如果它永远不会，结果是<code>-1</code>。</p> <pre><code class="language-js">&gt; [1, -2, 3].findIndex(x =&gt; x &lt; 0)
1
&gt; [1, 2, 3].findIndex(x =&gt; x &lt; 0)
-1
</code></pre> </li>
<li> <p><code>.flat(depth = 1): any[]</code> [R，ES2019]</p> <p>“展平”数组：它创建数组的副本，其中嵌套数组中的值都出现在顶层。参数<code>depth</code>控制<code>.flat()</code>查找非数组值的深度。</p> <pre><code class="language-js">&gt; [ 1,2, [3,4], [[5,6]] ].flat(0) // no change
[ 1, 2, [ 3, 4 ], [ [ 5, 6 ] ] ]

&gt; [ 1,2, [3,4], [[5,6]] ].flat(1)
[ 1, 2, 3, 4, [ 5, 6 ] ]

&gt; [ 1,2, [3,4], [[5,6]] ].flat(2)
[ 1, 2, 3, 4, 5, 6 ]
</code></pre> </li>
<li> <p><code>.flatMap&lt;U&gt;(callback: (value: T, index: number, array: T[]) =&gt; U|Array&lt;U&gt;, thisValue?: any): U[]</code> [R，ES2019]</p> <p>通过为原始 Array 的每个元素调用<code>callback()</code>并连接它返回的 Arrays 来生成结果。</p> <pre><code class="language-js">&gt; ['a', 'b', 'c'].flatMap(x =&gt; [x,x])
[ 'a', 'a', 'b', 'b', 'c', 'c' ]
&gt; ['a', 'b', 'c'].flatMap(x =&gt; [x])
[ 'a', 'b', 'c' ]
&gt; ['a', 'b', 'c'].flatMap(x =&gt; [])
[]
</code></pre> </li>
<li> <p><code>.forEach(callback: (value: T, index: number, array: Array&lt;T&gt;) =&gt; void, thisArg?: any): void</code> [R，ES5]</p> <p>为每个元素调用<code>callback</code>。</p> <pre><code class="language-js">['a', 'b'].forEach((x, i) =&gt; console.log(x, i))

// Output:
// 'a', 0
// 'b', 1
</code></pre> </li>
<li> <p><code>.includes(searchElement: T, fromIndex=0): boolean</code> [R，ES2016]</p> <p>如果接收器具有值为<code>searchElement</code>和<code>false</code>的元素，则返回<code>true</code>。搜索从索引<code>fromIndex</code>开始。</p> <pre><code class="language-js">&gt; [0, 1, 2].includes(1)
true
&gt; [0, 1, 2].includes(5)
false
</code></pre> </li>
<li> <p><code>.indexOf(searchElement: T, fromIndex=0): number</code> [R，ES5]</p> <p>返回严格等于<code>searchElement</code>的第一个元素的索引。如果没有这样的元素，则返回<code>-1</code>。开始在索引<code>fromIndex</code>搜索，然后访问更高的索引。</p> <pre><code class="language-js">&gt; ['a', 'b', 'a'].indexOf('a')
0
&gt; ['a', 'b', 'a'].indexOf('a', 1)
2
&gt; ['a', 'b', 'a'].indexOf('c')
-1
</code></pre> </li>
<li> <p><code>.join(separator = ','): string</code> [R，ES1]</p> <p>通过连接所有元素的字符串表示形式创建一个字符串，用<code>separator</code>分隔它们。</p> <pre><code class="language-js">&gt; ['a', 'b', 'c'].join('##')
'a##b##c'
&gt; ['a', 'b', 'c'].join()
'a,b,c'
</code></pre> </li>
<li> <p><code>.keys(): Iterable&lt;number&gt;</code> [R，ES6]</p> <p>返回接收器的键上的可迭代。</p> <pre><code class="language-js">&gt; [...['a', 'b'].keys()]
[ 0, 1 ]
</code></pre> </li>
<li> <p><code>.lastIndexOf(searchElement: T, fromIndex=this.length-1): number</code> [R，ES5]</p> <p>返回严格等于<code>searchElement</code>的最后一个元素的索引。如果没有这样的元素，则返回<code>-1</code>。开始在索引<code>fromIndex</code>搜索，然后访问较低的索引。</p> <pre><code class="language-js">&gt; ['a', 'b', 'a'].lastIndexOf('a')
2
&gt; ['a', 'b', 'a'].lastIndexOf('a', 1)
0
&gt; ['a', 'b', 'a'].lastIndexOf('c')
-1
</code></pre> </li>
<li> <p><code>.map&lt;U&gt;(mapFunc: (value: T, index: number, array: Array&lt;T&gt;) =&gt; U, thisArg?: any): U[]</code> [R，ES5]</p> <p>返回一个新的 Array，其中每个元素都是<code>mapFunc</code>应用于接收器的相应元素的结果。</p> <pre><code class="language-js">&gt; [1, 2, 3].map(x =&gt; x * 2)
[ 2, 4, 6 ]
&gt; ['a', 'b', 'c'].map((x, i) =&gt; i)
[ 0, 1, 2 ]
</code></pre> </li>
<li> <p><code>.pop(): T | undefined</code> [W，ES3]</p> <p>删除并返回接收器的最后一个元素。也就是说，它将接收器的末尾视为堆栈。与<code>.push()</code>相反。</p> <pre><code class="language-js">&gt; const arr = ['a', 'b', 'c'];
&gt; arr.pop()
'c'
&gt; arr
[ 'a', 'b' ]
</code></pre> </li>
<li> <p><code>.push(...items: T[]): number</code> [W，ES3]</p> <p>在接收器的末尾添加零个或多个<code>items</code>。也就是说，它将接收器的末尾视为堆栈。返回值是更改后接收器的长度。与<code>.pop()</code>相反。</p> <pre><code class="language-js">&gt; const arr = ['a', 'b'];
&gt; arr.push('c', 'd')
4
&gt; arr
[ 'a', 'b', 'c', 'd' ]
</code></pre> </li>
<li> <p><code>.reduce&lt;U&gt;(callback: (accumulator: U, element: T, index: number, array: T[]) =&gt; U, init?: U): U</code> [R，ES5]</p> <p>此方法生成接收器的摘要：它将所有 Array 元素提供给<code>callback</code>，它将当前中间结果（在参数<code>accumulator</code>中）与当前 Array 元素组合并返回下一个<code>accumulator</code>：</p> <pre><code class="language-js">const accumulator_0 = callback(init, arr[0]);
const accumulator_1 = callback(accumulator_0, arr[1]);
const accumulator_2 = callback(accumulator_1, arr[2]);
// Etc.
</code></pre> <p><code>.reduce()</code>的结果是访问所有 Array 元素后<code>callback</code>的最后结果。</p> <p>如果未提供<code>init</code>，则使用索引 0 处的 Array 元素。</p> <pre><code class="language-js">&gt; [1, 2, 3].reduce((accu, x) =&gt; accu + x, 0)
6
&gt; [1, 2, 3].reduce((accu, x) =&gt; accu + String(x), '')
'123'
</code></pre> </li>
<li> <p><code>.reduceRight&lt;U&gt;(callback: (accumulator: U, element: T, index: number, array: T[]) =&gt; U, init?: U): U</code> [R，ES5]</p> <p>像<code>.reduce()</code>一样工作，但是从最后一个元素开始向后访问 Array 元素。</p> <pre><code class="language-js">&gt; [1, 2, 3].reduceRight((accu, x) =&gt; accu + String(x), '')
'321'
</code></pre> </li>
<li> <p><code>.reverse(): this</code> [W，ES1]</p> <p>重新排列接收器的元素，使它们的顺序相反，然后返回接收器。</p> <pre><code class="language-js">&gt; const arr = ['a', 'b', 'c'];
&gt; arr.reverse()
[ 'c', 'b', 'a' ]
&gt; arr
[ 'c', 'b', 'a' ]
</code></pre> </li>
<li> <p><code>.shift(): T | undefined</code> [W，ES3]</p> <p>删除并返回接收器的第一个元素。与<code>.unshift()</code>相反。</p> <pre><code class="language-js">&gt; const arr = ['a', 'b', 'c'];
&gt; arr.shift()
'a'
&gt; arr
[ 'b', 'c' ]
</code></pre> </li>
<li> <p><code>.slice(start=0, end=this.length): T[]</code> [R，ES3]</p> <p>返回一个新的 Array，包含接收器的元素，其索引在（incl。）<code>start</code>和（excl。）<code>end</code>之间。</p> <pre><code class="language-js">&gt; ['a', 'b', 'c', 'd'].slice(1, 3)
[ 'b', 'c' ]
&gt; ['a', 'b'].slice() // shallow copy
[ 'a', 'b' ]
</code></pre> </li>
<li> <p><code>.some(callback: (value: T, index: number, array: Array&lt;T&gt;) =&gt; boolean, thisArg?: any): boolean</code> [R，ES5]</p> <p>如果<code>callback</code>为至少一个元素返回<code>true</code>，则返回<code>true</code>，否则返回<code>false</code>。收到<code>true</code>后立即停止。该方法对应于数学中的存在量化（存在，<code>∃</code>）。</p> <pre><code class="language-js">&gt; [1, 2, 3].some(x =&gt; x &lt; 0)
false
&gt; [1, -2, 3].some(x =&gt; x &lt; 0)
true
</code></pre> </li>
<li> <p><code>.sort(compareFunc?: (a: T, b: T) =&gt; number): this</code> [W，ES1]</p> <p>对接收器进行排序并将其返回。从 ECMAScript 2019 开始，保证排序是稳定的：如果通过排序认为元素相等，那么排序不会改变这些元素的顺序（相对于彼此）。</p> <p>默认情况下，它对元素的字符串表示进行排序。它按字典顺序并根据字符的代码单元值（字符代码）执行：</p> <pre><code class="language-js">&gt; ['pie', 'cookie', 'éclair', 'Pie', 'Cookie', 'Éclair'].sort()
[ 'Cookie', 'Pie', 'cookie', 'pie', 'Éclair', 'éclair' ]
&gt; [200, 3, 10].sort()
[ 10, 200, 3 ]
</code></pre> <p>您可以通过<code>compareFunc</code>自定义排序顺序，它会返回一个数字：</p>
<ul>
<li>否定如果<code>a &lt; b</code></li>
<li>如果<code>a === b</code>为零</li>
<li>如果<code>a &gt; b</code>为正</li>
</ul> <p>排序数字的伎俩（有数字溢出的风险）：</p> <pre><code class="language-js">&gt; [200, 3, 10].sort((a, b) =&gt; a - b)
[ 3, 10, 200 ]
</code></pre> </li>
<li> <p><code>.splice(start: number, deleteCount=this.length-start, ...items: T[]): T[]</code> [W，ES3]</p> <p>在索引<code>start</code>处，它删除<code>deleteCount</code>元素并插入<code>items</code>。它返回已删除的元素。</p> <pre><code class="language-js">&gt; const arr = ['a', 'b', 'c', 'd'];
&gt; arr.splice(1, 2, 'x', 'y')
[ 'b', 'c' ]
&gt; arr
[ 'a', 'x', 'y', 'd' ]
</code></pre> </li>
<li> <p><code>.toString(): string</code> [R，ES1]</p> <p>返回一个字符串，其中包含所有元素的字符串，以逗号分隔。</p> <pre><code class="language-js">&gt; [1, 2, 3].toString()
'1,2,3'
&gt; ['a', 'b', 'c'].toString()
'a,b,c'
&gt; [].toString()
''
</code></pre> </li>
<li> <p><code>.unshift(...items: T[]): number</code> [W，ES3]</p> <p>在接收器的开头插入<code>items</code>并在此修改后返回其长度。</p> <pre><code class="language-js">&gt; const arr = ['c', 'd'];
&gt; arr.unshift('e', 'f')
4
&gt; arr
[ 'e', 'f', 'c', 'd' ]
</code></pre> </li>
<li> <p><code>.values(): Iterable&lt;T&gt;</code> [R，ES6]</p> <p>返回接收器值的可迭代。</p> <pre><code class="language-js">&gt; [...['a', 'b'].values()]
[ 'a', 'b' ]
</code></pre> </li>
</ul>
<h4 id="28124来源">28.12.4。来源</h4>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript/blob/master/lib/">TypeScript 的内置打字</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">适用于 JavaScript 的 MDN 网络文档</a></li>
<li><a href="https://tc39.github.io/ecma262/">ECMAScript 语言规范</a></li>
</ul>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/bf533f04c482f83bfc407f318306f995.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/bf533f04c482f83bfc407f318306f995.svg" alt=""></a> <strong>测验</strong></p>
<p>参见<a href="ch_quizzes-exercises.html#quizzes">测验应用程序</a>。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/53/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/53/index.html">前端开发者指南 2018</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/30.html">稀土</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">103页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 282个">282</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/61/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/61/index.html">前端开发者手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/37.html">dwqs</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 548个">548</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/72/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/72/index.html">前端开发规范手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/45.html">Aaaaaashu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 693个">693</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/132/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/vuejs_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/132/index.html">vue-router文档</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/71.html">srzyhead</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="vuejs">vuejs</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">30页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 0个">0</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/188/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/git_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/188/index.html">git基本概念，git flow，git提交规范，git插件以及常见问题解决</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="git">git</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/11/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/gradle_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/11/index.html">Gradle实战</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/7.html">EZLippi</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="gradle">gradle</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">37页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 299个">299</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/171/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/171/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/1.html" title="I.背景" data-book-page-rel-url="docs/1.html" data-book-page-id="11641">I.背景</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/2.html" title="1.关于本书（ES2019 版）" data-book-page-rel-url="docs/2.html" data-book-page-id="11642">1.关于本书（ES2019 版）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/3.html" title="2.常见问题：本书" data-book-page-rel-url="docs/3.html" data-book-page-id="11643">2.常见问题：本书</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/4.html" title="3. JavaScript 的历史和演变" data-book-page-rel-url="docs/4.html" data-book-page-id="11644">3. JavaScript 的历史和演变</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/5.html" title="4.常见问题：JavaScript" data-book-page-rel-url="docs/5.html" data-book-page-id="11645">4.常见问题：JavaScript</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/6.html" title="II.第一步" data-book-page-rel-url="docs/6.html" data-book-page-id="11646">II.第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/7.html" title="5.概览" data-book-page-rel-url="docs/7.html" data-book-page-id="11647">5.概览</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/8.html" title="6.语法" data-book-page-rel-url="docs/8.html" data-book-page-id="11648">6.语法</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/9.html" title="7.在控制台上打印信息（`console.*`）" data-book-page-rel-url="docs/9.html" data-book-page-id="11649">7.在控制台上打印信息（`console.*`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/10.html" title="8.断言 API" data-book-page-rel-url="docs/10.html" data-book-page-id="11650">8.断言 API</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/11.html" title="9.测验和练习入门" data-book-page-rel-url="docs/11.html" data-book-page-id="11651">9.测验和练习入门</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/12.html" title="III.变量和值" data-book-page-rel-url="docs/12.html" data-book-page-id="11652">III.变量和值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/13.html" title="10.变量和赋值" data-book-page-rel-url="docs/13.html" data-book-page-id="11653">10.变量和赋值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/14.html" title="11.值" data-book-page-rel-url="docs/14.html" data-book-page-id="11654">11.值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/15.html" title="12.运算符" data-book-page-rel-url="docs/15.html" data-book-page-id="11655">12.运算符</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/16.html" title="IV.原始值" data-book-page-rel-url="docs/16.html" data-book-page-id="11656">IV.原始值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/17.html" title="13.非值`undefined`和`null`" data-book-page-rel-url="docs/17.html" data-book-page-id="11657">13.非值`undefined`和`null`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/18.html" title="14.布尔值" data-book-page-rel-url="docs/18.html" data-book-page-id="11658">14.布尔值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/19.html" title="15.数字" data-book-page-rel-url="docs/19.html" data-book-page-id="11659">15.数字</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/20.html" title="16. `Math`" data-book-page-rel-url="docs/20.html" data-book-page-id="11660">16. `Math`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/21.html" title="17. Unicode - 简要介绍（高级）" data-book-page-rel-url="docs/21.html" data-book-page-id="11661">17. Unicode - 简要介绍（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/22.html" title="18.字符串" data-book-page-rel-url="docs/22.html" data-book-page-id="11662">18.字符串</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/23.html" title="19.使用模板字面值和标记模板" data-book-page-rel-url="docs/23.html" data-book-page-id="11663">19.使用模板字面值和标记模板</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/24.html" title="20.符号" data-book-page-rel-url="docs/24.html" data-book-page-id="11664">20.符号</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/25.html" title="V.控制流和数据流" data-book-page-rel-url="docs/25.html" data-book-page-id="11665">V.控制流和数据流</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/26.html" title="21.控制流语句" data-book-page-rel-url="docs/26.html" data-book-page-id="11666">21.控制流语句</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/27.html" title="22.异常处理" data-book-page-rel-url="docs/27.html" data-book-page-id="11667">22.异常处理</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/28.html" title="23.可调用值" data-book-page-rel-url="docs/28.html" data-book-page-id="11668">23.可调用值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/29.html" title="VI.模块化" data-book-page-rel-url="docs/29.html" data-book-page-id="11669">VI.模块化</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/30.html" title="24.模块" data-book-page-rel-url="docs/30.html" data-book-page-id="11670">24.模块</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/31.html" title="25.单个对象" data-book-page-rel-url="docs/31.html" data-book-page-id="11671">25.单个对象</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/32.html" title="26.原型链和类" data-book-page-rel-url="docs/32.html" data-book-page-id="11672">26.原型链和类</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/33.html" title="七.集合" data-book-page-rel-url="docs/33.html" data-book-page-id="11673">七.集合</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/34.html" title="27.同步迭代" data-book-page-rel-url="docs/34.html" data-book-page-id="11674">27.同步迭代</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/35.html" title="28.数组（`Array`）" data-book-page-rel-url="docs/35.html" data-book-page-id="11675">28.数组（`Array`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/36.html" title="29.类型化数组：处理二进制数据（高级）" data-book-page-rel-url="docs/36.html" data-book-page-id="11676">29.类型化数组：处理二进制数据（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/37.html" title="30.映射（`Map`）" data-book-page-rel-url="docs/37.html" data-book-page-id="11677">30.映射（`Map`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/38.html" title="31. WeakMaps（`WeakMap`）" data-book-page-rel-url="docs/38.html" data-book-page-id="11678">31. WeakMaps（`WeakMap`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/39.html" title="32.集（`Set`）" data-book-page-rel-url="docs/39.html" data-book-page-id="11679">32.集（`Set`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/40.html" title="33. WeakSets（`WeakSet`）" data-book-page-rel-url="docs/40.html" data-book-page-id="11680">33. WeakSets（`WeakSet`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/41.html" title="34.解构" data-book-page-rel-url="docs/41.html" data-book-page-id="11681">34.解构</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/42.html" title="35.同步生成器（高级）" data-book-page-rel-url="docs/42.html" data-book-page-id="11682">35.同步生成器（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/43.html" title="八.异步" data-book-page-rel-url="docs/43.html" data-book-page-id="11683">八.异步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/44.html" title="36. JavaScript 中的异步编程" data-book-page-rel-url="docs/44.html" data-book-page-id="11684">36. JavaScript 中的异步编程</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/45.html" title="37.异步编程的 Promise" data-book-page-rel-url="docs/45.html" data-book-page-id="11685">37.异步编程的 Promise</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/46.html" title="38.异步函数" data-book-page-rel-url="docs/46.html" data-book-page-id="11686">38.异步函数</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/47.html" title="IX.更多标准库" data-book-page-rel-url="docs/47.html" data-book-page-id="11687">IX.更多标准库</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/48.html" title="39.正则表达式（`RegExp`）" data-book-page-rel-url="docs/48.html" data-book-page-id="11688">39.正则表达式（`RegExp`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/49.html" title="40.日期（`Date`）" data-book-page-rel-url="docs/49.html" data-book-page-id="11689">40.日期（`Date`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/50.html" title="41.创建和解析 JSON（`JSON`）" data-book-page-rel-url="docs/50.html" data-book-page-id="11690">41.创建和解析 JSON（`JSON`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/51.html" title="42.其余章节在哪里？" data-book-page-rel-url="docs/51.html" data-book-page-id="11691">42.其余章节在哪里？</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =171;var bookPageId =11675;var bookPageRelUrl ='docs/35.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>