
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>26.原型链和类-[译] 写给不耐烦程序员的 JavaScript</title>
<meta content='26.原型链和类,[译] 写给不耐烦程序员的 JavaScript' name='keywords'>
<meta content='26.原型链和类,[译] 写给不耐烦程序员的 JavaScript' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/171/docs/31.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">25.单个对象</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/171/docs/33.html">
<span class="">七.集合</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/171/index.html">[译] 写给不耐烦程序员的 JavaScript</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/impatient-js-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h2 id="26原型链和类">26.原型链和类</h2>
<blockquote>
<p>原文： <a href="http://exploringjs.com/impatient-js/ch_proto-chains-classes.html">http://exploringjs.com/impatient-js/ch_proto-chains-classes.html</a></p>
</blockquote>
<p>在本书中，JavaScript 的面向对象编程（OOP）风格分四步介绍。本章包括步骤 2-4，<a href="ch_single-objects.html">前一章</a>涵盖步骤 1.步骤为（图 <a href="#fig:oop_steps2">8</a> ）：</p>
<ol>
<li>单个对象：_ 对象 _（JavaScript 的基本 OOP 构建块）如何独立工作？</li>
<li>**原型链：**每个对象都有一个零个或多个 _ 原型对象链 _。原型是 JavaScript 的核心继承机制。</li>
<li><strong>类：</strong> JavaScript 的 _ 类 _ 是对象的工厂。类及其实例之间的关系基于原型继承。</li>
<li><strong>子类化：</strong> _ 亚类 _ 与其 _ 超类 _ 之间的关系也是基于原型继承。</li>
</ol>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/e1cac10143c67068f2a509776d766f98.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/e1cac10143c67068f2a509776d766f98.svg" alt="Figure 8: This book introduces object-oriented programming in JavaScript in four steps."></a></p>
<p>Figure 8: This book introduces object-oriented programming in JavaScript in four steps.</p>
<h3 id="261原型链">26.1。原型链</h3>
<p>原型是 JavaScript 唯一的继承机制：每个对象都有一个原型，它是<code>null</code>或一个对象。在后一种情况下，对象继承了所有原型的属性。</p>
<p>在对象字面值中，您可以通过特殊属性<code>__proto__</code>设置原型：</p>
<pre><code class="language-js">const proto = {
  protoProp: 'a',
};
const obj = {
  __proto__: proto,
  objProp: 'b',
};

// obj inherits .protoProp:
assert.equal(obj.protoProp, 'a');
assert.equal('protoProp' in obj, true);
</code></pre>
<p>鉴于原型对象本身可以拥有原型，我们得到了一系列对象 - 所谓的 _ 原型链 _。这意味着继承给我们的印象是我们正在处理单个对象，但实际上我们处理的是对象链。</p>
<p>图 <a href="#fig:oo_proto_chain">9</a> 显示<code>obj</code>的原型链是什么样的。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/02de2628368fc24cf01200b28bf0d3dc.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/02de2628368fc24cf01200b28bf0d3dc.svg" alt="Figure 9: obj starts a chain of objects that continues with proto and other objects."></a></p>
<p>Figure 9: <code>obj</code> starts a chain of objects that continues with <code>proto</code> and other objects.</p>
<p>非继承属性称为 _ 自己的属性 _。 <code>obj</code>有一个属性<code>.objProp</code>。</p>
<h4 id="2611陷阱只有原型链的第一个成员发生了变异">26.1.1。陷阱：只有原型链的第一个成员发生了变异</h4>
<p>可能违反直觉的原型链的一个方面是通过对象设置 _ 任何 _ 属性 - 甚至是继承的 - 仅改变该对象 - 从不是原型之一。</p>
<p>考虑以下对象<code>obj</code>：</p>
<pre><code class="language-js">const proto = {
  protoProp: 'a',
};
const obj = {
  __proto__: proto,
  objProp: 'b',
};
</code></pre>
<p>当我们在行 A 中设置继承属性<code>obj.protoProp</code>时，我们通过创建自己的属性来“更改”它：当读取<code>obj.protoProp</code>时，首先找到自己的属性，它的值将覆盖继承属性的值。</p>
<pre><code class="language-js">assert.deepEqual(Object.keys(obj), ['objProp']);

obj.protoProp = 'x'; // (A)

// We created a new own property:
assert.deepEqual(Object.keys(obj), ['objProp', 'protoProp']);

// The inherited property itself is unchanged:
assert.equal(proto.protoProp, 'a');
</code></pre>
<p><code>obj</code>的原型链如图 2 所示。 <a href="#fig:oo_overriding">10</a> 。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/a9009db57e62df365c82084eb1af21bd.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/a9009db57e62df365c82084eb1af21bd.svg" alt="Figure 10: The own property .protoProp of obj overrides the property inherited from proto."></a></p>
<p>Figure 10: The own property <code>.protoProp</code> of <code>obj</code> overrides the property inherited from <code>proto</code>.</p>
<h4 id="2612使用原型的提示高级">26.1.2。使用原型的提示（高级）</h4>
<h5 id="26121避免--proto--除了对象字面值">26.1.2.1。避免<code>__proto__</code>（除了对象字面值）</h5>
<p>我建议避免使用特殊属性<code>__proto__</code>：它是通过<code>Object.prototype</code>中的 getter 和 setter 实现的，因此只有在<code>Object.prototype</code>位于对象的原型链中时才可用。通常情况就是如此，但为了安全起见，您可以使用以下替代方案：</p>
<ul>
<li> <p>设置原型的最佳方法是创建对象。例如。通过：</p> <pre><code class="language-js">Object.create(proto: Object) : Object
</code></pre> <p>如果必须，可以使用<code>Object.setPrototypeOf()</code>更改现有对象的原型。</p> </li>
<li> <p>获取原型的最佳方法是通过以下方法：</p> <pre><code class="language-js">Object.getPrototypeOf(obj: Object) : Object
</code></pre> </li>
</ul>
<p>以下是这些功能的使用方法：</p>
<pre><code class="language-js">const proto1 = {};
const proto2 = {};

const obj = Object.create(proto1);
assert.equal(Object.getPrototypeOf(obj), proto1);

Object.setPrototypeOf(obj, proto2);
assert.equal(Object.getPrototypeOf(obj), proto2);
</code></pre>
<p>请注意，对象字面值中的<code>__proto__</code>是不同的。在那里，它是一个内置功能，总是安全使用。</p>
<h5 id="26122检查对象是另一个的原型吗">26.1.2.2。检查：对象是另一个的原型吗？</h5>
<p>更宽松的定义“<code>o</code>是<code>p</code>的原型”是“<code>o</code>在<code>p</code>的原型链中”。可以通过以下方式检查此关系：</p>
<pre><code class="language-js">p.isPrototypeOf(o)
</code></pre>
<p>例如：</p>
<pre><code class="language-js">const p = {};
const o = {__proto__: p};

assert.equal(p.isPrototypeOf(o), true);
assert.equal(o.isPrototypeOf(p), false);

// Object.prototype is almost always in the prototype chain
// (more on that later)
assert.equal(Object.prototype.isPrototypeOf(p), true);
</code></pre>
<h4 id="2613通过原型共享数据">26.1.3。通过原型共享数据</h4>
<p>请考虑以下代码：</p>
<pre><code class="language-js">const jane = {
  name: 'Jane',
  describe() {
    return 'Person named '+this.name;
  },
};
const tarzan = {
  name: 'Tarzan',
  describe() {
    return 'Person named '+this.name;
  },
};

assert.equal(jane.describe(), 'Person named Jane');
assert.equal(tarzan.describe(), 'Person named Tarzan');
</code></pre>
<p>我们有两个非常相似的对象。两者都有两个属性，其名称为<code>.name</code>和<code>.describe</code>。另外，方法<code>.describe()</code>是相同的。我们怎样才能避免重复该方法？</p>
<p>我们可以将它移动到共享原型，<code>PersonProto</code>：</p>
<pre><code class="language-js">const PersonProto = {
  describe() {
    return 'Person named ' + this.name;
  },
};
const jane = {
  __proto__: PersonProto,
  name: 'Jane',
};
const tarzan = {
  __proto__: PersonProto,
  name: 'Tarzan',
};
</code></pre>
<p>原型的名称反映出<code>jane</code>和<code>tarzan</code>都是人。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/dc382a1fdb61290ed049c61f26cf43ad.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/dc382a1fdb61290ed049c61f26cf43ad.svg" alt="Figure 11: Objects jane and tarzan share method .describe(), via their common prototype PersonProto."></a></p>
<p>Figure 11: Objects <code>jane</code> and <code>tarzan</code> share method <code>.describe()</code>, via their common prototype <code>PersonProto</code>.</p>
<p>图中的图表 <a href="#fig:oo_person_shared">11</a> 说明了三个对象是如何连接的：底部的对象现在包含特定于<code>jane</code>和<code>tarzan</code>的属性。顶部的对象包含它们之间共享的属性。</p>
<p>当您调用方法<code>jane.describe()</code>时，<code>this</code>指向该方法调用的接收者，<code>jane</code>（在图的左下角）。这就是该方法仍然有效的原因。当你打调用给<code>tarzan.describe()</code>时会发生类似的事情。</p>
<pre><code class="language-js">assert.equal(jane.describe(), 'Person named Jane');
assert.equal(tarzan.describe(), 'Person named Tarzan');
</code></pre>
<h3 id="262类">26.2。类</h3>
<p>我们现在准备接受类，这基本上是用于设置原型链的紧凑语法。虽然他们的基础可能是非常规的，但是如果您以前使用过面向对象的语言，那么使用 JavaScript 的类仍然应该感觉很熟悉。</p>
<h4 id="2621一类人">26.2.1。一类人</h4>
<p>我们之前使用过<code>jane</code>和<code>tarzan</code>，代表人物的单个对象。让我们用一个班来为人们实施一个工厂：</p>
<pre><code class="language-js">class Person {
  constructor(name) {
    this.name = name;
  }
  describe() {
    return 'Person named '+this.name;
  }
}
</code></pre>
<p>现在可以通过<code>new Person()</code>创建<code>jane</code>和<code>tarzan</code>：</p>
<pre><code class="language-js">const jane = new Person('Jane');
assert.equal(jane.describe(), 'Person named Jane');

const tarzan = new Person('Tarzan');
assert.equal(tarzan.describe(), 'Person named Tarzan');
</code></pre>
<h4 id="2622类表达式">26.2.2。类表达式</h4>
<p>前一个类定义是 _ 类声明 _。还有 _ 匿名类表达式 _：</p>
<pre><code class="language-js">const Person = class { ··· };
</code></pre>
<p>并且 _ 命名了类表达式 _：</p>
<pre><code class="language-js">const Person = class MyClass { ··· };
</code></pre>
<h4 id="2623引擎盖下的课程高级">26.2.3。引擎盖下的课程（高级）</h4>
<p>在课程的引擎下有很多事情要做。让我们看一下<code>jane</code>的图表（图 <a href="#fig:oo_person_class">12</a> ）。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/777de5d75ebd225ed6fb6ee6409bb74b.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/777de5d75ebd225ed6fb6ee6409bb74b.svg" alt="Figure 12: The class Person has the property .prototype that points to an object that is the prototype of all instances of Person. jane is one such instance."></a></p>
<p>Figure 12: The class <code>Person</code> has the property <code>.prototype</code> that points to an object that is the prototype of all instances of <code>Person</code>. <code>jane</code> is one such instance.</p>
<p>类<code>Person</code>的主要目的是在右侧设置原型链（<code>jane</code>，然后是<code>Person.prototype</code>）。值得注意的是，类<code>Person</code>（<code>.constructor</code>和<code>.describe()</code>）内的两个构造都为<code>Person.prototype</code>创建了属性，而不是<code>Person</code>。</p>
<p>这种稍微奇怪的方法的原因是向后兼容性：在类之前，_ 构造函数 _（<a href="ch_callables.html#roles-of-ordinary-functions">普通函数</a>，通过<code>new</code>运算符调用）通常用作对象的工厂。类通常是构造函数的更好语法，因此与旧代码保持兼容。这解释了为什么类是函数：</p>
<pre><code class="language-js">&gt; typeof Person
'function'
</code></pre>
<p>在本书中，我可以互换地使用术语 _ 构造函数（函数）_ 和 _ 类 _。</p>
<p>很多人混淆<code>.__proto__</code>和<code>.prototype</code>。希望图中的图表。 <a href="#fig:oo_person_class">12</a> 清楚说明了它们的区别：</p>
<ul>
<li><code>.__proto__</code>是用于访问对象原型的特殊属性。</li>
<li><code>.prototype</code>是一个普通的属性，由于<code>new</code>操作符的使用方式，它只是特殊的。名称并不理想：<code>Person.prototype</code>没有指向<code>Person</code>的原型，它指向<code>Person</code>的所有实例的原型。</li>
</ul>
<h5 id="26231-personprototypeconstructor">26.2.3.1。 <code>Person.prototype.constructor</code></h5>
<p>图中有一个细节。 <a href="#fig:oo_person_class">12</a> 我们尚未查看，但是：<code>Person.prototype.constructor</code>指回<code>Person</code>：</p>
<pre><code class="language-js">&gt; Person.prototype.constructor === Person
true
</code></pre>
<p>由于历史原因，此设置也存在。但它也有两个好处。</p>
<p>首先，类的每个实例都继承属性<code>.constructor</code>。因此，给定一个实例，您可以通过它创建“类似”对象：</p>
<pre><code class="language-js">const jane = new Person('Jane');

const cheeta = new jane.constructor('Cheeta');
// cheeta is also an instance of Person
// (the instanceof operator is explained later)
assert.equal(cheeta instanceof Person, true);
</code></pre>
<p>其次，您可以获取创建给定实例的类的名称：</p>
<pre><code class="language-js">const tarzan = new Person('Tarzan');

assert.equal(tarzan.constructor.name, 'Person');
</code></pre>
<h4 id="2624类定义原型属性">26.2.4。类定义：原型属性</h4>
<p>以下代码演示了创建<code>Foo.prototype</code>属性的类定义<code>Foo</code>的所有部分：</p>
<pre><code class="language-js">class Foo {
  constructor(prop) {
    this.prop = prop;
  }
  protoMethod() {
    return 'protoMethod';
  }
  get protoGetter() {
    return 'protoGetter';
  }
}
</code></pre>
<p>让我们按顺序检查它们：</p>
<ul>
<li>在创建<code>Foo</code>的新实例后调用<code>.constructor()</code>来设置该实例。</li>
<li><code>.protoMethod()</code>是一种常规方法。它存储在<code>Foo.prototype</code>中。</li>
<li><code>.protoGetter</code>是存储在<code>Foo.prototype</code>中的吸气剂。</li>
</ul>
<p>以下交互使用类<code>Foo</code>：</p>
<pre><code class="language-js">&gt; const foo = new Foo(123);
&gt; foo.prop
123

&gt; foo.protoMethod()
'protoMethod'
&gt; foo.protoGetter
'protoGetter'
</code></pre>
<h4 id="2625类定义静态属性">26.2.5。类定义：静态属性</h4>
<p>下面的代码演示了类定义的所有部分，它们创建了所谓的 _ 静态属性 _ - 类本身的属性。</p>
<pre><code class="language-js">class Bar {
  static staticMethod() {
    return 'staticMethod';
  }
  static get staticGetter() {
    return 'staticGetter';
  }
}
</code></pre>
<p>静态方法和静态吸气剂使用如下。</p>
<pre><code class="language-js">&gt; Bar.staticMethod()
'staticMethod'
&gt; Bar.staticGetter
'staticGetter'
</code></pre>
<h4 id="2626-instanceof运算符">26.2.6。 <code>instanceof</code>运算符</h4>
<p><code>instanceof</code>运算符告诉您某个值是否是给定类的实例：</p>
<pre><code class="language-js">&gt; new Person('Jane') instanceof Person
true
&gt; ({}) instanceof Person
false
&gt; ({}) instanceof Object
true
&gt; [] instanceof Array
true
</code></pre>
<p>在我们查看子类化之后，我们将在后面中更详细地探索<code>instanceof</code>运算符。</p>
<h4 id="2627为什么我推荐课程">26.2.7。为什么我推荐课程</h4>
<p>我推荐使用类，原因如下：</p>
<ul>
<li>类是对象创建和继承的通用标准，现在跨框架（React，Angular，Ember 等）广泛支持。</li>
<li>他们帮助 IDE 和类型检查器等工具完成工作并启用新功能。</li>
<li>它们是未来功能的基础，例如值对象，不可变对象，装饰器等。</li>
<li>它们使新手更容易开始使用 JavaScript。</li>
<li>JavaScript 引擎优化它们。也就是说，使用类的代码通常比使用自定义继承库的代码更快。</li>
</ul>
<p>这并不意味着课程是完美的。我和他们有一个问题是：</p>
<ul>
<li>课程看起来与他们在幕后的不同。换句话说，语法和语义之间存在脱节。</li>
</ul>
<p>如果类是（语法）构造函数 _ 对象 _（<code>new</code> - 原型对象）而不是构造函数 _ 函数 _，那将是很好的。但后向兼容性是他们成为后者的正当理由。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：实现一个类</strong></p>
<p><code>exercises/proto-chains-classes/point_class_test.js</code></p>
<h3 id="263类的私有数据">26.3。类的私有数据</h3>
<p>本节描述了从外部隐藏对象的一些数据的技术。我们在类的上下文中讨论它们，但它们也适用于通过对象字面值等直接创建的对象。</p>
<h4 id="2631私有数据命名约定">26.3.1。私有数据：命名约定</h4>
<p>第一种技术通过在其名称前加下划线来使属性成为私有属性。这不会以任何方式保护财产;它只是向外界发出信号：“你不需要知道这个房产。”</p>
<p>在以下代码中，属性<code>._counter</code>和<code>._action</code>是私有的。</p>
<pre><code class="language-js">class Countdown {
  constructor(counter, action) {
    this._counter = counter;
    this._action = action;
  }
  dec() {
    if (this._counter &lt; 1) return;
    this._counter--;
    if (this._counter === 0) {
      this._action();
    }
  }
}

// The two properties aren’t really private:
assert.deepEqual(
  Reflect.ownKeys(new Countdown()),
  ['_counter', '_action']);
</code></pre>
<p>使用这种技术，您不会得到任何保护，私人名称可能会发生冲突。从好的方面来说，它很容易使用。</p>
<h4 id="2632私人数据weakmaps">26.3.2。私人数据：WeakMaps</h4>
<p>另一种技术是使用 WeakMaps。在<a href="ch_weakmaps.html#private-data-via-weakmaps">关于 WeakMaps</a> 的章节中解释了究竟是如何工作的。这是预览：</p>
<pre><code class="language-js">let _counter = new WeakMap();
let _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
    let counter = _counter.get(this);
    if (counter &lt; 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) {
      _action.get(this)();
    }
  }
}

// The two pseudo-properties are truly private:
assert.deepEqual(
  Reflect.ownKeys(new Countdown()),
  []);
</code></pre>
<p>这种技术为您提供了相当大的外部访问保护，并且不会有任何名称冲突。但使用起来也更复杂。</p>
<h4 id="2633更多私人数据技术">26.3.3。更多私人数据技术</h4>
<p>类的私有数据有更多技术。这些在<a href="http://exploringjs.com/es6/ch_classes.html#sec_private-data-for-classes">“探索 ES6”</a>中进行了解释。</p>
<p>本节没有深入探讨的原因是 JavaScript 可能很快就会内置对私有数据的支持。请参阅 ECMAScript 提案<a href="https://github.com/tc39/proposal-class-fields">“类公共实例字段＆amp;私有实例字段“</a>了解详情。</p>
<h3 id="264子类">26.4。子类</h3>
<p>类也可以子类化（“扩展”）现有类。例如，以下类<code>Employee</code>子类<code>Person</code>：</p>
<pre><code class="language-js">class Person {
  constructor(name) {
    this.name = name;
  }
  describe() {
    return `Person named ${this.name}`;
  }
  static logNames(persons) {
    for (const person of persons) {
      console.log(person.name);
    }
  }
}

class Employee extends Person {
  constructor(name, title) {
    super(name);
    this.title = title;
  }
  describe() {
    return super.describe() +
      ` (${this.title})`;
  }
}

const jane = new Employee('Jane', 'CTO');
assert.equal(
  jane.describe(),
  'Person named Jane (CTO)');
</code></pre>
<p>两条评论：</p>
<ul>
<li> <p>在<code>.constructor()</code>方法中，必须先通过<code>super()</code>调用超级构造函数，然后才能访问<code>this</code>。那是因为在调用超级构造函数之前<code>this</code>不存在（这种现象特定于类）。</p> </li>
<li> <p>静态方法也是继承的。例如，<code>Employee</code>继承静态方法<code>.logNames()</code>：</p> <pre><code class="language-js">&gt; 'logNames' in Employee
true
</code></pre> </li>
</ul>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/326f85074b5e7828bef014ad113651df.svg" alt=""></a> <strong>练习：子类化</strong></p>
<p><code>exercises/proto-chains-classes/color_point_class_test.js</code></p>
<h4 id="2641引擎盖下的子类高级">26.4.1。引擎盖下的子类（高级）</h4>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/3c36c91423290bc7be761ede9bb78ac2.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/3c36c91423290bc7be761ede9bb78ac2.svg" alt="Figure 13: These are the objects that make up class Person and its subclass, Employee. The left column is about classes. The right column is about the Employee instance jane and its prototype chain."></a></p>
<p>Figure 13: These are the objects that make up class <code>Person</code> and its subclass, <code>Employee</code>. The left column is about classes. The right column is about the <code>Employee</code> instance <code>jane</code> and its prototype chain.</p>
<p>上一节中的<code>Person</code>和<code>Employee</code>类由几个对象组成（图 <a href="#fig:oo_subclassing">13</a> ）。理解这些对象如何相关的一个关键见解是，有两个原型链：</p>
<ul>
<li>实例原型链，在右侧。</li>
<li>类原型链，在左边。</li>
</ul>
<h5 id="26411实例原型链右栏">26.4.1.1。实例原型链（右栏）</h5>
<p>实例原型链以<code>jane</code>开始，并继续<code>Employee.prototype</code>和<code>Person.prototype</code>。原则上，原型链在此时结束，但我们还得到一个对象：<code>Object.prototype</code>。这个原型为几乎所有对象提供服务，这也是为什么它包含在这里：</p>
<pre><code class="language-js">&gt; Object.getPrototypeOf(Person.prototype) === Object.prototype
true
</code></pre>
<h5 id="26412类原型链左栏">26.4.1.2。类原型链（左栏）</h5>
<p>在类原型链中，<code>Employee</code>首先出现，<code>Person</code>接下来。之后，链继续<code>Function.prototype</code>，只有那里，因为<code>Person</code>是一个功能，功能需要<code>Function.prototype</code>的服务。</p>
<pre><code class="language-js">&gt; Object.getPrototypeOf(Person) === Function.prototype
true
</code></pre>
<h4 id="2642-instanceof更详细高级">26.4.2。 <code>instanceof</code>更详细（高级）</h4>
<p>我们还没有看到<code>instanceof</code>如何真正起作用。给定表达式<code>x instanceof C</code>，<code>instanceof</code>如何确定<code>x</code>是否是<code>C</code>的实例？它通过检查<code>C.prototype</code>是否在<code>x</code>的原型链中来实现。也就是说，以下两个表达式是等效的：</p>
<pre><code class="language-js">x instanceof C
C.prototype.isPrototypeOf(x)
</code></pre>
<p>如果我们回到图。 <a href="#fig:oo_subclassing">13</a> ，我们可以确认原型链确实引导我们得到以下答案：</p>
<pre><code class="language-js">&gt; jane instanceof Employee
true
&gt; jane instanceof Person
true
&gt; jane instanceof Object
true
</code></pre>
<h4 id="2643内置对象的原型链高级">26.4.3。内置对象的原型链（高级）</h4>
<p>接下来，我们将使用我们的子类化知识来理解一些内置对象的原型链。以下工具功能<code>p()</code>帮助我们进行探索。</p>
<pre><code class="language-js">const p = Object.getPrototypeOf.bind(Object);
</code></pre>
<p>我们提取<code>Object</code>的方法<code>.getPrototypeOf()</code>并将其分配给<code>p</code>。</p>
<h5 id="26431-的原型链">26.4.3.1。 <code>{}</code>的原型链</h5>
<p>让我们从检查普通对象开始：</p>
<pre><code class="language-js">&gt; p({}) === Object.prototype
true
&gt; p(p({})) === null
true
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/a5b2d2666ff567f2901188b85a2d0ed1.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/a5b2d2666ff567f2901188b85a2d0ed1.svg" alt="Figure 14: The prototype chain of an object created via an object literal starts with that object, continues with Object.prototype and ends with null."></a></p>
<p>Figure 14: The prototype chain of an object created via an object literal starts with that object, continues with <code>Object.prototype</code> and ends with <code>null</code>.</p>
<p>图 <a href="#fig:proto_chain_object">14</a> 显示了该原型链的图表。我们可以看到<code>{}</code>确实是<code>Object</code>的实例 - <code>Object.prototype</code>在其原型链中。</p>
<p><code>Object.prototype</code>是一个奇怪的值：它是一个对象，但它不是<code>Object</code>的实例：</p>
<pre><code class="language-js">&gt; typeof Object.prototype
'object'
&gt; Object.prototype instanceof Object
false
</code></pre>
<p>这是无法避免的，因为<code>Object.prototype</code>不能在自己的原型链中。</p>
<h5 id="26432-的原型链">26.4.3.2。 <code>[]</code>的原型链</h5>
<p>Array 的原型链是什么样的？</p>
<pre><code class="language-js">&gt; p([]) === Array.prototype
true
&gt; p(p([])) === Object.prototype
true
&gt; p(p(p([]))) === null
true
</code></pre>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/848dd45359b1d30583ddf4a0596a374a.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/848dd45359b1d30583ddf4a0596a374a.svg" alt="Figure 15: The prototype chain of an Array has these members: the Array instance, Array.prototype, Object.prototype, null."></a></p>
<p>Figure 15: The prototype chain of an Array has these members: the Array instance, <code>Array.prototype</code>, <code>Object.prototype</code>, <code>null</code>.</p>
<p>这个原型链（在图 <a href="#fig:proto_chain_array">15</a> 中可视化）告诉我们一个 Array 对象是<code>Array</code>的一个实例，它是<code>Object</code>的子类。</p>
<h5 id="26433-function--的原型链">26.4.3.3。 <code>function () {}</code>的原型链</h5>
<p>最后，普通函数的原型链告诉我们所有函数都是对象：</p>
<pre><code class="language-js">&gt; p(function () {}) === Function.prototype
true
&gt; p(p(function () {})) === Object.prototype
true
</code></pre>
<h5 id="26434不是object实例的对象">26.4.3.4。不是<code>Object</code>实例的对象</h5>
<p>如果<code>Object.prototype</code>在其原型链中，则对象只是<code>Object</code>的实例。通过各种字面值创建的大多数对象是<code>Object</code>的实例：</p>
<pre><code class="language-js">&gt; ({}) instanceof Object
true
&gt; (() =&gt; {}) instanceof Object
true
&gt; /abc/ug instanceof Object
true
</code></pre>
<p>没有原型的对象不是<code>Object</code>的实例：</p>
<pre><code class="language-js">&gt; ({ __proto__: null }) instanceof Object
false
&gt; Object.create(null) instanceof Object
false
</code></pre>
<p><code>Object.prototype</code>结束了大多数原型链。它的原型是<code>null</code>，这意味着它不是<code>Object</code>的实例，也是：</p>
<pre><code class="language-js">&gt; Object.prototype instanceof Object
false
</code></pre>
<h4 id="2644调度与直接方法调用高级">26.4.4。调度与直接方法调用（高级）</h4>
<p>让我们来看一下方法调用如何与类一起工作。我们从之前再次访问<code>jane</code>：</p>
<pre><code class="language-js">class Person {
  constructor(name) {
    this.name = name;
  }
  describe() {
    return 'Person named '+this.name;
  }
}
const jane = new Person('Jane');
</code></pre>
<p>图 <a href="#fig:jane_proto_chain">16</a> 有一个带有<code>jane</code>原型链的图表。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/b13a5622237f1e2afb82ec794ce9a4fd.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/b13a5622237f1e2afb82ec794ce9a4fd.svg" alt="Figure 16: The prototype chain of jane starts with jane and continues with Person.prototype."></a></p>
<p>Figure 16: The prototype chain of <code>jane</code> starts with <code>jane</code> and continues with <code>Person.prototype</code>.</p>
<p>正常方法调用是 _ 调度 _。要使方法调用<code>jane.describe()</code>：</p>
<ul>
<li>JavaScript 首先通过遍历原型链来查找<code>jane.describe</code>的值。</li>
<li>然后它调用它找到的函数，同时将<code>this</code>设置为<code>jane</code>。 <code>this</code>是方法调用的 _ 接收器 _（其中搜索属性<code>.describe</code>已启动）。</li>
</ul>
<p>这种动态查找方法的方式称为 _ 动态调度 _。</p>
<p>您可以在绕过调度时进行相同的方法调用：</p>
<pre><code class="language-js">Person.prototype.describe.call(jane)
</code></pre>
<p>这次，<code>Person.prototype.describe</code>是一个自己的属性，不需要搜索原型。我们还通过<code>.call()</code>自己指定<code>this</code>。</p>
<p>注意<code>this</code>总是指向原型链的开头。这使<code>.describe()</code>能够访问<code>.name</code>。这是突变发生的地方（如果方法想要设置<code>.name</code>）。</p>
<h5 id="26441借用方法">26.4.4.1。借用方法</h5>
<p>使用<code>Object.prototype</code>的方法时，直接方法调用很有用。例如，<code>Object.prototype.hasOwnProperty()</code>检查对象是否具有其键为给定的非继承属性：</p>
<pre><code class="language-js">&gt; const obj = { foo: 123 };
&gt; obj.hasOwnProperty('foo')
true
&gt; obj.hasOwnProperty('bar')
false
</code></pre>
<p>但是，可以覆盖此方法。然后调度的方法调用不起作用：</p>
<pre><code class="language-js">&gt; const obj = { hasOwnProperty: true };
&gt; obj.hasOwnProperty('bar')
TypeError: obj.hasOwnProperty is not a function
</code></pre>
<p>解决方法是使用直接方法调用：</p>
<pre><code class="language-js">&gt; Object.prototype.hasOwnProperty.call(obj, 'bar')
false
&gt; Object.prototype.hasOwnProperty.call(obj, 'hasOwnProperty')
true
</code></pre>
<p>这种直接方法调用通常缩写如下：</p>
<pre><code class="language-js">&gt; ({}).hasOwnProperty.call(obj, 'bar')
false
&gt; ({}).hasOwnProperty.call(obj, 'hasOwnProperty')
true
</code></pre>
<p>JavaScript 引擎优化了这种模式，因此性能不应成为问题。</p>
<h4 id="2645-mixin-课程高级">26.4.5。 Mixin 课程（高级）</h4>
<p>JavaScript 的类系统仅支持 _ 单继承 _。也就是说，每个类最多只能有一个超类。绕过这种限制的方法是通过称为 _mixin 类 _（简称： <em>mixins</em> ）的技术。</p>
<p>这个想法如下：让我们假设有一个类<code>C</code>扩展了一个类<code>S</code> - 它的超类。 Mixins 是插入<code>C</code>和<code>S</code>之间的类片段。</p>
<p>在 JavaScript 中，您可以通过一个函数实现 mixin <code>Mix</code>，该函数的输入是一个类，其输出是 mixin 类片段 - 一个扩展输入的新类。要使用<code>Mix()</code>，请按如下方式创建<code>C</code>。</p>
<pre><code class="language-js">class C extends Mix(S) {
  ···
}
</code></pre>
<p>我们来看一个例子：</p>
<pre><code class="language-js">const Branded = S =&gt; class extends S {
  setBrand(brand) {
    this._brand = brand;
    return this;
  }
  getBrand() {
    return this._brand;
  }
};
</code></pre>
<p>我们使用这个 mixin 在<code>Car</code>和<code>Object</code>之间插入一个类：</p>
<pre><code class="language-js">class Car extends Branded(Object) {
  constructor(model) {
    super();
    this._model = model;
  }
  toString() {
    return `${this.getBrand()} ${this._model}`;
  }
}
</code></pre>
<p>以下代码确认 mixin 有效：<code>Car</code>具有<code>Branded</code>的方法<code>.setBrand()</code>。</p>
<pre><code class="language-js">const modelT = new Car('Model T').setBrand('Ford');
assert.equal(modelT.toString(), 'Ford Model T');
</code></pre>
<p>Mixins 比普通类更灵活：</p>
<ul>
<li> <p>首先，您可以在多个类中多次使用相同的 mixin。</p> </li>
<li> <p>其次，您可以同时使用多个 mixin。例如，考虑一个名为<code>Stringifiable</code>的附加 mixin，它有助于实现<code>.toString()</code>。我们可以使用<code>Branded</code>和<code>Stringifiable</code>如下：</p> <pre><code class="language-js">class Car extends Stringifiable(Branded(Object)) {
  ···
}
</code></pre> </li>
</ul>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/bf533f04c482f83bfc407f318306f995.svg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/bf533f04c482f83bfc407f318306f995.svg" alt=""></a> <strong>测验</strong></p>
<p>参见<a href="ch_quizzes-exercises.html#quizzes">测验应用程序</a>。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/147/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/147/index.html">JSON风格指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/79.html">darcyliu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1139个">1139</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/153/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/153/index.html">你不懂JS：ES6与未来</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/85.html">getify</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">13页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 98514个">98514</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/53/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/53/index.html">前端开发者指南 2018</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/30.html">稀土</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">103页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 282个">282</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/38/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/38/index.html">Java资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">61页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月23日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7938个">7938</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/112/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/django_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/112/index.html">从Python到Django入门教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/62.html">tzivanmoe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="django">django</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">41页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/105/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/105/index.html">程序员的自我修养</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/64.html">leohxj</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">136页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 130个">130</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/171/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/171/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/1.html" title="I.背景" data-book-page-rel-url="docs/1.html" data-book-page-id="11641">I.背景</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/2.html" title="1.关于本书（ES2019 版）" data-book-page-rel-url="docs/2.html" data-book-page-id="11642">1.关于本书（ES2019 版）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/3.html" title="2.常见问题：本书" data-book-page-rel-url="docs/3.html" data-book-page-id="11643">2.常见问题：本书</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/4.html" title="3. JavaScript 的历史和演变" data-book-page-rel-url="docs/4.html" data-book-page-id="11644">3. JavaScript 的历史和演变</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/5.html" title="4.常见问题：JavaScript" data-book-page-rel-url="docs/5.html" data-book-page-id="11645">4.常见问题：JavaScript</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/6.html" title="II.第一步" data-book-page-rel-url="docs/6.html" data-book-page-id="11646">II.第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/7.html" title="5.概览" data-book-page-rel-url="docs/7.html" data-book-page-id="11647">5.概览</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/8.html" title="6.语法" data-book-page-rel-url="docs/8.html" data-book-page-id="11648">6.语法</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/9.html" title="7.在控制台上打印信息（`console.*`）" data-book-page-rel-url="docs/9.html" data-book-page-id="11649">7.在控制台上打印信息（`console.*`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/10.html" title="8.断言 API" data-book-page-rel-url="docs/10.html" data-book-page-id="11650">8.断言 API</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/11.html" title="9.测验和练习入门" data-book-page-rel-url="docs/11.html" data-book-page-id="11651">9.测验和练习入门</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/12.html" title="III.变量和值" data-book-page-rel-url="docs/12.html" data-book-page-id="11652">III.变量和值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/13.html" title="10.变量和赋值" data-book-page-rel-url="docs/13.html" data-book-page-id="11653">10.变量和赋值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/14.html" title="11.值" data-book-page-rel-url="docs/14.html" data-book-page-id="11654">11.值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/15.html" title="12.运算符" data-book-page-rel-url="docs/15.html" data-book-page-id="11655">12.运算符</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/16.html" title="IV.原始值" data-book-page-rel-url="docs/16.html" data-book-page-id="11656">IV.原始值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/17.html" title="13.非值`undefined`和`null`" data-book-page-rel-url="docs/17.html" data-book-page-id="11657">13.非值`undefined`和`null`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/18.html" title="14.布尔值" data-book-page-rel-url="docs/18.html" data-book-page-id="11658">14.布尔值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/19.html" title="15.数字" data-book-page-rel-url="docs/19.html" data-book-page-id="11659">15.数字</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/20.html" title="16. `Math`" data-book-page-rel-url="docs/20.html" data-book-page-id="11660">16. `Math`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/21.html" title="17. Unicode - 简要介绍（高级）" data-book-page-rel-url="docs/21.html" data-book-page-id="11661">17. Unicode - 简要介绍（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/22.html" title="18.字符串" data-book-page-rel-url="docs/22.html" data-book-page-id="11662">18.字符串</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/23.html" title="19.使用模板字面值和标记模板" data-book-page-rel-url="docs/23.html" data-book-page-id="11663">19.使用模板字面值和标记模板</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/24.html" title="20.符号" data-book-page-rel-url="docs/24.html" data-book-page-id="11664">20.符号</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/25.html" title="V.控制流和数据流" data-book-page-rel-url="docs/25.html" data-book-page-id="11665">V.控制流和数据流</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/26.html" title="21.控制流语句" data-book-page-rel-url="docs/26.html" data-book-page-id="11666">21.控制流语句</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/27.html" title="22.异常处理" data-book-page-rel-url="docs/27.html" data-book-page-id="11667">22.异常处理</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/28.html" title="23.可调用值" data-book-page-rel-url="docs/28.html" data-book-page-id="11668">23.可调用值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/29.html" title="VI.模块化" data-book-page-rel-url="docs/29.html" data-book-page-id="11669">VI.模块化</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/30.html" title="24.模块" data-book-page-rel-url="docs/30.html" data-book-page-id="11670">24.模块</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/31.html" title="25.单个对象" data-book-page-rel-url="docs/31.html" data-book-page-id="11671">25.单个对象</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/32.html" title="26.原型链和类" data-book-page-rel-url="docs/32.html" data-book-page-id="11672">26.原型链和类</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/33.html" title="七.集合" data-book-page-rel-url="docs/33.html" data-book-page-id="11673">七.集合</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/34.html" title="27.同步迭代" data-book-page-rel-url="docs/34.html" data-book-page-id="11674">27.同步迭代</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/35.html" title="28.数组（`Array`）" data-book-page-rel-url="docs/35.html" data-book-page-id="11675">28.数组（`Array`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/36.html" title="29.类型化数组：处理二进制数据（高级）" data-book-page-rel-url="docs/36.html" data-book-page-id="11676">29.类型化数组：处理二进制数据（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/37.html" title="30.映射（`Map`）" data-book-page-rel-url="docs/37.html" data-book-page-id="11677">30.映射（`Map`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/38.html" title="31. WeakMaps（`WeakMap`）" data-book-page-rel-url="docs/38.html" data-book-page-id="11678">31. WeakMaps（`WeakMap`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/39.html" title="32.集（`Set`）" data-book-page-rel-url="docs/39.html" data-book-page-id="11679">32.集（`Set`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/40.html" title="33. WeakSets（`WeakSet`）" data-book-page-rel-url="docs/40.html" data-book-page-id="11680">33. WeakSets（`WeakSet`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/41.html" title="34.解构" data-book-page-rel-url="docs/41.html" data-book-page-id="11681">34.解构</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/42.html" title="35.同步生成器（高级）" data-book-page-rel-url="docs/42.html" data-book-page-id="11682">35.同步生成器（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/43.html" title="八.异步" data-book-page-rel-url="docs/43.html" data-book-page-id="11683">八.异步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/44.html" title="36. JavaScript 中的异步编程" data-book-page-rel-url="docs/44.html" data-book-page-id="11684">36. JavaScript 中的异步编程</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/45.html" title="37.异步编程的 Promise" data-book-page-rel-url="docs/45.html" data-book-page-id="11685">37.异步编程的 Promise</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/46.html" title="38.异步函数" data-book-page-rel-url="docs/46.html" data-book-page-id="11686">38.异步函数</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/47.html" title="IX.更多标准库" data-book-page-rel-url="docs/47.html" data-book-page-id="11687">IX.更多标准库</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/48.html" title="39.正则表达式（`RegExp`）" data-book-page-rel-url="docs/48.html" data-book-page-id="11688">39.正则表达式（`RegExp`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/49.html" title="40.日期（`Date`）" data-book-page-rel-url="docs/49.html" data-book-page-id="11689">40.日期（`Date`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/50.html" title="41.创建和解析 JSON（`JSON`）" data-book-page-rel-url="docs/50.html" data-book-page-id="11690">41.创建和解析 JSON（`JSON`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/51.html" title="42.其余章节在哪里？" data-book-page-rel-url="docs/51.html" data-book-page-id="11691">42.其余章节在哪里？</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =171;var bookPageId =11672;var bookPageRelUrl ='docs/32.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>