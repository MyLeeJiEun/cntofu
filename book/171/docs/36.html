
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>29.类型化数组：处理二进制数据（高级）-[译] 写给不耐烦程序员的 JavaScript</title>
<meta content='29.类型化数组：处理二进制数据（高级）,[译] 写给不耐烦程序员的 JavaScript' name='keywords'>
<meta content='29.类型化数组：处理二进制数据（高级）,[译] 写给不耐烦程序员的 JavaScript' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/171/docs/35.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">28.数组（`Arra..</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/171/docs/37.html">
<span class="">30.映射（`Map`）</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/171/index.html">[译] 写给不耐烦程序员的 JavaScript</a>
<a target="_blank" rel="nofollow" href="https://github.com/apachecn/impatient-js-zh" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h2 id="29类型化数组处理二进制数据高级">29.类型化数组：处理二进制数据（高级）</h2>
<blockquote>
<p>原文： <a href="http://exploringjs.com/impatient-js/ch_typed-arrays.html">http://exploringjs.com/impatient-js/ch_typed-arrays.html</a></p>
</blockquote>
<h3 id="291-api-的基础知识">29.1。 API 的基础知识</h3>
<p>Web 上的大量数据是文本：JSON 文件，HTML 文件，CSS 文件，JavaScript 代码等.JavaScript 通过其内置字符串很好地处理这些数据。</p>
<p>但是，在 2011 年之前，它没有很好地处理二进制数据。 <a href="https://www.khronos.org/registry/typedarray/specs/1.0/">2011 年 2 月 8 日推出了 Typed Array Specification 1.0</a> ，并提供了处理二进制数据的工具。使用 ECMAScript 6，将类型数组添加到核心语言中，并获得以前仅适用于普通数组（<code>.map()</code>，<code>.filter()</code>等）的方法。</p>
<h4 id="2911-typed-arrays-的用例">29.1.1。 Typed Arrays 的用例</h4>
<p>Typed Arrays 的主要用例是：</p>
<ul>
<li>处理二进制数据：处理 HTML Canvas 元素中的图像数据，解析二进制文件，处理二进制网络协议等。</li>
<li>与本机 API 交互：本机 API 通常以二进制格式接收和返回数据，您无法在 ES6 之前的 JavaScript 中存储或操作。这意味着，无论何时与这种 API 进行通信，每次调用时都必须将数据从 JavaScript 转换为二进制并返回。 Typed Arrays 消除了这个瓶颈。与本机 API 通信的一个示例是 WebGL，最初为其创建了 Typed Arrays。文章<a href="http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/#toc-history">“类型数组：浏览器中的二进制数据”</a>（由 Ilmari Heikkinen 为 HTML5 Rocks 提供）<a href="http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/#toc-history">“类型数组的历史”</a>部分提供了更多信息。</li>
</ul>
<h4 id="2912支持-typed-arrays-的浏览器-api">29.1.2。支持 Typed Arrays 的浏览器 API</h4>
<p>以下浏览器 API 支持 Typed Arrays：</p>
<ul>
<li><a href="http://www.w3.org/TR/FileAPI/">文件 API</a></li>
<li><a href="http://www.w3.org/TR/XMLHttpRequest/"><code>XMLHttpRequest</code></a></li>
<li><a href="https://fetch.spec.whatwg.org/">Fetch API</a></li>
<li><a href="http://www.w3.org/TR/2dcontext/">画布</a></li>
<li><a href="http://www.w3.org/TR/websockets/">WebSockets</a></li>
<li><a href="https://www.khronos.org/registry/webgl/">WebGL</a></li>
<li><a href="http://www.w3.org/TR/webaudio/">网络音频 API</a></li>
<li>（和更多）</li>
</ul>
<h4 id="2913核心类arraybuffer类型数组dataview">29.1.3。核心类：<code>ArrayBuffer</code>，类型数组，<code>DataView</code></h4>
<p>Typed Array API 将二进制数据存储在<code>ArrayBuffer</code>的实例中：</p>
<pre><code class="language-js">const buf = new ArrayBuffer(4); // length in bytes
  // buf is initialized with zeros
</code></pre>
<p>ArrayBuffer 本身是不透明的。如果要访问其数据，则必须将其包装在另一个对象中 - _ 视图对象 _。有两种视图对象可供选择：</p>
<ul>
<li>类型化数组：允许您将数据作为所有具有相同类型的索引元素序列进行访问。例子包括：
<ul>
<li><code>Uint8Array</code>：元素是无符号 8 位整数。 _ 无符号 _ 表示它们的范围从零开始。</li>
<li><code>Int16Array</code>：元素是带符号的 16 位整数。 _ 签名 _ 意味着他们有一个标志，可以是负数，零或正数。</li>
<li><code>Float32Array</code>：元素是 32 位浮点数。</li>
</ul> </li>
<li>DataViews：允许您将数据解释为可以在任何字节偏移处读取和写入的各种类型（<code>Uint8</code>，<code>Int16</code>，<code>Float32</code>等）。</li>
</ul>
<p>图 <a href="#fig:typed_arrays_class_diagram">19</a> 显示了 API 的类图。</p>
<p><a href="https://img.cntofu.com/book/impatient-js-zh/docs/img/fb9a5ee3c1d8dd09dbaaa3d59e79be80.jpg" data-uk-lightbox><img src="https://img.cntofu.com/book/impatient-js-zh/docs/img/fb9a5ee3c1d8dd09dbaaa3d59e79be80.jpg" alt="Figure 19: The classes of the Typed Array API."></a></p>
<p>Figure 19: The classes of the Typed Array API.</p>
<h4 id="2914使用-typed-arrays">29.1.4。使用 Typed Arrays</h4>
<p>类型数组的使用方式与普通数组非常相似，但有一些显着差异：</p>
<ul>
<li>Typed Arrays 将其数据存储在 ArrayBuffers 中。</li>
<li>所有元素都用零初始化。</li>
<li>所有元素都具有相同的类型。将值写入类型化数组会将它们强制转换为该类型。读取值会产生正常数字。</li>
<li>创建类型化数组后，其长度永远不会改变。</li>
<li>Typed Arrays 不能有洞。</li>
</ul>
<p>这是使用类型化数组的示例：</p>
<pre><code class="language-js">const typedArray = new Uint8Array(2); // 2 elements
assert.equal(typedArray.length, 2);

// The wrapped ArrayBuffer
assert.deepEqual(
  typedArray.buffer, new ArrayBuffer(2)); // 2 bytes

// Getting and setting elements:
assert.equal(typedArray[1], 0); // initialized with 0
typedArray[1] = 72;
assert.equal(typedArray[1], 72);
</code></pre>
<p>其他创建类型数组的方法：</p>
<pre><code class="language-js">const ta1 = new Uint8Array([5, 6]);
const ta2 = Uint8Array.of(5, 6);
assert.deepEqual(ta1, ta2);
</code></pre>
<h4 id="2915使用-dataviews">29.1.5。使用 DataViews</h4>
<p>这就是 DataViews 的使用方式：</p>
<pre><code class="language-js">const dataView = new DataView(new ArrayBuffer(4));
assert.equal(dataView.getUint16(0), 0);
assert.equal(dataView.getUint8(0), 0);
dataView.setUint8(0, 5);
</code></pre>
<h3 id="292-typed-array-api-的基础">29.2。 Typed Array API 的基础</h3>
<h4 id="2921元素类型">29.2.1。元素类型</h4>
<p>API 支持以下元素类型：</p>
<table>
<thead>
<tr>
<th>元素类型</th>
<th>字节</th>
<th>描述</th>
<th>C 型</th>
</tr>
</thead>
<tbody>
<tr>
<td>INT8</td>
<td>1</td>
<td>8 位有符号整数</td>
<td>签名的 char</td>
</tr>
<tr>
<td>UINT8</td>
<td>1</td>
<td>8 位无符号整数</td>
<td>无符号的字符</td>
</tr>
<tr>
<td>Uint8C</td>
<td>1</td>
<td>8 位无符号整数（钳位转换）</td>
<td>无符号的字符</td>
</tr>
<tr>
<td>INT16</td>
<td>2</td>
<td>16 位有符号整数</td>
<td>短</td>
</tr>
<tr>
<td>UINT16</td>
<td>2</td>
<td>16 位无符号整数</td>
<td>未签约的短片</td>
</tr>
<tr>
<td>INT32</td>
<td>4</td>
<td>32 位有符号整数</td>
<td>INT</td>
</tr>
<tr>
<td>UINT32</td>
<td>4</td>
<td>32 位无符号整数</td>
<td>unsigned int</td>
</tr>
<tr>
<td>FLOAT32</td>
<td>4</td>
<td>32 位浮点</td>
<td>浮动</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
<td>64 位浮点</td>
<td>双</td>
</tr>
</tbody>
</table>
<p>元素类型<code>Uint8C</code>是特殊的：<code>DataView</code>不支持它，仅存在以启用<code>Uint8ClampedArray</code>。这个类型数组由<code>canvas</code>元素使用（它替换<code>CanvasPixelArray</code>）。 <code>Uint8C</code>和<code>Uint8</code>之间的唯一区别是溢出和下溢的处理方式（如下一节所述）。建议避免前者 - <a href="https://mail.mozilla.org/pipermail/es-discuss/2015-August/043902.html">引用 Brendan Eich</a> ：</p>
<blockquote>
<p>只是为了超级清晰（我出生时就在身边），<code>Uint8ClampedArray</code>完全是一个历史神器（HTML5 画布元素）。除非你真的在做帆布的事情，否则要避免。</p>
</blockquote>
<h4 id="2922处理溢出和下溢">29.2.2。处理溢出和下溢</h4>
<p>通常，当值超出元素类型的范围时，使用模运算将其转换为范围内的值。对于有符号和无符号整数，这意味着：</p>
<ul>
<li>最高值加 1 将转换为最低值（0 表示无符号整数）。</li>
<li>最低值减 1 将转换为最高值。</li>
</ul>
<p>以下功能有助于说明转换的工作原理：</p>
<pre><code class="language-js">function setAndGet(typedArray, value) {
  typedArray[0] = value;
  return typedArray[0];
}
</code></pre>
<p>无符号 8 位整数的模数转换：</p>
<pre><code class="language-js">const uint8 = new Uint8Array(1);

// Highest value of range
assert.equal(setAndGet(uint8, 255), 255);
// Overflow
assert.equal(setAndGet(uint8, 256), 0);

// Lowest value of range
assert.equal(setAndGet(uint8, 0), 0);
// Underflow
assert.equal(setAndGet(uint8, -1), 255);
</code></pre>
<p>有符号 8 位整数的模数转换：</p>
<pre><code class="language-js">const int8 = new Int8Array(1);

// Highest value of range
assert.equal(setAndGet(int8, 127), 127);
// Overflow
assert.equal(setAndGet(int8, 128), -128);

// Lowest value of range
assert.equal(setAndGet(int8, -128), -128);
// Underflow
assert.equal(setAndGet(int8, -129), 127);
</code></pre>
<p>夹紧转换是不同的：</p>
<ul>
<li>所有下溢值都将转换为最低值。</li>
<li>所有溢出值都将转换为最高值。</li>
</ul>
<pre><code class="language-js">const uint8c = new Uint8ClampedArray(1);

// Highest value of range
assert.equal(setAndGet(uint8c, 255), 255);
// Overflow
assert.equal(setAndGet(uint8c, 256), 255);

// Lowest value of range
assert.equal(setAndGet(uint8c, 0), 0);
// Underflow
assert.equal(setAndGet(uint8c, -1), 0);
</code></pre>
<h4 id="2923字节序">29.2.3。字节序</h4>
<p>每当一个类型（例如<code>Uint16</code>）被存储为多个字节的序列时， <em>endianness</em> 很重要：</p>
<ul>
<li>Big endian：最重要的字节首先出现。例如，<code>Uint16</code>值 0x4321 存储为两个字节 - 首先是 0x43，然后是 0x21。</li>
<li>小端：最不重要的字节首先出现。例如，<code>Uint16</code>值 0x4321 存储为两个字节 - 首先是 0x21，然后是 0x43。</li>
</ul>
<p>Endianness 往往是针对每个 CPU 架构固定的，并且在本机 API 之间保持一致。类型化数组用于与这些 API 通信，这就是为什么它们的字节顺序遵循平台的字节顺序而无法更改。</p>
<p>另一方面，协议和二进制文件的字节顺序各不相同，并且在不同平台上是固定的。因此，我们必须能够以任何字节顺序访问数据。 DataViews 提供此用例，并允许您在获取或设置值时指定字节序。</p>
<p><a href="https://en.wikipedia.org/wiki/Endianness">引用关于 Endianness 的维基百科</a>：</p>
<ul>
<li>Big-endian 表示是数据网络中最常见的惯例; Internet 协议套件协议中的字段，如 IPv4，IPv6，TCP 和 UDP，以 big-endian 顺序传输。因此，big-endian 字节顺序也称为网络字节顺序。</li>
<li>小端存储器在微处理器中很受欢迎，部分原因是英特尔公司对微处理器设计产生了重大的历史影响。</li>
</ul>
<p>您可以使用以下函数来确定平台的字节顺序。</p>
<pre><code class="language-js">const BIG_ENDIAN = Symbol('BIG_ENDIAN');
const LITTLE_ENDIAN = Symbol('LITTLE_ENDIAN');
function getPlatformEndianness() {
  const arr32 = Uint32Array.of(0x87654321);
  const arr8 = new Uint8Array(arr32.buffer);
  if (compare(arr8, [0x87, 0x65, 0x43, 0x21])) {
    return BIG_ENDIAN;
  } else if (compare(arr8, [0x21, 0x43, 0x65, 0x87])) {
    return LITTLE_ENDIAN;
  } else {
    throw new Error('Unknown endianness');
  }
}
function compare(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i=0; i&lt;arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
</code></pre>
<p>其他排序也是可能的。这些通常被称为 _ 中端 _ 或 _ 混合端 _。</p>
<h4 id="2924指数和抵消">29.2.4。指数和抵消</h4>
<p>对于 Typed Arrays，我们区分：</p>
<ul>
<li> <p>括号运算符的指数<code>[ ]</code>：您只能使用非负指数（从 0 开始）。</p> </li>
<li> <p>ArrayBuffers，Typed Arrays 和 DataViews 方法的索引：每个索引都可以是负数。如果是，则将其添加到实体的长度，以生成实际索引。因此，<code>-1</code>指的是最后一个元素，<code>-2</code>指向倒数第二个等。正常数组的方法以相同的方式工作。</p> <pre><code class="language-js">const ui8 = Uint8Array.of(0, 1, 2);
assert.deepEqual(ui8.slice(-1), Uint8Array.of(2));
</code></pre> </li>
<li> <p>传递给 Typed Arrays 和 DataViews 方法的偏移量：必须是非负数。例如：</p> <pre><code class="language-js">const dataView = new DataView(new ArrayBuffer(4));
assert.throws(
  () =&gt; dataView.getUint8(-1),
  {
    name: 'RangeError',
    message: 'Offset is outside the bounds of the DataView',
  });
</code></pre> </li>
</ul>
<h3 id="293-arraybuffers">29.3。 ArrayBuffers</h3>
<p>ArrayBuffers 存储二进制数据，可通过 Typed Arrays 和 DataViews 访问。</p>
<h4 id="2931-new-arraybuffer">29.3.1。 <code>new ArrayBuffer()</code></h4>
<p>构造函数的类型签名是：</p>
<pre><code class="language-js">new ArrayBuffer(length: number)
</code></pre>
<p>通过<code>new</code>调用此构造函数会创建一个容量为<code>length</code>字节的实例。每个字节最初为 0。</p>
<p>您无法更改 ArrayBuffer 的长度，您只能创建一个具有不同长度的新长度。</p>
<h4 id="2932-arraybuffer的静态方法">29.3.2。 <code>ArrayBuffer</code>的静态方法</h4>
<ul>
<li><code>ArrayBuffer.isView(arg: any)</code> 如果<code>arg</code>是对象，则返回<code>true</code>，返回 ArrayBuffer（Typed Array 或 DataView）的视图。</li>
</ul>
<h4 id="2933-arraybufferprototype的属性">29.3.3。 <code>ArrayBuffer.prototype</code>的属性</h4>
<ul>
<li> <p><code>get .byteLength(): number</code></p> <p>以字节为单位返回此 ArrayBuffer 的容量。</p> </li>
<li> <p><code>.slice(startIndex: number, endIndex=this.byteLength)</code></p> <p>创建一个新的 ArrayBuffer，其中包含此 ArrayBuffer 的字节，其索引大于或等于<code>startIndex</code>且小于<code>endIndex</code>。 <code>start</code>和<code>endIndex</code>可以是负数（参见<a href="ch_typed-arrays.html#typed-arrays-indices-offsets">“指数和偏移”</a>部分）。</p> </li>
</ul>
<h3 id="294键入的数组">29.4。键入的数组</h3>
<p>各种类型的数组只是不同的 w.r.t.他们的元素类型：</p>
<ul>
<li>元素为整数的类型化数组：<code>Int8Array</code>，<code>Uint8Array</code>，<code>Uint8ClampedArray</code>，<code>Int16Array</code>，<code>Uint16Array</code>，<code>Int32Array</code>，<code>Uint32Array</code></li>
<li>元素为浮点数的类型数组：<code>Float32Array</code>，<code>Float64Array</code></li>
</ul>
<h4 id="2941键入数组与普通数组">29.4.1。键入数组与普通数组</h4>
<p>类型数组与普通数组非常相似：它们有<code>.length</code>，元素可以通过括号运算符<code>[ ]</code>访问，并且它们具有大多数标准数组方法。它们在以下方面与普通数组不同：</p>
<ul>
<li> <p>Typed Arrays 有缓冲区。类型数组<code>ta</code>的元素不存储在<code>ta</code>中，它们存储在可通过<code>ta.buffer</code>访问的关联 ArrayBuffer 中：</p> <pre><code class="language-js">const ta = new Uint8Array(4); // 4 elements
assert.deepEqual(
  ta.buffer, new ArrayBuffer(4)); // 4 bytes
</code></pre> </li>
</ul>
<pre><code>
*   使用零初始化类型化数组：

    *   `new Array(4)`创建一个没有任何元素的普通数组。它只有 4 个 _ 孔 _（小于`.length`的指数没有相关元素）。
    *   `new Uint8Array(4)`创建一个 Typed Array，其中 4 个元素都为 0。
    
    ```js
    assert.deepEqual(new Uint8Array(4), Uint8Array.of(0, 0, 0, 0));
    ```
    
*   Typed Array 的所有元素都具有相同的类型：

    *   设置元素将值转换为该类型。
    
        ```js
        const ta = new Uint8Array(1);

        ta[0] = 256;
        assert.equal(ta[0], 0);

        ta[0] = '2';
        assert.equal(ta[0], 2);
        ```

    *   获取元素返回数字。
        
        ```js
        const ta = new Uint8Array(1);
        assert.equal(ta[0], 0);
        assert.equal(typeof ta[0], 'number');
        ```

*   Typed Array 的`.length`派生自其 ArrayBuffer 并且永远不会更改（除非您切换到不同的 ArrayBuffer）。

*   普通数组可以有孔;键入的数组不能。

#### 29.4.2。类型化数组是可迭代的

类型数组是[可迭代的](ch_sync-iteration.html)。这意味着您可以使用`for-of`循环和类似的机制：

```js
const ui8 = Uint8Array.of(0,1,2);
for (const byte of ui8) {
  console.log(byte);
}
// Output:
// 0
// 1
// 2
</code></pre>
<p>ArrayBuffers 和 DataViews 不可迭代。</p>
<h4 id="2943将类型化数组转换为普通数组">29.4.3。将类型化数组转换为普通数组</h4>
<p>要将普通数组转换为类型化数组，请将其传递给类型化数组构造函数。例如：</p>
<pre><code class="language-js">const tarr = new Uint8Array([0,1,2]);
</code></pre>
<p>要将 Typed Array 转换为普通 Array，可以使用 spread 或<code>Array.from()</code>（因为 Typed Arrays 是可迭代的）：</p>
<pre><code class="language-js">assert.deepEqual([...tarr], [0,1,2]);
assert.deepEqual(Array.from(tarr), [0,1,2]);
</code></pre>
<h4 id="2944-typed-arrays-的类层次结构">29.4.4。 Typed Arrays 的类层次结构</h4>
<p>各种 Typed Array 对象的属性分两步介绍：</p>
<ol>
<li><code>TypedArray</code>：首先，我们看一下所有 Typed Array 类的公共超类（在本章开头的类图<a href="#fig:typed_arrays_class_diagram">中显示）。我正在调用超类<code>TypedArray</code>，但它不能直接从 JavaScript 访问。 <code>TypedArray.prototype</code>包含 Typed Arrays 的所有方法。</a></li>
<li><code>«ElementType»Array</code>：实际的 Typed Array 类称为<code>Uint8Array</code>，<code>Int16Array</code>，<code>Float32Array</code>等。</li>
</ol>
<h4 id="2945-typedarray的静态方法">29.4.5。 <code>TypedArray</code>的静态方法</h4>
<p>静态<code>TypedArray</code>方法都由其子类（<code>Uint8Array</code>等）继承。</p>
<h5 id="29451-typedarrayof">29.4.5.1。 <code>TypedArray.of()</code></h5>
<p>此方法具有类型签名：</p>
<pre><code class="language-js">.of(...items: number[]): instanceof this
</code></pre>
<p>返回类型的表示法是我的发明：<code>.of()</code>返回<code>this</code>的实例（调用<code>of()</code>的类）。实例的元素是<code>of()</code>的参数。</p>
<p>您可以将<code>of()</code>视为 Typed Arrays 的自定义字面值：</p>
<pre><code class="language-js">const float32Arr = Float32Array.of(0.151, -8, 3.7);
const int16Arr = Int32Array.of(-10, 5, 7);
</code></pre>
<h5 id="29452-typedarrayfrom">29.4.5.2。 <code>TypedArray.from()</code></h5>
<p>此方法具有类型签名：</p>
<pre><code class="language-js">TypedArray&lt;T&gt;.from&lt;S&gt;(
  source: Iterable&lt;S&gt;|ArrayLike&lt;S&gt;, mapfn?: S =&gt; T, thisArg?: any)
  : instanceof this
</code></pre>
<p>它将<code>source</code>转换为<code>this</code>（类型化数组）的实例。再一次，语法<code>instanceof this</code>是我的发明。</p>
<p>例如，普通数组是可迭代的，可以使用此方法转换：</p>
<pre><code class="language-js">assert.deepEqual(
  Uint16Array.from([0, 1, 2]),
  Uint16Array.of(0, 1, 2));
</code></pre>
<p>类型化数组也是可迭代的：</p>
<pre><code class="language-js">assert.deepEqual(
  Uint16Array.from(Uint8Array.of(0, 1, 2)),
  Uint16Array.of(0, 1, 2));
</code></pre>
<p><code>source</code>也可以是<a href="ch_arrays.html#array-like-objects">类似于数组的对象</a>：</p>
<pre><code class="language-js">assert.deepEqual(
  Uint16Array.from({0:0, 1:1, 2:2, length: 3}),
  Uint16Array.of(0, 1, 2));
</code></pre>
<p>可选的<code>mapfn</code>允许您在<code>source</code>成为结果元素之前对其进行转换。为什么一次执行两个步骤 _ 映射 _ 和 _ 转换 _？与通过<code>.map()</code>单独映射相比，有两个优点：</p>
<ol>
<li>不需要中间数组或类型数组。</li>
<li>在具有不同精度的类型化数组之间进行转换时，可能会出现更少的错误。</li>
</ol>
<p>为了说明第二个优点，我们首先将 Typed 数组转换为具有更高精度的 Typed 数组。如果我们使用<code>.from()</code>进行映射，结果会自动更正。否则，您必须先转换然后映射。</p>
<pre><code class="language-js">const typedArray = Int8Array.of(127, 126, 125);
assert.deepEqual(
  Int16Array.from(typedArray, x =&gt; x * 2),
  Int16Array.of(254, 252, 250));

assert.deepEqual(
  Int16Array.from(typedArray).map(x =&gt; x * 2),
  Int16Array.of(254, 252, 250)); // OK
assert.deepEqual(
  Int16Array.from(typedArray.map(x =&gt; x * 2)),
  Int16Array.of(-2, -4, -6)); // wrong
</code></pre>
<p>如果我们从类型化数组转换为具有较低精度的类型化数组，则通过<code>.from()</code>进行映射会产生正确的结果。否则，我们必须首先映射然后转换。</p>
<pre><code class="language-js">assert.deepEqual(
  Int8Array.from(Int16Array.of(254, 252, 250), x =&gt; x / 2),
  Int8Array.of(127, 126, 125));

assert.deepEqual(
  Int8Array.from(Int16Array.of(254, 252, 250).map(x =&gt; x / 2)),
  Int8Array.of(127, 126, 125)); // OK
assert.deepEqual(
  Int8Array.from(Int16Array.of(254, 252, 250)).map(x =&gt; x / 2),
  Int8Array.of(-1, -2, -3)); // wrong
</code></pre>
<p>问题是，如果我们通过<code>.map()</code>进行映射，那么输入类型和输出类型是相同的（如果我们使用 Typed Arrays）。相反，<code>.from()</code>从任意输入类型变为您通过其接收器指定的输出类型。</p>
<p><a href="https://twitter.com/awbjs/status/585199958661472257">根据 Allen Wirfs-Brock</a> ，Typed Arrays 之间的映射是<code>.from()</code>的<code>mapfn</code>参数的动机。</p>
<h4 id="2946-typedarraytprototype的属性">29.4.6。 <code>TypedArray&lt;T&gt;.prototype</code>的属性</h4>
<p>Typed Array 方法接受的索引可能是否定的（它们就像传统的 Array 方法一样）。偏移必须是非负的。有关详细信息，请参见<a href="ch_typed-arrays.html#typed-arrays-indices-offsets">“指数和偏移”</a>部分。</p>
<h5 id="29461-typed-arrays-特有的属性">29.4.6.1。 Typed Arrays 特有的属性</h5>
<p>以下属性特定于 Typed Arrays;普通数组没有它们：</p>
<ul>
<li> <p><code>get .buffer(): ArrayBuffer</code></p> <p>返回支持此 Typed Array 的缓冲区。</p> </li>
<li> <p><code>get .length(): number</code></p> <p>返回此 Typed Array 缓冲区元素的长度。请注意，普通数组的长度不是 getter，它是实例具有的特殊属性。</p> </li>
<li> <p><code>get .byteLength(): number</code></p> <p>返回此 Typed Array 缓冲区的大小（以字节为单位）。</p> </li>
<li> <p><code>get .byteOffset(): number</code></p> <p>返回此 Arrayd Array 在其 ArrayBuffer 中“启动”的偏移量。</p> </li>
<li> <p><code>.set(arrayLike: ArrayLike&lt;number&gt;, offset=0): void</code></p> </li>
<li> <p><code>.set(typedArray: TypedArray, offset=0): void</code>将第一个参数的所有元素复制到此 Typed 数组。参数索引 0 处的元素被写入此类型数组的索引<code>offset</code>（等）。</p>
<ul>
<li>第一个参数是<code>arrayLike</code>：它的元素被转换为数字，然后转换为此类型数组的元素类型<code>T</code>。</li>
<li>第一个参数是<code>typedArray</code>：它的每个元素都直接转换为此类型数组的相应类型。如果两个 Typed Arrays 具有相同的元素类型然后更快，则使用逐字节复制。</li>
</ul> </li>
<li> <p><code>.subarray(startIndex=0, end=this.length): TypedArray&lt;T&gt;</code></p> <p>返回一个新的 Typed Array，它与此 Typed Array 具有相同的缓冲区，但是（通常）较小的范围。如果<code>startIndex</code>为非负数，则生成的类型化数组的第一个元素为<code>this[startIndex]</code>，第二个<code>this[startIndex+1]</code>（等）。如果<code>startIndex</code>为负数，则进行适当转换。</p> </li>
</ul>
<h5 id="29462数组方法">29.4.6.2。数组方法</h5>
<p>以下方法与普通数组的方法基本相同：</p>
<ul>
<li><code>.copyWithin(target: number, start: number, end=this.length): this</code> [W，ES6]</li>
<li><code>.entries(): Iterable&lt;[number, T]&gt;</code> [R，ES6]</li>
<li><code>.every(callback: (value: T, index: number, array: TypedArray&lt;T&gt;) =&gt; boolean, thisArg?: any): boolean</code> [R，ES5]</li>
<li><code>.fill(value: T, start=0, end=this.length): this</code> [W，ES6]</li>
<li><code>.filter(callback: (value: T, index: number, array: TypedArray&lt;T&gt;) =&gt; any, thisArg?: any): T[]</code> [R，ES5]</li>
<li><code>.find(predicate: (value: T, index: number, obj: T[]) =&gt; boolean, thisArg?: any): T | undefined</code> [R，ES6]</li>
<li><code>.findIndex(predicate: (value: T, index: number, obj: T[]) =&gt; boolean, thisArg?: any): number</code> [R，ES6]</li>
<li><code>.forEach(callback: (value: T, index: number, array: TypedArray&lt;T&gt;) =&gt; void, thisArg?: any): void</code> [R，ES5]</li>
<li><code>.includes(searchElement: T, fromIndex=0): boolean</code> [R，ES2016]</li>
<li><code>.indexOf(searchElement: T, fromIndex=0): number</code> [R，ES5]</li>
<li><code>.join(separator = ','): string</code> [R，ES1]</li>
<li><code>.keys(): Iterable&lt;number&gt;</code> [R，ES6]</li>
<li><code>.lastIndexOf(searchElement: T, fromIndex=this.length-1): number</code> [R，ES5]</li>
<li><code>.map&lt;U&gt;(mapFunc: (value: T, index: number, array: TypedArray&lt;T&gt;) =&gt; U, thisArg?: any): U[]</code> [R，ES5]</li>
<li><code>.reduce&lt;U&gt;(callback: (accumulator: U, element: T, index: number, array: T[]) =&gt; U, init?: U): U</code> [R，ES5]</li>
<li><code>.reduceRight&lt;U&gt;(callback: (accumulator: U, element: T, index: number, array: T[]) =&gt; U, init?: U): U</code> [R，ES5]</li>
<li><code>.reverse(): this</code> [W，ES1]</li>
<li><code>.slice(start=0, end=this.length): T[]</code> [R，ES3]</li>
<li><code>.some(callback: (value: T, index: number, array: TypedArray&lt;T&gt;) =&gt; boolean, thisArg?: any): boolean</code> [R，ES5]</li>
<li><code>.sort(compareFunc?: (a: T, b: T) =&gt; number): this</code> [W，ES1]</li>
<li><code>.toString(): string</code> [R，ES1]</li>
<li><code>.values(): Iterable&lt;number&gt;</code> [R，ES6]</li>
</ul>
<p>有关这些方法如何工作的详细信息，请参阅<a href="ch_arrays.html#quickref-array-prototype">关于普通数组</a>的章节。</p>
<h4 id="2947-new-elementtypearray">29.4.7。 <code>new «ElementType»Array()</code></h4>
<p>每个 Typed Array 构造函数的名称都遵循模式<code>«ElementType»Array</code>，其中<code>«ElementType»</code>是开头表格中的元素类型之一。这意味着有 9 个类型数组的构造函数：<code>Int8Array</code>，<code>Uint8Array</code>，<code>Uint8ClampedArray</code>（元素类型<code>Uint8C</code>），<code>Int16Array</code>，<code>Uint16Array</code>，<code>Int32Array</code>，<code>Uint32Array</code>，<code>Float32Array</code>， <code>Float64Array</code>。</p>
<p>每个构造函数都有四个 _ 重载 _ 版本 - 它的行为会有所不同，具体取决于它接收的参数数量以及它们的类型：</p>
<ul>
<li> <p><code>new «ElementType»Array(buffer: ArrayBuffer, byteOffset=0, length=0)</code></p> <p>创建一个新的<code>«ElementType»Array</code>，其缓冲区为<code>buffer</code>。它开始访问给定<code>byteOffset</code>的缓冲区，并具有给定的<code>length</code>。请注意，<code>length</code>计算 Typed Array 的元素（每个 1-4 字节），而不是字节。</p> </li>
<li> <p><code>new «ElementType»Array(length=0)</code></p> <p>使用给定的<code>length</code>和相应的缓冲区（其大小以字节为<code>length * «ElementType»Array.BYTES_PER_ELEMENT</code>）创建新的<code>«ElementType»Array</code>。</p> </li>
<li> <p><code>new «ElementType»Array(source: TypedArray)</code></p> <p>创建<code>«ElementType»Array</code>的新实例，其元素与<code>source</code>的元素具有相同的值，但强制为<code>ElementType</code>。</p> </li>
<li> <p><code>new «ElementType»Array(source: ArrayLike&lt;number&gt;)</code></p> <p>创建<code>«ElementType»Array</code>的新实例，其元素与<code>source</code>的元素具有相同的值，但强制为<code>ElementType</code>。 （有关类似数组的对象的更多信息，请参阅<a href="ch_arrays.html#array-like-objects">关于数组</a>的章节。）</p> </li>
</ul>
<p>以下代码显示了创建相同 Typed 数组的三种不同方法：</p>
<pre><code class="language-js">const ta1 = new Uint8Array([0, 1, 2]);

const ta2 = Uint8Array.of(0, 1, 2);

const ta3 = new Uint8Array(3);
ta3[0] = 0;
ta3[1] = 1;
ta3[2] = 2;

assert.deepEqual(ta1, ta2);
assert.deepEqual(ta1, ta3);
</code></pre>
<h4 id="2948-elementtypearray的静态属性">29.4.8。 <code>«ElementType»Array</code>的静态属性</h4>
<ul>
<li> <p><code>«ElementType»Array.BYTES_PER_ELEMENT: number</code></p> <p>计算存储单个元素需要多少字节：</p> <pre><code class="language-js">&gt; Uint8Array.BYTES_PER_ELEMENT
1
&gt; Int16Array.BYTES_PER_ELEMENT
2
&gt; Float64Array.BYTES_PER_ELEMENT
8
</code></pre> </li>
</ul>
<h4 id="2949-elementtypearrayprototype的属性">29.4.9。 <code>«ElementType»Array.prototype</code>的属性</h4>
<ul>
<li> <p><code>.BYTES_PER_ELEMENT: number</code></p> <p>与<code>«ElementType»Array.BYTES_PER_ELEMENT</code>相同。</p> </li>
</ul>
<h4 id="29410连接类型数组">29.4.10。连接类型数组</h4>
<p>类型数组没有方法<code>.concat()</code>，就像普通数组那样。解决方法是使用该方法</p>
<pre><code class="language-js">.set(typedArray: TypedArray, offset=0): void
</code></pre>
<p>该方法将现有的 Typed Array 复制到索引<code>offset</code>的<code>typedArray</code>中。然后你只需要确保<code>typedArray</code>足够大以容纳你想要连接的所有（Typed）数组：</p>
<pre><code class="language-js">function concatenate(resultConstructor, ...arrays) {
  let totalLength = 0;
  for (const arr of arrays) {
    totalLength += arr.length;
  }
  const result = new resultConstructor(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
assert.deepEqual(
  concatenate(Uint8Array,
    Uint8Array.of(1, 2), [3, 4]),
    Uint8Array.of(1, 2, 3, 4)
);
</code></pre>
<h3 id="295-dataviews-的">29.5。 DataViews 的</h3>
<h4 id="2951-new-dataview">29.5.1。 <code>new DataView()</code></h4>
<ul>
<li> <p><code>new DataView(buffer: ArrayBuffer, byteOffset=0, byteLength=buffer.byteLength-byteOffset)</code></p> <p>创建一个新的 DataView，其数据存储在 ArrayBuffer <code>buffer</code>中。默认情况下，新的 DataView 可以访问所有<code>buffer</code>，最后两个参数允许您更改它。</p> </li>
</ul>
<h4 id="2952-dataviewprototype的属性">29.5.2。 <code>DataView.prototype</code>的属性</h4>
<p><code>«ElementType»</code>可以是：<code>Float32</code>，<code>Float64</code>，<code>Int8</code>，<code>Int16</code>，<code>Int32</code>，<code>Uint8</code>，<code>Uint16</code>，<code>Uint32</code>。</p>
<ul>
<li> <p><code>get .buffer()</code></p> <p>返回此 DataView 的 ArrayBuffer。</p> </li>
<li> <p><code>get .byteLength()</code></p> <p>返回此 DataView 可以访问的字节数。</p> </li>
<li> <p><code>get .byteOffset()</code></p> <p>返回此 DataView 开始访问其缓冲区中的字节的偏移量。</p> </li>
<li> <p><code>.get«ElementType»(byteOffset: number, littleEndian=false)</code></p> <p>从此 DataView 的缓冲区中读取值。</p> </li>
<li> <p><code>.set«ElementType»(byteOffset: number, value: number, littleEndian=false)</code></p> <p>将<code>value</code>写入此 DataView 的缓冲区。</p> </li>
</ul>
<h3 id="296进一步阅读">29.6。进一步阅读</h3>
<p><a href="http://exploringjs.com/es6/ch_typed-arrays.html">“探索 ES6”中关于类型化数组</a>的章节还有一些额外的内容：</p>
<ul>
<li>有关支持 Typed Arrays 的浏览器 API 的更多详细信息</li>
<li>一个现实世界的例子</li>
<li>还有一些技术细节。</li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/61/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/61/index.html">前端开发者手册</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/37.html">dwqs</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="css3">css3</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月5日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 548个">548</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/67/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/67/index.html">JavaScript 资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 4565个">4565</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/147/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/147/index.html">JSON风格指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/79.html">darcyliu</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年3月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1139个">1139</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/96/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/96/index.html">零基础学Python</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/59.html">qiwsir</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">80页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月29日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1635个">1635</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/187/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/187/index.html">软件开发的工程化</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 112个">112</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/37/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/android_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/37/index.html">安卓逆向系列教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/15.html">wizardforcel</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="android">android</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">20页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 87个">87</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/171/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/171/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/1.html" title="I.背景" data-book-page-rel-url="docs/1.html" data-book-page-id="11641">I.背景</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/2.html" title="1.关于本书（ES2019 版）" data-book-page-rel-url="docs/2.html" data-book-page-id="11642">1.关于本书（ES2019 版）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/3.html" title="2.常见问题：本书" data-book-page-rel-url="docs/3.html" data-book-page-id="11643">2.常见问题：本书</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/4.html" title="3. JavaScript 的历史和演变" data-book-page-rel-url="docs/4.html" data-book-page-id="11644">3. JavaScript 的历史和演变</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/5.html" title="4.常见问题：JavaScript" data-book-page-rel-url="docs/5.html" data-book-page-id="11645">4.常见问题：JavaScript</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/6.html" title="II.第一步" data-book-page-rel-url="docs/6.html" data-book-page-id="11646">II.第一步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/7.html" title="5.概览" data-book-page-rel-url="docs/7.html" data-book-page-id="11647">5.概览</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/8.html" title="6.语法" data-book-page-rel-url="docs/8.html" data-book-page-id="11648">6.语法</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/9.html" title="7.在控制台上打印信息（`console.*`）" data-book-page-rel-url="docs/9.html" data-book-page-id="11649">7.在控制台上打印信息（`console.*`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/10.html" title="8.断言 API" data-book-page-rel-url="docs/10.html" data-book-page-id="11650">8.断言 API</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/11.html" title="9.测验和练习入门" data-book-page-rel-url="docs/11.html" data-book-page-id="11651">9.测验和练习入门</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/12.html" title="III.变量和值" data-book-page-rel-url="docs/12.html" data-book-page-id="11652">III.变量和值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/13.html" title="10.变量和赋值" data-book-page-rel-url="docs/13.html" data-book-page-id="11653">10.变量和赋值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/14.html" title="11.值" data-book-page-rel-url="docs/14.html" data-book-page-id="11654">11.值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/15.html" title="12.运算符" data-book-page-rel-url="docs/15.html" data-book-page-id="11655">12.运算符</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/16.html" title="IV.原始值" data-book-page-rel-url="docs/16.html" data-book-page-id="11656">IV.原始值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/17.html" title="13.非值`undefined`和`null`" data-book-page-rel-url="docs/17.html" data-book-page-id="11657">13.非值`undefined`和`null`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/18.html" title="14.布尔值" data-book-page-rel-url="docs/18.html" data-book-page-id="11658">14.布尔值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/19.html" title="15.数字" data-book-page-rel-url="docs/19.html" data-book-page-id="11659">15.数字</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/20.html" title="16. `Math`" data-book-page-rel-url="docs/20.html" data-book-page-id="11660">16. `Math`</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/21.html" title="17. Unicode - 简要介绍（高级）" data-book-page-rel-url="docs/21.html" data-book-page-id="11661">17. Unicode - 简要介绍（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/22.html" title="18.字符串" data-book-page-rel-url="docs/22.html" data-book-page-id="11662">18.字符串</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/23.html" title="19.使用模板字面值和标记模板" data-book-page-rel-url="docs/23.html" data-book-page-id="11663">19.使用模板字面值和标记模板</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/24.html" title="20.符号" data-book-page-rel-url="docs/24.html" data-book-page-id="11664">20.符号</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/25.html" title="V.控制流和数据流" data-book-page-rel-url="docs/25.html" data-book-page-id="11665">V.控制流和数据流</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/26.html" title="21.控制流语句" data-book-page-rel-url="docs/26.html" data-book-page-id="11666">21.控制流语句</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/27.html" title="22.异常处理" data-book-page-rel-url="docs/27.html" data-book-page-id="11667">22.异常处理</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/28.html" title="23.可调用值" data-book-page-rel-url="docs/28.html" data-book-page-id="11668">23.可调用值</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/29.html" title="VI.模块化" data-book-page-rel-url="docs/29.html" data-book-page-id="11669">VI.模块化</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/30.html" title="24.模块" data-book-page-rel-url="docs/30.html" data-book-page-id="11670">24.模块</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/31.html" title="25.单个对象" data-book-page-rel-url="docs/31.html" data-book-page-id="11671">25.单个对象</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/32.html" title="26.原型链和类" data-book-page-rel-url="docs/32.html" data-book-page-id="11672">26.原型链和类</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/33.html" title="七.集合" data-book-page-rel-url="docs/33.html" data-book-page-id="11673">七.集合</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/34.html" title="27.同步迭代" data-book-page-rel-url="docs/34.html" data-book-page-id="11674">27.同步迭代</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/35.html" title="28.数组（`Array`）" data-book-page-rel-url="docs/35.html" data-book-page-id="11675">28.数组（`Array`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/36.html" title="29.类型化数组：处理二进制数据（高级）" data-book-page-rel-url="docs/36.html" data-book-page-id="11676">29.类型化数组：处理二进制数据（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/37.html" title="30.映射（`Map`）" data-book-page-rel-url="docs/37.html" data-book-page-id="11677">30.映射（`Map`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/38.html" title="31. WeakMaps（`WeakMap`）" data-book-page-rel-url="docs/38.html" data-book-page-id="11678">31. WeakMaps（`WeakMap`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/39.html" title="32.集（`Set`）" data-book-page-rel-url="docs/39.html" data-book-page-id="11679">32.集（`Set`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/40.html" title="33. WeakSets（`WeakSet`）" data-book-page-rel-url="docs/40.html" data-book-page-id="11680">33. WeakSets（`WeakSet`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/41.html" title="34.解构" data-book-page-rel-url="docs/41.html" data-book-page-id="11681">34.解构</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/42.html" title="35.同步生成器（高级）" data-book-page-rel-url="docs/42.html" data-book-page-id="11682">35.同步生成器（高级）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/43.html" title="八.异步" data-book-page-rel-url="docs/43.html" data-book-page-id="11683">八.异步</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/44.html" title="36. JavaScript 中的异步编程" data-book-page-rel-url="docs/44.html" data-book-page-id="11684">36. JavaScript 中的异步编程</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/45.html" title="37.异步编程的 Promise" data-book-page-rel-url="docs/45.html" data-book-page-id="11685">37.异步编程的 Promise</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/46.html" title="38.异步函数" data-book-page-rel-url="docs/46.html" data-book-page-id="11686">38.异步函数</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/47.html" title="IX.更多标准库" data-book-page-rel-url="docs/47.html" data-book-page-id="11687">IX.更多标准库</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/48.html" title="39.正则表达式（`RegExp`）" data-book-page-rel-url="docs/48.html" data-book-page-id="11688">39.正则表达式（`RegExp`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/49.html" title="40.日期（`Date`）" data-book-page-rel-url="docs/49.html" data-book-page-id="11689">40.日期（`Date`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/50.html" title="41.创建和解析 JSON（`JSON`）" data-book-page-rel-url="docs/50.html" data-book-page-id="11690">41.创建和解析 JSON（`JSON`）</a>
</li>
<li>
<a class="pjax" href="../../../book/171/docs/51.html" title="42.其余章节在哪里？" data-book-page-rel-url="docs/51.html" data-book-page-id="11691">42.其余章节在哪里？</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =171;var bookPageId =11676;var bookPageRelUrl ='docs/36.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>