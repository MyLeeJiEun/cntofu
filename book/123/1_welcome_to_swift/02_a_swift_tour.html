
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Swift 概述-The Swift Programming Language 中文破船版</title>
<meta content='Swift 概述,The Swift Programming Language 中文破船版' name='keywords'>
<meta content='Swift 概述,The Swift Programming Language 中文破船版' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/123/1_welcome_to_swift/01_about_swift.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">关于 Swift</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/123/language_guide/README.html">
<span class="">Swift 语言指导</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/123/index.html">The Swift Programming Language 中文破船版</a>
<a target="_blank" rel="nofollow" href="https://github.com/tzivanmoe/the-swift-programming-language-chinese-bv-version" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="swift-概述">Swift 概述</h1>
<blockquote>
<p>本节<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html">苹果官方原文</a></p>
</blockquote>
<hr>
<p>本节目录</p>
<ul>
<li><a href="#simple_values">简单的值</a></li>
<li><a href="#Control_Flow">流程控制</a></li>
<li><a href="#Functions_and_Closures">函数和闭包</a></li>
<li><a href="#Objects_and_Classes">对象和类</a></li>
<li><a href="#Enumerations_and_Structures">枚举和结构体</a></li>
<li><a href="#Protocols_and_Extensions">协议和扩展</a></li>
<li><a href="#Generics">泛型</a></li>
</ul>
<hr>
<p>按照惯例，学习一门新的编程语言，写的第一个程序就是在屏幕中打印出 "Hello, World"。在 Swift 中，只需要一行代码就可以搞定：</p>
<pre><code class="language-swift">println("Hello, world")
</code></pre>
<p>如果你写过 C 或 Objective-C 代码，那么上面用 Swift 写的代码你看起来应该眼熟，上面这行代码就是一个完整的程序。不需要 import 某个库来处理输入 / 输出，或做字符处理。写在全局范围的代码会被认作程序的入口点，所以 main 函数不是必须的。在语句尾部也不需要写分号。</p>
<p>这里的概述通过向你展示如何完成各种编程任务，提供足够多的信息来开始写 Swift 代码。本节中介绍的某些内容如果你不理解，也不用担心，在本书的后续章节中会做详细的解释。</p>
<blockquote>
<p>####注意 为了最佳编程体验，在 Xcode 中以 playground 方式打开本章内容。Playground 允许我们边写代码边看结果。</p>
<p>打开 <a href="https://github.com/BeyondVincent/the-swift-programming-language-chinese-bv-version/blob/master/1_welcome_to_swift/GuidedTour.playground.zip?raw=true">Playground</a></p>
</blockquote>
<p><a name="simple_values"></a> ##简单的值</p>
<p>使用 <code>let</code> 关键字声明一个常量，而变量的声明则用 <code>var</code>。虽然不需要知道常量在编译时期的值，但是需要给常量做一次确定的赋值。这意味着用常量来命名一个值时只能一次完成，不过可以在多个地方使用。</p>
<pre><code class="language-swift">var myVariable = 42
myVariable = 50
let myConstant = 42
</code></pre>
<p>一个常量或变量的类型必须与你希望给其赋值的类型相同。不过我们不需要总是把类型明确的标示出来。当创建一个常量或变量时，编译器会推断出所提供值的类型。在上面的示例中，编译器推断出 <code>myVariable</code> 的类型是一个整型。因为它的初始值是整型。</p>
<p>如果初始值不能提供足够多的信息 (或者没有初始值)，可以在变量名后面指定具体的类型，类型与变量名之间用冒号分开。</p>
<pre><code class="language-swift">let implicitInteger = 70
let implicitDouble = 70.0
let explicitDouble: Double = 70
</code></pre>
<blockquote>
<p>####实验 创建一个常量，其类型明确指定为 <code>Float</code>，并且初始值为 <code>4</code>。</p>
</blockquote>
<p>值永远不会隐式的转换为另外一种类型。如果需要将值转换为另外一种不同的类型，需要根据所需类型创建一个实例。</p>
<pre><code class="language-swift">let label = "The width is "
let width = 94
let widthLabel = label + String(width)
</code></pre>
<blockquote>
<p>####实验 将上面最后一行代码中的 <code>String</code> 移除，看看会出现什么错误？</p>
</blockquote>
<p>在字符串中包含一个值还有更简单的方法：将值写在括弧中，然后在括弧前面写一个反斜线(\)。例如：</p>
<pre><code class="language-swift">let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fruitSummary = "I have \(apples + oranges) pieces of fruit."
</code></pre>
<blockquote>
<p>####实验 在一个字符串中利用 <code>\\()</code> 包含一个浮点计算，以及对某人的问候。</p>
</blockquote>
<p>使用括号 ([]) 创建一个数组和字典，并通过索引或括号中的 key 来访问里面的元素。</p>
<pre><code class="language-swift">var shoppingList = ["catfish", "water", "tulips", "blue paint"]
shoppingList[1] = "bottle of water"

var occupations = [
    "Malcolm": "Captain",
    "Kaylee": "Mechanic",
]
occupations["Jayne"] = "Public Relations"
</code></pre>
<p>要创建一个空数组或字典，可以使用初始化语法。</p>
<pre><code class="language-swift">let emptyArray = [String]()
let emptyDictionary = Dictionary&lt;String, Float&gt;()
</code></pre>
<p>如果编译器能够推断出相关的类型，那么可以用 <code>[]</code> 代表空数组，<code>[:]</code> 代表空字典 — 例如，当你要给一个变量设置新的值，或给函数传递一个参数时。</p>
<pre><code>shoppingList = []   // 去购物吧
</code></pre>
<p><a name="Control_Flow"></a> ##流程控制</p>
<p>条件表达式使用 <code>if</code> 和 <code>switch</code> 关键字，而循环语句可以使用关键字<code>for-in</code>, <code>for</code>, <code>while</code> 和 <code>do-while</code>。条件表达式和循环语句附近的扩或是可选的，而里面的内容则必须要使用括弧。</p>
<pre><code class="language-swift">let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score &gt; 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
teamScore
</code></pre>
<p>在 <code>if</code> 语句中，条件必须是布尔表达式 — 也就是说这样的代码 <code>if score { ... }</code> 是错误的，并不会隐式的比较为 0。</p>
<p>可以结合 <code>if</code> 和 <code>let</code> 一起使用，表示相关的值可能会缺失。这些相关的值表示可选的 (optional)。一个可选的值可以包含一个值，或者包含一个 <code>nil</code> (表示这个值缺失)。在值的类型后面写一个问号 (?) 表示这个值是可选的。</p>
<pre><code class="language-swift">var optionalString: String? = "Hello"
optionalString == nil

var optionalName: String? = "John Appleseed"
var greeting = "Hello!"
if let name = optionalName {
    greeting = "Hello, \(name)"
}
</code></pre>
<blockquote>
<p>####实验 将 <code>optionalName</code> 的值修改为 <code>nil</code>。看看得到什么结果？添加一个 <code>else</code> 分支，如果 <code>optionalName</code> 是 <code>nil</code> 时，设置不同的问候。</p>
</blockquote>
<p>如果可选值是 <code>nil'，条件表达式将是</code>false<code>，就不会执行括弧中的代码。否则，将会把值展开，并赋给</code>let` 后面的常量，可以在后面的代码块中使用这个常量值。</p>
<p>switch 支持任意类型的数据，以及各种各样的比较操作 — 不限于整型和相等性检测。</p>
<pre><code class="language-swift">let vegetable = "red pepper"
switch vegetable {
case "celery":
    let vegetableComment = "Add some raisins and make ants on a log."
case "cucumber", "watercress":
    let vegetableComment = "That would make a good tea sandwich."
case let x where x.hasSuffix("pepper"):
    let vegetableComment = "Is it a spicy \(x)?"
default:
    let vegetableComment = "Everything tastes good in soup."
}
</code></pre>
<blockquote>
<p>####实验 移除上面代码中的 default 分支。观察一下会发生什么？</p>
</blockquote>
<p>在执行完匹配上的 case 之后，程序会退出 switch 语句，并不会接着执行后续的 case。所以在 case 语句代码的尾部不需要明确写上 break。</p>
<p>使用 <code>for-in</code> 可以迭代字典中的每一项，每次可以获得一对键值。</p>
<pre><code class="language-swift">let interestingNumbers = [
    "Prime": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Square": [1, 4, 9, 16, 25],
]
var largest = 0
for (kind, numbers) in interestingNumbers {
    for number in numbers {
        if number &gt; largest {
            largest = number
        }
    }
}
largest
</code></pre>
<blockquote>
<p>####实验 添加另外一个变量来记录最大数字的类型。</p>
</blockquote>
<p>使用 <code>while</code> 来重复执行代码块，直到条件发生改变。循环条件可以放在尾部，这样可以确保代码块至少运行一次。</p>
<pre><code class="language-swift">var n = 2
while n &lt; 100 {
    n = n * 2
}
n

var m = 2
do {
    m = m * 2
} while m &lt; 100
m
</code></pre>
<p>在循环中可以使用索引 — 通过 <code>..&lt;</code> 设置索引的范围或明确的写出初始值、条件和增量。下面的两个循环结果是一样的：</p>
<pre><code class="language-swift">var firstForLoop = 0
for i in 0..&lt;4 {
    firstForLoop += i
}
firstForLoop

var secondForLoop = 0
for var i = 0; i &lt; 4; ++i {
    secondForLoop += i
}
secondForLoop
</code></pre>
<p>使用 <code>..&lt;</code> 构建的范围忽略了上限值，而使用 <code>...&lt;</code>构建的范围则包括上限和下限值。</p>
<p><a name="Functions_and_Closures"></a> ##函数和闭包</p>
<p>使用 <code>func</code> 来声明一个函数。通过在函数名称后面的括弧中跟上参数列表，就可以对函数进行调用。</p>
<pre><code class="language-swift">func greet(name: String, day: String) -&gt; String {
    return "Hello \(name), today is \(day)."
}
greet("Bob", "Tuesday")
</code></pre>
<blockquote>
<p>####实验 移除掉上面代码中的 <code>day</code> 参数，然后添加一个参数，用来在问候中包含今天的午餐。</p>
</blockquote>
<p>使用一个元祖 (tuple) 可以从一个函数中返回多个值。</p>
<pre><code class="language-swift">func getGasPrices() -&gt; (Double, Double, Double) {
    return (3.59, 3.69, 3.79)
}
getGasPrices()
</code></pre>
<p>函数同样可以接受可变参数，它会将这些参数封装进一个数组中。</p>
<pre><code class="language-swift">func sumOf(numbers: Int...) -&gt; Int {
    var sum = 0
    for number in numbers {
        sum += number
    }
    return sum
}
sumOf()
sumOf(42, 597, 12)
</code></pre>
<blockquote>
<p>####实验 写一个函数，用来计算出该函数中参数的平均值。</p>
</blockquote>
<p>函数还可以嵌套。被嵌套的函数可以访问外部函数中定义的变量。我们可以用嵌套函数来编写长或复杂的代码。</p>
<pre><code class="language-swift">func returnFifteen() -&gt; Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
</code></pre>
<p>swift 中的函数是 一等 (first-class) 类型。这就意味着一个函数可以将另外一个函数以值的方式返回。</p>
<pre><code class="language-swift">func makeIncrementer() -&gt; (Int -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre>
<p>函数还可以当做参数传入到另外一个函数中。</p>
<pre><code class="language-swift">func hasAnyMatches(list: [Int], condition: Int -&gt; Bool) -&gt; Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(numbers, lessThanTen)
</code></pre>
<p>函数实际上是一种特殊的闭包：可以在后面调用函数中的代码块。在闭包中的代码可以访问在创建闭包所在范围构建的内容，例如变量和函数，甚至是闭包在执行的时候可以访问不同范围的内容 — 例如上面介绍的嵌套函数。我们可以写没有名字的闭包，只需要将代码写在大括弧 (<code>{}</code>) 内即可。在闭包代码体内利用 <code>in</code> 关键字将参数和返回值与代码体分隔开。</p>
<pre><code class="language-swift">numbers.map({
    (number: Int) -&gt; Int in
    let result = 3 * number
    return result
    })
</code></pre>
<blockquote>
<p>####实验 重写上面的闭包代码，所有的奇数都返回 0。</p>
</blockquote>
<p>有多种选择可以让编写的闭包代码更简洁。当已知闭包的类型时，例如调用一个 delegate，那么可以忽略掉它的参数和返回值。一行语句的闭包表示将返回语句的值。</p>
<pre><code class="language-swift">let mappedNumbers = numbers.map({ number in 3 * number })
mappedNumbers
</code></pre>
<p>对参数的引用可以用参数的位置来代替参数的名称 — 这种方法在很短的闭包中非常有用。一个闭包以最后一个参数传递给某个函数时，这个闭包可以立即跟在括弧后面。</p>
<pre><code class="language-swift">let sortedNumbers = sorted(numbers) { $0 &gt; $1 }
sortedNumbers
</code></pre>
<p><a name="Objects_and_Classes"></a> ##对象和类</p>
<p>在 <code>class</code> 后面跟上类名就可以创建一个类。在类中，属性声明的写法与常量或者变量声明一样，唯一的区别就是它们的上下文处于类中。同样，函数和方法的声明也是一样的。</p>
<pre><code class="language-swift">class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
        return "A shape with \(numberOfSides) sides."
    }
}
</code></pre>
<blockquote>
<p>####实验 在上面的代码中用 <code>let</code> 添加一个常量属性，以及带一个参数的方法。</p>
</blockquote>
<p>在类名后面跟上括弧就能创建一个类实例。使用 <code>.</code> 语法可以访问实例的属性和方法。</p>
<pre><code class="language-swift">var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre>
<p>上面的 <code>Shape</code> 类缺少一些重要的内容：当创建类实例时所需要进行的初始化工作。我们使用 <code>init</code> 可以创建一个。</p>
<pre><code class="language-swift">class NamedShape {
    var numberOfSides: Int = 0
    var name: String

    init(name: String) {
        self.name = name
    }

    func simpleDescription() -&gt; String {
        return "A shape with \(numberOfSides) sides."
    }
}
</code></pre>
<p>注意观察， <code>init</code> 中的 <code>self</code> 用来区分属性 <code>name</code> 和参数中的<code>name</code>。接收一个参数的初始化方法会在创建类的实例时被调用。每一个属性都需要被赋值 — 无论是在类中声明的 (例如 <code>numberOfSides</code>) 或者是在初始化方法中 (如 <code>name</code>)。</p>
<p>如果需要在对象销毁之前执行一些清理任务，可以利用实现一下 <code>deinit</code> 方法。</p>
<p>子类后面可以跟上父类，中间用冒号隔开。在 Swift 中不需要子类继承自某个标准的基类。所以根据需求，我们可以包含或者略去某个父类。</p>
<p>子类中的方法想要重写 (override) 父类中实现的方法，需要将其标记为 <code>override</code> — 如果重写了父类中的某个方法，但是没有 <code>override</code> 标记，编译器会检测出相关错误。另外如果在类中标记为 <code>override</code> 的方法，不存在于父类中，编译器同样会报错。</p>
<pre><code class="language-swift">class Square: NamedShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }

    func area() -&gt;  Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -&gt; String {
        return "A square with sides of length \(sideLength)."
    }
}
let test = Square(sideLength: 5.2, name: "my test square")
test.area()
test.simpleDescription()
</code></pre>
<blockquote>
<p>####实验 构建另外一个基于 <code>NamedShape</code> 的子类：<code>Circle</code>，它的初始化方法接收两个参数：半径和姓名。并实现 <code>area</code> 和 <code>describe</code> 两个方法。</p>
</blockquote>
<p>除了简单属性的存储外，属性还可以有 getter 和 setter。</p>
<pre><code class="language-swift">class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }

    var perimeter: Double {
    get {
        return 3.0 * sideLength
    }
    set {
        sideLength = newValue / 3.0
    }
    }

    override func simpleDescription() -&gt; String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
triangle.perimeter
triangle.perimeter = 9.9
triangle.sideLength
</code></pre>
<p>上面的代码中为 <code>perimeter</code> 编写了一个 setter，隐式的新值用命名为 <code>newValue</code>。在 <code>set</code> 后面可以写一个明确的名称在括号中。</p>
<p>注意 <code>EquilateralTriangle</code> 类的初始化方法中有 3 个不同的步骤：</p>
<ol>
<li>设置这个子类中声明属性的值。</li>
<li>调用父类中的初始化方法。</li>
<li>修改父类中定义的属性值。此处可以做一些额外的工作，例如使用方法，getters 或 setters。</li>
</ol>
<p>如果你不需要对属性做计算，但是又想在属性设置新值之前和之后执行一些代码，那么请使用 <code>willSet</code> 和 <code>didSet</code>。例如，下面这个类总是能够确保三角形的边长与正方形的边长相等。</p>
<pre><code class="language-swift">class TriangleAndSquare {
    var triangle: EquilateralTriangle {
    willSet {
        square.sideLength = newValue.sideLength
    }
    }
    var square: Square {
    willSet {
        triangle.sideLength = newValue.sideLength
    }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
triangleAndSquare.square.sideLength
triangleAndSquare.triangle.sideLength
triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
triangleAndSquare.triangle.sideLength
</code></pre>
<p>类中的函数 (methods) 与普通方法 (functions) 有一个重要的区别。在普通方法中的参数名称只能用于方法内容，而类中函数的参数名称在调用该函数时需要用到 (除了第一个参数)。默认情况下，在调用函数或者函数内部时，，函数的参数名称与参数一样。当然，你可以指定另外一个名称，在函数内部使用。</p>
<pre><code class="language-swift">class Counter {
    var count: Int = 0
    func incrementBy(amount: Int, numberOfTimes times: Int) {
        count += amount * times
    }
}
var counter = Counter()
counter.incrementBy(2, numberOfTimes: 7)
</code></pre>
<p>当使用可选值 (optional values) 时，可以在操作 (这些操作包括函数，属性和下标) 之前写一个 <code>?</code>。如果 <code>?</code> 前面的值是 <code>nil</code>，那么会忽略掉 <code>?</code> 后面的所有内容，并且整个表达式的值为 <code>nil</code>，否则可选值将被展开运行，所有 <code>?</code> 后面内容的运行结果将作为可选值。这两种情况下，整个表达式的值都是一个可选值。</p>
<pre><code class="language-swift">let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
let sideLength = optionalSquare?.sideLength

</code></pre>
<p><a name="Enumerations_and_Structures"></a> ##枚举和结构体</p>
<p>使用关键字 <code>enum</code> 关键字来创建枚举。枚举跟类和其它命名类型一样，枚举中可以包含函数。</p>
<pre><code class="language-swift">enum Rank: Int {
    case Ace = 1
    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
    case Jack, Queen, King
    func simpleDescription() -&gt; String {
        switch self {
        case .Ace:
            return "ace"
        case .Jack:
            return "jack"
        case .Queen:
            return "queen"
        case .King:
            return "king"
        default:
            return String(self.toRaw())
        }
    }
}
let ace = Rank.Ace
let aceRawValue = ace.toRaw()
</code></pre>
<blockquote>
<p>####实验 写一个方法对两个 <code>Rank</code> 的原始值进行对比。</p>
</blockquote>
<p>在上面的示例中，枚举的原始值类型是 <code>Int</code>，所以只需要指定第一个原始值即可。剩余的原始值会按顺序被赋值。除了使用 <code>Int</code> 外，还可以使用字符串或浮点型当做枚举的原始值类型。</p>
<p>使用 <code>toRaw</code> 和 <code>fromRaw</code> 方法可以在原始值和枚举值之间进行转换。</p>
<pre><code class="language-swift">if let convertedRank = Rank.fromRaw(3) {
    let threeDescription = convertedRank.simpleDescription()
}
</code></pre>
<p>枚举的成员值就是其实际的值，并不需要为其写另外一个原始值。。实际上，如果原始值没有意义，那么可以不提供。</p>
<pre><code class="language-swift">enum Suit {
    case Spades, Hearts, Diamonds, Clubs
    func simpleDescription() -&gt; String {
        switch self {
        case .Spades:
            return "spades"
        case .Hearts:
            return "hearts"
        case .Diamonds:
            return "diamonds"
        case .Clubs:
            return "clubs"
        }
    }
}
let hearts = Suit.Hearts
let heartsDescription = hearts.simpleDescription()
</code></pre>
<blockquote>
<p>####实验 给上面的 <code>Suit</code> 添加一个 <code>color</code> 方法，如果是 spades 和 clubs 则返回 "black"，如果是 hearts 和 diamonds 则返回 "red"。</p>
</blockquote>
<p>注意观察上面代码中涉及到 <code>Hearts</code> 成员的两种使用方法：当给常量 <code>hearts</code> 赋值时，由于常量没有明确的指定类型，所以枚举成员变量 <code>Suit.Hearts</code> 的使用方式是全名引用。而在 switch 内部，通过 <code>.Hearts</code> 的方式引用枚举，这是因为里面的 <code>self</code> 值被当做 Suit 处理。当某个值的类型已知的情况下，可以在任意时候使用简写。</p>
<p>使用 <code>sturct</code> 来创建结构体。结构体支持的许多行为与类相似，，包括函数和初始化。结构体与类最重要的一个区别就是：在代码中传递结构体时，总是值传递，而类则是引用传递。</p>
<pre><code class="language-swift">struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -&gt; String {
        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
    }
}
let threeOfSpades = Card(rank: .Three, suit: .Spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
</code></pre>
<blockquote>
<p>####实验 在 <code>Card</code> 中添加一个方法，以构建一副完整的扑克牌，每张牌由点数和花色构成。</p>
</blockquote>
<p>一个枚举成员的实例可以有与实例相关的值。相同枚举成员的实例可以有不同的值。在创建实例时，我们提供相关的值即可。实例相关的值与原始值是不同的：对于同一个枚举成员的所有实例来说，它们的原始值都是相同的，这些原始值是在定义枚举的时候提供的。</p>
<p>例如，我们从服务器上请求日出和日落的时间。服务器要么返回相关正确信息，要么返回一些错误信息。</p>
<pre><code class="language-swift">enum ServerResponse {
    case Result(String, String)
    case Error(String)
}

let success = ServerResponse.Result("6:00 am", "8:09 pm")
let failure = ServerResponse.Error("Out of cheese.")

switch success {
case let .Result(sunrise, sunset):
    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
case let .Error(error):
    let serverResponse = "Failure...  \(error)"
}
</code></pre>
<blockquote>
<p>####实验 给 <code>ServerResponse</code> 和 switch 添加第三个 case。</p>
</blockquote>
<p>注意观察上面的代码中，ServerResponse 作为 switch case 匹配值的一部分，我们是如何从 ServerResponse 中提取出 日出和日落时间的。</p>
<p><a name="Protocols_and_Extensions"></a> ##协议和扩展</p>
<p>使用 <code>protocol</code> 关键字来声明一个协议。</p>
<pre><code class="language-swift">protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
</code></pre>
<p>类，枚举和结构体都可以遵循协议。</p>
<pre><code class="language-swift">class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
</code></pre>
<blockquote>
<p>####实验 参考上面的代码，写一个遵循 <code>ExampleProtocol</code> 协议的枚举。</p>
</blockquote>
<p>注意在上面声明 <code>SimpleStructure</code> 代码中使用了 <code>mutating</code> 关键字，用来对某个方法做出标记，表示其修改了结构。而 <code>SimpleClass</code> 不需要对其中的函数做出这样的标记，因为在类中的方法可以总是对类做出修改。</p>
<p>使用 <code>extension</code> 关键字可以给已存在的类型添加功能，例如添加一个新的函数和对属性做出计算处理。通过<code>extension</code>，你可以给某个类型添加一个遵循的协议，这个类型可以是在任何地方声明的，也可以是从某个库或者 framework 中导入的。</p>
<pre><code class="language-swift">extension Int: ExampleProtocol {
    var simpleDescription: String {
    return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
7.simpleDescription
</code></pre>
<blockquote>
<p>####实验 给 <code>Double</code> 类型写一个 <code>extension</code>，添加一个 <code>absoluteVule</code> 属性。</p>
</blockquote>
<p>你可以像使用其它类型一样使用协议名称 — 例如，创建一个不同类型，但又都遵循单个协议的对象的集合。当使用协议定义的值时，超出协议所定义的方法是不可用的。</p>
<pre><code class="language-swift">let protocolValue: ExampleProtocol = a
protocolValue.simpleDescription
// protocolValue.anotherProperty  // Uncomment to see the error
</code></pre>
<p>虽然 <code>protocolValue</code> 拥有一个 <code>SimpleClass</code> 的运行时类型，但是编译器依旧根据指定的 <code>ExampleProtocol</code> 类型来处理。这就意味着你不能用其访问在类中实现，而没有在协议中声明的方法或属性。</p>
<p><a name="Generics"></a> ##泛型</p>
<p>在尖括弧里面写一个名称就能构建一个泛型函数或类型。</p>
<pre><code class="language-swift">func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; [ItemType] {
    var result = [ItemType]()
    for i in 0..&lt;times {
        result += item
    }
    return result
}
repeat("knock", 4)
</code></pre>
<p>我们不仅可以构建泛型函数和方法，还可以是泛型类、枚举和结构体。</p>
<pre><code class="language-swift">// 重新实现了 Swift 标准库中的可选类型
enum OptionalValue&lt;T&gt; {
    case None
    case Some(T)
}
var possibleInteger: OptionalValue&lt;Int&gt; = .None
possibleInteger = .Some(100)
</code></pre>
<p>在类型名称后面可以使用 <code>where</code> 指定需求列表 — 例如，要求类型实现一个协议，要求两个类型都是相同的，或者要求一个类是继承自某个特定的类。</p>
<pre><code class="language-swift">func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool {
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }
    return false
}
anyCommonElements([1, 2, 3], [3])
</code></pre>
<blockquote>
<p>####实验 修改 <code>anyCommonElements</code> 方法，让其返回一个数组，该数组中的值同时存在于两个序列中。</p>
</blockquote>
<p>在编写简单的类时，可以忽略掉 <code>where</code> 关键字，只需要将协议或类名跟在一个冒号后面即可。例如 <code>&lt;T: Equatable&gt;</code> 的写法与 <code>&lt;T where T: Equatable&gt;</code> 一样。</p>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/12/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/swift_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/12/index.html">Swift 官方教程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/8.html">numbbbbb</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="swift">swift</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">51页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 18022个">18022</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/165/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/165/index.html">Python学习知识库</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/94.html">coco369</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">85页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 190个">190</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/162/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/162/index.html">Python方向综合面试题</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/92.html">jackfrued</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">115页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 35个">35</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/38/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/38/index.html">Java资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">61页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月23日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7938个">7938</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/170/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/170/index.html">scikit-learn (sklearn) 官方文档中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/18.html">ApacheCN</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">65页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2022个">2022</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/125/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/html5_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/125/index.html">前端早读课</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/67.html">if2er</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="html5">html5</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年7月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 7个">7</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/123/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/123/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/123/1_welcome_to_swift/README.html" title="欢迎进入 Swift" data-book-page-rel-url="1_welcome_to_swift/README.html" data-book-page-id="8336">欢迎进入 Swift</a>
<ul>
<li>
<a class="pjax" href="../../../book/123/1_welcome_to_swift/01_about_swift.html" title="关于 Swift" data-book-page-rel-url="1_welcome_to_swift/01_about_swift.html" data-book-page-id="8337">关于 Swift</a>
</li>
<li>
<a class="pjax" href="../../../book/123/1_welcome_to_swift/02_a_swift_tour.html" title="Swift 概述" data-book-page-rel-url="1_welcome_to_swift/02_a_swift_tour.html" data-book-page-id="8338">Swift 概述</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/README.html" title="Swift 语言指导" data-book-page-rel-url="language_guide/README.html" data-book-page-id="8339">Swift 语言指导</a>
<ul>
<li>
<a class="pjax" href="../../../book/123/language_guide/the_basics.html" title="基础知识" data-book-page-rel-url="language_guide/the_basics.html" data-book-page-id="8340">基础知识</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/basic_operators.html" title="基本运算符" data-book-page-rel-url="language_guide/basic_operators.html" data-book-page-id="8341">基本运算符</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/strings_and_characters.html" title="字符串和字符" data-book-page-rel-url="language_guide/strings_and_characters.html" data-book-page-id="8342">字符串和字符</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/collection_types.html" title="集合类型" data-book-page-rel-url="language_guide/collection_types.html" data-book-page-id="8343">集合类型</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/control_flow.html" title="流程控制" data-book-page-rel-url="language_guide/control_flow.html" data-book-page-id="8344">流程控制</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/functions.html" title="函数" data-book-page-rel-url="language_guide/functions.html" data-book-page-id="8345">函数</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/closures.html" title="闭包" data-book-page-rel-url="language_guide/closures.html" data-book-page-id="8346">闭包</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/enumerations.html" title="枚举" data-book-page-rel-url="language_guide/enumerations.html" data-book-page-id="8347">枚举</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/class_and_structures.html" title="类和结构体" data-book-page-rel-url="language_guide/class_and_structures.html" data-book-page-id="8348">类和结构体</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/properties.html" title="属性" data-book-page-rel-url="language_guide/properties.html" data-book-page-id="8349">属性</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/methods.html" title="方法" data-book-page-rel-url="language_guide/methods.html" data-book-page-id="8350">方法</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/subscripts.html" title="下标" data-book-page-rel-url="language_guide/subscripts.html" data-book-page-id="8351">下标</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/inheritance.html" title="继承" data-book-page-rel-url="language_guide/inheritance.html" data-book-page-id="8352">继承</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/initialization.html" title="初始化" data-book-page-rel-url="language_guide/initialization.html" data-book-page-id="8353">初始化</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/deinitialization.html" title="析构" data-book-page-rel-url="language_guide/deinitialization.html" data-book-page-id="8354">析构</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/automatic_reference_counting.html" title="自动引用计数" data-book-page-rel-url="language_guide/automatic_reference_counting.html" data-book-page-id="8355">自动引用计数</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/optional_chaining.html" title="可选链" data-book-page-rel-url="language_guide/optional_chaining.html" data-book-page-id="8356">可选链</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/type_casting.html" title="类型转换" data-book-page-rel-url="language_guide/type_casting.html" data-book-page-id="8357">类型转换</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/nested_types.html" title="嵌套类型" data-book-page-rel-url="language_guide/nested_types.html" data-book-page-id="8358">嵌套类型</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/extensions.html" title="扩展" data-book-page-rel-url="language_guide/extensions.html" data-book-page-id="8359">扩展</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/protocols.html" title="协议" data-book-page-rel-url="language_guide/protocols.html" data-book-page-id="8360">协议</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/generics.html" title="泛型" data-book-page-rel-url="language_guide/generics.html" data-book-page-id="8361">泛型</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/access_control.html" title="访问控制" data-book-page-rel-url="language_guide/access_control.html" data-book-page-id="8362">访问控制</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_guide/advanced_operators.html" title="高级运算符" data-book-page-rel-url="language_guide/advanced_operators.html" data-book-page-id="8363">高级运算符</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/README.html" title="Swift 语言参考" data-book-page-rel-url="language_reference/README.html" data-book-page-id="8364">Swift 语言参考</a>
<ul>
<li>
<a class="pjax" href="../../../book/123/language_reference/about_the_language_reference.html" title="关于 Swift 语言参考" data-book-page-rel-url="language_reference/about_the_language_reference.html" data-book-page-id="8365">关于 Swift 语言参考</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/lexical_structure.html" title="语法结构" data-book-page-rel-url="language_reference/lexical_structure.html" data-book-page-id="8366">语法结构</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/types.html" title="类型" data-book-page-rel-url="language_reference/types.html" data-book-page-id="8367">类型</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/expressions.html" title="表达式" data-book-page-rel-url="language_reference/expressions.html" data-book-page-id="8368">表达式</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/statements.html" title="语句" data-book-page-rel-url="language_reference/statements.html" data-book-page-id="8369">语句</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/declarations.html" title="声明" data-book-page-rel-url="language_reference/declarations.html" data-book-page-id="8370">声明</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/attributes.html" title="特性" data-book-page-rel-url="language_reference/attributes.html" data-book-page-id="8371">特性</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/patterns.html" title="模式" data-book-page-rel-url="language_reference/patterns.html" data-book-page-id="8372">模式</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/generic_parameters_and_arguments.html" title="泛型参数和引数" data-book-page-rel-url="language_reference/generic_parameters_and_arguments.html" data-book-page-id="8373">泛型参数和引数</a>
</li>
<li>
<a class="pjax" href="../../../book/123/language_reference/summary_of_the_grammar.html" title="语法总结" data-book-page-rel-url="language_reference/summary_of_the_grammar.html" data-book-page-id="8374">语法总结</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/123/why_this_project/README.html" title="缘由" data-book-page-rel-url="why_this_project/README.html" data-book-page-id="8375">缘由</a>
</li>
<li>
<a class="pjax" href="../../../book/123/revision_history/README.html" title="修订记录" data-book-page-rel-url="revision_history/README.html" data-book-page-id="8376">修订记录</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =123;var bookPageId =8338;var bookPageRelUrl ='1_welcome_to_swift/02_a_swift_tour.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>