
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>Spring事务管理-Java后端开发笔记</title>
<meta content='Spring事务管理,Java后端开发笔记' name='keywords'>
<meta content='Spring事务管理,Java后端开发笔记' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/84/spring/spring-view-resolver.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">Spring view..</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/84/spring/asfsadf.html">
<span class="">基于Token的WEB..</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/84/index.html">Java后端开发笔记</a>
<a target="_blank" rel="nofollow" href="https://github.com/shunliz/j2ee" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<p>写这篇博客之前我首先读了《Spring in action》，之后在网上看了一些关于Spring事务管理的文章，感觉都没有讲全，这里就将书上的和网上关于事务的知识总结一下，参考的文章如下：</p>
<blockquote>
<ul>
<li><a href="http://www.open-open.com/lib/view/open1350865116821.html">Spring事务机制详解</a></li>
<li><a href="http://www.blogjava.net/robbie/archive/2009/04/05/264003.html">Spring事务配置的五种方式</a></li>
<li><a href="http://www.jb51.net/article/57589.htm">Spring中的事务管理实例详解</a></li>
</ul>
</blockquote>
<h1 id="1-初步理解-1-初步理解">1 初步理解 {#1-初步理解}</h1>
<p>理解事务之前，先讲一个你日常生活中最常干的事：取钱。<br> 比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。<br> 事务就是用来解决类似问题的。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。<br> 在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。<br> 事务有四个特性：ACID</p>
<blockquote>
<ul>
<li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li>
<li>
<ul>
<li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
</ul> </li>
<li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li>
</ul>
</blockquote>
<h1 id="2-核心接口-2-核心接口">2 核心接口 {#2-核心接口}</h1>
<p>Spring事务管理的实现有许多细节，如果对整个接口框架有个大体了解会非常有利于我们理解事务，下面通过讲解Spring的事务接口来了解Spring实现事务的具体策略。<br> Spring事务管理涉及的接口的联系如下：</p>
<p><a href="http://img.blog.csdn.net/20160324011156424" data-uk-lightbox><img src="http://img.blog.csdn.net/20160324011156424" alt="" title="技术分享"></a></p>
<h2 id="21-事务管理器-21-事务管理器">2.1 事务管理器 {#21-事务管理器}</h2>
<p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。<br> Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。此接口的内容如下：</p>
<pre><code class="language-java">Public interface PlatformTransactionManager()...{  
    // 由TransactionDefinition得到TransactionStatus对象
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; 
    // 提交
    Void commit(TransactionStatus status) throws TransactionException;  
    // 回滚
    Void rollback(TransactionStatus status) throws TransactionException;  
    }
</code></pre>
<p>从这里可知具体的具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。</p>
<h3 id="211-jdbc事务-211-jdbc事务">2.1.1 JDBC事务 {#211-jdbc事务}</h3>
<p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：</p>
<pre><code class="language-xml">    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;
</code></pre>
<p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p>
<h3 id="212-hibernate事务-212-hibernate事务">2.1.2 Hibernate事务 {#212-hibernate事务}</h3>
<p>如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<code>&lt;bean&gt;</code>声明：</p>
<pre><code class="language-xml">    &lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;
</code></pre>
<p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p>
<h3 id="213-java持久化api事务jpa-213-java持久化api事务jpa">2.1.3 Java持久化API事务（JPA） {#213-java持久化api事务jpa}</h3>
<p>Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager：</p>
<pre><code class="language-xml">    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;
</code></pre>
<p>JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。</p>
<h3 id="214-java原生api事务-214-java原生api事务">2.1.4 Java原生API事务 {#214-java原生api事务}</h3>
<p>如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：</p>
<pre><code class="language-xml">    &lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"&gt;
        &lt;property name="transactionManagerName" value="java:/TransactionManager" /&gt;
    &lt;/bean&gt;
</code></pre>
<p>JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。</p>
<h2 id="22-基本事务属性的定义-22-基本事务属性的定义">2.2 基本事务属性的定义 {#22-基本事务属性的定义}</h2>
<p>上面讲到的事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。<br> 那么什么是事务属性呢？事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面，如图所示：</p>
<p><a href="http://img.blog.csdn.net/20160325003448793" data-uk-lightbox><img src="http://img.blog.csdn.net/20160325003448793" alt="" title="技术分享"></a></p>
<p>而TransactionDefinition接口内容如下：</p>
<pre><code class="language-java">public interface TransactionDefinition {
    int getPropagationBehavior(); // 返回事务的传播行为
    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据
    int getTimeout();  // 返回事务必须在多少秒内完成
    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的
}
</code></pre>
<p>我们可以发现TransactionDefinition正好用来定义事务属性，下面详细介绍一下各个事务属性。</p>
<h3 id="221-传播行为-221-传播行为">2.2.1 传播行为 {#221-传播行为}</h3>
<p>事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：</p>
<table>
<thead>
<tr>
<th align="left">传播行为</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">PROPAGATION_REQUIRED</td>
<td align="left">表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务</td>
</tr>
<tr>
<td align="left">PROPAGATION_SUPPORTS</td>
<td align="left">表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td>
</tr>
<tr>
<td align="left">PROPAGATION_MANDATORY</td>
<td align="left">表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常</td>
</tr>
<tr>
<td align="left">PROPAGATION_REQUIRED_NEW</td>
<td align="left">表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td align="left">PROPAGATION_NOT_SUPPORTED</td>
<td align="left">表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td align="left">PROPAGATION_NEVER</td>
<td align="left">表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常</td>
</tr>
<tr>
<td align="left">PROPAGATION_NESTED</td>
<td align="left">表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务</td>
</tr>
</tbody>
</table>
<p><em>注：以下具体讲解传播行为的内容参考自</em><a href="http://www.open-open.com/lib/view/open1350865116821.html"><em>Spring事务机制详解</em></a><br> （1）PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>
<pre><code>//事务属性 PROPAGATION_REQUIRED
</code></pre>
<pre><code>methodA
{
……
methodB()
;
……
}
</code></pre>
<pre><code>//事务属性 PROPAGATION_REQUIRED

methodB
{
……
}
</code></pre>
<p>使用spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。</p>
<p>单独调用methodB方法：</p>
<pre><code>main
{

    metodB();
}
</code></pre>
<p>相当于</p>
<pre><code>Main{ 
    Connection con=null; 
    try{ 
        con = getConnection(); 
        con.setAutoCommit(false); 

        //方法调用
        methodB(); 

        //提交事务
        con.commit(); 
    } Catch(RuntimeException ex) { 
        //回滚事务
        con.rollback();   
    } finally { 
        //释放资源
        closeCon(); 
    } 
}
</code></pre>
<p>Spring保证在methodB方法中所有的调用都获得到一个相同的连接。在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。<br> 单独调用MethodA时，在MethodA内又会调用MethodB.</p>
<p>执行效果相当于：</p>
<pre><code>main{ 
    Connection con = null; 
    try{ 
        con = getConnection(); 
        methodA(); 
        con.commit(); 
    } catch(RuntimeException ex) { 
        con.rollback(); 
    } finally {    
        closeCon(); 
    }  
}
</code></pre>
<p>调用MethodA时，环境中没有事务，所以开启一个新的事务.当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务。</p>
<p>（2）PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>
<pre><code>//事务属性 PROPAGATION_REQUIRED
methodA(){
  methodB();
}

//事务属性 PROPAGATION_SUPPORTS
methodB(){
  ……
}
</code></pre>
<p>单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行。</p>
<p>（3）PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<pre><code>//事务属性 PROPAGATION_REQUIRED
methodA(){
    methodB();
}

//事务属性 PROPAGATION_MANDATORY
    methodB(){
    ……
}
</code></pre>
<p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用methodA时，methodB则加入到methodA的事务中，事务地执行。</p>
<p>（4）PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<pre><code>//事务属性 PROPAGATION_REQUIRED
methodA(){
    doSomeThingA();
    methodB();
    doSomeThingB();
}

//事务属性 PROPAGATION_REQUIRES_NEW
methodB(){
    ……
}
</code></pre>
<p>调用A方法：</p>
<pre><code>main()
{
methodA();
}
</code></pre>
<p>相当于</p>
<pre><code>main(){
    TransactionManager tm = null;
    try{
        //获得一个JTA事务管理器
        tm = getTransactionManager();
        tm.begin();//开启一个新的事务
        Transaction ts1 = tm.getTransaction();
        doSomeThing();
        tm.suspend();//挂起当前事务
        try{
            tm.begin();//重新开启第二个事务
            Transaction ts2 = tm.getTransaction();
            methodB();
            ts2.commit();//提交第二个事务
        } Catch(RunTimeException ex) {
            ts2.rollback();//回滚第二个事务
        } finally {
            //释放资源
        }
        //methodB执行完后，恢复第一个事务
        tm.resume(ts1);
        doSomeThingB();
        ts1.commit();//提交第一个事务
    } catch(RunTimeException ex) {
        ts1.rollback();//回滚第一个事务
    } finally {
        //释放资源
    }
}
</code></pre>
<p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于 ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了 methodB之外的其它代码导致的结果却被回滚了。使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。</p>
<p>（5）PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。（代码示例同上，可同理推出）</p>
<p>（6）PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>
<p>（7）PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而 nestedTransactionAllowed属性值默认为false。</p>
<pre><code>//事务属性 PROPAGATION_REQUIRED
methodA(){
    doSomeThingA();
    methodB();
    doSomeThingB();
}

//事务属性 PROPAGATION_NESTED
methodB(){
    ……
}
</code></pre>
<p>如果单独调用methodB方法，则按REQUIRED属性执行。如果调用methodA方法，相当于下面的效果：</p>
<pre><code>main(){
    Connection con = null;
    Savepoint savepoint = null;
    try{
        con = getConnection();
        con.setAutoCommit(false);
        doSomeThingA();
        savepoint = con2.setSavepoint();
        try{
            methodB();
        } catch(RuntimeException ex) {
            con.rollback(savepoint);
        } finally {
            //释放资源
        }
        doSomeThingB();
        con.commit();
    } catch(RuntimeException ex) {
        con.rollback();
    } finally {
        //释放资源
    }
}
</code></pre>
<p>当methodB方法调用之前，调用setSavepoint方法，保存当前的状态到savepoint。如果methodB方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括methodB方法的所有操作。</p>
<p>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
<p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。</p>
<p>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。</p>
<p>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。</p>
<p>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。</p>
<p>由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.</p>
<p>PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p>
<h3 id="222-隔离级别-222-隔离级别">2.2.2 隔离级别 {#222-隔离级别}</h3>
<p>事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。<br> （1）并发事务引起的问题<br> 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。</p>
<blockquote>
<ul>
<li>脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li>
<li>不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</li>
<li>幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li>
</ul>
</blockquote>
<p><strong>不可重复读与幻读的区别</strong></p>
<p>不可重复读的重点是修改:<br> 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了<br> 例如：在事务1中，Mary 读取了自己的工资为1000,操作并没有完成</p>
<pre><code>    con1 = getConnection();  
    select salary from employee empId ="Mary";
</code></pre>
<p>在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.</p>
<pre><code>    con2 = getConnection();  
    update employee set salary = 2000;  
    con2.commit();
</code></pre>
<p>在事务1中，Mary 再次读取自己的工资时，工资变为了2000</p>
<pre><code>    //con1  
    select salary from employee empId ="Mary";
</code></pre>
<p>在一个事务中前后两次读取的结果并不一致，导致了不可重复读。</p>
<p>幻读的重点在于新增或者删除：<br> 同样的条件, 第1次和第2次读出来的记录数不一样<br> 例如：目前工资为1000的员工有10人。事务1,读取所有工资为1000的员工。</p>
<pre><code>    con1 = getConnection();  
    Select * from employee where salary =1000;
</code></pre>
<p>共读取10条记录</p>
<p>这时另一个事务向employee表插入了一条员工记录，工资也为1000</p>
<pre><code>    con2 = getConnection();  
    Insert into employee(empId,salary) values("Lili",1000);  
    con2.commit();
</code></pre>
<p>事务1再次读取所有工资为1000的员工</p>
<pre><code>    //con1  
    select * from employee where salary =1000;
</code></pre>
<p>共读取到了11条记录，这就产生了幻像读。</p>
<p>从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。<br> 对于前者, 只需要锁住满足条件的记录。<br> 对于后者, 要锁住满足条件及其相近的记录。</p>
<p>（2）隔离级别</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">ISOLATION_DEFAULT</td>
<td align="left">使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td align="left">ISOLATION_READ_UNCOMMITTED</td>
<td align="left">最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td align="left">ISOLATION_READ_COMMITTED</td>
<td align="left">允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</td>
</tr>
<tr>
<td align="left">ISOLATION_REPEATABLE_READ</td>
<td align="left">对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</td>
</tr>
<tr>
<td align="left">ISOLATION_SERIALIZABLE</td>
<td align="left">最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td>
</tr>
</tbody>
</table>
<h3 id="223-只读-223-只读">2.2.3 只读 {#223-只读}</h3>
<p>事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。</p>
<h3 id="224-事务超时-224-事务超时">2.2.4 事务超时 {#224-事务超时}</h3>
<p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</p>
<h3 id="225-回滚规则-225-回滚规则">2.2.5 回滚规则 {#225-回滚规则}</h3>
<p>事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）<br> 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p>
<h2 id="23-事务状态-23-事务状态">2.3 事务状态 {#23-事务状态}</h2>
<p>上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现，这个接口的内容如下：</p>
<pre><code>public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事物
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}
</code></pre>
<p>可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。</p>
<h1 id="3-编程式事务-3-编程式事务">3 编程式事务 {#3-编程式事务}</h1>
<h2 id="31-编程式和声明式事务的区别-31-编程式和声明式事务的区别">3.1 编程式和声明式事务的区别 {#31-编程式和声明式事务的区别}</h2>
<p>Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。<br> 简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p>
<h2 id="32-如何实现编程式事务-32-如何实现编程式事务">3.2 如何实现编程式事务？ {#32-如何实现编程式事务}</h2>
<p>Spring提供两种方式的编程式事务管理，分别是：使用TransactionTemplate和直接使用PlatformTransactionManager。</p>
<h3 id="321-使用transactiontemplate-321-使用transactiontemplate">3.2.1 使用TransactionTemplate {#321-使用transactiontemplate}</h3>
<p>采用TransactionTemplate和采用其他Spring模板，如JdbcTempalte和HibernateTemplate是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate是线程安全的。代码片段：</p>
<pre><code>    TransactionTemplate tt = new TransactionTemplate(); // 新建一个TransactionTemplate
    Object result = tt.execute(
        new TransactionCallback(){  
            public Object doTransaction(TransactionStatus status){  
                updateOperation();  
                return resultOfUpdateOperation();  
            }  
    }); // 执行execute方法进行事务管理
</code></pre>
<p>使用TransactionCallback()可以返回一个值。如果使用TransactionCallbackWithoutResult则没有返回值。</p>
<h3 id="322-使用platformtransactionmanager-322-使用platformtransactionmanager">3.2.2 使用PlatformTransactionManager {#322-使用platformtransactionmanager}</h3>
<p>示例代码如下：</p>
<pre><code>    DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); //定义一个某个框架平台的TransactionManager，如JDBC、Hibernate
    dataSourceTransactionManager.setDataSource(this.getJdbcTemplate().getDataSource()); // 设置数据源
    DefaultTransactionDefinition transDef = new DefaultTransactionDefinition(); // 定义事务属性
    transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED); // 设置传播行为属性
    TransactionStatus status = dataSourceTransactionManager.getTransaction(transDef); // 获得事务状态
    try {
        // 数据库操作
        dataSourceTransactionManager.commit(status);// 提交
    } catch (Exception e) {
        dataSourceTransactionManager.rollback(status);// 回滚
    }
</code></pre>
<h1 id="4-声明式事务-4-声明式事务">4 声明式事务 {#4-声明式事务}</h1>
<h2 id="41-配置方式-41-配置方式">4.1 配置方式 {#41-配置方式}</h2>
<p><em>注：以下配置代码参考自</em><a href="http://www.blogjava.net/robbie/archive/2009/04/05/264003.html"><em>Spring事务配置的五种方式</em></a></p>
<p>根据代理机制的不同，总结了五种Spring事务的配置方式，配置文件如下：</p>
<p>（1）每个Bean都有一个代理</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

    &lt;bean id="sessionFactory" 
            class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; 
        &lt;property name="configLocation" value="classpath:hibernate.cfg.xml" /&gt; 
        &lt;property name="configurationClass" value="org.hibernate.cfg.AnnotationConfiguration" /&gt;
    &lt;/bean&gt; 

    &lt;!-- 定义事务管理器（声明式的事务） --&gt; 
    &lt;bean id="transactionManager"
        class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;

    &lt;!-- 配置DAO --&gt;
    &lt;bean id="userDaoTarget" class="com.bluesky.spring.dao.UserDaoImpl"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;

    &lt;bean id="userDao" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt; 
           &lt;!-- 配置事务管理器 --&gt; 
           &lt;property name="transactionManager" ref="transactionManager" /&gt;    
        &lt;property name="target" ref="userDaoTarget" /&gt; 
         &lt;property name="proxyInterfaces" value="com.bluesky.spring.dao.GeneratorDao" /&gt;
        &lt;!-- 配置事务属性 --&gt; 
        &lt;property name="transactionAttributes"&gt; 
            &lt;props&gt; 
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt; 
        &lt;/property&gt; 
    &lt;/bean&gt; 
&lt;/beans&gt;
</code></pre>
<p>（2）所有Bean共享一个代理基类</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

    &lt;bean id="sessionFactory" 
            class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; 
        &lt;property name="configLocation" value="classpath:hibernate.cfg.xml" /&gt; 
        &lt;property name="configurationClass" value="org.hibernate.cfg.AnnotationConfiguration" /&gt;
    &lt;/bean&gt; 

    &lt;!-- 定义事务管理器（声明式的事务） --&gt; 
    &lt;bean id="transactionManager"
        class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;

    &lt;bean id="transactionBase" 
            class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean" 
            lazy-init="true" abstract="true"&gt; 
        &lt;!-- 配置事务管理器 --&gt; 
        &lt;property name="transactionManager" ref="transactionManager" /&gt; 
        &lt;!-- 配置事务属性 --&gt; 
        &lt;property name="transactionAttributes"&gt; 
            &lt;props&gt; 
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; 
            &lt;/props&gt; 
        &lt;/property&gt; 
    &lt;/bean&gt;   

    &lt;!-- 配置DAO --&gt;
    &lt;bean id="userDaoTarget" class="com.bluesky.spring.dao.UserDaoImpl"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;

    &lt;bean id="userDao" parent="transactionBase" &gt; 
        &lt;property name="target" ref="userDaoTarget" /&gt;  
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>（3）使用拦截器</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

    &lt;bean id="sessionFactory" 
            class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; 
        &lt;property name="configLocation" value="classpath:hibernate.cfg.xml" /&gt; 
        &lt;property name="configurationClass" value="org.hibernate.cfg.AnnotationConfiguration" /&gt;
    &lt;/bean&gt; 

    &lt;!-- 定义事务管理器（声明式的事务） --&gt; 
    &lt;bean id="transactionManager"
        class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt; 

    &lt;bean id="transactionInterceptor" 
        class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt; 
        &lt;property name="transactionManager" ref="transactionManager" /&gt; 
        &lt;!-- 配置事务属性 --&gt; 
        &lt;property name="transactionAttributes"&gt; 
            &lt;props&gt; 
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; 
            &lt;/props&gt; 
        &lt;/property&gt; 
    &lt;/bean&gt;

    &lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt; 
        &lt;property name="beanNames"&gt; 
            &lt;list&gt; 
                &lt;value&gt;*Dao&lt;/value&gt;
            &lt;/list&gt; 
        &lt;/property&gt; 
        &lt;property name="interceptorNames"&gt; 
            &lt;list&gt; 
                &lt;value&gt;transactionInterceptor&lt;/value&gt; 
            &lt;/list&gt; 
        &lt;/property&gt; 
    &lt;/bean&gt; 

    &lt;!-- 配置DAO --&gt;
    &lt;bean id="userDao" class="com.bluesky.spring.dao.UserDaoImpl"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>（4）使用tx标签配置的拦截器</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

    &lt;context:annotation-config /&gt;
    &lt;context:component-scan base-package="com.bluesky" /&gt;

    &lt;bean id="sessionFactory" 
            class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; 
        &lt;property name="configLocation" value="classpath:hibernate.cfg.xml" /&gt; 
        &lt;property name="configurationClass" value="org.hibernate.cfg.AnnotationConfiguration" /&gt;
    &lt;/bean&gt; 

    &lt;!-- 定义事务管理器（声明式的事务） --&gt; 
    &lt;bean id="transactionManager"
        class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;

    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="*" propagation="REQUIRED" /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id="interceptorPointCuts"
            expression="execution(* com.bluesky.spring.dao.*.*(..))" /&gt;
        &lt;aop:advisor advice-ref="txAdvice"
            pointcut-ref="interceptorPointCuts" /&gt;       
    &lt;/aop:config&gt;     
&lt;/beans&gt;
</code></pre>
<p>（5）全注解</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

    &lt;context:annotation-config /&gt;
    &lt;context:component-scan base-package="com.bluesky" /&gt;

    &lt;tx:annotation-driven transaction-manager="transactionManager"../../../&gt;

    &lt;bean id="sessionFactory" 
            class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; 
        &lt;property name="configLocation" value="classpath:hibernate.cfg.xml" /&gt; 
        &lt;property name="configurationClass" value="org.hibernate.cfg.AnnotationConfiguration" /&gt;
    &lt;/bean&gt; 

    &lt;!-- 定义事务管理器（声明式的事务） --&gt; 
    &lt;bean id="transactionManager"
        class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>此时在DAO上需加上@Transactional注解，如下：</p>
<pre><code>package com.bluesky.spring.dao;

import java.util.List;

import org.hibernate.SessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;
import org.springframework.stereotype.Component;

import com.bluesky.spring.domain.User;

@Transactional
@Component("userDao")
public class UserDaoImpl extends HibernateDaoSupport implements UserDao {

    public List&lt;User&gt; listUsers() {
        return this.getSession().createQuery("from User").list();
    }  
}
</code></pre>
<h2 id="42-一个声明式事务的实例-42-一个声明式事务的实例">4.2 一个声明式事务的实例 {#42-一个声明式事务的实例}</h2>
<p><em>注：该实例参考自</em><a href="http://www.jb51.net/article/57589.htm"><em>Spring中的事务管理实例详解</em></a></p>
<p><strong>首先是数据库表</strong><br> book(isbn, book_name, price)<br> account(username, balance)<br> book_stock(isbn, stock)</p>
<p><strong>然后是XML配置</strong></p>
<pre><code>&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xmlns:aop="http://www.springframework.org/schema/aop"
xmlns:tx="http://www.springframework.org/schema/tx"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-3.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

    &lt;import resource="applicationContext-db.xml" /&gt;

    &lt;context:component-scan
        base-package="com.springinaction.transaction"&gt;
    &lt;/context:component-scan&gt;

    &lt;tx:annotation-driven transaction-manager="txManager"../../../&gt;

    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p><strong>使用的类</strong></p>
<p>BookShopDao</p>
<pre><code class="language-java">package com.springinaction.transaction;

public interface BookShopDao {
    // 根据书号获取书的单价
    public int findBookPriceByIsbn(String isbn);
    // 更新书的库存，使书号对应的库存-1
    public void updateBookStock(String isbn);
    // 更新用户的账户余额：account的balance-price
    public void updateUserAccount(String username, int price);
}
</code></pre>
<p>BookShopDaoImpl</p>
<pre><code class="language-java">package com.springinaction.transaction;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository("bookShopDao")
public class BookShopDaoImpl implements BookShopDao {

    @Autowired
    private JdbcTemplate JdbcTemplate;

    @Override
    public int findBookPriceByIsbn(String isbn) {
        String sql = "SELECT price FROM book WHERE isbn = ?";

        return JdbcTemplate.queryForObject(sql, Integer.class, isbn);
    }

    @Override
    public void updateBookStock(String isbn) {
        //检查书的库存是否足够，若不够，则抛出异常
        String sql2 = "SELECT stock FROM book_stock WHERE isbn = ?";
        int stock = JdbcTemplate.queryForObject(sql2, Integer.class, isbn);
        if (stock == 0) {
            throw new BookStockException("库存不足！");
        }
        String sql = "UPDATE book_stock SET stock = stock - 1 WHERE isbn = ?";
        JdbcTemplate.update(sql, isbn);
    }

    @Override
    public void updateUserAccount(String username, int price) {
        //检查余额是否不足，若不足，则抛出异常
        String sql2 = "SELECT balance FROM account WHERE username = ?";
        int balance = JdbcTemplate.queryForObject(sql2, Integer.class, username);
        if (balance &lt; price) {
            throw new UserAccountException("余额不足！");
        }       
        String sql = "UPDATE account SET balance = balance - ? WHERE username = ?";
        JdbcTemplate.update(sql, price, username);
    }

}
</code></pre>
<p>BookShopService</p>
<pre><code>package com.springinaction.transaction;
public interface BookShopService {
     public void purchase(String username, String isbn);
}
</code></pre>
<p>BookShopServiceImpl</p>
<pre><code>package com.springinaction.transaction;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Service("bookShopService")
public class BookShopServiceImpl implements BookShopService {

    @Autowired
    private BookShopDao bookShopDao;

    /**
     * 1.添加事务注解
     * 使用propagation 指定事务的传播行为，即当前的事务方法被另外一个事务方法调用时如何使用事务。
     * 默认取值为REQUIRED，即使用调用方法的事务
     * REQUIRES_NEW：使用自己的事务，调用的事务方法的事务被挂起。
     *
     * 2.使用isolation 指定事务的隔离级别，最常用的取值为READ_COMMITTED
     * 3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚，也可以通过对应的属性进行设置。通常情况下，默认值即可。
     * 4.使用readOnly 指定事务是否为只读。 表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。若真的是一个只读取数据库值得方法，应设置readOnly=true
     * 5.使用timeOut 指定强制回滚之前事务可以占用的时间。
     */
    @Transactional(propagation=Propagation.REQUIRES_NEW,
            isolation=Isolation.READ_COMMITTED,
            noRollbackFor={UserAccountException.class},
            readOnly=true, timeout=3)
    @Override
    public void purchase(String username, String isbn) {
        //1.获取书的单价
        int price = bookShopDao.findBookPriceByIsbn(isbn);
        //2.更新书的库存
        bookShopDao.updateBookStock(isbn);
        //3.更新用户余额
        bookShopDao.updateUserAccount(username, price);
    }
}
</code></pre>
<p>Cashier</p>
<pre><code>package com.springinaction.transaction;
import java.util.List;
public interface Cashier {
    public void checkout(String username, List&lt;String&gt;isbns);
}
</code></pre>
<p>CashierImpl：CashierImpl.checkout和bookShopService.purchase联合测试了事务的传播行为</p>
<pre><code>package com.springinaction.transaction;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service("cashier")
public class CashierImpl implements Cashier {
    @Autowired
    private BookShopService bookShopService;

    @Transactional
    @Override
    public void checkout(String username, List&lt;String&gt; isbns) {
        for(String isbn : isbns) {
            bookShopService.purchase(username, isbn);
        }
    }
}
</code></pre>
<p>BookStockException</p>
<pre><code>package com.springinaction.transaction;
public class BookStockException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public BookStockException() {
        super();
        // TODO Auto-generated constructor stub
    }

    public BookStockException(String arg0, Throwable arg1, boolean arg2,
            boolean arg3) {
        super(arg0, arg1, arg2, arg3);
        // TODO Auto-generated constructor stub
    }

    public BookStockException(String arg0, Throwable arg1) {
        super(arg0, arg1);
        // TODO Auto-generated constructor stub
    }

    public BookStockException(String arg0) {
        super(arg0);
        // TODO Auto-generated constructor stub
    }

    public BookStockException(Throwable arg0) {
        super(arg0);
        // TODO Auto-generated constructor stub
    }
}
</code></pre>
<p>UserAccountException</p>
<pre><code>package com.springinaction.transaction;
public class UserAccountException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public UserAccountException() {
        super();
        // TODO Auto-generated constructor stub
    }

    public UserAccountException(String arg0, Throwable arg1, boolean arg2,
            boolean arg3) {
        super(arg0, arg1, arg2, arg3);
        // TODO Auto-generated constructor stub
    }

    public UserAccountException(String arg0, Throwable arg1) {
        super(arg0, arg1);
        // TODO Auto-generated constructor stub
    }

    public UserAccountException(String arg0) {
        super(arg0);
        // TODO Auto-generated constructor stub
    }

    public UserAccountException(Throwable arg0) {
        super(arg0);
        // TODO Auto-generated constructor stub
    }
}
</code></pre>
<p>测试类</p>
<pre><code>package com.springinaction.transaction;

import java.util.Arrays;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringTransitionTest {

    private ApplicationContext ctx = null;
    private BookShopDao bookShopDao = null;
    private BookShopService bookShopService = null;
    private Cashier cashier = null;
    {
        ctx = new ClassPathXmlApplicationContext("config/transaction.xml");
        bookShopDao = ctx.getBean(BookShopDao.class);
        bookShopService = ctx.getBean(BookShopService.class);
        cashier = ctx.getBean(Cashier.class);
    }

    @Test
    public void testBookShopDaoFindPriceByIsbn() {
        System.out.println(bookShopDao.findBookPriceByIsbn("1001"));
    }

    @Test
    public void testBookShopDaoUpdateBookStock(){
        bookShopDao.updateBookStock("1001");
    }

    @Test
    public void testBookShopDaoUpdateUserAccount(){
        bookShopDao.updateUserAccount("AA", 100);
    }
    @Test
    public void testBookShopService(){
        bookShopService.purchase("AA", "1001");
    }

    @Test
    public void testTransactionPropagation(){
        cashier.checkout("AA", Arrays.asList("1001", "1002"));
    }
}
</code></pre>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/158/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/158/index.html">java语法整理</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/90.html">niliv</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">42页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2个">2</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/71/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/71/index.html">使用 jMonkeyEngine 进行游戏开发</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/43.html">jmecn</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">23页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8个">8</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/65/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/java_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/65/index.html">更先进的Java - Java 8指南</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/41.html">winterbe</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="java">java</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 9341个">9341</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/183/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/183/index.html">一起来学算法吧！</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/100.html">MisterBooo</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 97个">97</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/186/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/186/index.html">leetcode题解，记录自己的leetcode解题之路</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/105.html">azl397985856</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">92页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 8204个">8204</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/162/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/python_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/162/index.html">Python方向综合面试题</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/92.html">jackfrued</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="python">python</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">115页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2019年5月26日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 35个">35</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/84/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/84/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/84/README.html" title="简介" data-book-page-rel-url="README.html" data-book-page-id="6570">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/84/spring.html" title="Spring" data-book-page-rel-url="spring.html" data-book-page-id="6571">Spring</a>
<ul>
<li>
<a class="pjax" href="../../../book/84/spring/spring-mvc.html" title="Spring MVC" data-book-page-rel-url="spring/spring-mvc.html" data-book-page-id="6572">Spring MVC</a>
</li>
<li>
<a class="pjax" href="../../../book/84/spring/spring-view-resolver.html" title="Spring view resolver" data-book-page-rel-url="spring/spring-view-resolver.html" data-book-page-id="6573">Spring view resolver</a>
</li>
<li>
<a class="pjax" href="../../../book/84/spring/springshi-wu-guan-li.html" title="Spring事务管理" data-book-page-rel-url="spring/springshi-wu-guan-li.html" data-book-page-id="6574">Spring事务管理</a>
</li>
<li>
<a class="pjax" href="../../../book/84/spring/asfsadf.html" title="基于Token的WEB后台认证机制" data-book-page-rel-url="spring/asfsadf.html" data-book-page-id="6575">基于Token的WEB后台认证机制</a>
</li>
<li>
<a class="pjax" href="../../../book/84/spring/csrf.html" title="CSRF" data-book-page-rel-url="spring/csrf.html" data-book-page-id="6576">CSRF</a>
</li>
<li>
<a class="pjax" href="../../../book/84/spring/qian-tao-shi-wu-hui-gun.html" title="嵌套事务回滚" data-book-page-rel-url="spring/qian-tao-shi-wu-hui-gun.html" data-book-page-id="6577">嵌套事务回滚</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/84/spring-boot.html" title="Spring Boot" data-book-page-rel-url="spring-boot.html" data-book-page-id="6578">Spring Boot</a>
</li>
<li>
<a class="pjax" href="../../../book/84/spring-cloud.html" title="Spring Cloud" data-book-page-rel-url="spring-cloud.html" data-book-page-id="6579">Spring Cloud</a>
<ul>
<li>
<a class="pjax" href="../../../book/84/hystrix.html" title="Hystrix" data-book-page-rel-url="hystrix.html" data-book-page-id="6580">Hystrix</a>
</li>
<li>
<a class="pjax" href="../../../book/84/jia-gou.html" title="架构" data-book-page-rel-url="jia-gou.html" data-book-page-id="6581">架构</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/84/jhipster.html" title="jhipster" data-book-page-rel-url="jhipster.html" data-book-page-id="6582">jhipster</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="Web" disabled data-book-page-rel-url="" data-book-page-id="6583">Web</a>
<ul>
<li>
<a class="pjax" href="../../../book/84/mei-tuan-qian-duan-you-hua-shi-jian.html" title="美团前端优化实践" data-book-page-rel-url="mei-tuan-qian-duan-you-hua-shi-jian.html" data-book-page-id="6584">美团前端优化实践</a>
</li>
</ul>
</li>
<li>
<a class="pjax" href="../../../book/84/sso-cas.html" title="SSO CAS" data-book-page-rel-url="sso-cas.html" data-book-page-id="6585">SSO CAS</a>
<ul>
<li>
<a class="pjax" href="../../../book/84/sso-cas/cas.html" title="CAS" data-book-page-rel-url="sso-cas/cas.html" data-book-page-id="6586">CAS</a>
</li>
<li>
<a class="pjax" href="../../../book/84/sso-cas/cong-ling-xue-xi-cas.html" title="从零学习CAS" data-book-page-rel-url="sso-cas/cong-ling-xue-xi-cas.html" data-book-page-id="6587">从零学习CAS</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =84;var bookPageId =6574;var bookPageRelUrl ='spring/springshi-wu-guan-li.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>