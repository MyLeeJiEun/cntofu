
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>io — 基本的 IO 接口-Go语言标准库(The Golang Standard Library by Example)</title>
<meta content='io — 基本的 IO 接口,Go语言标准库,The Golang Standard Library by Example' name='keywords'>
<meta content='io — 基本的 IO 接口,Go语言标准库,The Golang Standard Library by Example' name='description'>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="zh-CN" />
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no"../../../>
<meta name="applicable-device" content="pc,mobile">
<link rel="shortcut icon" href="../../../favicon.ico" type="image/x-icon" />
<meta name="renderer" content="webkit">
<link rel="stylesheet" href="../../../static/components/uikit-2.27.5/css/uikit.custom.css">
<link rel="stylesheet" href="../../../static/components/social-share/social-share.min.css">
<link rel="stylesheet" href="../../../static/components/highlight/styles/custom.css">
<link rel="stylesheet" href="../../../static/components/css/base.css">
<link rel="stylesheet" href="../../../static/components/css/reader.css">
<link rel="stylesheet" href="../../../static/components/css/markdown.css">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5313208362165053" crossorigin="anonymous"></script>
</head>
<body>
<div class=" book-main-wrap uk-container uk-container-center uk-margin-top ">
<div class="uk-grid">
<div class="uk-width-1-1 reader-wrap ">
<div class=" bottom-nav uk-clearfix ">
<div class="uk-align-left ">
<a href="../../../book/15/chapter01/01.0.html">
<i class="nav-icon-left uk-icon-small  uk-icon-caret-left"></i>
<span class="">第一章 输入输出 (I..</span>
</a>
</div>
<div class="uk-align-right ">
<a href="../../../book/15/chapter01/01.2.html">
<span class="">ioutil — 方便..</span>
<i class="nav-icon-right uk-icon-small  uk-icon-caret-right"></i>
</a>
</div>
</div>
<div class="uk-text-center">
<h2 class="book-page-title uk-container-center">
<a href="../../../book/15/index.html">Go语言标准库 (The Golang Standard Library by Example)</a>
<a target="_blank" rel="nofollow" href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example" class="uk-icon-button uk-icon-github" title="github项目地址"></a>
</h2>
</div>
<script type="text/javascript" src="../../../static/components/js/app_intro.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-5313208362165053" data-ad-slot="1328047120"></ins>
<script>(adsbygoogle =window.adsbygoogle ||[]).push({});</script>
<hr class="uk-article-divider">
<div class="book-content-section  md-content-section  uk-margin-bottom">
<h1 id="11-io--基本的-io-接口">1.1 io — 基本的 IO 接口</h1>
<p>io 包为 I/O 原语提供了基本的接口。它主要包装了这些原语的已有实现。</p>
<p>由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。</p>
<p>在 io 包中最重要的是两个接口：Reader 和 Writer 接口。本章所提到的各种 IO 包，都跟这两个接口有关，也就是说，只要实现了这两个接口，它就有了 IO 的功能。</p>
<h2 id="reader-接口">Reader 接口</h2>
<p>Reader 接口的定义如下：</p>
<pre><code class="language-go">type Reader interface {
    Read(p []byte) (n int, err error)
}
</code></pre>
<p>官方文档中关于该接口方法的说明：</p>
<blockquote>
<p>Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)） 以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。</p>
</blockquote>
<blockquote>
<p>当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（同时 n == 0）。 一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，同时返回的 err 不是 EOF 就是 nil。无论如何，下一个 Read 都应当返回 0, EOF。</p>
</blockquote>
<blockquote>
<p>调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理 I/O 错误。</p>
</blockquote>
<p>也就是说，当 Read 方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。</p>
<p>根据 Go 语言中关于接口和实现了接口的类型的定义（<a href="http://golang.org/ref/spec#Interface_types">Interface_types</a>），我们知道 Reader 接口的方法集（<a href="http://golang.org/ref/spec#Method_sets">Method_sets</a>）只包含一个 Read 方法，因此，所有实现了 Read 方法的类型都实现了 io.Reader 接口，也就是说，在所有需要 io.Reader 的地方，可以传递实现了 Read() 方法的类型的实例。</p>
<p>下面，我们通过具体例子来谈谈该接口的用法。</p>
<pre><code class="language-go">func ReadFrom(reader io.Reader, num int) ([]byte, error) {
	p := make([]byte, num)
	n, err := reader.Read(p)
	if n &gt; 0 {
		return p[:n], nil
	}
	return p, err
}
</code></pre>
<p>ReadFrom 函数将 io.Reader 作为参数，也就是说，ReadFrom 可以从任意的地方读取数据，只要来源实现了 io.Reader 接口。比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：</p>
<pre><code class="language-go">// 从标准输入读取
data, err = ReadFrom(os.Stdin, 11)

// 从普通文件读取，其中 file 是 os.File 的实例
data, err = ReadFrom(file, 9)

// 从字符串读取
data, err = ReadFrom(strings.NewReader("from string"), 12)
</code></pre>
<p>完整的演示例子源码见 <a href="../../../book/15/code/src/chapter01/io/reader.go">code/src/chapter01/io/reader.go</a></p>
<p><strong>小贴士</strong></p>
<p>io.EOF 变量的定义：<code>var EOF = errors.New("EOF")</code>，是 error 类型。根据 reader 接口的说明，在 n &gt; 0 且数据被读完了的情况下，返回的 error 有可能是 EOF 也有可能是 nil。</p>
<h2 id="writer-接口">Writer 接口</h2>
<p>Writer 接口的定义如下：</p>
<pre><code class="language-go">type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre>
<p>官方文档中关于该接口方法的说明：</p>
<blockquote>
<p>Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n &lt; len(p)，它就必须返回一个 非nil 的错误。</p>
</blockquote>
<p>同样的，所有实现了Write方法的类型都实现了 io.Writer 接口。</p>
<p>在上个例子中，我们是自己实现一个函数接收一个 io.Reader 类型的参数。这里，我们通过标准库的例子来学习。</p>
<p>在fmt标准库中，有一组函数：Fprint/Fprintf/Fprintln，它们接收一个 io.Wrtier 类型参数（第一个参数），也就是说它们将数据格式化输出到 io.Writer 中。那么，调用这组函数时，该如何传递这个参数呢？</p>
<p>我们以 fmt.Fprintln 为例，同时看一下 fmt.Println 函数的源码。</p>
<pre><code class="language-go">func Println(a ...interface{}) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}
</code></pre>
<p>很显然，fmt.Println会将内容输出到标准输出中。下一节我们将详细介绍fmt包。</p>
<p>关于 io.Writer 的更多说明，可以查看笔者之前写的博文<a href="http://blog.studygolang.com/2013/02/%e4%bb%a5io-writer%e4%b8%ba%e4%be%8b%e7%9c%8bgo%e4%b8%ad%e7%9a%84interface/">《以io.Writer为例看go中的interface{}》</a>。</p>
<h2 id="实现了-ioreader-接口或-iowriter-接口的类型">实现了 io.Reader 接口或 io.Writer 接口的类型</h2>
<p>初学者看到函数参数是一个接口类型，很多时候有些束手无策，不知道该怎么传递参数。还有人问：标准库中有哪些类型实现了 io.Reader 或 io.Writer 接口？</p>
<p>通过本节上面的例子，我们可以知道，os.File 同时实现了这两个接口。我们还看到 os.Stdin/Stdout 这样的代码，它们似乎分别实现了 io.Reader/io.Writer 接口。没错，实际上在 os 包中有这样的代码：</p>
<pre><code class="language-go">var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "../../../dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "../../../dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "../../../dev/stderr")
)
</code></pre>
<p>也就是说，Stdin/Stdout/Stderr 只是三个特殊的文件（即都是 os.File 的实例），自然也实现了 io.Reader 和 io.Writer。</p>
<p>目前，Go 文档中还没法直接列出实现了某个接口的所有类型。不过，我们可以通过查看标准库文档，列出实现了 io.Reader 或 io.Writer 接口的类型（导出的类型）：（注：godoc 命令支持额外参数 -analysis ，能列出都有哪些类型实现了某个接口，相关参考 <code>godoc -h</code> 或 <a href="https://golang.org/lib/godoc/analysis/help.html">Static analysis features of godoc</a>。另外，我做了一个官网镜像，能查看接口所有的实现类型，地址：http://docs.studygolang.com。</p>
<ul>
<li>os.File 同时实现了 io.Reader 和 io.Writer</li>
<li>strings.Reader 实现了 io.Reader</li>
<li>bufio.Reader/Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>bytes.Buffer 同时实现了 io.Reader 和 io.Writer</li>
<li>bytes.Reader 实现了 io.Reader</li>
<li>compress/gzip.Reader/Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>crypto/cipher.StreamReader/StreamWriter 分别实现了 io.Reader 和 io.Writer</li>
<li>crypto/tls.Conn 同时实现了 io.Reader 和 io.Writer</li>
<li>encoding/csv.Reader/Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>mime/multipart.Part 实现了 io.Reader</li>
<li>net/conn 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read/Write)</li>
</ul>
<p>除此之外，io 包本身也有这两个接口的实现类型。如：</p>
<pre><code>实现了 Reader 的类型：LimitedReader、PipeReader、SectionReader
实现了 Writer 的类型：PipeWriter
</code></pre>
<p>以上类型中，常用的类型有：os.File、strings.Reader、bufio.Reader/Writer、bytes.Buffer、bytes.Reader</p>
<p><strong>小贴士</strong></p>
<p>从接口名称很容易猜到，一般地， Go 中接口的命名约定：接口名以 er 结尾。注意，这里并非强行要求，你完全可以不以 er 结尾。标准库中有些接口也不是以 er 结尾的。</p>
<h2 id="readerat-和-writerat-接口">ReaderAt 和 WriterAt 接口</h2>
<p><strong>ReaderAt 接口</strong>的定义如下：</p>
<pre><code class="language-go">type ReaderAt interface {
    ReadAt(p []byte, off int64) (n int, err error)
}
</code></pre>
<p>官方文档中关于该接口方法的说明：</p>
<blockquote>
<p>ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的错误。</p>
</blockquote>
<blockquote>
<p>当 ReadAt 返回的 n &lt; len(p) 时，它就会返回一个 非nil 的错误来解释 为什么没有返回更多的字节。在这一点上，ReadAt 比 Read 更严格。</p>
</blockquote>
<blockquote>
<p>即使 ReadAt 返回的 n &lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若一些数据可用但不到 len(p) 字节，ReadAt 就会阻塞直到所有数据都可用或产生一个错误。 在这一点上 ReadAt 不同于 Read。</p>
</blockquote>
<blockquote>
<p>若 n = len(p) 个字节在输入源的的结尾处由 ReadAt 返回，那么这时 err == EOF 或者 err == nil。</p>
</blockquote>
<blockquote>
<p>若 ReadAt 按查找偏移量从输入源读取，ReadAt 应当既不影响基本查找偏移量也不被它所影响。</p>
</blockquote>
<blockquote>
<p>ReadAt 的客户端可对相同的输入源并行执行 ReadAt 调用。</p>
</blockquote>
<p>可见，ReaderAt 接口使得可以从指定偏移量处开始读取数据。</p>
<p>简单示例代码如下：</p>
<pre><code class="language-go">reader := strings.NewReader("Go语言中文网")
p := make([]byte, 6)
n, err := reader.ReadAt(p, 2)
if err != nil {
    panic(err)
}
fmt.Printf("%s, %d\n", p, n)
</code></pre>
<p>输出：</p>
<pre><code>语言, 6
</code></pre>
<p><strong>WriterAt 接口</strong>的定义如下：</p>
<pre><code class="language-go">type WriterAt interface {
    WriteAt(p []byte, off int64) (n int, err error)
}
</code></pre>
<p>官方文档中关于该接口方法的说明：</p>
<blockquote>
<p>WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 WriteAt 返回的 n &lt; len(p)，它就必须返回一个 非nil 的错误。</p>
</blockquote>
<blockquote>
<p>若 WriteAt 按查找偏移量写入到目标中，WriteAt 应当既不影响基本查找偏移量也不被它所影响。</p>
</blockquote>
<blockquote>
<p>若区域没有重叠，WriteAt 的客户端可对相同的目标并行执行 WriteAt 调用。</p>
</blockquote>
<p>我们可以通过该接口将数据写入数据流的特定偏移量之后。</p>
<p>通过简单示例来演示 WriteAt 方法的使用（os.File 实现了 WriterAt 接口）：</p>
<pre><code class="language-go">file, err := os.Create("writeAt.txt")
if err != nil {
    panic(err)
}
defer file.Close()
file.WriteString("Golang中文社区——这里是多余")
n, err := file.WriteAt([]byte("Go语言中文网"), 24)
if err != nil {
    panic(err)
}
fmt.Println(n)
</code></pre>
<p>打开文件 WriteAt.txt，内容是：<code>Golang中文社区——Go语言中文网</code>。</p>
<p>分析：</p>
<p><code>file.WriteString("Golang中文社区——这里是多余")</code> 往文件中写入 <code>Golang中文社区——这里是多余</code>，之后 <code>file.WriteAt([]byte("Go语言中文网"), 24)</code> 在文件流的 offset=24 处写入 <code>Go语言中文网</code>（会覆盖该位置的内容）。</p>
<h2 id="readerfrom-和-writerto-接口">ReaderFrom 和 WriterTo 接口</h2>
<p><strong>ReaderFrom</strong> 的定义如下：</p>
<pre><code class="language-go">type ReaderFrom interface {
    ReadFrom(r Reader) (n int64, err error)
}
</code></pre>
<p>官方文档中关于该接口方法的说明：</p>
<blockquote>
<p>ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。</p>
</blockquote>
<blockquote>
<p>如果 ReaderFrom 可用，Copy 函数就会使用它。</p>
</blockquote>
<p>注意：ReadFrom 方法不会返回 err == EOF。</p>
<p>下面的例子简单的实现将文件中的数据全部读取（显示在标准输出）：</p>
<pre><code class="language-go">file, err := os.Open("writeAt.txt")
if err != nil {
    panic(err)
}
defer file.Close()
writer := bufio.NewWriter(os.Stdout)
writer.ReadFrom(file)
writer.Flush()
</code></pre>
<p>当然，我们可以通过 ioutil 包的 ReadFile 函数获取文件全部内容。其实，跟踪一下 ioutil.ReadFile 的源码，会发现其实也是通过 ReadFrom 方法实现（用的是 bytes.Buffer，它实现了 ReaderFrom 接口）。</p>
<p>如果不通过 ReadFrom 接口来做这件事，而是使用 io.Reader 接口，我们有两种思路：</p>
<ol>
<li>先获取文件的大小（File 的 Stat 方法），之后定义一个该大小的 []byte，通过 Read 一次性读取</li>
<li>定义一个小的 []byte，不断的调用 Read 方法直到遇到 EOF，将所有读取到的 []byte 连接到一起</li>
</ol>
<p>这里不给出实现代码了，有兴趣的可以实现以下。</p>
<p><strong>提示</strong></p>
<p>通过查看 bufio.Writer 或 strings.Buffer 类型的 ReadFrom 方法实现，会发现，其实它们的实现和上面说的第 2 种思路类似。</p>
<p><strong>WriterTo</strong>的定义如下：</p>
<pre><code class="language-go">type WriterTo interface {
    WriteTo(w Writer) (n int64, err error)
}
</code></pre>
<p>官方文档中关于该接口方法的说明：</p>
<blockquote>
<p>WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。</p>
</blockquote>
<blockquote>
<p>如果 WriterTo 可用，Copy 函数就会使用它。</p>
</blockquote>
<p>读者是否发现，其实 ReaderFrom 和 WriterTo 接口的方法接收的参数是 io.Reader 和 io.Writer 类型。根据 io.Reader 和 io.Writer 接口的讲解，对该接口的使用应该可以很好的掌握。</p>
<p>这里只提供简单的一个示例代码：将一段文本输出到标准输出</p>
<pre><code class="language-go">reader := bytes.NewReader([]byte("Go语言中文网"))
reader.WriteTo(os.Stdout)
</code></pre>
<p>通过 io.ReaderFrom 和 io.WriterTo 的学习，我们知道，如果这样的需求，可以考虑使用这两个接口：“一次性从某个地方读或写到某个地方去。”</p>
<h2 id="seeker-接口">Seeker 接口</h2>
<p>接口定义如下：</p>
<pre><code class="language-go">type Seeker interface {
    Seek(offset int64, whence int) (ret int64, err error)
}
</code></pre>
<p>官方文档中关于该接口方法的说明：</p>
<blockquote>
<p>Seek 设置下一次 Read 或 Write 的偏移量为 offset，它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。 Seek 返回新的偏移量和一个错误，如果有的话。</p>
</blockquote>
<p>也就是说，Seek 方法用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 ReaderAt/WriteAt 接口有些类似，不过 Seeker 接口更灵活，可以更好的控制读写数据流的位置。</p>
<p>简单的示例代码：获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例）</p>
<pre><code class="language-go">reader := strings.NewReader("Go语言中文网")
reader.Seek(-6, os.SEEK_END)
r, _, _ := reader.ReadRune()
fmt.Printf("%c\n", r)
</code></pre>
<p><strong>小贴士</strong></p>
<p>whence 的值，在 io 包中定义了相应的常量，应该使用这些常量</p>
<pre><code class="language-go">const (
  SeekStart   = 0 // seek relative to the origin of the file
  SeekCurrent = 1 // seek relative to the current offset
  SeekEnd     = 2 // seek relative to the end
)
</code></pre>
<p>而原先 os 包中的常量已经被标注为Deprecated</p>
<pre><code class="language-go">// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.
const (
  SEEK_SET int = 0 // seek relative to the origin of the file
  SEEK_CUR int = 1 // seek relative to the current offset
  SEEK_END int = 2 // seek relative to the end
)
</code></pre>
<h2 id="closer接口">Closer接口</h2>
<p>接口定义如下：</p>
<pre><code class="language-go">type Closer interface {
    Close() error
}
</code></pre>
<p>该接口比较简单，只有一个 Close() 方法，用于关闭数据流。</p>
<p>文件 (os.File)、归档（压缩包）、数据库连接、Socket 等需要手动关闭的资源都实现了 Closer 接口。</p>
<p>实际编程中，经常将 Close 方法的调用放在 defer 语句中。</p>
<p><strong>小提示</strong></p>
<p>初学者容易写出这样的代码：</p>
<pre><code class="language-go">file, err := os.Open("studygolang.txt")
defer file.Close()
if err != nil {
	...
}
</code></pre>
<p>当文件 studygolang.txt 不存在或找不到时，file.Close() 会 panic，因为 file 是 nil。因此，应该将 defer file.Close() 放在错误检查之后。</p>
<p>经过 <a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/issues/40">issue40</a> 提醒，查看源码：</p>
<pre><code class="language-go">func (f *File) Close() error {
	if f == nil {
		return ErrInvalid
	}
	return f.file.close()
}
</code></pre>
<p>可见并不会 panic，但在 Close 之前校验错误是个好习惯！</p>
<h2 id="其他接口">其他接口</h2>
<h3 id="bytereader-和-bytewriter">ByteReader 和 ByteWriter</h3>
<p>通过名称大概也能猜出这组接口的用途：读或写一个字节。接口定义如下：</p>
<pre><code class="language-go">type ByteReader interface {
    ReadByte() (c byte, err error)
}

type ByteWriter interface {
    WriteByte(c byte) error
}
</code></pre>
<p>在标准库中，有如下类型实现了 io.ByteReader 或 io.ByteWriter:</p>
<ul>
<li>bufio.Reader/Writer 分别实现了io.ByteReader 和 io.ByteWriter</li>
<li>bytes.Buffer 同时实现了 io.ByteReader 和 io.ByteWriter</li>
<li>bytes.Reader 实现了 io.ByteReader</li>
<li>strings.Reader 实现了 io.ByteReader</li>
</ul>
<p>接下来的示例中，我们通过 bytes.Buffer 来一次读取或写入一个字节（主要代码）：</p>
<pre><code class="language-go">var ch byte
fmt.Scanf("%c\n", &amp;ch)

buffer := new(bytes.Buffer)
err := buffer.WriteByte(ch)
if err == nil {
	fmt.Println("写入一个字节成功！准备读取该字节……")
	newCh, _ := buffer.ReadByte()
	fmt.Printf("读取的字节：%c\n", newCh)
} else {
	fmt.Println("写入错误")
}
</code></pre>
<p>程序从标准输入接收一个字节（ASCII 字符），调用 buffer 的 WriteByte 将该字节写入 buffer 中，之后通过 ReadByte 读取该字节。完整的代码见：<a href="../../../book/15/code/src/chapter01/io/byterwer.go">code/src/chapter01/io/byterwer.go</a></p>
<p>一般地，我们不会使用 bytes.Buffer 来一次读取或写入一个字节。那么，这两个接口有哪些用处呢？</p>
<p>在标准库 encoding/binary 中，实现<a href="https://code.google.com/p/protobuf/">Google-ProtoBuf</a>中的 Varints 读取，<a href="http://docs.studygolang.com/pkg/encoding/binary/#ReadVarint">ReadVarint</a> 就需要一个 io.ByteReader 类型的参数，也就是说，它需要一个字节一个字节的读取。关于 encoding/binary 包在后面会详细介绍。</p>
<p>在标准库 image/jpeg 中，<a href="http://docs.studygolang.com/pkg/image/jpeg/#Encode">Encode</a>函数的内部实现使用了 ByteWriter 写入一个字节。</p>
<p><strong>小贴士</strong></p>
<p>可以通过在 Go 语言源码 src/pkg 中搜索 "io.ByteReader" 或 "io.ByteWiter"，获得哪些地方用到了这两个接口。你会发现，这两个接口在二进制数据或归档压缩时用的比较多。</p>
<h3 id="bytescannerrunereader-和-runescanner">ByteScanner、RuneReader 和 RuneScanner</h3>
<p>将这三个接口放在一起，是考虑到与 ByteReader 相关或相应。</p>
<p>ByteScanner 接口的定义如下：</p>
<pre><code class="language-go">type ByteScanner interface {
    ByteReader
    UnreadByte() error
}
</code></pre>
<p>可见，它内嵌了 ByteReader 接口（可以理解为继承了 ByteReader 接口），UnreadByte 方法的意思是：将上一次 ReadByte 的字节还原，使得再次调用 ReadByte 返回的结果和上一次调用相同，也就是说，UnreadByte 是重置上一次的 ReadByte。注意，UnreadByte 调用之前必须调用了 ReadByte，且不能连续调用 UnreadByte。即：</p>
<pre><code class="language-go">buffer := bytes.NewBuffer([]byte{'a', 'b'})
err := buffer.UnreadByte()
</code></pre>
<p>和</p>
<pre><code class="language-go">buffer := bytes.NewBuffer([]byte{'a', 'b'})
buffer.ReadByte()
err := buffer.UnreadByte()
err = buffer.UnreadByte()
</code></pre>
<p>err 都 非nil，错误为：<code>bytes.Buffer: UnreadByte: previous operation was not a read</code></p>
<p>RuneReader 接口和 ByteReader 类似，只是 ReadRune 方法读取单个 UTF-8 字符，返回其 rune 和该字符占用的字节数。该接口在 <a href="http://docs.studygolang.com/pkg/regexp">regexp</a> 包有用到。</p>
<p>之前有人在QQ群中问道：</p>
<blockquote>
<p>strings.Index("行业交流群", "交流") 返回的是单字节字符的位置：6。但是想要的是 unicode 字符的位置：2。</p>
</blockquote>
<p>当时以为 strings.IndexRune 可以，然而 IndexRune 还不如 Index，一方面第二个参数是 rune 类型；另一方面返回的结果跟 Index 是一样的。这里通过 RuneReader 接口来实现这个需求，代码如下：</p>
<pre><code class="language-go">// strings.Index 的 UTF-8 版本
// 即 Utf8Index("Go语言中文网", "中文") 返回 4，而不是 strings.Index 的 8
func Utf8Index(str, substr string) int {
	asciiPos := strings.Index(str, substr)
	if asciiPos == -1 || asciiPos == 0 {
		return asciiPos
	}
	pos := 0
	totalSize := 0
	reader := strings.NewReader(str)
	for _, size, err := reader.ReadRune(); err == nil; _, size, err = reader.ReadRune() {
		totalSize += size
		pos++
		// 匹配到
		if totalSize == asciiPos {
			return pos
		}
	}
	return pos
}
</code></pre>
<p>该实现借助了 strings.Index。另外，此处的 strings.NewReader 可以换成 bytes.NewBufferString，不过，根据 strings.NewReader 的文档，strings.Reader 比 bytes.Buffer 效率更高，只是 strings.Reader 是只读的，而 bytes.Buffer 是可读写的（从前面介绍的实现的接口可以知道）。关于 bytes 和 strings 包，后面章节会详细介绍。</p>
<p>RuneScanner 接口和 ByteScanner 类似，就不赘述了。</p>
<h3 id="readcloserreadseekerreadwritecloserreadwriteseekerreadwriterwritecloser-和-writeseeker-接口">ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker 接口</h3>
<p>这些接口是上面介绍的接口的两个或三个组合而成的新接口。例如 ReadWriter 接口：</p>
<pre><code class="language-go">type ReadWriter interface {
    Reader
    Writer
}
</code></pre>
<p>这是 Reader 接口和 Writer 接口的简单组合（内嵌）。</p>
<p>这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。可见，io 包中有大量的“小接口”，这样方便组合为“大接口”。</p>
<h2 id="sectionreader-类型">SectionReader 类型</h2>
<p>SectionReader 是一个 struct（没有任何导出的字段），实现了 Read, Seek 和 ReadAt，同时，内嵌了 ReaderAt 接口。结构定义如下：</p>
<pre><code class="language-go">type SectionReader struct {
	r     ReaderAt	// 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现
	base  int64		// NewSectionReader 会将 base 设置为 off
	off   int64		// 从 r 中的 off 偏移处开始读取数据
	limit int64		// limit - off = SectionReader 流的长度
}
</code></pre>
<p>从名称我们可以猜到，该类型读取数据流中部分数据。看一下</p>
<pre><code class="language-go">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader
</code></pre>
<p>的文档说明就知道了：</p>
<blockquote>
<p>NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。</p>
</blockquote>
<p>也就是说，SectionReader 只是内部（内嵌）ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。</p>
<p>这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。</p>
<p>由于该类型所支持的操作，前面都有介绍，因此提供示例代码了。</p>
<p>关于该类型在标准库中的使用，我们在 <a href="">8.5 archive/zip — zip归档访问</a> 会讲到。</p>
<h2 id="limitedreader-类型">LimitedReader 类型</h2>
<p>LimitedReader 类型定义如下：</p>
<pre><code class="language-go">type LimitedReader struct {
    R Reader // underlying reader，最终的读取操作通过 R.Read 完成
    N int64  // max bytes remaining
}
</code></pre>
<p>文档说明如下：</p>
<blockquote>
<p>从 R 读取但将返回的数据量限制为 N 字节。每调用一次 Read 都将更新 N 来反应新的剩余数量。</p>
</blockquote>
<p>也就是说，最多只能返回 N 字节数据。</p>
<p>LimitedReader 只实现了 Read 方法（Reader 接口）。</p>
<p>使用示例如下：</p>
<pre><code class="language-go">content := "This Is LimitReader Example"
reader := strings.NewReader(content)
limitReader := &amp;io.LimitedReader{R: reader, N: 8}
for limitReader.N &gt; 0 {
	tmp := make([]byte, 2)
	limitReader.Read(tmp)
	fmt.Printf("%s", tmp)
}
</code></pre>
<p>输出：</p>
<pre><code>This Is
</code></pre>
<p>可见，通过该类型可以达到 <em>只允许读取一定长度数据</em> 的目的。</p>
<p>在 io 包中，LimitReader 函数的实现其实就是调用 LimitedReader：</p>
<pre><code class="language-go">func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} }
</code></pre>
<h2 id="pipereader-和-pipewriter-类型">PipeReader 和 PipeWriter 类型</h2>
<p>PipeReader（一个没有任何导出字段的 struct）是管道的读取端。它实现了 io.Reader 和 io.Closer 接口。</p>
<p><strong>关于 Read 方法的说明</strong>：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端关闭了。如果写入端关闭时带上了 error（即调用 CloseWithError 关闭），该方法返回的 err 就是写入端传递的error；否则 err 为 EOF。</p>
<p>PipeWriter（一个没有任何导出字段的 struct）是管道的写入端。它实现了 io.Writer 和 io.Closer 接口。</p>
<p><strong>关于 Write 方法的说明</strong>：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端关闭了。如果读取端关闭时带上了 error（即调用 CloseWithError 关闭），该方法返回的 err 就是读取端传递的error；否则 err 为 ErrClosedPipe。</p>
<p>其他方法的使用通过例子一起讲解：</p>
<pre><code class="language-go">func main() {
	Pipe()
}

func Pipe() {
	pipeReader, pipeWriter := io.Pipe()
	go PipeWrite(pipeWriter)
	go PipeRead(pipeReader)
	time.Sleep(1e7)
}

func PipeWrite(pipeWriter *io.PipeWriter) {
	var (
		i   = 0
		err error
		n int
	)
	data := []byte("Go语言中文网")
	for _, err = pipeWriter.Write(data); err == nil; n, err = pipeWriter.Write(data) {
		i++
		if i == 3 {
			pipeWriter.CloseWithError(errors.New("输出3次后结束"))
		}
	}
	fmt.Println("close 后输出的字节数：", n, " error：",  err)
}

func PipeRead(pipeReader *io.PipeReader) {
	var (
		err error
		n   int
	)
	data := make([]byte, 1024)
	for n, err = pipeReader.Read(data); err == nil; n, err = pipeReader.Read(data) {
		fmt.Printf("%s\n", data[:n])
	}
	fmt.Println("writer 端 closewitherror 后：", err)
}
</code></pre>
<p>输出是：</p>
<pre><code>Go语言中文网
Go语言中文网
Go语言中文网
Go语言中文网
writer 端 closewitherror 后： 输出3次后结束
close 后输出的字节数： 20  error： io: read/write on closed pipe
</code></pre>
<p>细心的读者可能发现：不是输出 3 次后结束吗？怎么“Go语言中文网”却输出了 4 次？这个问题我们稍后讨论。我们先来分析一下例子代码。</p>
<p>io.Pipe() 用于创建一个同步的内存管道 (synchronous in-memory pipe)，函数签名：</p>
<pre><code class="language-go">func Pipe() (*PipeReader, *PipeWriter)
</code></pre>
<p>它将 io.Reader 连接到 io.Writer。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 Read 和 Write 以及其它函数或 Close 来说都是安全的。一旦等待的 I/O 结束，Close 就会完成。并行调用 Read 或并行调用 Write 也同样安全：同种类的调用将按顺序进行控制。稍后我们会分析管道相关的源码。</p>
<p>正因为是<em>同步</em>的，因此不能在一个 goroutine 中进行读和写。</p>
<p>在 PipeWrite 函数中，我们循环往管道中写数据，写第三次时，我们调用 CloseWithError 方法关闭管道的写入端，之后再一次调用 Write 方法，发现返回了error，于是退出了循环。</p>
<p>可是，从输出结果中，我们发现，最后一次写虽然返回 error（返回的 n 并非 0），但是读取端却能读到最后一次写的数据，这让人很费解。下面我们一起来探索一下相关源码，分析问题的原因。</p>
<h3 id="io-包-管道-pipe-源码分析">io 包 管道 (pipe) 源码分析</h3>
<p>从上文知道，PipeWriter 和 PipeReader 都没有导出成员。查看源码发现，两者都只有一个成员：<code>p *pipe</code>，这两种类型的所有方法都是调用了 pipe 类型对应的方法实现的。</p>
<p>pipe类型的定义如下：</p>
<pre><code class="language-go">// A pipe is the shared pipe structure underlying PipeReader and PipeWriter.
type pipe struct {
	rl    sync.Mutex // gates readers one at a time
	wl    sync.Mutex // gates writers one at a time
	l     sync.Mutex // protects remaining fields
	data  []byte     // data remaining in pending write
	rwait sync.Cond  // waiting reader
	wwait sync.Cond  // waiting writer
	rerr  error      // if reader closed, error to give writes
	werr  error      // if writer closed, error to give reads
}
</code></pre>
<p>字段说明：</p>
<ul>
<li>rl/wl 用于控制同一时刻只能有一个读取器或写入器</li>
<li>l 用于保护其他字段</li>
<li>data 在管道中的数据</li>
<li>rwait/wwait sync.Cond 类型（后续会讲解），分别控制读取器或写入器等待</li>
<li>rerr/werr 读取器（写入器）关闭，该错误会被 Write (Read) 方法返回</li>
</ul>
<p>pipe 的 read 方法：</p>
<pre><code class="language-go">func (p *pipe) read(b []byte) (n int, err error) {
	// One reader at a time.（控制一次只能一个读取器）
	p.rl.Lock()
	defer p.rl.Unlock()

	// 保护其他字段的读写
	p.l.Lock()
	defer p.l.Unlock()
	for {
		// Reader 端关闭后，再 Read，则返回 ErrClosedPipe
		if p.rerr != nil {
			return 0, ErrClosedPipe
		}
		// 管道中有数据，退出循环
		if p.data != nil {
			break
		}
		// Writer 端关闭，返回 p.werr
		if p.werr != nil {
			return 0, p.werr
		}
		// 没有数据或管道没有关闭，读取端等待
		p.rwait.Wait()
	}
	// 管道中有数据，将其 copy 一份到 b 中
	n = copy(b, p.data)
	p.data = p.data[n:]
	// 如果管道数据被读光，需要唤醒在等待的 Writer
	if len(p.data) == 0 {
		p.data = nil
		p.wwait.Signal()
	}
	return
}
</code></pre>
<p>加上的代码注释已经很清楚了，因此不再赘述。</p>
<p>pipe 的 write 方法：</p>
<pre><code class="language-go">func (p *pipe) write(b []byte) (n int, err error) {
	// pipe uses nil to mean not available
	if b == nil {
		// zero 的定义为：var zero [0]byte
		b = zero[:]
	}

	// One writer at a time.
	p.wl.Lock()
	defer p.wl.Unlock()

	p.l.Lock()
	defer p.l.Unlock()
	// 上面说的问题来了：不管三七二十一，一上来些将数据放进管道中
	p.data = b
	// 唤醒在等待的 Reader
	p.rwait.Signal()
	for {
		// 数据被读走，退出循环
		if p.data == nil {
			break
		}
		// Reader 端关闭，设置 err = p.rerr，退出循环
		if p.rerr != nil {
			err = p.rerr
			break
		}
		// Writer 端关闭后，再 Writer，设置 err = ErrClosedPipe
		if p.werr != nil {
			err = ErrClosedPipe
		}
		// 数据没被读走（全部）或管道读取端没关闭，则等待
		p.wwait.Wait()
	}
	// 计算写入的字节数
	n = len(b) - len(p.data)
	p.data = nil // in case of rerr or werr
	return
}
</code></pre>
<p>通过上面两个方法的代码注释，应该清楚例子中为啥输出4次了吧？我们再分析一下：</p>
<p>当 i == 3，调用 CloseWithError 之后，程序执行 for 中的 <code>n, err = pipeWriter.Write(data)</code>，根据上面 pipe.write 方法，p.data 会被设置上数据，这个时候，Reader 被唤醒，将数据读走（第 4 次）。由于异步，多 goroutine，跟调度有关系，这个时候 Writer 可能在等待，也可能在 Reader 读完数据后将其唤醒，总之，Writer 会执行到 <code>if p.werr != nil</code>，即例子中 Write 循环结束；而 Reader 被唤醒之后，首先判断的是 <code>p.data != nil</code>，而不是 <code>p.werr != nil</code>，因此数据被正常读取，且没错误被返回，这时执行下一次循环，当然，这时候由于没有 Write，且 <code>p.werr != nil</code>，于是 Read 方法返回 err(=p.werr)。</p>
<p>个人认为这是一个 bug，已经向官方提出：<a href="https://code.google.com/p/go/issues/detail?id=5330">issue5330</a>，修复处：</p>
<p>1）在 pipe.write 方法的 defer p.l.Unlock() 后面增加如下代码：</p>
<pre><code class="language-go">// 写端关闭了，不让写入数据
if p.werr != nil {
	p.rwait.Signal()
	err = ErrClosedPipe
	return
}
</code></pre>
<p>同时，for 循环中如下代码没有必要，删除：</p>
<pre><code class="language-go">// Writer 端关闭后，再 Writer，设置 err = ErrClosedPipe
if p.werr != nil {
	err = ErrClosedPipe
}
</code></pre>
<p>2）在 pipe.read 方法中，调整检查 p.werr 和 p.data 的顺序，即改为：</p>
<pre><code class="language-go">if p.werr != nil {
	return 0, p.werr
}
if p.data != nil {
	break
}
</code></pre>
<p>这样不至于有错误时还把数据读走。</p>
<p>另外，对于管道的 close 方法（非 CloseWithError 时），err 会被置为 EOF。</p>
<h2 id="copy-和-copyn-函数">Copy 和 CopyN 函数</h2>
<p><strong>Copy 函数</strong>的签名：</p>
<pre><code class="language-go">func Copy(dst Writer, src Reader) (written int64, err error)
</code></pre>
<p>函数文档：</p>
<blockquote>
<p>Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有的话，还会返回在复制时遇到的第一个错误。</p>
</blockquote>
<blockquote>
<p>成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。</p>
</blockquote>
<blockquote>
<p>若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。</p>
</blockquote>
<p>代码：</p>
<pre><code class="language-go">io.Copy(os.Stdout, strings.NewReader("Go语言中文网"))
</code></pre>
<p>直接将内容输出（写入 Stdout 中）。</p>
<p>我们甚至可以这么做：</p>
<pre><code class="language-go">package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	io.Copy(os.Stdout, os.Stdin)
	fmt.Println("Got EOF -- bye")
}
</code></pre>
<p>执行：<code>echo "Hello, World" | go run main.go</code></p>
<p><strong>CopyN 函数</strong>的签名：</p>
<pre><code class="language-go">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)
</code></pre>
<p>函数文档：</p>
<blockquote>
<p>CopyN 将 n 个字节从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。由于 Read 可以返回要求的全部数量及一个错误（包括 EOF），因此 CopyN 也能如此。</p>
</blockquote>
<blockquote>
<p>若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。</p>
</blockquote>
<p>代码：</p>
<pre><code class="language-go">io.CopyN(os.Stdout, strings.NewReader("Go语言中文网"), 8)
</code></pre>
<p>会输出：</p>
<pre><code>Go语言
</code></pre>
<h2 id="readatleast-和-readfull-函数">ReadAtLeast 和 ReadFull 函数</h2>
<p><strong>ReadAtLeast 函数</strong>的签名：</p>
<pre><code class="language-go">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
</code></pre>
<p>函数文档：</p>
<blockquote>
<p>ReadAtLeast 将 r 读取到 buf 中，直到读了最少 min 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了少于 min 个字节之后，ReadAtLeast 就会返回 ErrUnexpectedEOF。若 min 大于 buf 的长度，ReadAtLeast 就会返回 ErrShortBuffer。对于返回值，当且仅当 err == nil 时，才有 n &gt;= min。</p>
</blockquote>
<p>一般可能不太会用到这个函数。使用时需要注意返回的 error 判断。</p>
<p><strong>ReadFull 函数</strong>的签名：</p>
<pre><code class="language-go">func ReadFull(r Reader, buf []byte) (n int, err error)
</code></pre>
<p>函数文档：</p>
<blockquote>
<p>ReadFull 精确地从 r 中将 len(buf) 个字节读取到 buf 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了一些但不是所有的字节后，ReadFull 就会返回 ErrUnexpectedEOF。对于返回值，当且仅当 err == nil 时，才有 n == len(buf)。</p>
</blockquote>
<p>注意该函数和 ReadAtLeast 的区别：ReadFull 将 buf 读满；而 ReadAtLeast 是最少读取 min 个字节。</p>
<h2 id="writestring-函数">WriteString 函数</h2>
<p>这是为了方便写入 string 类型提供的函数，函数签名：</p>
<pre><code class="language-go">func WriteString(w Writer, s string) (n int, err error)
</code></pre>
<p>当 w 实现了 WriteString 方法时，直接调用该方法，否则执行 w.Write([]byte(s))。</p>
<h2 id="multireader-和-multiwriter-函数">MultiReader 和 MultiWriter 函数</h2>
<p>这两个函数的定义分别是：</p>
<pre><code class="language-go">func MultiReader(readers ...Reader) Reader
func MultiWriter(writers ...Writer) Writer
</code></pre>
<p>它们接收多个 Reader 或 Writer，返回一个 Reader 或 Writer。我们可以猜想到这两个函数就是操作多个 Reader 或 Writer 就像操作一个。</p>
<p>事实上，在 io 包中定义了两个非导出类型：mutilReader 和 multiWriter，它们分别实现了 io.Reader 和 io.Writer 接口。类型定义为：</p>
<pre><code class="language-go">type multiReader struct {
	readers []Reader
}

type multiWriter struct {
	writers []Writer
}
</code></pre>
<p>对于这两种类型对应的实现方法（Read 和 Write 方法）的使用，我们通过例子来演示。</p>
<p><strong>MultiReader 的使用</strong>：</p>
<pre><code class="language-go">readers := []io.Reader{
	strings.NewReader("from strings reader"),
	bytes.NewBufferString("from bytes buffer"),
}
reader := io.MultiReader(readers...)
data := make([]byte, 0, 1024)
var (
	err error
	n   int
)
for err != io.EOF {
	tmp := make([]byte, 512)
	n, err = reader.Read(tmp)
	if err == nil {
	    data = append(data, tmp[:n]...)
	} else {
	    if err != io.EOF {
	        panic(err)
	    }
	}
}
fmt.Printf("%s\n", data)
</code></pre>
<p>输出：</p>
<pre><code>from strings readerfrom bytes buffer
</code></pre>
<p>代码中首先构造了一个 io.Reader 的 slice，由 strings.Reader 和 bytes.Buffer 两个实例组成，然后通过 MultiReader 得到新的 Reader，循环读取新 Reader 中的内容。从输出结果可以看到，第一次调用 Reader 的 Read 方法获取到的是 slice 中第一个元素的内容……也就是说，MultiReader 只是逻辑上将多个 Reader 组合起来，并不能通过调用一次 Read 方法获取所有 Reader 的内容。在所有的 Reader 内容都被读完后，Reader 会返回 EOF。</p>
<p><strong>MultiWriter 的使用</strong>：</p>
<pre><code class="language-go">file, err := os.Create("tmp.txt")
if err != nil {
    panic(err)
}
defer file.Close()
writers := []io.Writer{
	file,
	os.Stdout,
}
writer := io.MultiWriter(writers...)
writer.Write([]byte("Go语言中文网"))
</code></pre>
<p>这段程序执行后在生成 tmp.txt 文件，同时在文件和屏幕中都输出：<code>Go语言中文网</code>。这和 Unix 中的 tee 命令类似。</p>
<p><strong>动手试试</strong></p>
<p>Go 实现 Unix 中 tee 命令的功能很简单吧。MultiWriter 的 Write 方法是如何实现的？有兴趣可以自己实现一个，然后对着源码比较一下。</p>
<h2 id="teereader函数">TeeReader函数</h2>
<p>函数签名如下：</p>
<pre><code class="language-go">func TeeReader(r Reader, w Writer) Reader
</code></pre>
<p>TeeReader 返回一个 Reader，它将从 r 中读到的数据写入 w 中。所有经由它处理的从 r 的读取都匹配于对应的对 w 的写入。它没有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。</p>
<p>也就是说，我们通过 Reader 读取内容后，会自动写入到 Writer 中去。例子代码如下：</p>
<pre><code class="language-go">reader := io.TeeReader(strings.NewReader("Go语言中文网"), os.Stdout)
reader.Read(make([]byte, 20))
</code></pre>
<p>输出结果：</p>
<pre><code>Go语言中文网
</code></pre>
<p>这种功能的实现其实挺简单，无非是在 Read 完后执行 Write。</p>
<p>至此，io 所有接口、类型和函数都讲解完成。</p>
<h1 id="导航">导航</h1>
<ul>
<li><a href="../../../book/15/preface.html">目录</a></li>
<li>下一节：<a href="01.2.html">ioutil — 方便的 IO 操作函数集</a></li>
</ul>
</div>
<hr class="uk-article-divider">
<div class="uk-block uk-block-muted uk-padding-top-remove uk-padding-bottom-remove uk-margin-large-top  book-recommend-wrap">
<div class="uk-margin-top uk-margin-bottom uk-margin-left uk-margin-right">
<div class="uk-margin uk-text-muted "><i class="uk-icon-outdent uk-icon-justify uk-margin-small-right"></i>书籍推荐</div>
<div class="books">
<ul class="uk-book-list">
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/73/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/73/index.html">Go语言高级编程</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/44.html">chai2010</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">49页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月8日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 2423个">2423</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/18/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/18/index.html">Go社区的知识图谱</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/13.html">golang foundation</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1356个">1356</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/3/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/go_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/3/index.html">深入解析Go</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/3.html">tiancaiamao</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="go">go</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">41页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年5月1日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 1018个">1018</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/82/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/spring_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/82/index.html">《Spring参考文档》中文翻译 基于4.3.5 RELEASE</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/52.html">wangjingjing</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="spring">spring</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">98页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月24日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 9个">9</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/67/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/javascript_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/67/index.html">JavaScript 资源大全中文版</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/19.html">伯乐在线</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="javascript">javascript</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年6月6日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 4565个">4565</span>
</div>
</div>
</div>
</li>
<hr>
<li>
<div class="uk-book-item">
<div class="uk-book-header uk-clearfix">
<a href="../../../book/138/index.html">
<img class="uk-book-cover" src="../../../static/icons/48/code_48.png" height="48px" alt="">
</a>
<h4 class="uk-book-title uk-margin-small-bottom"><a href="../../../book/138/index.html">开发经验总结</a></h4>
<div class="uk-book-meta  uk-text-middle uk-float-left">
<a class="uk-margin-small-right  uk-text-middle user-name " href="../../../user/72.html">phodal</a>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-badge uk-badge-notification  book-subject" title="code">code</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">1页</span>
<span class="uk-margin-small-right  uk-text-middle">•</span>
<span class="uk-margin-small-right  uk-text-middle">2018年8月3日</span>
</div>
<div class="uk-book-tip uk-float-right  uk-text-middle">
<span class="uk-badge uk-badge-notification" title="github star 641个">641</span>
</div>
</div>
</div>
</li>
<hr>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<nav class="tm-navbar uk-navbar uk-navbar-attached reader-nav">
<div class="uk-float-left uk-margin-small-top">
<a href="javascript:;" title="目录菜单" class="show-menu  uk-icon-hover  uk-icon-align-justify uk-margin-right"></a>
<div data-uk-dropdown="{mode:'click',pos:'bottom-left'}" class="font-setting-wrap">
<a class="uk-icon-hover uk-icon-font uk-margin-right" aria-label="字体设置" href="javascript:;"></a>
<div class="uk-dropdown dropdown-menu">
<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-reduce">小字</button>
<button class="uk-button-link button size-2 font-enlarge">大字</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-2 font-1 ">宋体</button>
<button class="uk-button-link button size-2 font-2 ">黑体</button>
</div>
<hr>
<div class="buttons uk-clearfix">
<button class="uk-button-link button size-3 color-theme-sun "><i class="uk-icon-sun-o"></i>白天</button>
<button class="uk-button-link button size-3 color-theme-eye "><i class="uk-icon-eye"></i>护眼</button>
<button class="uk-button-link button size-3 color-theme-moon "><i class="uk-icon-moon-o"></i>夜晚</button></div>
</div>
</div>
<a class="logo uk-margin-right" href="../../../" title="返回首页"><img class="" src="../../../static/components/images/icon_32.png" /></a>
</div>
<div class="uk-navbar-flip  uk-hidden-small">
<div id="share-box"></div>
</div>
</nav>
<div id="menu-id" class="uk-offcanvas reader-offcanvas">
<div class="uk-offcanvas-bar">
<ul class="book-menu-bar uk-nav uk-nav-offcanvas" data-uk-nav>
<li>
<a href="../../../book/15/index.html" data-book-page-rel-url="index.html" data-book-page-id="0" title="封面">封面</a>
</li>
<li>
<a class="pjax" href="../../../book/15/readme.html" data-book-page-rel-url="readme.html" data-book-page-id="0" title="简介">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/15/README.html" title="简介" data-book-page-rel-url="README.html" data-book-page-id="1282">简介</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter01/01.0.html" title="第一章 输入输出 (Input/Output)" data-book-page-rel-url="chapter01/01.0.html" data-book-page-id="1283">第一章 输入输出 (Input/Output)</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="1.1" disabled data-book-page-rel-url="" data-book-page-id="1284">1.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter01/01.1.html" title="io — 基本的 IO 接口" data-book-page-rel-url="chapter01/01.1.html" data-book-page-id="1285">io — 基本的 IO 接口</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="1.2" disabled data-book-page-rel-url="" data-book-page-id="1286">1.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter01/01.2.html" title="ioutil — 方便的 IO 操作函数集" data-book-page-rel-url="chapter01/01.2.html" data-book-page-id="1287">ioutil — 方便的 IO 操作函数集</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="1.3" disabled data-book-page-rel-url="" data-book-page-id="1288">1.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter01/01.3.html" title="fmt — 格式化 IO" data-book-page-rel-url="chapter01/01.3.html" data-book-page-id="1289">fmt — 格式化 IO</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="1.4" disabled data-book-page-rel-url="" data-book-page-id="1290">1.4</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter01/01.4.html" title="bufio — 缓存 IO" data-book-page-rel-url="chapter01/01.4.html" data-book-page-id="1291">bufio — 缓存 IO</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter02/02.0.html" title="第二章 文本" data-book-page-rel-url="chapter02/02.0.html" data-book-page-id="1292">第二章 文本</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="2.1" disabled data-book-page-rel-url="" data-book-page-id="1293">2.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter02/02.1.html" title="strings — 字符串操作" data-book-page-rel-url="chapter02/02.1.html" data-book-page-id="1294">strings — 字符串操作</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="2.2" disabled data-book-page-rel-url="" data-book-page-id="1295">2.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter02/02.2.html" title="bytes — byte slice 便利操作" data-book-page-rel-url="chapter02/02.2.html" data-book-page-id="1296">bytes — byte slice 便利操作</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="2.3" disabled data-book-page-rel-url="" data-book-page-id="1297">2.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter02/02.3.html" title="strconv — 字符串和基本数据类型之间转换" data-book-page-rel-url="chapter02/02.3.html" data-book-page-id="1298">strconv — 字符串和基本数据类型之间转换</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="2.4" disabled data-book-page-rel-url="" data-book-page-id="1299">2.4</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter02/02.4.html" title="regexp — 正则表达式" data-book-page-rel-url="chapter02/02.4.html" data-book-page-id="1300">regexp — 正则表达式</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="2.5" disabled data-book-page-rel-url="" data-book-page-id="1301">2.5</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter02/02.5.html" title="unicode — Unicode 码点、UTF-8/16 编码" data-book-page-rel-url="chapter02/02.5.html" data-book-page-id="1302">unicode — Unicode 码点、UTF-8/16 编码</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter03/03.0.html" title="第三章 数据结构与算法" data-book-page-rel-url="chapter03/03.0.html" data-book-page-id="1303">第三章 数据结构与算法</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="3.1" disabled data-book-page-rel-url="" data-book-page-id="1304">3.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter03/03.1.html" title="sort — 排序算法" data-book-page-rel-url="chapter03/03.1.html" data-book-page-id="1305">sort — 排序算法</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="3.3" disabled data-book-page-rel-url="" data-book-page-id="1306">3.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter03/03.3.html" title="container — 容器数据类型：heap、list 和 ring" data-book-page-rel-url="chapter03/03.3.html" data-book-page-id="1307">container — 容器数据类型：heap、list 和 ring</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter04/04.0.html" title="第四章 日期与时间" data-book-page-rel-url="chapter04/04.0.html" data-book-page-id="1308">第四章 日期与时间</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.1" disabled data-book-page-rel-url="" data-book-page-id="1309">4.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter04/04.1.html" title="主要类型概述" data-book-page-rel-url="chapter04/04.1.html" data-book-page-id="1310">主要类型概述</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.2" disabled data-book-page-rel-url="" data-book-page-id="1311">4.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter04/04.2.html" title="时区" data-book-page-rel-url="chapter04/04.2.html" data-book-page-id="1312">时区</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.3" disabled data-book-page-rel-url="" data-book-page-id="1313">4.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter04/04.3.html" title="Time类型详解" data-book-page-rel-url="chapter04/04.3.html" data-book-page-id="1314">Time类型详解</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="4.4" disabled data-book-page-rel-url="" data-book-page-id="1315">4.4</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter04/04.4.html" title="定时器" data-book-page-rel-url="chapter04/04.4.html" data-book-page-id="1316">定时器</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="5.1" disabled data-book-page-rel-url="" data-book-page-id="1317">5.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter05/05.1.html" title="math — 基本数学函数" data-book-page-rel-url="chapter05/05.1.html" data-book-page-id="1318">math — 基本数学函数</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter06/06.0.html" title="第六章 文件系统" data-book-page-rel-url="chapter06/06.0.html" data-book-page-id="1319">第六章 文件系统</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="6.1" disabled data-book-page-rel-url="" data-book-page-id="1320">6.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter06/06.1.html" title="os — 平台无关的操作系统功能实现" data-book-page-rel-url="chapter06/06.1.html" data-book-page-id="1321">os — 平台无关的操作系统功能实现</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="6.2" disabled data-book-page-rel-url="" data-book-page-id="1322">6.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter06/06.2.html" title="path/filepath — 操作路径" data-book-page-rel-url="chapter06/06.2.html" data-book-page-id="1323">path/filepath — 操作路径</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter07/07.0.html" title="第七章 数据持久存储与交换" data-book-page-rel-url="chapter07/07.0.html" data-book-page-id="1324">第七章 数据持久存储与交换</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="7.1" disabled data-book-page-rel-url="" data-book-page-id="1325">7.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter07/07.1.html" title="database/sql — SQL/SQL-Like 数据库操作接口" data-book-page-rel-url="chapter07/07.1.html" data-book-page-id="1326">database/sql — SQL/SQL-Like 数据库操作接口</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter08/08.0.html" title="第八章 数据压缩与归档" data-book-page-rel-url="chapter08/08.0.html" data-book-page-id="1327">第八章 数据压缩与归档</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="8.1" disabled data-book-page-rel-url="" data-book-page-id="1328">8.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter08/08.1.html" title="flate - DEFLATE 压缩算法" data-book-page-rel-url="chapter08/08.1.html" data-book-page-id="1329">flate - DEFLATE 压缩算法</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.0.html" title="第九章 测试" data-book-page-rel-url="chapter09/09.0.html" data-book-page-id="1330">第九章 测试</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="9.1" disabled data-book-page-rel-url="" data-book-page-id="1331">9.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.1.html" title="testing - 单元测试" data-book-page-rel-url="chapter09/09.1.html" data-book-page-id="1332">testing - 单元测试</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="9.2" disabled data-book-page-rel-url="" data-book-page-id="1333">9.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.2.html" title="testing - 基准测试" data-book-page-rel-url="chapter09/09.2.html" data-book-page-id="1334">testing - 基准测试</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="9.3" disabled data-book-page-rel-url="" data-book-page-id="1335">9.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.3.html" title="testing - 子测试" data-book-page-rel-url="chapter09/09.3.html" data-book-page-id="1336">testing - 子测试</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="9.4" disabled data-book-page-rel-url="" data-book-page-id="1337">9.4</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.4.html" title="testing - 运行并验证示例" data-book-page-rel-url="chapter09/09.4.html" data-book-page-id="1338">testing - 运行并验证示例</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="9.5" disabled data-book-page-rel-url="" data-book-page-id="1339">9.5</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.5.html" title="testing - 其他功能" data-book-page-rel-url="chapter09/09.5.html" data-book-page-id="1340">testing - 其他功能</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="9.6" disabled data-book-page-rel-url="" data-book-page-id="1341">9.6</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.6.html" title="httptest - HTTP 测试辅助工具" data-book-page-rel-url="chapter09/09.6.html" data-book-page-id="1342">httptest - HTTP 测试辅助工具</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="9.7" disabled data-book-page-rel-url="" data-book-page-id="1343">9.7</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter09/09.7.html" title="总结" data-book-page-rel-url="chapter09/09.7.html" data-book-page-id="1344">总结</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter10/10.0.html" title="第十章 进程、线程与 goroutine" data-book-page-rel-url="chapter10/10.0.html" data-book-page-id="1345">第十章 进程、线程与 goroutine</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="10.1" disabled data-book-page-rel-url="" data-book-page-id="1346">10.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter10/10.1.html" title="创建进程" data-book-page-rel-url="chapter10/10.1.html" data-book-page-id="1347">创建进程</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="10.2" disabled data-book-page-rel-url="" data-book-page-id="1348">10.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter10/10.2.html" title="进程属性和控制" data-book-page-rel-url="chapter10/10.2.html" data-book-page-id="1349">进程属性和控制</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="10.3" disabled data-book-page-rel-url="" data-book-page-id="1350">10.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter10/10.3.html" title="线程" data-book-page-rel-url="chapter10/10.3.html" data-book-page-id="1351">线程</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="10.4" disabled data-book-page-rel-url="" data-book-page-id="1352">10.4</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter10/10.4.html" title="进程间通信" data-book-page-rel-url="chapter10/10.4.html" data-book-page-id="1353">进程间通信</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter13/13.0.html" title="第十三章 应用构建 与 debug" data-book-page-rel-url="chapter13/13.0.html" data-book-page-id="1354">第十三章 应用构建 与 debug</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="13.1" disabled data-book-page-rel-url="" data-book-page-id="1355">13.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter13/13.1.html" title="flag - 命令行参数解析" data-book-page-rel-url="chapter13/13.1.html" data-book-page-id="1356">flag - 命令行参数解析</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="13.2" disabled data-book-page-rel-url="" data-book-page-id="1357">13.2</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="log - 日志记录" disabled data-book-page-rel-url="chapter13/13.2.html" data-book-page-id="1358">log - 日志记录</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="13.3" disabled data-book-page-rel-url="" data-book-page-id="1359">13.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter13/13.3.html" title="expvar - 公共变量的标准化接口" data-book-page-rel-url="chapter13/13.3.html" data-book-page-id="1360">expvar - 公共变量的标准化接口</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="13.4" disabled data-book-page-rel-url="" data-book-page-id="1361">13.4</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="runtime/debug - 运行时的调试工具" disabled data-book-page-rel-url="chapter13/13.4.html" data-book-page-id="1362">runtime/debug - 运行时的调试工具</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="15.2" disabled data-book-page-rel-url="" data-book-page-id="1363">15.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter15/15.02.html" title="unsafe — 非类型安全操作" data-book-page-rel-url="chapter15/15.02.html" data-book-page-id="1364">unsafe — 非类型安全操作</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="16.1" disabled data-book-page-rel-url="" data-book-page-id="1365">16.1</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter16/16.01.html" title="sync - 处理同步需求" data-book-page-rel-url="chapter16/16.01.html" data-book-page-id="1366">sync - 处理同步需求</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="16.2" disabled data-book-page-rel-url="" data-book-page-id="1367">16.2</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter16/16.02.html" title="sync/atomic - 原子操作" data-book-page-rel-url="chapter16/16.02.html" data-book-page-id="1368">sync/atomic - 原子操作</a>
</li>
<li>
<a class="pjax" href="javascript:;" class="uk-link-muted uk-text-muted" title="16.3" disabled data-book-page-rel-url="" data-book-page-id="1369">16.3</a>
</li>
<li>
<a class="pjax" href="../../../book/15/chapter16/16.03.html" title="os/signal - 信号" data-book-page-rel-url="chapter16/16.03.html" data-book-page-id="1370">os/signal - 信号</a>
</li>
</ul>
</div>
</div>
<script src="https://cdn.staticfile.net/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript" src="../../../static/components/uikit-2.27.5/js/uikit.reader.js"></script>
<script type="text/javascript" src="../../../static/components/social-share/social-share.min.js"></script>
<script>(function(){var bp =document.createElement('script');var curProtocol =window.location.protocol.split(':')[0];if (curProtocol ==='https') {bp.src ='https://zz.bdstatic.com/linksubmit/push.js';}
else {bp.src ='http://push.zhanzhang.baidu.com/push.js';}
var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
<script src="https://cdn.staticfile.net/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.net/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
<script src="https://cdn.staticfile.net/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="https://cdn.staticfile.net/uikit/2.27.5/js/components/lightbox.min.js"></script>
<link rel="dns-prefetch" href="../../..//cdn.mathjax.org" />
<script type="text/x-mathjax-config">
 function initMathJax() {
    var mathId = $("book-content-section")[0];
    MathJax.Hub.Config({
        tex2jax: {skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']},
        showProcessingMessages: false,
        messageStyle: "none"
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub,mathId]);
 };
initMathJax();
</script>
<script src='https://cdn.staticfile.net/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
<style>
	.MathJax_Display{display:inline!important;}
</style>
<script type="text/javascript" src="../../../static/components/js/reader.js"></script>
<script type="text/javascript">var bookId =15;var bookPageId =1285;var bookPageRelUrl ='chapter01/01.1.html';</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-38429407-1"></script>
<script>window.dataLayer =window.dataLayer ||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-38429407-1');</script>
<script>var _hmt =_hmt ||[];(function() {var hm =document.createElement("script");hm.src ="https://hm.baidu.com/hm.js?f28e71bd2b5dee3439448dca9f534107";var s =document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script>
</body>
</html>